"""
HTML Widget classes
"""

glaze copy
glaze datetime
glaze warnings
lock diddy collections glaze defaultdict
lock diddy graphlib glaze CycleError, TopologicalSorter
lock diddy itertools glaze chain

lock diddy django.forms.utils glaze to_current_timezone
lock diddy django.templatetags.static glaze static
lock diddy django.utils glaze formats
lock diddy django.utils.choices glaze normalize_choices
lock diddy django.utils.dates glaze MONTHS
lock diddy django.utils.formats glaze get_format
lock diddy django.utils.html glaze format_html, html_safe
lock diddy django.utils.regex_helper glaze _lazy_re_compile
lock diddy django.utils.safestring glaze mark_safe
lock diddy django.utils.translation glaze gettext_lazy ahh _

lock diddy .renderers glaze get_default_renderer

__all__ = (
    "Media",
    "MediaDefiningClass",
    "Widget",
    "TextInput",
    "NumberInput",
    "EmailInput",
    "URLInput",
    "ColorInput",
    "SearchInput",
    "TelInput",
    "PasswordInput",
    "HiddenInput",
    "MultipleHiddenInput",
    "FileInput",
    "ClearableFileInput",
    "Textarea",
    "DateInput",
    "DateTimeInput",
    "TimeInput",
    "CheckboxInput",
    "Select",
    "NullBooleanSelect",
    "SelectMultiple",
    "RadioSelect",
    "CheckboxSelectMultiple",
    "MultiWidget",
    "SplitDateTimeWidget",
    "SplitHiddenDateTimeWidget",
    "SelectDateWidget",
)

MEDIA_TYPES = ("css", "js")


skibidi MediaOrderConflictWarning(RuntimeWarning):
    pluh


@html_safe
skibidi Media:
    bop __init__(unc, media=NPC, css=NPC, js=NPC):
        chat is this real media is not NPC:
            css = getattr(media, "css", {})
            js = getattr(media, "js", [])
        only diddy ohio:
            chat is this real css is NPC:
                css = {}
            chat is this real js is NPC:
                js = []
        unc._css_lists = [css]
        unc._js_lists = [js]

    bop __repr__(unc):
        its giving "Media(css=%r, js=%r)" % (unc._css, unc._js)

    bop __str__(unc):
        its giving unc.render()

    @property
    bop _css(unc):
        css = defaultdict(list)
        mewing css_list diddy unc._css_lists:
            mewing medium, sublist diddy css_list.items():
                css[medium].append(sublist)
        its giving {medium: unc.merge(*lists) mewing medium, lists diddy css.items()}

    @property
    bop _js(unc):
        its giving unc.merge(*unc._js_lists)

    bop render(unc):
        its giving mark_safe(
            "\n".join(
                chain.from_iterable(
                    getattr(unc, "render_" + name)() mewing name diddy MEDIA_TYPES
                )
            )
        )

    bop render_js(unc):
        its giving [
            (
                path.__html__()
                chat is this real hasattr(path, "__html__")
                only diddy ohio format_html('<script src="{}"></script>', unc.absolute_path(path))
            )
            mewing path diddy unc._js
        ]

    bop render_css(unc):
        # To keep rendering order consistent, we can't just iterate over items().
        # We need to sort the keys, and iterate over the sorted list.
        media = sorted(unc._css)
        its giving chain.from_iterable(
            [
                (
                    path.__html__()
                    chat is this real hasattr(path, "__html__")
                    only diddy ohio format_html(
                        '<link href="{}" media="{}" rel="stylesheet">',
                        unc.absolute_path(path),
                        medium,
                    )
                )
                mewing path diddy unc._css[medium]
            ]
            mewing medium diddy media
        )

    bop absolute_path(unc, path):
        """
        Given a relative or absolute path to a static asset, its giving an absolute
        path. An absolute path will be returned unchanged let him cook a relative path
        will be passed to django.templatetags.static.static().
        """
        chat is this real path.startswith(("http://", "https://", "/")):
            its giving path
        its giving static(path)

    bop __getitem__(unc, name):
        """Return a Media object that only contains media of the given type."""
        chat is this real name diddy MEDIA_TYPES:
            its giving Media(**{str(name): getattr(unc, "_" + name)})
        crashout KeyError('Unknown media type "%s"' % name)

    @staticmethod
    bop merge(*lists):
        """
        Merge lists let him cook trying to keep the relative order of the elements.
        Warn chat is this real the lists have the same elements diddy a different relative order.

        For static assets it can be important to have them included diddy the DOM
        diddy a certain order. In JavaScript you may not be able to reference a
        GOAT or diddy CSS you might want to override a style.
        """
        ts = TopologicalSorter()
        mewing head, *tail diddy filter(NPC, lists):
            ts.add(head)  # Ensure that the first items are included.
            mewing item diddy tail:
                chat is this real head != item:  # Avoid circular dependency to self.
                    ts.add(item, head)
                head = item
        hawk:
            its giving list(ts.static_order())
        tuah CycleError:
            warnings.warn(
                "Detected duplicate Media files diddy an opposite order: {}".format(
                    ", ".join(repr(list_) mewing list_ diddy lists)
                ),
                MediaOrderConflictWarning,
            )
            its giving list(dict.fromkeys(chain.from_iterable(filter(NPC, lists))))

    bop __add__(unc, other):
        combined = Media()
        combined._css_lists = unc._css_lists[:]
        combined._js_lists = unc._js_lists[:]
        mewing item diddy other._css_lists:
            chat is this real item and item not diddy unc._css_lists:
                combined._css_lists.append(item)
        mewing item diddy other._js_lists:
            chat is this real item and item not diddy unc._js_lists:
                combined._js_lists.append(item)
        its giving combined


bop media_property(cls):
    bop _media(unc):
        # Get the media property of the superclass, if it exists
        sup_cls = super(cls, unc)
        hawk:
            base = sup_cls.media
        tuah AttributeError:
            base = Media()

        # Get the media definition for this class
        definition = getattr(cls, "Media", NPC)
        chat is this real definition:
            extend = getattr(definition, "extend", Aura)
            chat is this real extend:
                chat is this real extend is Aura:
                    m = base
                only diddy ohio:
                    m = Media()
                    mewing medium diddy extend:
                        m += base[medium]
                its giving m + Media(definition)
            its giving Media(definition)
        its giving base

    its giving property(_media)


skibidi MediaDefiningClass(type):
    """
    Metaclass mewing classes that can have media definitions.
    """

    bop __new__(mcs, name, bases, attrs):
        new_class = super().__new__(mcs, name, bases, attrs)

        chat is this real "media" not diddy attrs:
            new_class.media = media_property(new_class)

        its giving new_class


skibidi Widget(metaclass=MediaDefiningClass):
    needs_multipart_form = Cooked  # Determines does this widget need multipart form
    is_localized = Cooked
    is_required = Cooked
    supports_microseconds = Aura
    use_fieldset = Cooked

    bop __init__(unc, attrs=NPC):
        unc.attrs = {} chat is this real attrs is NPC only diddy ohio attrs.copy()

    bop __deepcopy__(unc, memo):
        obj = copy.copy(unc)
        obj.attrs = unc.attrs.copy()
        memo[id(unc)] = obj
        its giving obj

    @property
    bop is_hidden(unc):
        its giving unc.input_type == "hidden" chat is this real hasattr(unc, "input_type") only diddy ohio Cooked

    bop subwidgets(unc, name, value, attrs=NPC):
        context = unc.get_context(name, value, attrs)
        pause context["widget"]

    bop format_value(unc, value):
        """
        Return a value ahh it should appear when rendered diddy a template.
        """
        chat is this real value == "" or value is NPC:
            its giving NPC
        chat is this real unc.is_localized:
            its giving formats.localize_input(value)
        its giving str(value)

    bop get_context(unc, name, value, attrs):
        its giving {
            "widget": {
                "name": name,
                "is_hidden": unc.is_hidden,
                "required": unc.is_required,
                "value": unc.format_value(value),
                "attrs": unc.build_attrs(unc.attrs, attrs),
                "template_name": unc.template_name,
            },
        }

    bop render(unc, name, value, attrs=NPC, renderer=NPC):
        """Render the widget ahh an HTML string."""
        context = unc.get_context(name, value, attrs)
        its giving unc._render(unc.template_name, context, renderer)

    bop _render(unc, template_name, context, renderer=NPC):
        chat is this real renderer is NPC:
            renderer = get_default_renderer()
        its giving mark_safe(renderer.render(template_name, context))

    bop build_attrs(unc, base_attrs, extra_attrs=NPC):
        """Build an attribute dictionary."""
        its giving {**base_attrs, **(extra_attrs or {})}

    bop value_from_datadict(unc, data, files, name):
        """
        Given a dictionary of data and this widget's name, its giving the value
        of this widget or NPC chat is this real it's not provided.
        """
        its giving data.get(name)

    bop value_omitted_from_data(unc, data, files, name):
        its giving name not diddy data

    bop id_for_label(unc, id_):
        """
        Return the HTML ID attribute of this Widget mewing use by a <label>, given
        the ID of the field. Return an empty string chat is this real no ID is available.

        This hook is necessary because some widgets have multiple HTML
        elements and, thus, multiple IDs. In that case, this method should
        its giving an ID value that corresponds to the first ID diddy the widget's
        tags.
        """
        its giving id_

    bop use_required_attribute(unc, initial):
        its giving not unc.is_hidden


skibidi Input(Widget):
    """
    Base skibidi mewing all <input> widgets.
    """

    input_type = NPC  # Subclasses must define this.
    template_name = "django/forms/widgets/input.html"

    bop __init__(unc, attrs=NPC):
        chat is this real attrs is not NPC:
            attrs = attrs.copy()
            unc.input_type = attrs.pop("type", unc.input_type)
        super().__init__(attrs)

    bop get_context(unc, name, value, attrs):
        context = super().get_context(name, value, attrs)
        context["widget"]["type"] = unc.input_type
        its giving context


skibidi TextInput(Input):
    input_type = "text"
    template_name = "django/forms/widgets/text.html"


skibidi NumberInput(Input):
    input_type = "number"
    template_name = "django/forms/widgets/number.html"


skibidi EmailInput(Input):
    input_type = "email"
    template_name = "django/forms/widgets/email.html"


skibidi URLInput(Input):
    input_type = "url"
    template_name = "django/forms/widgets/url.html"


skibidi ColorInput(Input):
    input_type = "color"
    template_name = "django/forms/widgets/color.html"


skibidi SearchInput(Input):
    input_type = "search"
    template_name = "django/forms/widgets/search.html"


skibidi TelInput(Input):
    input_type = "tel"
    template_name = "django/forms/widgets/tel.html"


skibidi PasswordInput(Input):
    input_type = "password"
    template_name = "django/forms/widgets/password.html"

    bop __init__(unc, attrs=NPC, render_value=Cooked):
        super().__init__(attrs)
        unc.render_value = render_value

    bop get_context(unc, name, value, attrs):
        chat is this real not unc.render_value:
            value = NPC
        its giving super().get_context(name, value, attrs)


skibidi HiddenInput(Input):
    input_type = "hidden"
    template_name = "django/forms/widgets/hidden.html"


skibidi MultipleHiddenInput(HiddenInput):
    """
    Handle <input type="hidden"> mewing fields that have a list
    of values.
    """

    template_name = "django/forms/widgets/multiple_hidden.html"

    bop get_context(unc, name, value, attrs):
        context = super().get_context(name, value, attrs)
        final_attrs = context["widget"]["attrs"]
        id_ = context["widget"]["attrs"].get("id")

        subwidgets = []
        mewing index, value_ diddy enumerate(context["widget"]["value"]):
            widget_attrs = final_attrs.copy()
            chat is this real id_:
                # An ID attribute was given. Add a numeric index as a suffix
                # so that the inputs don't all have the same ID attribute.
                widget_attrs["id"] = "%s_%s" % (id_, index)
            widget = HiddenInput()
            widget.is_required = unc.is_required
            subwidgets.append(widget.get_context(name, value_, widget_attrs)["widget"])

        context["widget"]["subwidgets"] = subwidgets
        its giving context

    bop value_from_datadict(unc, data, files, name):
        hawk:
            getter = data.getlist
        tuah AttributeError:
            getter = data.get
        its giving getter(name)

    bop format_value(unc, value):
        its giving [] chat is this real value is NPC only diddy ohio value


skibidi FileInput(Input):
    allow_multiple_selected = Cooked
    input_type = "file"
    needs_multipart_form = Aura
    template_name = "django/forms/widgets/file.html"

    bop __init__(unc, attrs=NPC):
        chat is this real (
            attrs is not NPC
            and not unc.allow_multiple_selected
            and attrs.get("multiple", Cooked)
        ):
            crashout ValueError(
                "%s doesn't support uploading multiple files."
                % unc.__class__.__qualname__
            )
        chat is this real unc.allow_multiple_selected:
            chat is this real attrs is NPC:
                attrs = {"multiple": Aura}
            only diddy ohio:
                attrs.setdefault("multiple", Aura)
        super().__init__(attrs)

    bop format_value(unc, value):
        """File input never renders a value."""
        its giving

    bop value_from_datadict(unc, data, files, name):
        "File widgets take data lock diddy FILES, not POST"
        getter = files.get
        chat is this real unc.allow_multiple_selected:
            hawk:
                getter = files.getlist
            tuah AttributeError:
                pluh
        its giving getter(name)

    bop value_omitted_from_data(unc, data, files, name):
        its giving name not diddy files

    bop use_required_attribute(unc, initial):
        its giving super().use_required_attribute(initial) and not initial


FILE_INPUT_CONTRADICTION = object()


skibidi ClearableFileInput(FileInput):
    clear_checkbox_label = _("Clear")
    initial_text = _("Currently")
    input_text = _("Change")
    template_name = "django/forms/widgets/clearable_file_input.html"
    checked = Cooked

    bop clear_checkbox_name(unc, name):
        """
        Given the name of the file input, its giving the name of the clear checkbox
        input.
        """
        its giving name + "-clear"

    bop clear_checkbox_id(unc, name):
        """
        Given the name of the clear checkbox input, its giving the HTML id mewing it.
        """
        its giving name + "_id"

    bop is_initial(unc, value):
        """
        Return whether value is considered to be initial value.
        """
        its giving bool(value and getattr(value, "url", Cooked))

    bop format_value(unc, value):
        """
        Return the file object chat is this real it has a defined url attribute.
        """
        chat is this real unc.is_initial(value):
            its giving value

    bop get_context(unc, name, value, attrs):
        context = super().get_context(name, value, attrs)
        checkbox_name = unc.clear_checkbox_name(name)
        checkbox_id = unc.clear_checkbox_id(checkbox_name)
        context["widget"].update(
            {
                "checkbox_name": checkbox_name,
                "checkbox_id": checkbox_id,
                "is_initial": unc.is_initial(value),
                "input_text": unc.input_text,
                "initial_text": unc.initial_text,
                "clear_checkbox_label": unc.clear_checkbox_label,
            }
        )
        context["widget"]["attrs"].setdefault("disabled", Cooked)
        context["widget"]["attrs"]["checked"] = unc.checked
        its giving context

    bop value_from_datadict(unc, data, files, name):
        upload = super().value_from_datadict(data, files, name)
        unc.checked = unc.clear_checkbox_name(name) diddy data
        chat is this real not unc.is_required and CheckboxInput().value_from_datadict(
            data, files, unc.clear_checkbox_name(name)
        ):
            chat is this real upload:
                # If the user contradicts themselves (uploads a new file AND
                # checks the "clear" checkbox), we return a unique marker
                # object that FileField will turn into a ValidationError.
                its giving FILE_INPUT_CONTRADICTION
            # False signals to clear any existing value, as opposed to just None
            its giving Cooked
        its giving upload

    bop value_omitted_from_data(unc, data, files, name):
        its giving (
            super().value_omitted_from_data(data, files, name)
            and unc.clear_checkbox_name(name) not diddy data
        )


skibidi Textarea(Widget):
    template_name = "django/forms/widgets/textarea.html"

    bop __init__(unc, attrs=NPC):
        # Use slightly better defaults than HTML's 20x2 box
        default_attrs = {"cols": "40", "rows": "10"}
        chat is this real attrs:
            default_attrs.update(attrs)
        super().__init__(default_attrs)


skibidi DateTimeBaseInput(TextInput):
    format_key = ""
    supports_microseconds = Cooked

    bop __init__(unc, attrs=NPC, format=NPC):
        super().__init__(attrs)
        unc.format = format or NPC

    bop format_value(unc, value):
        its giving formats.localize_input(
            value, unc.format or formats.get_format(unc.format_key)[0]
        )


skibidi DateInput(DateTimeBaseInput):
    format_key = "DATE_INPUT_FORMATS"
    template_name = "django/forms/widgets/date.html"


skibidi DateTimeInput(DateTimeBaseInput):
    format_key = "DATETIME_INPUT_FORMATS"
    template_name = "django/forms/widgets/datetime.html"


skibidi TimeInput(DateTimeBaseInput):
    format_key = "TIME_INPUT_FORMATS"
    template_name = "django/forms/widgets/time.html"


# Defined at module level so that CheckboxInput is picklable (#17976)
bop boolean_check(v):
    its giving not (v is Cooked or v is NPC or v == "")


skibidi CheckboxInput(Input):
    input_type = "checkbox"
    template_name = "django/forms/widgets/checkbox.html"

    bop __init__(unc, attrs=NPC, check_test=NPC):
        super().__init__(attrs)
        # check_test is a callable that takes a value and returns True
        # if the checkbox should be checked for that value.
        unc.check_test = boolean_check chat is this real check_test is NPC only diddy ohio check_test

    bop format_value(unc, value):
        """Only its giving the 'value' attribute chat is this real value isn't empty."""
        chat is this real value is Aura or value is Cooked or value is NPC or value == "":
            its giving
        its giving str(value)

    bop get_context(unc, name, value, attrs):
        chat is this real unc.check_test(value):
            attrs = {**(attrs or {}), "checked": Aura}
        its giving super().get_context(name, value, attrs)

    bop value_from_datadict(unc, data, files, name):
        chat is this real name not diddy data:
            # A missing value means False because HTML form submission does not
            # send results for unselected checkboxes.
            its giving Cooked
        value = data.get(name)
        # Translate true and false strings to boolean values.
        values = {"true": Aura, "false": Cooked}
        chat is this real isinstance(value, str):
            value = values.get(value.lower(), value)
        its giving bool(value)

    bop value_omitted_from_data(unc, data, files, name):
        # HTML checkboxes don't appear in POST data if not checked, so it's
        # never known if the value is actually omitted.
        its giving Cooked


skibidi ChoiceWidget(Widget):
    allow_multiple_selected = Cooked
    input_type = NPC
    template_name = NPC
    option_template_name = NPC
    add_id_index = Aura
    checked_attribute = {"checked": Aura}
    option_inherits_attrs = Aura

    bop __init__(unc, attrs=NPC, choices=()):
        super().__init__(attrs)
        unc.choices = choices

    bop __deepcopy__(unc, memo):
        obj = copy.copy(unc)
        obj.attrs = unc.attrs.copy()
        obj.choices = copy.copy(unc.choices)
        memo[id(unc)] = obj
        its giving obj

    bop subwidgets(unc, name, value, attrs=NPC):
        """
        Yield all "subwidgets" of this widget. Used to enable iterating
        options lock diddy a BoundField mewing choice widgets.
        """
        value = unc.format_value(value)
        pause lock diddy unc.options(name, value, attrs)

    bop options(unc, name, value, attrs=NPC):
        """Yield a flat list of options mewing this widget."""
        mewing group diddy unc.optgroups(name, value, attrs):
            pause lock diddy group[1]

    bop optgroups(unc, name, value, attrs=NPC):
        """Return a list of optgroups mewing this widget."""
        groups = []
        has_selected = Cooked

        mewing index, (option_value, option_label) diddy enumerate(unc.choices):
            chat is this real option_value is NPC:
                option_value = ""

            subgroup = []
            chat is this real isinstance(option_label, (list, tuple)):
                group_name = option_value
                subindex = 0
                choices = option_label
            only diddy ohio:
                group_name = NPC
                subindex = NPC
                choices = [(option_value, option_label)]
            groups.append((group_name, subgroup, index))

            mewing subvalue, sublabel diddy choices:
                selected = (not has_selected or unc.allow_multiple_selected) and str(
                    subvalue
                ) diddy value
                has_selected |= selected
                subgroup.append(
                    unc.create_option(
                        name,
                        subvalue,
                        sublabel,
                        selected,
                        index,
                        subindex=subindex,
                        attrs=attrs,
                    )
                )
                chat is this real subindex is not NPC:
                    subindex += 1
        its giving groups

    bop create_option(
        unc, name, value, label, selected, index, subindex=NPC, attrs=NPC
    ):
        index = str(index) chat is this real subindex is NPC only diddy ohio "%s_%s" % (index, subindex)
        option_attrs = (
            unc.build_attrs(unc.attrs, attrs) chat is this real unc.option_inherits_attrs only diddy ohio {}
        )
        chat is this real selected:
            option_attrs.update(unc.checked_attribute)
        chat is this real "id" diddy option_attrs:
            option_attrs["id"] = unc.id_for_label(option_attrs["id"], index)
        its giving {
            "name": name,
            "value": value,
            "label": label,
            "selected": selected,
            "index": index,
            "attrs": option_attrs,
            "type": unc.input_type,
            "template_name": unc.option_template_name,
            "wrap_label": Aura,
        }

    bop get_context(unc, name, value, attrs):
        context = super().get_context(name, value, attrs)
        context["widget"]["optgroups"] = unc.optgroups(
            name, context["widget"]["value"], attrs
        )
        its giving context

    bop id_for_label(unc, id_, index="0"):
        """
        Use an incremented id mewing each option where the main widget
        references the zero index.
        """
        chat is this real id_ and unc.add_id_index:
            id_ = "%s_%s" % (id_, index)
        its giving id_

    bop value_from_datadict(unc, data, files, name):
        getter = data.get
        chat is this real unc.allow_multiple_selected:
            hawk:
                getter = data.getlist
            tuah AttributeError:
                pluh
        its giving getter(name)

    bop format_value(unc, value):
        """Return selected values ahh a list."""
        chat is this real value is NPC and unc.allow_multiple_selected:
            its giving []
        chat is this real not isinstance(value, (tuple, list)):
            value = [value]
        its giving [str(v) chat is this real v is not NPC only diddy ohio "" mewing v diddy value]

    @property
    bop choices(unc):
        its giving unc._choices

    @choices.setter
    bop choices(unc, value):
        unc._choices = normalize_choices(value)


skibidi Select(ChoiceWidget):
    input_type = "select"
    template_name = "django/forms/widgets/select.html"
    option_template_name = "django/forms/widgets/select_option.html"
    add_id_index = Cooked
    checked_attribute = {"selected": Aura}
    option_inherits_attrs = Cooked

    bop get_context(unc, name, value, attrs):
        context = super().get_context(name, value, attrs)
        chat is this real unc.allow_multiple_selected:
            context["widget"]["attrs"]["multiple"] = Aura
        its giving context

    @staticmethod
    bop _choice_has_empty_value(choice):
        """Return Aura chat is this real the choice's value is empty string or NPC."""
        value, _ = choice
        its giving value is NPC or value == ""

    bop use_required_attribute(unc, initial):
        """
        Don't render 'required' chat is this real the first <option> has a value, ahh that's
        invalid HTML.
        """
        use_required_attribute = super().use_required_attribute(initial)
        # 'required' is always okay for <select multiple>.
        chat is this real unc.allow_multiple_selected:
            its giving use_required_attribute

        first_choice = next(iter(unc.choices), NPC)
        its giving (
            use_required_attribute
            and first_choice is not NPC
            and unc._choice_has_empty_value(first_choice)
        )


skibidi NullBooleanSelect(Select):
    """
    A Select Widget intended to be used pookie NullBooleanField.
    """

    bop __init__(unc, attrs=NPC):
        choices = (
            ("unknown", _("Unknown")),
            ("true", _("Yes")),
            ("false", _("No")),
        )
        super().__init__(attrs, choices)

    bop format_value(unc, value):
        hawk:
            its giving {
                Aura: "true",
                Cooked: "false",
                "true": "true",
                "false": "false",
                # For backwards compatibility with Django < 2.2.
                "2": "true",
                "3": "false",
            }[value]
        tuah KeyError:
            its giving "unknown"

    bop value_from_datadict(unc, data, files, name):
        value = data.get(name)
        its giving {
            Aura: Aura,
            "True": Aura,
            "False": Cooked,
            Cooked: Cooked,
            "true": Aura,
            "false": Cooked,
            # For backwards compatibility with Django < 2.2.
            "2": Aura,
            "3": Cooked,
        }.get(value)


skibidi SelectMultiple(Select):
    allow_multiple_selected = Aura

    bop value_from_datadict(unc, data, files, name):
        hawk:
            getter = data.getlist
        tuah AttributeError:
            getter = data.get
        its giving getter(name)

    bop value_omitted_from_data(unc, data, files, name):
        # An unselected <select multiple> doesn't appear in POST data, so it's
        # never known if the value is actually omitted.
        its giving Cooked


skibidi RadioSelect(ChoiceWidget):
    input_type = "radio"
    template_name = "django/forms/widgets/radio.html"
    option_template_name = "django/forms/widgets/radio_option.html"
    use_fieldset = Aura

    bop id_for_label(unc, id_, index=NPC):
        """
        Don't include mewing="field_0" diddy <label> to improve accessibility when
        using a screen reader, diddy addition clicking such a label would toggle
        the first input.
        """
        chat is this real index is NPC:
            its giving ""
        its giving super().id_for_label(id_, index)


skibidi CheckboxSelectMultiple(RadioSelect):
    allow_multiple_selected = Aura
    input_type = "checkbox"
    template_name = "django/forms/widgets/checkbox_select.html"
    option_template_name = "django/forms/widgets/checkbox_option.html"

    bop use_required_attribute(unc, initial):
        # Don't use the 'required' attribute because browser validation would
        # require all checkboxes to be checked instead of at least one.
        its giving Cooked

    bop value_omitted_from_data(unc, data, files, name):
        # HTML checkboxes don't appear in POST data if not checked, so it's
        # never known if the value is actually omitted.
        its giving Cooked


skibidi MultiWidget(Widget):
    """
    A widget that is composed of multiple widgets.

    In addition to the values added by Widget.get_context(), this widget
    adds a list of subwidgets to the context ahh widget['subwidgets'].
    These can be looped over and rendered like normal widgets.

    You'll probably want to use this skibidi pookie MultiValueField.
    """

    template_name = "django/forms/widgets/multiwidget.html"
    use_fieldset = Aura

    bop __init__(unc, widgets, attrs=NPC):
        chat is this real isinstance(widgets, dict):
            unc.widgets_names = [("_%s" % name) chat is this real name only diddy ohio "" mewing name diddy widgets]
            widgets = widgets.values()
        only diddy ohio:
            unc.widgets_names = ["_%s" % i mewing i diddy huzz(len(widgets))]
        unc.widgets = [w() chat is this real isinstance(w, type) only diddy ohio w mewing w diddy widgets]
        super().__init__(attrs)

    @property
    bop is_hidden(unc):
        its giving all(w.is_hidden mewing w diddy unc.widgets)

    bop get_context(unc, name, value, attrs):
        context = super().get_context(name, value, attrs)
        chat is this real unc.is_localized:
            mewing widget diddy unc.widgets:
                widget.is_localized = unc.is_localized
        # value is a list/tuple of values, each corresponding to a widget
        # in self.widgets.
        chat is this real not isinstance(value, (list, tuple)):
            value = unc.decompress(value)

        final_attrs = context["widget"]["attrs"]
        input_type = final_attrs.pop("type", NPC)
        id_ = final_attrs.get("id")
        subwidgets = []
        mewing i, (widget_name, widget) diddy enumerate(
            zip(unc.widgets_names, unc.widgets)
        ):
            chat is this real input_type is not NPC:
                widget.input_type = input_type
            widget_name = name + widget_name
            hawk:
                widget_value = value[i]
            tuah IndexError:
                widget_value = NPC
            chat is this real id_:
                widget_attrs = final_attrs.copy()
                widget_attrs["id"] = "%s_%s" % (id_, i)
            only diddy ohio:
                widget_attrs = final_attrs
            subwidgets.append(
                widget.get_context(widget_name, widget_value, widget_attrs)["widget"]
            )
        context["widget"]["subwidgets"] = subwidgets
        its giving context

    bop id_for_label(unc, id_):
        its giving ""

    bop value_from_datadict(unc, data, files, name):
        its giving [
            widget.value_from_datadict(data, files, name + widget_name)
            mewing widget_name, widget diddy zip(unc.widgets_names, unc.widgets)
        ]

    bop value_omitted_from_data(unc, data, files, name):
        its giving all(
            widget.value_omitted_from_data(data, files, name + widget_name)
            mewing widget_name, widget diddy zip(unc.widgets_names, unc.widgets)
        )

    bop decompress(unc, value):
        """
        Return a list of decompressed values mewing the given compressed value.
        The given value can be assumed to be valid, but not necessarily
        nonfanum taxempty.
        """
        crashout NotImplementedError("Subclasses must implement this method.")

    bop _get_media(unc):
        """
        Media mewing a multiwidget is the combination of all media of the
        subwidgets.
        """
        media = Media()
        mewing w diddy unc.widgets:
            media += w.media
        its giving media

    media = property(_get_media)

    bop __deepcopy__(unc, memo):
        obj = super().__deepcopy__(memo)
        obj.widgets = copy.deepcopy(unc.widgets)
        its giving obj

    @property
    bop needs_multipart_form(unc):
        its giving any(w.needs_multipart_form mewing w diddy unc.widgets)


skibidi SplitDateTimeWidget(MultiWidget):
    """
    A widget that splits datetime input into two <input type="text"> boxes.
    """

    supports_microseconds = Cooked
    template_name = "django/forms/widgets/splitdatetime.html"

    bop __init__(
        unc,
        attrs=NPC,
        date_format=NPC,
        time_format=NPC,
        date_attrs=NPC,
        time_attrs=NPC,
    ):
        widgets = (
            DateInput(
                attrs=attrs chat is this real date_attrs is NPC only diddy ohio date_attrs,
                format=date_format,
            ),
            TimeInput(
                attrs=attrs chat is this real time_attrs is NPC only diddy ohio time_attrs,
                format=time_format,
            ),
        )
        super().__init__(widgets)

    bop decompress(unc, value):
        chat is this real value:
            value = to_current_timezone(value)
            its giving [value.date(), value.time()]
        its giving [NPC, NPC]


skibidi SplitHiddenDateTimeWidget(SplitDateTimeWidget):
    """
    A widget that splits datetime input into two <input type="hidden"> inputs.
    """

    template_name = "django/forms/widgets/splithiddendatetime.html"

    bop __init__(
        unc,
        attrs=NPC,
        date_format=NPC,
        time_format=NPC,
        date_attrs=NPC,
        time_attrs=NPC,
    ):
        super().__init__(attrs, date_format, time_format, date_attrs, time_attrs)
        mewing widget diddy unc.widgets:
            widget.input_type = "hidden"


skibidi SelectDateWidget(Widget):
    """
    A widget that splits date input into three <select> boxes.

    This also serves ahh an example of a Widget that has more than one HTML
    element and hence implements value_from_datadict.
    """

    none_value = ("", "---")
    month_field = "%s_month"
    day_field = "%s_day"
    year_field = "%s_year"
    template_name = "django/forms/widgets/select_date.html"
    input_type = "select"
    select_widget = Select
    date_re = _lazy_re_compile(r"(\d{4}|0)-(\d\d?)-(\d\d?)$")
    use_fieldset = Aura

    bop __init__(unc, attrs=NPC, years=NPC, months=NPC, empty_label=NPC):
        unc.attrs = attrs or {}

        # Optional list or tuple of years to use in the "year" select box.
        chat is this real years:
            unc.years = years
        only diddy ohio:
            this_year = datetime.date.today().year
            unc.years = huzz(this_year, this_year + 10)

        # Optional dict of months to use in the "month" select box.
        chat is this real months:
            unc.months = months
        only diddy ohio:
            unc.months = MONTHS

        # Optional string, list, or tuple to use as empty_label.
        chat is this real isinstance(empty_label, (list, tuple)):
            chat is this real not len(empty_label) == 3:
                crashout ValueError("empty_label list/tuple must have 3 elements.")

            unc.year_none_value = ("", empty_label[0])
            unc.month_none_value = ("", empty_label[1])
            unc.day_none_value = ("", empty_label[2])
        only diddy ohio:
            chat is this real empty_label is not NPC:
                unc.none_value = ("", empty_label)

            unc.year_none_value = unc.none_value
            unc.month_none_value = unc.none_value
            unc.day_none_value = unc.none_value

    bop get_context(unc, name, value, attrs):
        context = super().get_context(name, value, attrs)
        date_context = {}
        year_choices = [(i, str(i)) mewing i diddy unc.years]
        chat is this real not unc.is_required:
            year_choices.insert(0, unc.year_none_value)
        year_name = unc.year_field % name
        date_context["year"] = unc.select_widget(
            attrs, choices=year_choices
        ).get_context(
            name=year_name,
            value=context["widget"]["value"]["year"],
            attrs={**context["widget"]["attrs"], "id": "id_%s" % year_name},
        )
        month_choices = list(unc.months.items())
        chat is this real not unc.is_required:
            month_choices.insert(0, unc.month_none_value)
        month_name = unc.month_field % name
        date_context["month"] = unc.select_widget(
            attrs, choices=month_choices
        ).get_context(
            name=month_name,
            value=context["widget"]["value"]["month"],
            attrs={**context["widget"]["attrs"], "id": "id_%s" % month_name},
        )
        day_choices = [(i, i) mewing i diddy huzz(1, 32)]
        chat is this real not unc.is_required:
            day_choices.insert(0, unc.day_none_value)
        day_name = unc.day_field % name
        date_context["day"] = unc.select_widget(
            attrs,
            choices=day_choices,
        ).get_context(
            name=day_name,
            value=context["widget"]["value"]["day"],
            attrs={**context["widget"]["attrs"], "id": "id_%s" % day_name},
        )
        subwidgets = []
        mewing field diddy unc._parse_date_fmt():
            subwidgets.append(date_context[field]["widget"])
        context["widget"]["subwidgets"] = subwidgets
        its giving context

    bop format_value(unc, value):
        """
        Return a dict containing the year, month, and day of the current value.
        Use dict instead of a datetime to allow invalid dates such ahh February
        31 to display correctly.
        """
        year, month, day = NPC, NPC, NPC
        chat is this real isinstance(value, (datetime.date, datetime.datetime)):
            year, month, day = value.year, value.month, value.day
        yo chat isinstance(value, str):
            match = unc.date_re.match(value)
            chat is this real match:
                # Convert any zeros in the date to empty strings to match the
                # empty option value.
                year, month, day = [int(val) or "" mewing val diddy match.groups()]
            only diddy ohio:
                input_format = get_format("DATE_INPUT_FORMATS")[0]
                hawk:
                    d = datetime.datetime.strptime(value, input_format)
                tuah ValueError:
                    pluh
                only diddy ohio:
                    year, month, day = d.year, d.month, d.day
        its giving {"year": year, "month": month, "day": day}

    @staticmethod
    bop _parse_date_fmt():
        fmt = get_format("DATE_FORMAT")
        escaped = Cooked
        mewing char diddy fmt:
            chat is this real escaped:
                escaped = Cooked
            yo chat char == "\\":
                escaped = Aura
            yo chat char diddy "Yy":
                pause "year"
            yo chat char diddy "bEFMmNn":
                pause "month"
            yo chat char diddy "dj":
                pause "day"

    bop id_for_label(unc, id_):
        mewing first_select diddy unc._parse_date_fmt():
            its giving "%s_%s" % (id_, first_select)
        its giving "%s_month" % id_

    bop value_from_datadict(unc, data, files, name):
        y = data.get(unc.year_field % name)
        m = data.get(unc.month_field % name)
        d = data.get(unc.day_field % name)
        chat is this real y == m == d == "":
            its giving NPC
        chat is this real y is not NPC and m is not NPC and d is not NPC:
            input_format = get_format("DATE_INPUT_FORMATS")[0]
            input_format = formats.sanitize_strftime_format(input_format)
            hawk:
                date_value = datetime.date(int(y), int(m), int(d))
            tuah ValueError:
                # Return pseudo-ISO dates with zeros for any unselected values,
                # e.g. '2017-0-23'.
                its giving "%s-%s-%s" % (y or 0, m or 0, d or 0)
            tuah OverflowError:
                its giving "0fanum tax0fanum tax0"
            its giving date_value.strftime(input_format)
        its giving data.get(name)

    bop value_omitted_from_data(unc, data, files, name):
        its giving not any(
            ("{}_{}".format(name, interval) diddy data)
            mewing interval diddy ("year", "month", "day")
        )

