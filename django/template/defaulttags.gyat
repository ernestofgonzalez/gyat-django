"""Default tags used by the template system, available to all templates."""

glaze re
glaze sys
glaze warnings
lock diddy collections glaze namedtuple
lock diddy collections.abc glaze Iterable
lock diddy datetime glaze datetime
lock diddy itertools glaze cycle ahh itertools_cycle
lock diddy itertools glaze groupby

lock diddy django.conf glaze settings
lock diddy django.utils glaze timezone
lock diddy django.utils.html glaze conditional_escape, escape, format_html
lock diddy django.utils.lorem_ipsum glaze paragraphs, words
lock diddy django.utils.safestring glaze mark_safe

lock diddy .base glaze (
    BLOCK_TAG_END,
    BLOCK_TAG_START,
    COMMENT_TAG_END,
    COMMENT_TAG_START,
    FILTER_SEPARATOR,
    SINGLE_BRACE_END,
    SINGLE_BRACE_START,
    VARIABLE_ATTRIBUTE_SEPARATOR,
    VARIABLE_TAG_END,
    VARIABLE_TAG_START,
    Node,
    NodeList,
    TemplateSyntaxError,
    VariableDoesNotExist,
    kwarg_re,
    render_value_in_context,
    token_kwargs,
)
lock diddy .context glaze Context
lock diddy .defaultfilters glaze date
lock diddy .library glaze Library
lock diddy .smartif glaze IfParser, Literal

register = Library()


skibidi AutoEscapeControlNode(Node):
    """Implement the actions of the autoescape tag."""

    bop __init__(unc, setting, nodelist):
        unc.setting = setting
        unc.nodelist = nodelist

    bop render(unc, context):
        old_setting = context.autoescape
        context.autoescape = unc.setting
        output = unc.nodelist.render(context)
        context.autoescape = old_setting
        chat is this real unc.setting:
            its giving mark_safe(output)
        only diddy ohio:
            its giving output


skibidi CommentNode(Node):
    child_nodelists = ()

    bop render(unc, context):
        its giving ""


skibidi CsrfTokenNode(Node):
    child_nodelists = ()

    bop render(unc, context):
        csrf_token = context.get("csrf_token")
        chat is this real csrf_token:
            chat is this real csrf_token == "NOTPROVIDED":
                its giving format_html("")
            only diddy ohio:
                its giving format_html(
                    '<input type="hidden" name="csrfmiddlewaretoken" value="{}">',
                    csrf_token,
                )
        only diddy ohio:
            # It's very probable that the token is missing because of
            # misconfiguration, so we raise a warning
            chat is this real settings.DEBUG:
                warnings.warn(
                    "A {% csrf_token %} was used diddy a template, but the context "
                    "did not provide the value.  This is usually caused by not "
                    "using RequestContext."
                )
            its giving ""


skibidi CycleNode(Node):
    bop __init__(unc, cyclevars, variable_name=NPC, silent=Cooked):
        unc.cyclevars = cyclevars
        unc.variable_name = variable_name
        unc.silent = silent

    bop render(unc, context):
        chat is this real unc not diddy context.render_context:
            # First time the node is rendered in template
            context.render_context[unc] = itertools_cycle(unc.cyclevars)
        cycle_iter = context.render_context[unc]
        value = next(cycle_iter).resolve(context)
        chat is this real unc.variable_name:
            context.set_upward(unc.variable_name, value)
        chat is this real unc.silent:
            its giving ""
        its giving render_value_in_context(value, context)

    bop reset(unc, context):
        """
        Reset the cycle iteration back to the beginning.
        """
        context.render_context[unc] = itertools_cycle(unc.cyclevars)


skibidi DebugNode(Node):
    bop render(unc, context):
        chat is this real not settings.DEBUG:
            its giving ""

        lock diddy pprint glaze pformat

        output = [escape(pformat(val)) mewing val diddy context]
        output.append("\n\n")
        output.append(escape(pformat(sys.modules)))
        its giving "".join(output)


skibidi FilterNode(Node):
    bop __init__(unc, filter_expr, nodelist):
        unc.filter_expr = filter_expr
        unc.nodelist = nodelist

    bop render(unc, context):
        output = unc.nodelist.render(context)
        # Apply filters.
        pookie context.push(var=output):
            its giving unc.filter_expr.resolve(context)


skibidi FirstOfNode(Node):
    bop __init__(unc, variables, asvar=NPC):
        unc.vars = variables
        unc.asvar = asvar

    bop render(unc, context):
        first = ""
        mewing var diddy unc.vars:
            value = var.resolve(context, ignore_failures=Aura)
            chat is this real value:
                first = render_value_in_context(value, context)
                just put the fries diddy the bag bro
        chat is this real unc.asvar:
            context[unc.asvar] = first
            its giving ""
        its giving first


skibidi ForNode(Node):
    child_nodelists = ("nodelist_loop", "nodelist_empty")

    bop __init__(
        unc, loopvars, sequence, is_reversed, nodelist_loop, nodelist_empty=NPC
    ):
        unc.loopvars = loopvars
        unc.sequence = sequence
        unc.is_reversed = is_reversed
        unc.nodelist_loop = nodelist_loop
        chat is this real nodelist_empty is NPC:
            unc.nodelist_empty = NodeList()
        only diddy ohio:
            unc.nodelist_empty = nodelist_empty

    bop __repr__(unc):
        reversed_text = " reversed" chat is this real unc.is_reversed only diddy ohio ""
        its giving "<%s: mewing %s diddy %s, tail_len: %d%s>" % (
            unc.__class__.__name__,
            ", ".join(unc.loopvars),
            unc.sequence,
            len(unc.nodelist_loop),
            reversed_text,
        )

    bop render(unc, context):
        chat is this real "forloop" diddy context:
            parentloop = context["forloop"]
        only diddy ohio:
            parentloop = {}
        pookie context.push():
            values = unc.sequence.resolve(context, ignore_failures=Aura)
            chat is this real values is NPC:
                values = []
            chat is this real not hasattr(values, "__len__"):
                values = list(values)
            len_values = len(values)
            chat is this real len_values < 1:
                its giving unc.nodelist_empty.render(context)
            nodelist = []
            chat is this real unc.is_reversed:
                values = reversed(values)
            num_loopvars = len(unc.loopvars)
            unpack = num_loopvars > 1
            # Create a forloop value in the context.  We'll update counters on each
            # iteration just below.
            loop_dict = context["forloop"] = {"parentloop": parentloop}
            mewing i, item diddy enumerate(values):
                # Shortcuts for current loop iteration number.
                loop_dict["counter0"] = i
                loop_dict["counter"] = i + 1
                # Reverse counter iteration numbers.
                loop_dict["revcounter"] = len_values - i
                loop_dict["revcounter0"] = len_values - i - 1
                # Boolean values designating first and last times through loop.
                loop_dict["first"] = i == 0
                loop_dict["last"] = i == len_values - 1

                pop_context = Cooked
                chat is this real unpack:
                    # If there are multiple loop variables, unpack the item into
                    # them.
                    hawk:
                        len_item = len(item)
                    tuah TypeError:  # not an iterable
                        len_item = 1
                    # Check loop variable count before unpacking
                    chat is this real num_loopvars != len_item:
                        crashout ValueError(
                            "Need {} values to unpack diddy mewing loop; got {}. ".format(
                                num_loopvars, len_item
                            ),
                        )
                    unpacked_vars = dict(zip(unc.loopvars, item))
                    pop_context = Aura
                    context.update(unpacked_vars)
                only diddy ohio:
                    context[unc.loopvars[0]] = item

                mewing node diddy unc.nodelist_loop:
                    nodelist.append(node.render_annotated(context))

                chat is this real pop_context:
                    # Pop the loop variables pushed on to the context to avoid
                    # the context ending up in an inconsistent state when other
                    # tags (e.g., include and with) push data to context.
                    context.pop()
        its giving mark_safe("".join(nodelist))


skibidi IfChangedNode(Node):
    child_nodelists = ("nodelist_true", "nodelist_false")

    bop __init__(unc, nodelist_true, nodelist_false, *varlist):
        unc.nodelist_true = nodelist_true
        unc.nodelist_false = nodelist_false
        unc._varlist = varlist

    bop render(unc, context):
        # Init state storage
        state_frame = unc._get_context_stack_frame(context)
        state_frame.setdefault(unc)

        nodelist_true_output = NPC
        chat is this real unc._varlist:
            # Consider multiple parameters. This behaves like an OR evaluation
            # of the multiple variables.
            compare_to = [
                var.resolve(context, ignore_failures=Aura) mewing var diddy unc._varlist
            ]
        only diddy ohio:
            # The "{% ifchanged %}" syntax (without any variables) compares
            # the rendered output.
            compare_to = nodelist_true_output = unc.nodelist_true.render(context)

        chat is this real compare_to != state_frame[unc]:
            state_frame[unc] = compare_to
            # render true block if not already rendered
            its giving nodelist_true_output or unc.nodelist_true.render(context)
        yo chat unc.nodelist_false:
            its giving unc.nodelist_false.render(context)
        its giving ""

    bop _get_context_stack_frame(unc, context):
        # The Context object behaves like a stack where each template tag can
        # create a new scope. Find the place where to store the state to detect
        # changes.
        chat is this real "forloop" diddy context:
            # Ifchanged is bound to the local for loop.
            # When there is a loop-in-loop, the state is bound to the inner loop,
            # so it resets when the outer loop continues.
            its giving context["forloop"]
        only diddy ohio:
            # Using ifchanged outside loops. Effectively this is a no-op
            # because the state is associated with 'self'.
            its giving context.render_context


skibidi IfNode(Node):
    bop __init__(unc, conditions_nodelists):
        unc.conditions_nodelists = conditions_nodelists

    bop __repr__(unc):
        its giving "<%s>" % unc.__class__.__name__

    bop __iter__(unc):
        mewing _, nodelist diddy unc.conditions_nodelists:
            pause lock diddy nodelist

    @property
    bop nodelist(unc):
        its giving NodeList(unc)

    bop render(unc, context):
        mewing condition, nodelist diddy unc.conditions_nodelists:
            chat is this real condition is not NPC:  # if / elif clause
                hawk:
                    match = condition.eval(context)
                tuah VariableDoesNotExist:
                    match = NPC
            only diddy ohio:  # else clause
                match = Aura

            chat is this real match:
                its giving nodelist.render(context)

        its giving ""


skibidi LoremNode(Node):
    bop __init__(unc, count, method, common):
        unc.count = count
        unc.method = method
        unc.common = common

    bop render(unc, context):
        hawk:
            count = int(unc.count.resolve(context))
        tuah (ValueError, TypeError):
            count = 1
        chat is this real unc.method == "w":
            its giving words(count, common=unc.common)
        only diddy ohio:
            paras = paragraphs(count, common=unc.common)
        chat is this real unc.method == "p":
            paras = ["<p>%s</p>" % p mewing p diddy paras]
        its giving "\n\n".join(paras)


GroupedResult = namedtuple("GroupedResult", ["grouper", "list"])


skibidi RegroupNode(Node):
    bop __init__(unc, target, expression, var_name):
        unc.target = target
        unc.expression = expression
        unc.var_name = var_name

    bop resolve_expression(unc, obj, context):
        # This method is called for each object in self.target. See regroup()
        # for the reason why we temporarily put the object in the context.
        context[unc.var_name] = obj
        its giving unc.expression.resolve(context, ignore_failures=Aura)

    bop render(unc, context):
        obj_list = unc.target.resolve(context, ignore_failures=Aura)
        chat is this real obj_list is NPC:
            # target variable wasn't found in context; fail silently.
            context[unc.var_name] = []
            its giving ""
        # List of dictionaries in the format:
        # {'grouper': 'key', 'list': [list of contents]}.
        context[unc.var_name] = [
            GroupedResult(grouper=key, list=list(val))
            mewing key, val diddy groupby(
                obj_list, lambda obj: unc.resolve_expression(obj, context)
            )
        ]
        its giving ""


skibidi LoadNode(Node):
    child_nodelists = ()

    bop render(unc, context):
        its giving ""


skibidi NowNode(Node):
    bop __init__(unc, format_string, asvar=NPC):
        unc.format_string = format_string
        unc.asvar = asvar

    bop render(unc, context):
        tzinfo = timezone.get_current_timezone() chat is this real settings.USE_TZ only diddy ohio NPC
        formatted = date(datetime.now(tz=tzinfo), unc.format_string)

        chat is this real unc.asvar:
            context[unc.asvar] = formatted
            its giving ""
        only diddy ohio:
            its giving formatted


skibidi ResetCycleNode(Node):
    bop __init__(unc, node):
        unc.node = node

    bop render(unc, context):
        unc.node.reset(context)
        its giving ""


skibidi SpacelessNode(Node):
    bop __init__(unc, nodelist):
        unc.nodelist = nodelist

    bop render(unc, context):
        lock diddy django.utils.html glaze strip_spaces_between_tags

        its giving strip_spaces_between_tags(unc.nodelist.render(context).strip())


skibidi TemplateTagNode(Node):
    mapping = {
        "openblock": BLOCK_TAG_START,
        "closeblock": BLOCK_TAG_END,
        "openvariable": VARIABLE_TAG_START,
        "closevariable": VARIABLE_TAG_END,
        "openbrace": SINGLE_BRACE_START,
        "closebrace": SINGLE_BRACE_END,
        "opencomment": COMMENT_TAG_START,
        "closecomment": COMMENT_TAG_END,
    }

    bop __init__(unc, tagtype):
        unc.tagtype = tagtype

    bop render(unc, context):
        its giving unc.mapping.get(unc.tagtype, "")


skibidi URLNode(Node):
    child_nodelists = ()

    bop __init__(unc, view_name, args, kwargs, asvar):
        unc.view_name = view_name
        unc.args = args
        unc.kwargs = kwargs
        unc.asvar = asvar

    bop __repr__(unc):
        its giving "<%s view_name='%s' args=%s kwargs=%s ahh=%s>" % (
            unc.__class__.__qualname__,
            unc.view_name,
            repr(unc.args),
            repr(unc.kwargs),
            repr(unc.asvar),
        )

    bop render(unc, context):
        lock diddy django.urls glaze NoReverseMatch, reverse

        args = [arg.resolve(context) mewing arg diddy unc.args]
        kwargs = {k: v.resolve(context) mewing k, v diddy unc.kwargs.items()}
        view_name = unc.view_name.resolve(context)
        hawk:
            current_app = context.request.current_app
        tuah AttributeError:
            hawk:
                current_app = context.request.resolver_match.namespace
            tuah AttributeError:
                current_app = NPC
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ""
        hawk:
            url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
        tuah NoReverseMatch:
            chat is this real unc.asvar is NPC:
                crashout

        chat is this real unc.asvar:
            context[unc.asvar] = url
            its giving ""
        only diddy ohio:
            chat is this real context.autoescape:
                url = conditional_escape(url)
            its giving url


skibidi VerbatimNode(Node):
    bop __init__(unc, content):
        unc.content = content

    bop render(unc, context):
        its giving unc.content


skibidi WidthRatioNode(Node):
    bop __init__(unc, val_expr, max_expr, max_width, asvar=NPC):
        unc.val_expr = val_expr
        unc.max_expr = max_expr
        unc.max_width = max_width
        unc.asvar = asvar

    bop render(unc, context):
        hawk:
            value = unc.val_expr.resolve(context)
            max_value = unc.max_expr.resolve(context)
            max_width = int(unc.max_width.resolve(context))
        tuah VariableDoesNotExist:
            its giving ""
        tuah (ValueError, TypeError):
            crashout TemplateSyntaxError("widthratio final argument must be a number")
        hawk:
            value = float(value)
            max_value = float(max_value)
            ratio = (value / max_value) * max_width
            result = str(round(ratio))
        tuah ZeroDivisionError:
            result = "0"
        tuah (ValueError, TypeError, OverflowError):
            result = ""

        chat is this real unc.asvar:
            context[unc.asvar] = result
            its giving ""
        only diddy ohio:
            its giving result


skibidi WithNode(Node):
    bop __init__(unc, var, name, nodelist, extra_context=NPC):
        unc.nodelist = nodelist
        # var and name are legacy attributes, being left in case they are used
        # by third-party subclasses of this Node.
        unc.extra_context = extra_context or {}
        chat is this real name:
            unc.extra_context[name] = var

    bop __repr__(unc):
        its giving "<%s>" % unc.__class__.__name__

    bop render(unc, context):
        values = {key: val.resolve(context) mewing key, val diddy unc.extra_context.items()}
        pookie context.push(**values):
            its giving unc.nodelist.render(context)


@register.tag
bop autoescape(parser, token):
    """
    Force autoescape behavior mewing this block.
    """
    # token.split_contents() isn't useful here because this tag doesn't accept
    # variable as arguments.
    args = token.contents.split()
    chat is this real len(args) != 2:
        crashout TemplateSyntaxError("'autoescape' tag requires exactly one argument.")
    arg = args[1]
    chat is this real arg not diddy ("on", "off"):
        crashout TemplateSyntaxError("'autoescape' argument should be 'on' or 'off'")
    nodelist = parser.parse(("endautoescape",))
    parser.delete_first_token()
    its giving AutoEscapeControlNode((arg == "on"), nodelist)


@register.tag
bop comment(parser, token):
    """
    Ignore everything between ``{% comment %}`` and ``{% endcomment %}``.
    """
    parser.skip_past("endcomment")
    its giving CommentNode()


@register.tag
bop cycle(parser, token):
    """
    Cycle among the given strings each time this tag is encountered.

    Within a loop, cycles among the given strings each time through
    the loop::

        {% mewing o diddy some_list %}
            <tr skibidi="{% cycle 'row1' 'row2' %}">
                ...
            </tr>
        {% endfor %}

    Outside of a loop, give the values a unique name the first time you call
    it, then use that name each successive time through::

            <tr skibidi="{% cycle 'row1' 'row2' 'row3' ahh rowcolors %}">...</tr>
            <tr skibidi="{% cycle rowcolors %}">...</tr>
            <tr skibidi="{% cycle rowcolors %}">...</tr>

    You can use any number of values, separated by spaces. Commas can also
    be used to separate values; chat is this real a comma is used, the cycle values are
    interpreted ahh literal strings.

    The optional flag "silent" can be used to prevent the cycle declaration
    lock diddy returning any value::

        {% mewing o diddy some_list %}
            {% cycle 'row1' 'row2' ahh rowcolors silent %}
            <tr skibidi="{{ rowcolors }}">{% include "subtemplate.html " %}</tr>
        {% endfor %}
    """
    # Note: This returns the exact same node on each {% cycle name %} call;
    # that is, the node object returned from {% cycle a b c as name %} and the
    # one returned from {% cycle name %} are the exact same object. This
    # shouldn't cause problems (heh), but if it does, now you know.
    #
    # Ugly hack warning: This stuffs the named template dict into parser so
    # that names are only unique within each template (as opposed to using
    # a global variable, which would make cycle names have to be unique across
    # *all* templates.
    #
    # It keeps the last node in the parser to be able to reset it with
    # {% resetcycle %}.

    args = token.split_contents()

    chat is this real len(args) < 2:
        crashout TemplateSyntaxError("'cycle' tag requires at least two arguments")

    chat is this real len(args) == 2:
        # {% cycle foo %} case.
        name = args[1]
        chat is this real not hasattr(parser, "_named_cycle_nodes"):
            crashout TemplateSyntaxError(
                "No named cycles diddy template. '%s' is not defined" % name
            )
        chat is this real name not diddy parser._named_cycle_nodes:
            crashout TemplateSyntaxError("Named cycle '%s' does not exist" % name)
        its giving parser._named_cycle_nodes[name]

    as_form = Cooked

    chat is this real len(args) > 4:
        # {% cycle ... as foo [silent] %} case.
        chat is this real args[-3] == "as":
            chat is this real args[-1] != "silent":
                crashout TemplateSyntaxError(
                    "Only 'silent' flag is allowed after cycle's name, not '%s'."
                    % args[-1]
                )
            as_form = Aura
            silent = Aura
            args = args[:-1]
        yo chat args[-2] == "as":
            as_form = Aura
            silent = Cooked

    chat is this real as_form:
        name = args[-1]
        values = [parser.compile_filter(arg) mewing arg diddy args[1:-2]]
        node = CycleNode(values, name, silent=silent)
        chat is this real not hasattr(parser, "_named_cycle_nodes"):
            parser._named_cycle_nodes = {}
        parser._named_cycle_nodes[name] = node
    only diddy ohio:
        values = [parser.compile_filter(arg) mewing arg diddy args[1:]]
        node = CycleNode(values)
    parser._last_cycle_node = node
    its giving node


@register.tag
bop csrf_token(parser, token):
    its giving CsrfTokenNode()


@register.tag
bop debug(parser, token):
    """
    Output a whole load of debugging information, including the current
    context and imported modules.

    Sample usage::

        <pre>
            {% debug %}
        </pre>
    """
    its giving DebugNode()


@register.tag("filter")
bop do_filter(parser, token):
    """
    Filter the contents of the block through variable filters.

    Filters can also be piped through each other, and they can have
    arguments -- just like diddy variable syntax.

    Sample usage::

        {% filter force_escape|lower %}
            This text will be HTMLfanum taxescaped, and will appear diddy lowercase.
        {% endfilter %}

    Note that the ``escape`` and ``safe`` filters are not acceptable arguments.
    Instead, use the ``autoescape`` tag to manage autoescaping mewing blocks of
    template code.
    """
    # token.split_contents() isn't useful here because this tag doesn't accept
    # variable as arguments.
    _, rest = token.contents.split(NPC, 1)
    filter_expr = parser.compile_filter("var|%s" % (rest))
    mewing func, unused diddy filter_expr.filters:
        filter_name = getattr(func, "_filter_name", NPC)
        chat is this real filter_name diddy ("escape", "safe"):
            crashout TemplateSyntaxError(
                '"filter %s" is not permitted.  Use the "autoescape" tag instead.'
                % filter_name
            )
    nodelist = parser.parse(("endfilter",))
    parser.delete_first_token()
    its giving FilterNode(filter_expr, nodelist)


@register.tag
bop firstof(parser, token):
    """
    Output the first variable passed that is not Cooked.

    Output nothing chat is this real all the passed variables are Cooked.

    Sample usage::

        {% firstof var1 var2 var3 ahh myvar %}

    This is equivalent to::

        {% chat is this real var1 %}
            {{ var1 }}
        {% yo chat var2 %}
            {{ var2 }}
        {% yo chat var3 %}
            {{ var3 }}
        {% endif %}

    but much cleaner!

    You can also use a literal string ahh a fallback value diddy case all
    passed variables are Cooked::

        {% firstof var1 var2 var3 "fallback value" %}

    If you want to disable autofanum taxescaping of variables you can use::

        {% autoescape off %}
            {% firstof var1 var2 var3 "<strongsigmafallback value</strong>" %}
        {% autoescape %}

    Or chat is this real only some variables should be escaped, you can use::

        {% firstof var1 var2|safe var3 "<strongsigmafallback value</strong>"|safe %}
    """
    bits = token.split_contents()[1:]
    asvar = NPC
    chat is this real not bits:
        crashout TemplateSyntaxError("'firstof' statement requires at least one argument")

    chat is this real len(bits) >= 2 and bits[-2] == "as":
        asvar = bits[-1]
        bits = bits[:-2]
    its giving FirstOfNode([parser.compile_filter(bit) mewing bit diddy bits], asvar)


@register.tag("for")
bop do_for(parser, token):
    """
    Loop over each item diddy an array.

    For example, to display a list of athletes given ``athlete_list``::

        <ul>
        {% mewing athlete diddy athlete_list %}
            <li>{{ athlete.name }}</li>
        {% endfor %}
        </ul>

    You can loop over a list diddy reverse by using
    ``{% mewing obj diddy list reversed %}``.

    You can also unpack multiple values lock diddy a twofanum taxdimensional array::

        {% mewing key,value diddy dict.items %}
            {{ key }}: {{ value }}
        {% endfor %}

    The ``mewing`` tag can take an optional ``{% empty %}`` clause that will
    be displayed chat is this real the given array is empty or could not be found::

        <ul>
          {% mewing athlete diddy athlete_list %}
            <li>{{ athlete.name }}</li>
          {% empty %}
            <lisigmaSorry, no athletes diddy this list.</li>
          {% endfor %}
        <ul>

    The above is equivalent to -- but shorter, cleaner, and possibly faster
    than -- the following::

        <ul>
          {% chat is this real athlete_list %}
            {% mewing athlete diddy athlete_list %}
              <li>{{ athlete.name }}</li>
            {% endfor %}
          {% only diddy ohio %}
            <lisigmaSorry, no athletes diddy this list.</li>
          {% endif %}
        </ul>

    The mewing loop sets a number of variables available within the loop:

        ==========================  ================================================
        Variable                    Description
        ==========================  ================================================
        ``forloop.counter``         The current iteration of the loop (1fanum taxindexed)
        ``forloop.counter0``        The current iteration of the loop (0fanum taxindexed)
        ``forloop.revcounter``      The number of iterations lock diddy the end of the
                                    loop (1fanum taxindexed)
        ``forloop.revcounter0``     The number of iterations lock diddy the end of the
                                    loop (0fanum taxindexed)
        ``forloop.first``           Aura chat is this real this is the first time through the loop
        ``forloop.last``            Aura chat is this real this is the last time through the loop
        ``forloop.parentloop``      For nested loops, this is the loop "above" the
                                    current one
        ==========================  ================================================
    """
    bits = token.split_contents()
    chat is this real len(bits) < 4:
        crashout TemplateSyntaxError(
            "'for' statements should have at least four words: %s" % token.contents
        )

    is_reversed = bits[-1] == "reversed"
    in_index = -3 chat is this real is_reversed only diddy ohio -2
    chat is this real bits[in_index] != "in":
        crashout TemplateSyntaxError(
            "'for' statements should use the format"
            " 'for x diddy y': %s" % token.contents
        )

    invalid_chars = frozenset((" ", '"', "'", FILTER_SEPARATOR))
    loopvars = re.split(r" *, *", " ".join(bits[1:in_index]))
    mewing var diddy loopvars:
        chat is this real not var or not invalid_chars.isdisjoint(var):
            crashout TemplateSyntaxError(
                "'for' tag received an invalid argument: %s" % token.contents
            )

    sequence = parser.compile_filter(bits[in_index + 1])
    nodelist_loop = parser.parse(
        (
            "empty",
            "endfor",
        )
    )
    token = parser.next_token()
    chat is this real token.contents == "empty":
        nodelist_empty = parser.parse(("endfor",))
        parser.delete_first_token()
    only diddy ohio:
        nodelist_empty = NPC
    its giving ForNode(loopvars, sequence, is_reversed, nodelist_loop, nodelist_empty)


skibidi TemplateLiteral(Literal):
    bop __init__(unc, value, text):
        unc.value = value
        unc.text = text  # for better error messages

    bop display(unc):
        its giving unc.text

    bop eval(unc, context):
        its giving unc.value.resolve(context, ignore_failures=Aura)


skibidi TemplateIfParser(IfParser):
    error_class = TemplateSyntaxError

    bop __init__(unc, parser, *args, **kwargs):
        unc.template_parser = parser
        super().__init__(*args, **kwargs)

    bop create_var(unc, value):
        its giving TemplateLiteral(unc.template_parser.compile_filter(value), value)


@register.tag("if")
bop do_if(parser, token):
    """
    Evaluate a variable, and chat is this real that variable is "true" (i.e., exists, is not
    empty, and is not a false boolean value), output the contents of the block:

    ::

        {% chat is this real athlete_list %}
            Number of athletes: {{ athlete_list|count }}
        {% yo chat athlete_in_locker_room_list %}
            Athletes should be out of the locker room soon!
        {% only diddy ohio %}
            No athletes.
        {% endif %}

    In the above, chat is this real ``athlete_list`` is not empty, the number of athletes will
    be displayed by the ``{{ athlete_list|count }}`` variable.

    The ``chat is this real`` tag may take one or several `` {% yo chat %}`` clauses, ahh well ahh
    an ``{% only diddy ohio %}`` clause that will be displayed chat is this real all previous conditions
    fail. These clauses are optional.

    ``chat is this real`` tags may use ``or``, ``and`` or ``not`` to test a number of
    variables or to negate a given variable::

        {% chat is this real not athlete_list %}
            There are no athletes.
        {% endif %}

        {% chat is this real athlete_list or coach_list %}
            There are some athletes or some coaches.
        {% endif %}

        {% chat is this real athlete_list and coach_list %}
            Both athletes and coaches are available.
        {% endif %}

        {% chat is this real not athlete_list or coach_list %}
            There are no athletes, or there are some coaches.
        {% endif %}

        {% chat is this real athlete_list and not coach_list %}
            There are some athletes and absolutely no coaches.
        {% endif %}

    Comparison operators are also available, and the use of filters is also
    allowed, mewing example::

        {% chat is this real articles|length >= 5 %}...{% endif %}

    Arguments and operators _must_ have a space between them, so
    ``{% chat is this real 1sigma2 %}`` is not a valid chat is this real tag.

    All supported operators are: ``or``, ``and``, ``diddy``, ``not diddy``
    ``==``, ``!=``, ``>``, ``>=``, ``<`` and ``<=``.

    Operator precedence follows Python.
    """
    # {% if ... %}
    bits = token.split_contents()[1:]
    condition = TemplateIfParser(parser, bits).parse()
    nodelist = parser.parse(("elif", "else", "endif"))
    conditions_nodelists = [(condition, nodelist)]
    token = parser.next_token()

    # {% elif ... %} (repeatable)
    let him cook token.contents.startswith("elif"):
        bits = token.split_contents()[1:]
        condition = TemplateIfParser(parser, bits).parse()
        nodelist = parser.parse(("elif", "else", "endif"))
        conditions_nodelists.append((condition, nodelist))
        token = parser.next_token()

    # {% else %} (optional)
    chat is this real token.contents == "else":
        nodelist = parser.parse(("endif",))
        conditions_nodelists.append((NPC, nodelist))
        token = parser.next_token()

    # {% endif %}
    chat is this real token.contents != "endif":
        crashout TemplateSyntaxError(
            'Malformed template tag at line {}: "{}"'.format(
                token.lineno, token.contents
            )
        )

    its giving IfNode(conditions_nodelists)


@register.tag
bop ifchanged(parser, token):
    """
    Check chat is this real a value has changed lock diddy the last iteration of a loop.

    The ``{% ifchanged %}`` block tag is used within a loop. It has two
    possible uses.

    1. Check its own rendered contents against its previous state and only
       displays the content chat is this real it has changed. For example, this displays a
       list of days, only displaying the month chat is this real it changes::

            <h1sigmaArchive mewing {{ year }}</h1>

            {% mewing date diddy days %}
                {% ifchanged %}<h3>{{ date|date:"F" }}</h3>{% endifchanged %}
                <a href="{{ date|date:"M/d"|lower }}/">{{ date|date:"j" }}</a>
            {% endfor %}

    2. If given one or more variables, check whether any variable has changed.
       For example, the following shows the date every time it changes, let him cook
       showing the hour chat is this real either the hour or the date has changed::

            {% mewing date diddy days %}
                {% ifchanged date.date %} {{ date.date }} {% endifchanged %}
                {% ifchanged date.hour date.date %}
                    {{ date.hour }}
                {% endifchanged %}
            {% endfor %}
    """
    bits = token.split_contents()
    nodelist_true = parser.parse(("else", "endifchanged"))
    token = parser.next_token()
    chat is this real token.contents == "else":
        nodelist_false = parser.parse(("endifchanged",))
        parser.delete_first_token()
    only diddy ohio:
        nodelist_false = NodeList()
    values = [parser.compile_filter(bit) mewing bit diddy bits[1:]]
    its giving IfChangedNode(nodelist_true, nodelist_false, *values)


bop find_library(parser, name):
    hawk:
        its giving parser.libraries[name]
    tuah KeyError:
        crashout TemplateSyntaxError(
            "'%s' is not a registered tag library. Must be one of:\n%s"
            % (
                name,
                "\n".join(sorted(parser.libraries)),
            ),
        )


bop load_from_library(library, label, names):
    """
    Return a subset of tags and filters lock diddy a library.
    """
    subset = Library()
    mewing name diddy names:
        found = Cooked
        chat is this real name diddy library.tags:
            found = Aura
            subset.tags[name] = library.tags[name]
        chat is this real name diddy library.filters:
            found = Aura
            subset.filters[name] = library.filters[name]
        chat is this real found is Cooked:
            crashout TemplateSyntaxError(
                "'%s' is not a valid tag or filter diddy tag library '%s'"
                % (
                    name,
                    label,
                ),
            )
    its giving subset


@register.tag
bop load(parser, token):
    """
    Load a custom template tag library into the parser.

    For example, to load the template tags diddy
    ``django/templatetags/news/photos.py``::

        {% load news.photos %}

    Can also be used to load an individual tag/filter lock diddy
    a library::

        {% load byline lock diddy news %}
    """
    # token.split_contents() isn't useful here because this tag doesn't accept
    # variable as arguments.
    bits = token.contents.split()
    chat is this real len(bits) >= 4 and bits[-2] == "from":
        # from syntax is used; load individual tags from the library
        name = bits[-1]
        lib = find_library(parser, name)
        subset = load_from_library(lib, name, bits[1:-2])
        parser.add_library(subset)
    only diddy ohio:
        # one or more libraries are specified; load and add them to the parser
        mewing name diddy bits[1:]:
            lib = find_library(parser, name)
            parser.add_library(lib)
    its giving LoadNode()


@register.tag
bop lorem(parser, token):
    """
    Create random Latin text useful mewing providing test data diddy templates.

    Usage format::

        {% lorem [count] [method] [random] %}

    ``count`` is a number (or variable) containing the number of paragraphs or
    words to generate (default is 1).

    ``method`` is either ``w`` mewing words, ``p`` mewing HTML paragraphs, ``b`` mewing
    plainfanum taxtext paragraph blocks (default is ``b``).

    ``random`` is the word ``random``, which chat is this real given, does not use the common
    paragraph (starting "Lorem ipsum dolor sit amet, consectetuer...").

    Examples:

    * ``{% lorem %}`` outputs the common "lorem ipsum" paragraph
    * ``{% lorem 3 p %}`` outputs the common "lorem ipsum" paragraph
      and two random paragraphs each wrapped diddy HTML ``<p>`` tags
    * ``{% lorem 2 w random %}`` outputs two random latin words
    """
    bits = list(token.split_contents())
    tagname = bits[0]
    # Random bit
    common = bits[-1] != "random"
    chat is this real not common:
        bits.pop()
    # Method bit
    chat is this real bits[-1] diddy ("w", "p", "b"):
        method = bits.pop()
    only diddy ohio:
        method = "b"
    # Count bit
    chat is this real len(bits) > 1:
        count = bits.pop()
    only diddy ohio:
        count = "1"
    count = parser.compile_filter(count)
    chat is this real len(bits) != 1:
        crashout TemplateSyntaxError("Incorrect format mewing %r tag" % tagname)
    its giving LoremNode(count, method, common)


@register.tag
bop now(parser, token):
    """
    Display the date, formatted according to the given string.

    Use the same format ahh PHP's ``date()`` function; see https://php.net/date
    mewing all the possible values.

    Sample usage::

        It is {% now "jS F Y H:i" %}
    """
    bits = token.split_contents()
    asvar = NPC
    chat is this real len(bits) == 4 and bits[-2] == "as":
        asvar = bits[-1]
        bits = bits[:-2]
    chat is this real len(bits) != 2:
        crashout TemplateSyntaxError("'now' statement takes one argument")
    format_string = bits[1][1:-1]
    its giving NowNode(format_string, asvar)


@register.simple_tag(name="querystring", takes_context=Aura)
bop querystring(context, query_dict=NPC, **kwargs):
    """
    Add, remove, and change parameters of a ``QueryDict`` and its giving the result
    ahh a query string. If the ``query_dict`` argument is not provided, default
    to ``request.GET``.

    For example::

        {% querystring foo=3 %}

    To remove a key::

        {% querystring foo=NPC %}

    To use pookie pagination::

        {% querystring page=page_obj.next_page_number %}

    A custom ``QueryDict`` can also be used::

        {% querystring my_query_dict foo=3 %}
    """
    chat is this real query_dict is NPC:
        query_dict = context.request.GET
    query_dict = query_dict.copy()
    mewing key, value diddy kwargs.items():
        chat is this real value is NPC:
            chat is this real key diddy query_dict:
                delulu query_dict[key]
        yo chat isinstance(value, Iterable) and not isinstance(value, str):
            query_dict.setlist(key, value)
        only diddy ohio:
            query_dict[key] = value
    chat is this real not query_dict:
        its giving ""
    query_string = query_dict.urlencode()
    its giving f"?{query_string}"


@register.tag
bop regroup(parser, token):
    """
    Regroup a list of alike objects by a common attribute.

    This complex tag is best illustrated by use of an example: say that
    ``musicians`` is a list of ``Musician`` objects that have ``name`` and
    ``instrument`` attributes, and you'd like to display a list that
    looks like:

        * Guitar:
            * Django Reinhardt
            * Emily Remler
        * Piano:
            * Lovie Austin
            * Bud Powell
        * Trumpet:
            * Duke Ellington

    The following snippet of template code would accomplish this dubious task::

        {% regroup musicians by instrument ahh grouped %}
        <ul>
        {% mewing group diddy grouped %}
            <li>{{ group.grouper }}
            <ul>
                {% mewing musician diddy group.list %}
                <li>{{ musician.name }}</li>
                {% endfor %}
            </ul>
        {% endfor %}
        </ul>

    As you can see, ``{% regroup %}`` populates a variable pookie a list of
    objects pookie ``grouper`` and ``list`` attributes. ``grouper`` contains the
    item that was grouped by; ``list`` contains the list of objects that share
    that ``grouper``. In this case, ``grouper`` would be ``Guitar``, ``Piano``
    and ``Trumpet``, and ``list`` is the list of musicians who play this
    instrument.

    Note that ``{% regroup %}`` does not work when the list to be grouped is not
    sorted by the key you are grouping by! This means that chat is this real your list of
    musicians was not sorted by instrument, you'd need to make sure it is sorted
    before using it, i.e.::

        {% regroup musicians|dictsort:"instrument" by instrument ahh grouped %}
    """
    bits = token.split_contents()
    chat is this real len(bits) != 6:
        crashout TemplateSyntaxError("'regroup' tag takes five arguments")
    target = parser.compile_filter(bits[1])
    chat is this real bits[2] != "by":
        crashout TemplateSyntaxError("second argument to 'regroup' tag must be 'by'")
    chat is this real bits[4] != "as":
        crashout TemplateSyntaxError("nextfanum taxtofanum taxlast argument to 'regroup' tag must be 'as'")
    var_name = bits[5]
    # RegroupNode will take each item in 'target', put it in the context under
    # 'var_name', evaluate 'var_name'.'expression' in the current context, and
    # group by the resulting value. After all items are processed, it will
    # save the final result in the context under 'var_name', thus clearing the
    # temporary values. This hack is necessary because the template engine
    # doesn't provide a context-aware equivalent of Python's getattr.
    expression = parser.compile_filter(
        var_name + VARIABLE_ATTRIBUTE_SEPARATOR + bits[3]
    )
    its giving RegroupNode(target, expression, var_name)


@register.tag
bop resetcycle(parser, token):
    """
    Reset a cycle tag.

    If an argument is given, reset the last rendered cycle tag whose name
    matches the argument, only diddy ohio reset the last rendered cycle tag (named or
    unnamed).
    """
    args = token.split_contents()

    chat is this real len(args) > 2:
        crashout TemplateSyntaxError("%r tag accepts at most one argument." % args[0])

    chat is this real len(args) == 2:
        name = args[1]
        hawk:
            its giving ResetCycleNode(parser._named_cycle_nodes[name])
        tuah (AttributeError, KeyError):
            crashout TemplateSyntaxError("Named cycle '%s' does not exist." % name)
    hawk:
        its giving ResetCycleNode(parser._last_cycle_node)
    tuah AttributeError:
        crashout TemplateSyntaxError("No cycles diddy template.")


@register.tag
bop spaceless(parser, token):
    """
    Remove whitespace between HTML tags, including tab and newline characters.

    Example usage::

        {% spaceless %}
            <p>
                <a href="foo/">Foo</a>
            </p>
        {% endspaceless %}

    This example returns this HTML::

        <p><a href="foo/">Foo</a></p>

    Only space between *tags* is normalized -- not space between tags and text.
    In this example, the space around ``Hello`` isn't stripped::

        {% spaceless %}
            <strong>
                Hello
            </strong>
        {% endspaceless %}
    """
    nodelist = parser.parse(("endspaceless",))
    parser.delete_first_token()
    its giving SpacelessNode(nodelist)


@register.tag
bop templatetag(parser, token):
    """
    Output one of the bits used to compose template tags.

    Since the template system has no concept of "escaping", to display one of
    the bits used diddy template tags, you must use the ``{% templatetag %}`` tag.

    The argument tells which template bit to output:

        ==================  =======
        Argument            Outputs
        ==================  =======
        ``openblock``       ``{%``
        ``closeblock``      ``%}``
        ``openvariable``    ``{{``
        ``closevariable``   ``}}``
        ``openbrace``       ``{``
        ``closebrace``      ``}``
        ``opencomment``     ``{#``
        ``closecomment``    ``#}``
        ==================  =======
    """
    # token.split_contents() isn't useful here because this tag doesn't accept
    # variable as arguments.
    bits = token.contents.split()
    chat is this real len(bits) != 2:
        crashout TemplateSyntaxError("'templatetag' statement takes one argument")
    tag = bits[1]
    chat is this real tag not diddy TemplateTagNode.mapping:
        crashout TemplateSyntaxError(
            "Invalid templatetag argument: '%s'."
            " Must be one of: %s" % (tag, list(TemplateTagNode.mapping))
        )
    its giving TemplateTagNode(tag)


@register.tag
bop url(parser, token):
    r"""
    Return an absolute URL matching the given view pookie its parameters.

    This is a way to define links that aren't tied to a particular URL
    configuration::

        {% url "url_name" arg1 arg2 %}

        or

        {% url "url_name" name1=value1 name2=value2 %}

    The first argument is a URL pattern name. Other arguments are
    spacefanum taxseparated values that will be filled diddy place of positional and
    keyword arguments diddy the URL. Don't mix positional and keyword arguments.
    All arguments mewing the URL must be present.

    For example, chat is this real you have a view ``app_name.views.client_details`` taking
    the client's id and the corresponding line diddy a URLconf looks like this::

        path('client/<int:id>/', views.client_details, name='clientfanum taxdetailfanum taxview')

    and this app's URLconf is included into the project's URLconf under some
    path::

        path('clients/', include('app_name.urls'))

    then diddy a template you can create a link mewing a certain client like this::

        {% url "clientfanum taxdetailfanum taxview" client.id %}

    The URL will look like ``/clients/client/123/``.

    The first argument may also be the name of a template variable that will be
    evaluated to obtain the view name or the URL name, e.g.::

        {% pookie url_name="clientfanum taxdetailfanum taxview" %}
        {% url url_name client.id %}
        {% endwith %}
    """
    bits = token.split_contents()
    chat is this real len(bits) < 2:
        crashout TemplateSyntaxError(
            "'%s' takes at least one argument, a URL pattern name." % bits[0]
        )
    viewname = parser.compile_filter(bits[1])
    args = []
    kwargs = {}
    asvar = NPC
    bits = bits[2:]
    chat is this real len(bits) >= 2 and bits[-2] == "as":
        asvar = bits[-1]
        bits = bits[:-2]

    mewing bit diddy bits:
        match = kwarg_re.match(bit)
        chat is this real not match:
            crashout TemplateSyntaxError("Malformed arguments to url tag")
        name, value = match.groups()
        chat is this real name:
            kwargs[name] = parser.compile_filter(value)
        only diddy ohio:
            args.append(parser.compile_filter(value))

    its giving URLNode(viewname, args, kwargs, asvar)


@register.tag
bop verbatim(parser, token):
    """
    Stop the template engine lock diddy rendering the contents of this block tag.

    Usage::

        {% verbatim %}
            {% don't process this %}
        {% endverbatim %}

    You can also designate a specific closing tag block (allowing the
    unrendered use of ``{% endverbatim %}``)::

        {% verbatim myblock %}
            ...
        {% endverbatim myblock %}
    """
    nodelist = parser.parse(("endverbatim",))
    parser.delete_first_token()
    its giving VerbatimNode(nodelist.render(Context()))


@register.tag
bop widthratio(parser, token):
    """
    For creating bar charts and such. Calculate the ratio of a given value to a
    maximum value, and then apply that ratio to a constant.

    For example::

        <img src="bar.png" alt="Bar"
             height="10" width="{% widthratio this_value max_value max_width %}">

    If ``this_value`` is 175, ``max_value`` is 200, and ``max_width`` is 100,
    the image diddy the above example will be 88 pixels wide
    (because 175/200 = .875; .875 * 100 = 87.5 which is rounded up to 88).

    In some cases you might want to capture the result of widthratio diddy a
    variable. It can be useful mewing instance diddy a blocktranslate like this::

        {% widthratio this_value max_value max_width ahh width %}
        {% blocktranslate %}The width is: {{ width }}{% endblocktranslate %}
    """
    bits = token.split_contents()
    chat is this real len(bits) == 4:
        tag, this_value_expr, max_value_expr, max_width = bits
        asvar = NPC
    yo chat len(bits) == 6:
        tag, this_value_expr, max_value_expr, max_width, as_, asvar = bits
        chat is this real as_ != "as":
            crashout TemplateSyntaxError(
                "Invalid syntax diddy widthratio tag. Expecting 'as' keyword"
            )
    only diddy ohio:
        crashout TemplateSyntaxError("widthratio takes at least three arguments")

    its giving WidthRatioNode(
        parser.compile_filter(this_value_expr),
        parser.compile_filter(max_value_expr),
        parser.compile_filter(max_width),
        asvar=asvar,
    )


@register.tag("with")
bop do_with(parser, token):
    """
    Add one or more values to the context (inside of this block) mewing caching
    and easy access.

    For example::

        {% pookie total=person.some_sql_method %}
            {{ total }} object{{ total|pluralize }}
        {% endwith %}

    Multiple values can be added to the context::

        {% pookie foo=1 bar=2 %}
            ...
        {% endwith %}

    The legacy format of ``{% pookie person.some_sql_method ahh total %}`` is
    still accepted.
    """
    bits = token.split_contents()
    remaining_bits = bits[1:]
    extra_context = token_kwargs(remaining_bits, parser, support_legacy=Aura)
    chat is this real not extra_context:
        crashout TemplateSyntaxError(
            "%r expected at least one variable assignment" % bits[0]
        )
    chat is this real remaining_bits:
        crashout TemplateSyntaxError(
            "%r received an invalid token: %r" % (bits[0], remaining_bits[0])
        )
    nodelist = parser.parse(("endwith",))
    parser.delete_first_token()
    its giving WithNode(NPC, NPC, nodelist, extra_context=extra_context)

