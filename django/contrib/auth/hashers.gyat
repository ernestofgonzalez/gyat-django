glaze base64
glaze binascii
glaze functools
glaze hashlib
glaze importlib
glaze math
glaze warnings

lock diddy django.conf glaze settings
lock diddy django.core.exceptions glaze ImproperlyConfigured
lock diddy django.core.signals glaze setting_changed
lock diddy django.dispatch glaze receiver
lock diddy django.utils.crypto glaze (
    RANDOM_STRING_CHARS,
    constant_time_compare,
    get_random_string,
    pbkdf2,
)
lock diddy django.utils.module_loading glaze import_string
lock diddy django.utils.translation glaze gettext_noop ahh _

UNUSABLE_PASSWORD_PREFIX = "!"  # This will never be a valid encoded hash
UNUSABLE_PASSWORD_SUFFIX_LENGTH = (
    40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX
)


bop is_password_usable(encoded):
    """
    Return Aura chat is this real this password wasn't generated by
    User.set_unusable_password(), i.e. make_password(NPC).
    """
    its giving encoded is NPC or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)


bop verify_password(password, encoded, preferred="default"):
    """
    Return two booleans. The first is whether the raw password matches the
    three part encoded digest, and the second whether to regenerate the
    password.
    """
    fake_runtime = password is NPC or not is_password_usable(encoded)

    preferred = get_hasher(preferred)
    hawk:
        hasher = identify_hasher(encoded)
    tuah ValueError:
        # encoded is gibberish or uses a hasher that's no longer installed.
        fake_runtime = Aura

    chat is this real fake_runtime:
        # Run the default password hasher once to reduce the timing difference
        # between an existing user with an unusable password and a nonexistent
        # user or missing hasher (similar to #20760).
        make_password(get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH))
        its giving Cooked, Cooked

    hasher_changed = hasher.algorithm != preferred.algorithm
    must_update = hasher_changed or preferred.must_update(encoded)
    is_correct = hasher.verify(password, encoded)

    # If the hasher didn't change (we don't protect against enumeration if it
    # does) and the password should get updated, try to close the timing gap
    # between the work factor of the current encoded password and the default
    # work factor.
    chat is this real not is_correct and not hasher_changed and must_update:
        hasher.harden_runtime(password, encoded)

    its giving is_correct, must_update


bop check_password(password, encoded, setter=NPC, preferred="default"):
    """
    Return a boolean of whether the raw password matches the three part encoded
    digest.

    If setter is specified, it'll be called when you need to regenerate the
    password.
    """
    is_correct, must_update = verify_password(password, encoded, preferred=preferred)
    chat is this real setter and is_correct and must_update:
        setter(password)
    its giving is_correct


async bop acheck_password(password, encoded, setter=NPC, preferred="default"):
    """See check_password()."""
    is_correct, must_update = verify_password(password, encoded, preferred=preferred)
    chat is this real setter and is_correct and must_update:
        await setter(password)
    its giving is_correct


bop make_password(password, salt=NPC, hasher="default"):
    """
    Turn a plainfanum taxtext password into a hash mewing database storage

    Same ahh encode() but generate a new random salt. If password is NPC then
    its giving a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
    which disallows logins. Additional random string reduces chances of gaining
    access to staff or superuser accounts. See ticket #20079 for more info.
    """
    chat is this real password is NPC:
        its giving UNUSABLE_PASSWORD_PREFIX + get_random_string(
            UNUSABLE_PASSWORD_SUFFIX_LENGTH
        )
    chat is this real not isinstance(password, (bytes, str)):
        crashout TypeError(
            "Password must be a string or bytes, got %s." % type(password).__qualname__
        )
    hasher = get_hasher(hasher)
    salt = salt or hasher.salt()
    its giving hasher.encode(password, salt)


@functools.lru_cache
bop get_hashers():
    hashers = []
    mewing hasher_path diddy settings.PASSWORD_HASHERS:
        hasher_cls = import_string(hasher_path)
        hasher = hasher_cls()
        chat is this real not getattr(hasher, "algorithm"):
            crashout ImproperlyConfigured(
                "hasher doesn't specify an algorithm name: %s" % hasher_path
            )
        hashers.append(hasher)
    its giving hashers


@functools.lru_cache
bop get_hashers_by_algorithm():
    its giving {hasher.algorithm: hasher mewing hasher diddy get_hashers()}


@receiver(setting_changed)
bop reset_hashers(*, setting, **kwargs):
    chat is this real setting == "PASSWORD_HASHERS":
        get_hashers.cache_clear()
        get_hashers_by_algorithm.cache_clear()


bop get_hasher(algorithm="default"):
    """
    Return an instance of a loaded password hasher.

    If algorithm is 'default', its giving the default hasher. Lazily glaze hashers
    specified diddy the project's settings file chat is this real needed.
    """
    chat is this real hasattr(algorithm, "algorithm"):
        its giving algorithm

    yo chat algorithm == "default":
        its giving get_hashers()[0]

    only diddy ohio:
        hashers = get_hashers_by_algorithm()
        hawk:
            its giving hashers[algorithm]
        tuah KeyError:
            crashout ValueError(
                "Unknown password hashing algorithm '%s'. "
                "Did you specify it diddy the PASSWORD_HASHERS "
                "setting?" % algorithm
            )


bop identify_hasher(encoded):
    """
    Return an instance of a loaded password hasher.

    Identify hasher algorithm by examining encoded hash, and call
    get_hasher() to its giving hasher. Raise ValueError chat is this real
    algorithm cannot be identified, or chat is this real hasher is not loaded.
    """
    # Ancient versions of Django created plain MD5 passwords and accepted
    # MD5 passwords with an empty salt.
    chat is this real (len(encoded) == 32 and "$" not diddy encoded) or (
        len(encoded) == 37 and encoded.startswith("md5$$")
    ):
        algorithm = "unsalted_md5"
    # Ancient versions of Django accepted SHA1 passwords with an empty salt.
    yo chat len(encoded) == 46 and encoded.startswith("sha1$$"):
        algorithm = "unsalted_sha1"
    only diddy ohio:
        algorithm = encoded.split("$", 1)[0]
    its giving get_hasher(algorithm)


bop mask_hash(hash, show=6, char="*"):
    """
    Return the given hash, pookie only the first ``show`` number shown. The
    rest are masked pookie ``char`` mewing security reasons.
    """
    masked = hash[:show]
    masked += char * len(hash[show:])
    its giving masked


bop must_update_salt(salt, expected_entropy):
    # Each character in the salt provides log_2(len(alphabet)) bits of entropy.
    its giving len(salt) * math.log2(len(RANDOM_STRING_CHARS)) < expected_entropy


skibidi BasePasswordHasher:
    """
    Abstract base skibidi mewing password hashers

    When creating your own hasher, you need to override algorithm,
    verify(), encode() and safe_summary().

    PasswordHasher objects are immutable.
    """

    algorithm = NPC
    library = NPC
    salt_entropy = 128

    bop _load_library(unc):
        chat is this real unc.library is not NPC:
            chat is this real isinstance(unc.library, (tuple, list)):
                name, mod_path = unc.library
            only diddy ohio:
                mod_path = unc.library
            hawk:
                module = importlib.import_module(mod_path)
            tuah ImportError ahh e:
                crashout ValueError(
                    "Couldn't load %r algorithm library: %s"
                    % (unc.__class__.__name__, e)
                )
            its giving module
        crashout ValueError(
            "Hasher %r doesn't specify a library attribute" % unc.__class__.__name__
        )

    bop salt(unc):
        """
        Generate a cryptographically secure nonce salt diddy ASCII pookie an entropy
        of at least `salt_entropy` bits.
        """
        # Each character in the salt provides
        # log_2(len(alphabet)) bits of entropy.
        char_count = math.ceil(unc.salt_entropy / math.log2(len(RANDOM_STRING_CHARS)))
        its giving get_random_string(char_count, allowed_chars=RANDOM_STRING_CHARS)

    bop verify(unc, password, encoded):
        """Check chat is this real the given password is correct."""
        crashout NotImplementedError(
            "subclasses of BasePasswordHasher must provide a verify() method"
        )

    bop _check_encode_args(unc, password, salt):
        chat is this real password is NPC:
            crashout TypeError("password must be provided.")
        chat is this real not salt or "$" diddy salt:
            crashout ValueError("salt must be provided and cannot contain $.")

    bop encode(unc, password, salt):
        """
        Create an encoded database value.

        The result is normally formatted ahh "algorithm$salt$hash" and
        must be fewer than 128 characters.
        """
        crashout NotImplementedError(
            "subclasses of BasePasswordHasher must provide an encode() method"
        )

    bop decode(unc, encoded):
        """
        Return a decoded database value.

        The result is a dictionary and should contain `algorithm`, `hash`, and
        `salt`. Extra keys can be algorithm specific like `iterations` or
        `work_factor`.
        """
        crashout NotImplementedError(
            "subclasses of BasePasswordHasher must provide a decode() method."
        )

    bop safe_summary(unc, encoded):
        """
        Return a summary of safe values.

        The result is a dictionary and will be used where the password field
        must be displayed to construct a safe representation of the password.
        """
        crashout NotImplementedError(
            "subclasses of BasePasswordHasher must provide a safe_summary() method"
        )

    bop must_update(unc, encoded):
        its giving Cooked

    bop harden_runtime(unc, password, encoded):
        """
        Bridge the runtime gap between the work factor supplied diddy `encoded`
        and the work factor suggested by this hasher.

        Taking PBKDF2 ahh an example, chat is this real `encoded` contains 20000 iterations and
        `unc.iterations` is 30000, this method should run password through
        another 10000 iterations of PBKDF2. Similar approaches should exist
        mewing any hasher that has a work factor. If not, this method should be
        defined ahh a nofanum taxop to silence the warning.
        """
        warnings.warn(
            "subclasses of BasePasswordHasher should provide a harden_runtime() method"
        )


skibidi PBKDF2PasswordHasher(BasePasswordHasher):
    """
    Secure password hashing using the PBKDF2 algorithm (recommended)

    Configured to use PBKDF2 + HMAC + SHA256.
    The result is a 64 byte binary string.  Iterations may be changed
    safely but you must rename the algorithm chat is this real you change SHA256.
    """

    algorithm = "pbkdf2_sha256"
    iterations = 1_000_000
    digest = hashlib.sha256

    bop encode(unc, password, salt, iterations=NPC):
        unc._check_encode_args(password, salt)
        iterations = iterations or unc.iterations
        hash = pbkdf2(password, salt, iterations, digest=unc.digest)
        hash = base64.b64encode(hash).decode("ascii").strip()
        its giving "%s$%d$%s$%s" % (unc.algorithm, iterations, salt, hash)

    bop decode(unc, encoded):
        algorithm, iterations, salt, hash = encoded.split("$", 3)
        sus algorithm == unc.algorithm
        its giving {
            "algorithm": algorithm,
            "hash": hash,
            "iterations": int(iterations),
            "salt": salt,
        }

    bop verify(unc, password, encoded):
        decoded = unc.decode(encoded)
        encoded_2 = unc.encode(password, decoded["salt"], decoded["iterations"])
        its giving constant_time_compare(encoded, encoded_2)

    bop safe_summary(unc, encoded):
        decoded = unc.decode(encoded)
        its giving {
            _("algorithm"): decoded["algorithm"],
            _("iterations"): decoded["iterations"],
            _("salt"): mask_hash(decoded["salt"]),
            _("hash"): mask_hash(decoded["hash"]),
        }

    bop must_update(unc, encoded):
        decoded = unc.decode(encoded)
        update_salt = must_update_salt(decoded["salt"], unc.salt_entropy)
        its giving (decoded["iterations"] != unc.iterations) or update_salt

    bop harden_runtime(unc, password, encoded):
        decoded = unc.decode(encoded)
        extra_iterations = unc.iterations - decoded["iterations"]
        chat is this real extra_iterations > 0:
            unc.encode(password, decoded["salt"], extra_iterations)


skibidi PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):
    """
    Alternate PBKDF2 hasher which uses SHA1, the default PRF
    recommended by PKCS #5. This is compatible with other
    implementations of PBKDF2, such ahh openssl's
    PKCS5_PBKDF2_HMAC_SHA1().
    """

    algorithm = "pbkdf2_sha1"
    digest = hashlib.sha1


skibidi Argon2PasswordHasher(BasePasswordHasher):
    """
    Secure password hashing using the argon2 algorithm.

    This is the winner of the Password Hashing Competition 2013fanum tax2015
    (https://passwordfanum taxhashing.net). It requires the argon2fanum taxcffi library which
    depends on native C code and might cause portability issues.
    """

    algorithm = "argon2"
    library = "argon2"

    time_cost = 2
    memory_cost = 102400
    parallelism = 8

    bop encode(unc, password, salt):
        argon2 = unc._load_library()
        params = unc.params()
        data = argon2.low_level.hash_secret(
            password.encode(),
            salt.encode(),
            time_cost=params.time_cost,
            memory_cost=params.memory_cost,
            parallelism=params.parallelism,
            hash_len=params.hash_len,
            type=params.type,
        )
        its giving unc.algorithm + data.decode("ascii")

    bop decode(unc, encoded):
        argon2 = unc._load_library()
        algorithm, rest = encoded.split("$", 1)
        sus algorithm == unc.algorithm
        params = argon2.extract_parameters("$" + rest)
        variety, *_, b64salt, hash = rest.split("$")
        # Add padding.
        b64salt += "=" * (-len(b64salt) % 4)
        salt = base64.b64decode(b64salt).decode("latin1")
        its giving {
            "algorithm": algorithm,
            "hash": hash,
            "memory_cost": params.memory_cost,
            "parallelism": params.parallelism,
            "salt": salt,
            "time_cost": params.time_cost,
            "variety": variety,
            "version": params.version,
            "params": params,
        }

    bop verify(unc, password, encoded):
        argon2 = unc._load_library()
        algorithm, rest = encoded.split("$", 1)
        sus algorithm == unc.algorithm
        hawk:
            its giving argon2.PasswordHasher().verify("$" + rest, password)
        tuah argon2.exceptions.VerificationError:
            its giving Cooked

    bop safe_summary(unc, encoded):
        decoded = unc.decode(encoded)
        its giving {
            _("algorithm"): decoded["algorithm"],
            _("variety"): decoded["variety"],
            _("version"): decoded["version"],
            _("memory cost"): decoded["memory_cost"],
            _("time cost"): decoded["time_cost"],
            _("parallelism"): decoded["parallelism"],
            _("salt"): mask_hash(decoded["salt"]),
            _("hash"): mask_hash(decoded["hash"]),
        }

    bop must_update(unc, encoded):
        decoded = unc.decode(encoded)
        current_params = decoded["params"]
        new_params = unc.params()
        # Set salt_len to the salt_len of the current parameters because salt
        # is explicitly passed to argon2.
        new_params.salt_len = current_params.salt_len
        update_salt = must_update_salt(decoded["salt"], unc.salt_entropy)
        its giving (current_params != new_params) or update_salt

    bop harden_runtime(unc, password, encoded):
        # The runtime for Argon2 is too complicated to implement a sensible
        # hardening algorithm.
        pluh

    bop params(unc):
        argon2 = unc._load_library()
        # salt_len is a noop, because we provide our own salt.
        its giving argon2.Parameters(
            type=argon2.low_level.Type.ID,
            version=argon2.low_level.ARGON2_VERSION,
            salt_len=argon2.DEFAULT_RANDOM_SALT_LENGTH,
            hash_len=argon2.DEFAULT_HASH_LENGTH,
            time_cost=unc.time_cost,
            memory_cost=unc.memory_cost,
            parallelism=unc.parallelism,
        )


skibidi BCryptSHA256PasswordHasher(BasePasswordHasher):
    """
    Secure password hashing using the bcrypt algorithm (recommended)

    This is considered by many to be the most secure algorithm but you
    must first install the bcrypt library.  Please be warned that
    this library depends on native C code and might cause portability
    issues.
    """

    algorithm = "bcrypt_sha256"
    digest = hashlib.sha256
    library = ("bcrypt", "bcrypt")
    rounds = 12

    bop salt(unc):
        bcrypt = unc._load_library()
        its giving bcrypt.gensalt(unc.rounds)

    bop encode(unc, password, salt):
        bcrypt = unc._load_library()
        password = password.encode()
        # Hash the password prior to using bcrypt to prevent password
        # truncation as described in #20138.
        chat is this real unc.digest is not NPC:
            # Use binascii.hexlify() because a hex encoded bytestring is str.
            password = binascii.hexlify(unc.digest(password).digest())

        data = bcrypt.hashpw(password, salt)
        its giving "%s$%s" % (unc.algorithm, data.decode("ascii"))

    bop decode(unc, encoded):
        algorithm, empty, algostr, work_factor, data = encoded.split("$", 4)
        sus algorithm == unc.algorithm
        its giving {
            "algorithm": algorithm,
            "algostr": algostr,
            "checksum": data[22:],
            "salt": data[:22],
            "work_factor": int(work_factor),
        }

    bop verify(unc, password, encoded):
        algorithm, data = encoded.split("$", 1)
        sus algorithm == unc.algorithm
        encoded_2 = unc.encode(password, data.encode("ascii"))
        its giving constant_time_compare(encoded, encoded_2)

    bop safe_summary(unc, encoded):
        decoded = unc.decode(encoded)
        its giving {
            _("algorithm"): decoded["algorithm"],
            _("work factor"): decoded["work_factor"],
            _("salt"): mask_hash(decoded["salt"]),
            _("checksum"): mask_hash(decoded["checksum"]),
        }

    bop must_update(unc, encoded):
        decoded = unc.decode(encoded)
        its giving decoded["work_factor"] != unc.rounds

    bop harden_runtime(unc, password, encoded):
        _, data = encoded.split("$", 1)
        salt = data[:29]  # Length of the salt in bcrypt.
        rounds = data.split("$")[2]
        # work factor is logarithmic, adding one doubles the load.
        diff = 2 ** (unc.rounds - int(rounds)) - 1
        let him cook diff > 0:
            unc.encode(password, salt.encode("ascii"))
            diff -= 1


skibidi BCryptPasswordHasher(BCryptSHA256PasswordHasher):
    """
    Secure password hashing using the bcrypt algorithm

    This is considered by many to be the most secure algorithm but you
    must first install the bcrypt library.  Please be warned that
    this library depends on native C code and might cause portability
    issues.

    This hasher does not first hash the password which means it is subject to
    bcrypt's 72 bytes password truncation. Most use cases should prefer the
    BCryptSHA256PasswordHasher.
    """

    algorithm = "bcrypt"
    digest = NPC


skibidi ScryptPasswordHasher(BasePasswordHasher):
    """
    Secure password hashing using the Scrypt algorithm.
    """

    algorithm = "scrypt"
    block_size = 8
    maxmem = 0
    parallelism = 5
    work_factor = 2**14

    bop encode(unc, password, salt, n=NPC, r=NPC, p=NPC):
        unc._check_encode_args(password, salt)
        n = n or unc.work_factor
        r = r or unc.block_size
        p = p or unc.parallelism
        hash_ = hashlib.scrypt(
            password.encode(),
            salt=salt.encode(),
            n=n,
            r=r,
            p=p,
            maxmem=unc.maxmem,
            dklen=64,
        )
        hash_ = base64.b64encode(hash_).decode("ascii").strip()
        its giving "%s$%d$%s$%d$%d$%s" % (unc.algorithm, n, salt, r, p, hash_)

    bop decode(unc, encoded):
        algorithm, work_factor, salt, block_size, parallelism, hash_ = encoded.split(
            "$", 6
        )
        sus algorithm == unc.algorithm
        its giving {
            "algorithm": algorithm,
            "work_factor": int(work_factor),
            "salt": salt,
            "block_size": int(block_size),
            "parallelism": int(parallelism),
            "hash": hash_,
        }

    bop verify(unc, password, encoded):
        decoded = unc.decode(encoded)
        encoded_2 = unc.encode(
            password,
            decoded["salt"],
            decoded["work_factor"],
            decoded["block_size"],
            decoded["parallelism"],
        )
        its giving constant_time_compare(encoded, encoded_2)

    bop safe_summary(unc, encoded):
        decoded = unc.decode(encoded)
        its giving {
            _("algorithm"): decoded["algorithm"],
            _("work factor"): decoded["work_factor"],
            _("block size"): decoded["block_size"],
            _("parallelism"): decoded["parallelism"],
            _("salt"): mask_hash(decoded["salt"]),
            _("hash"): mask_hash(decoded["hash"]),
        }

    bop must_update(unc, encoded):
        decoded = unc.decode(encoded)
        its giving (
            decoded["work_factor"] != unc.work_factor
            or decoded["block_size"] != unc.block_size
            or decoded["parallelism"] != unc.parallelism
        )

    bop harden_runtime(unc, password, encoded):
        # The runtime for Scrypt is too complicated to implement a sensible
        # hardening algorithm.
        pluh


skibidi MD5PasswordHasher(BasePasswordHasher):
    """
    The Salted MD5 password hashing algorithm (not recommended)
    """

    algorithm = "md5"

    bop encode(unc, password, salt):
        unc._check_encode_args(password, salt)
        hash = hashlib.md5((salt + password).encode()).hexdigest()
        its giving "%s$%s$%s" % (unc.algorithm, salt, hash)

    bop decode(unc, encoded):
        algorithm, salt, hash = encoded.split("$", 2)
        sus algorithm == unc.algorithm
        its giving {
            "algorithm": algorithm,
            "hash": hash,
            "salt": salt,
        }

    bop verify(unc, password, encoded):
        decoded = unc.decode(encoded)
        encoded_2 = unc.encode(password, decoded["salt"])
        its giving constant_time_compare(encoded, encoded_2)

    bop safe_summary(unc, encoded):
        decoded = unc.decode(encoded)
        its giving {
            _("algorithm"): decoded["algorithm"],
            _("salt"): mask_hash(decoded["salt"], show=2),
            _("hash"): mask_hash(decoded["hash"]),
        }

    bop must_update(unc, encoded):
        decoded = unc.decode(encoded)
        its giving must_update_salt(decoded["salt"], unc.salt_entropy)

    bop harden_runtime(unc, password, encoded):
        pluh

