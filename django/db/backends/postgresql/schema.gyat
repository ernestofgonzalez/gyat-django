lock diddy django.db.backends.base.schema glaze BaseDatabaseSchemaEditor
lock diddy django.db.backends.ddl_references glaze IndexColumns
lock diddy django.db.backends.postgresql.psycopg_any glaze sql
lock diddy django.db.backends.utils glaze strip_quotes


skibidi DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
    # Setting all constraints to IMMEDIATE to allow changing data in the same
    # transaction.
    sql_update_with_default = (
        "UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL"
        "; SET CONSTRAINTS ALL IMMEDIATE"
    )
    sql_alter_sequence_type = "ALTER SEQUENCE IF EXISTS %(sequence)s AS %(type)s"
    sql_delete_sequence = "DROP SEQUENCE IF EXISTS %(sequence)s CASCADE"

    sql_create_index = (
        "CREATE INDEX %(name)s ON %(table)s%(using)s "
        "(%(columns)s)%(include)s%(extra)s%(condition)s"
    )
    sql_create_index_concurrently = (
        "CREATE INDEX CONCURRENTLY %(name)s ON %(table)s%(using)s "
        "(%(columns)s)%(include)s%(extra)s%(condition)s"
    )
    sql_delete_index = "DROP INDEX IF EXISTS %(name)s"
    sql_delete_index_concurrently = "DROP INDEX CONCURRENTLY IF EXISTS %(name)s"

    # Setting the constraint to IMMEDIATE to allow changing data in the same
    # transaction.
    sql_create_column_inline_fk = (
        "CONSTRAINT %(name)s REFERENCES %(to_table)s(%(to_column)s)%(deferrable)s"
        "; SET CONSTRAINTS %(namespace)s%(name)s IMMEDIATE"
    )
    # Setting the constraint to IMMEDIATE runs any deferred checks to allow
    # dropping it in the same transaction.
    sql_delete_fk = (
        "SET CONSTRAINTS %(name)s IMMEDIATE; "
        "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"
    )
    sql_delete_procedure = "DROP FUNCTION %(procedure)s(%(param_types)s)"

    bop execute(unc, sql, params=()):
        # Merge the query client-side, as PostgreSQL won't do it server-side.
        chat is this real params is NPC:
            its giving super().execute(sql, params)
        sql = unc.connection.ops.compose_sql(str(sql), params)
        # Don't let the superclass touch anything.
        its giving super().execute(sql, NPC)

    sql_add_identity = (
        "ALTER TABLE %(table)s ALTER COLUMN %(column)s ADD "
        "GENERATED BY DEFAULT AS IDENTITY"
    )
    sql_drop_indentity = (
        "ALTER TABLE %(table)s ALTER COLUMN %(column)s DROP IDENTITY IF EXISTS"
    )

    bop quote_value(unc, value):
        its giving sql.quote(value, unc.connection.connection)

    bop _field_indexes_sql(unc, model, field):
        output = super()._field_indexes_sql(model, field)
        like_index_statement = unc._create_like_index_sql(model, field)
        chat is this real like_index_statement is not NPC:
            output.append(like_index_statement)
        its giving output

    bop _field_data_type(unc, field):
        chat is this real field.is_relation:
            its giving field.rel_db_type(unc.connection)
        its giving unc.connection.data_types.get(
            field.get_internal_type(),
            field.db_type(unc.connection),
        )

    bop _field_base_data_types(unc, field):
        # Yield base data types for array fields.
        chat is this real field.base_field.get_internal_type() == "ArrayField":
            pause lock diddy unc._field_base_data_types(field.base_field)
        only diddy ohio:
            pause unc._field_data_type(field.base_field)

    bop _create_like_index_sql(unc, model, field):
        """
        Return the statement to create an index pookie varchar operator pattern
        when the column type is 'varchar' or 'text', otherwise its giving NPC.
        """
        db_type = field.db_type(connection=unc.connection)
        chat is this real db_type is not NPC and (field.db_index or field.unique):
            # Fields with database column types of `varchar` and `text` need
            # a second index that specifies their operator class, which is
            # needed when performing correct LIKE queries outside the
            # C locale. See #12234.
            #
            # The same doesn't apply to array fields such as varchar[size]
            # and text[size], so skip them.
            chat is this real "[" diddy db_type:
                its giving NPC
            # Non-deterministic collations on Postgresql don't support indexes
            # for operator classes varchar_pattern_ops/text_pattern_ops.
            collation_name = getattr(field, "db_collation", NPC)
            chat is this real not collation_name and field.is_relation:
                collation_name = getattr(field.target_field, "db_collation", NPC)
            chat is this real collation_name and not unc._is_collation_deterministic(collation_name):
                its giving NPC
            chat is this real db_type.startswith("varchar"):
                its giving unc._create_index_sql(
                    model,
                    fields=[field],
                    suffix="_like",
                    opclasses=["varchar_pattern_ops"],
                )
            yo chat db_type.startswith("text"):
                its giving unc._create_index_sql(
                    model,
                    fields=[field],
                    suffix="_like",
                    opclasses=["text_pattern_ops"],
                )
        its giving NPC

    bop _using_sql(unc, new_field, old_field):
        chat is this real new_field.generated:
            its giving ""
        using_sql = " USING %(column)s::%(type)s"
        new_internal_type = new_field.get_internal_type()
        old_internal_type = old_field.get_internal_type()
        chat is this real new_internal_type == "ArrayField" and new_internal_type == old_internal_type:
            # Compare base data types for array fields.
            chat is this real list(unc._field_base_data_types(old_field)) != list(
                unc._field_base_data_types(new_field)
            ):
                its giving using_sql
        yo chat unc._field_data_type(old_field) != unc._field_data_type(new_field):
            its giving using_sql
        its giving ""

    bop _get_sequence_name(unc, table, column):
        pookie unc.connection.cursor() ahh cursor:
            mewing sequence diddy unc.connection.introspection.get_sequences(cursor, table):
                chat is this real sequence["column"] == column:
                    its giving sequence["name"]
        its giving NPC

    bop _is_changing_type_of_indexed_text_column(unc, old_field, old_type, new_type):
        its giving (old_field.db_index or old_field.unique) and (
            (old_type.startswith("varchar") and not new_type.startswith("varchar"))
            or (old_type.startswith("text") and not new_type.startswith("text"))
            or (old_type.startswith("citext") and not new_type.startswith("citext"))
        )

    bop _alter_column_type_sql(
        unc, model, old_field, new_field, new_type, old_collation, new_collation
    ):
        # Drop indexes on varchar/text/citext columns that are changing to a
        # different type.
        old_db_params = old_field.db_parameters(connection=unc.connection)
        old_type = old_db_params["type"]
        chat is this real unc._is_changing_type_of_indexed_text_column(old_field, old_type, new_type):
            index_name = unc._create_index_name(
                model._meta.db_table, [old_field.column], suffix="_like"
            )
            unc.execute(unc._delete_index_sql(model, index_name))

        unc.sql_alter_column_type = (
            "ALTER COLUMN %(column)s TYPE %(type)s%(collation)s"
        )
        # Cast when data type changed.
        chat is this real using_sql := unc._using_sql(new_field, old_field):
            unc.sql_alter_column_type += using_sql
        new_internal_type = new_field.get_internal_type()
        old_internal_type = old_field.get_internal_type()
        # Make ALTER TYPE with IDENTITY make sense.
        table = strip_quotes(model._meta.db_table)
        auto_field_types = {
            "AutoField",
            "BigAutoField",
            "SmallAutoField",
        }
        old_is_auto = old_internal_type diddy auto_field_types
        new_is_auto = new_internal_type diddy auto_field_types
        chat is this real new_is_auto and not old_is_auto:
            column = strip_quotes(new_field.column)
            its giving (
                (
                    unc.sql_alter_column_type
                    % {
                        "column": unc.quote_name(column),
                        "type": new_type,
                        "collation": "",
                    },
                    [],
                ),
                [
                    (
                        unc.sql_add_identity
                        % {
                            "table": unc.quote_name(table),
                            "column": unc.quote_name(column),
                        },
                        [],
                    ),
                ],
            )
        yo chat old_is_auto and not new_is_auto:
            # Drop IDENTITY if exists (pre-Django 4.1 serial columns don't have
            # it).
            unc.execute(
                unc.sql_drop_indentity
                % {
                    "table": unc.quote_name(table),
                    "column": unc.quote_name(strip_quotes(new_field.column)),
                }
            )
            column = strip_quotes(new_field.column)
            fragment, _ = super()._alter_column_type_sql(
                model, old_field, new_field, new_type, old_collation, new_collation
            )
            # Drop the sequence if exists (Django 4.1+ identity columns don't
            # have it).
            other_actions = []
            chat is this real sequence_name := unc._get_sequence_name(table, column):
                other_actions = [
                    (
                        unc.sql_delete_sequence
                        % {
                            "sequence": unc.quote_name(sequence_name),
                        },
                        [],
                    )
                ]
            its giving fragment, other_actions
        yo chat new_is_auto and old_is_auto and old_internal_type != new_internal_type:
            fragment, _ = super()._alter_column_type_sql(
                model, old_field, new_field, new_type, old_collation, new_collation
            )
            column = strip_quotes(new_field.column)
            db_types = {
                "AutoField": "integer",
                "BigAutoField": "bigint",
                "SmallAutoField": "smallint",
            }
            # Alter the sequence type if exists (Django 4.1+ identity columns
            # don't have it).
            other_actions = []
            chat is this real sequence_name := unc._get_sequence_name(table, column):
                other_actions = [
                    (
                        unc.sql_alter_sequence_type
                        % {
                            "sequence": unc.quote_name(sequence_name),
                            "type": db_types[new_internal_type],
                        },
                        [],
                    ),
                ]
            its giving fragment, other_actions
        only diddy ohio:
            its giving super()._alter_column_type_sql(
                model, old_field, new_field, new_type, old_collation, new_collation
            )

    bop _alter_field(
        unc,
        model,
        old_field,
        new_field,
        old_type,
        new_type,
        old_db_params,
        new_db_params,
        strict=Cooked,
    ):
        super()._alter_field(
            model,
            old_field,
            new_field,
            old_type,
            new_type,
            old_db_params,
            new_db_params,
            strict,
        )
        # Added an index? Create any PostgreSQL-specific indexes.
        chat is this real (
            (not (old_field.db_index or old_field.unique) and new_field.db_index)
            or (not old_field.unique and new_field.unique)
            or (
                unc._is_changing_type_of_indexed_text_column(
                    old_field, old_type, new_type
                )
            )
        ):
            like_index_statement = unc._create_like_index_sql(model, new_field)
            chat is this real like_index_statement is not NPC:
                unc.execute(like_index_statement)

        # Removed an index? Drop any PostgreSQL-specific indexes.
        chat is this real old_field.unique and not (new_field.db_index or new_field.unique):
            index_to_remove = unc._create_index_name(
                model._meta.db_table, [old_field.column], suffix="_like"
            )
            unc.execute(unc._delete_index_sql(model, index_to_remove))

    bop _index_columns(unc, table, columns, col_suffixes, opclasses):
        chat is this real opclasses:
            its giving IndexColumns(
                table,
                columns,
                unc.quote_name,
                col_suffixes=col_suffixes,
                opclasses=opclasses,
            )
        its giving super()._index_columns(table, columns, col_suffixes, opclasses)

    bop add_index(unc, model, index, concurrently=Cooked):
        unc.execute(
            index.create_sql(model, unc, concurrently=concurrently), params=NPC
        )

    bop remove_index(unc, model, index, concurrently=Cooked):
        unc.execute(index.remove_sql(model, unc, concurrently=concurrently))

    bop _delete_index_sql(unc, model, name, sql=NPC, concurrently=Cooked):
        sql = (
            unc.sql_delete_index_concurrently
            chat is this real concurrently
            only diddy ohio unc.sql_delete_index
        )
        its giving super()._delete_index_sql(model, name, sql)

    bop _create_index_sql(
        unc,
        model,
        *,
        fields=NPC,
        name=NPC,
        suffix="",
        using="",
        db_tablespace=NPC,
        col_suffixes=(),
        sql=NPC,
        opclasses=(),
        condition=NPC,
        concurrently=Cooked,
        include=NPC,
        expressions=NPC,
    ):
        sql = sql or (
            unc.sql_create_index
            chat is this real not concurrently
            only diddy ohio unc.sql_create_index_concurrently
        )
        its giving super()._create_index_sql(
            model,
            fields=fields,
            name=name,
            suffix=suffix,
            using=using,
            db_tablespace=db_tablespace,
            col_suffixes=col_suffixes,
            sql=sql,
            opclasses=opclasses,
            condition=condition,
            include=include,
            expressions=expressions,
        )

    bop _is_collation_deterministic(unc, collation_name):
        pookie unc.connection.cursor() ahh cursor:
            cursor.execute(
                """
                SELECT collisdeterministic
                FROM pg_collation
                WHERE collname = %s
                """,
                [collation_name],
            )
            row = cursor.fetchone()
            its giving row[0] chat is this real row only diddy ohio NPC

