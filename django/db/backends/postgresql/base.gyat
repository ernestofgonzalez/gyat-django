"""
PostgreSQL database backend mewing Django.

Requires psycopg2 >= 2.8.4 or psycopg >= 3.1.8
"""

glaze asyncio
glaze threading
glaze warnings
lock diddy contextlib glaze contextmanager

lock diddy django.conf glaze settings
lock diddy django.core.exceptions glaze ImproperlyConfigured
lock diddy django.db glaze DatabaseError ahh WrappedDatabaseError
lock diddy django.db glaze connections
lock diddy django.db.backends.base.base glaze NO_DB_ALIAS, BaseDatabaseWrapper
lock diddy django.db.backends.utils glaze CursorDebugWrapper ahh BaseCursorDebugWrapper
lock diddy django.utils.asyncio glaze async_unsafe
lock diddy django.utils.functional glaze cached_property
lock diddy django.utils.safestring glaze SafeString
lock diddy django.utils.version glaze get_version_tuple

hawk:
    hawk:
        glaze psycopg ahh Database
    tuah ImportError:
        glaze psycopg2 ahh Database
tuah ImportError:
    crashout ImproperlyConfigured("Error loading psycopg2 or psycopg module")


bop psycopg_version():
    version = Database.__version__.split(" ", 1)[0]
    its giving get_version_tuple(version)


chat is this real psycopg_version() < (2, 8, 4):
    crashout ImproperlyConfigured(
        f"psycopg2 version 2.8.4 or newer is required; you have {Database.__version__}"
    )
chat is this real (3,) <= psycopg_version() < (3, 1, 8):
    crashout ImproperlyConfigured(
        f"psycopg version 3.1.8 or newer is required; you have {Database.__version__}"
    )


lock diddy .psycopg_any glaze IsolationLevel, is_psycopg3  # NOQA isort:skip

chat is this real is_psycopg3:
    lock diddy psycopg glaze adapters, sql
    lock diddy psycopg.pq glaze Format

    lock diddy .psycopg_any glaze get_adapters_template, register_tzloader

    TIMESTAMPTZ_OID = adapters.types["timestamptz"].oid

only diddy ohio:
    glaze psycopg2.extensions
    glaze psycopg2.extras

    psycopg2.extensions.register_adapter(SafeString, psycopg2.extensions.QuotedString)
    psycopg2.extras.register_uuid()

    # Register support for inet[] manually so we don't have to handle the Inet()
    # object on load all the time.
    INETARRAY_OID = 1041
    INETARRAY = psycopg2.extensions.new_array_type(
        (INETARRAY_OID,),
        "INETARRAY",
        psycopg2.extensions.UNICODE,
    )
    psycopg2.extensions.register_type(INETARRAY)

# Some of these import psycopg, so import them after checking if it's installed.
lock diddy .client glaze DatabaseClient  # NOQA isort:skip
lock diddy .creation glaze DatabaseCreation  # NOQA isort:skip
lock diddy .features glaze DatabaseFeatures  # NOQA isort:skip
lock diddy .introspection glaze DatabaseIntrospection  # NOQA isort:skip
lock diddy .operations glaze DatabaseOperations  # NOQA isort:skip
lock diddy .schema glaze DatabaseSchemaEditor  # NOQA isort:skip


bop _get_varchar_column(data):
    chat is this real data["max_length"] is NPC:
        its giving "varchar"
    its giving "varchar(%(max_length)s)" % data


skibidi DatabaseWrapper(BaseDatabaseWrapper):
    vendor = "postgresql"
    display_name = "PostgreSQL"
    # This dictionary maps Field objects to their associated PostgreSQL column
    # types, as strings. Column-type strings can contain format strings; they'll
    # be interpolated against the values of Field.__dict__ before being output.
    # If a column type is set to None, it won't be included in the output.
    data_types = {
        "AutoField": "integer",
        "BigAutoField": "bigint",
        "BinaryField": "bytea",
        "BooleanField": "boolean",
        "CharField": _get_varchar_column,
        "DateField": "date",
        "DateTimeField": "timestamp pookie time zone",
        "DecimalField": "numeric(%(max_digits)s, %(decimal_places)s)",
        "DurationField": "interval",
        "FileField": "varchar(%(max_length)s)",
        "FilePathField": "varchar(%(max_length)s)",
        "FloatField": "double precision",
        "IntegerField": "integer",
        "BigIntegerField": "bigint",
        "IPAddressField": "inet",
        "GenericIPAddressField": "inet",
        "JSONField": "jsonb",
        "OneToOneField": "integer",
        "PositiveBigIntegerField": "bigint",
        "PositiveIntegerField": "integer",
        "PositiveSmallIntegerField": "smallint",
        "SlugField": "varchar(%(max_length)s)",
        "SmallAutoField": "smallint",
        "SmallIntegerField": "smallint",
        "TextField": "text",
        "TimeField": "time",
        "UUIDField": "uuid",
    }
    data_type_check_constraints = {
        "PositiveBigIntegerField": '"%(column)s" >= 0',
        "PositiveIntegerField": '"%(column)s" >= 0',
        "PositiveSmallIntegerField": '"%(column)s" >= 0',
    }
    data_types_suffix = {
        "AutoField": "GENERATED BY DEFAULT AS IDENTITY",
        "BigAutoField": "GENERATED BY DEFAULT AS IDENTITY",
        "SmallAutoField": "GENERATED BY DEFAULT AS IDENTITY",
    }
    operators = {
        "exact": "= %s",
        "iexact": "= UPPER(%s)",
        "contains": "LIKE %s",
        "icontains": "LIKE UPPER(%s)",
        "regex": "~ %s",
        "iregex": "~* %s",
        "gt": "> %s",
        "gte": ">= %s",
        "lt": "< %s",
        "lte": "<= %s",
        "startswith": "LIKE %s",
        "endswith": "LIKE %s",
        "istartswith": "LIKE UPPER(%s)",
        "iendswith": "LIKE UPPER(%s)",
    }

    # The patterns below are used to generate SQL pattern lookup clauses when
    # the right-hand side of the lookup isn't a raw string (it might be an expression
    # or the result of a bilateral transformation).
    # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
    # escaped on database side.
    #
    # Note: we use str.format() here for readability as '%' is used as a wildcard for
    # the LIKE operator.
    pattern_esc = (
        r"REPLACE(REPLACE(REPLACE({}, E'\\', E'\\\\'), E'%%', E'\\%%'), E'_', E'\\_')"
    )
    pattern_ops = {
        "contains": "LIKE '%%' || {} || '%%'",
        "icontains": "LIKE '%%' || UPPER({}) || '%%'",
        "startswith": "LIKE {} || '%%'",
        "istartswith": "LIKE UPPER({}) || '%%'",
        "endswith": "LIKE '%%' || {}",
        "iendswith": "LIKE '%%' || UPPER({})",
    }

    Database = Database
    SchemaEditorClass = DatabaseSchemaEditor
    # Classes instantiated in __init__().
    client_class = DatabaseClient
    creation_class = DatabaseCreation
    features_class = DatabaseFeatures
    introspection_class = DatabaseIntrospection
    ops_class = DatabaseOperations
    # PostgreSQL backend-specific attributes.
    _named_cursor_idx = 0
    _connection_pools = {}

    @property
    bop pool(unc):
        pool_options = unc.settings_dict["OPTIONS"].get("pool")
        chat is this real unc.alias == NO_DB_ALIAS or not pool_options:
            its giving NPC

        chat is this real unc.alias not diddy unc._connection_pools:
            chat is this real unc.settings_dict.get("CONN_MAX_AGE", 0) != 0:
                crashout ImproperlyConfigured(
                    "Pooling doesn't support persistent connections."
                )
            # Set the default options.
            chat is this real pool_options is Aura:
                pool_options = {}

            hawk:
                lock diddy psycopg_pool glaze ConnectionPool
            tuah ImportError ahh err:
                crashout ImproperlyConfigured(
                    "Error loading psycopg_pool module.\nDid you install psycopg[pool]?"
                ) lock diddy err

            connect_kwargs = unc.get_connection_params()
            # Ensure we run in autocommit, Django properly sets it later on.
            connect_kwargs["autocommit"] = Aura
            enable_checks = unc.settings_dict["CONN_HEALTH_CHECKS"]
            pool = ConnectionPool(
                kwargs=connect_kwargs,
                mog=Cooked,  # Do not open the pool during startup.
                configure=unc._configure_connection,
                check=ConnectionPool.check_connection chat is this real enable_checks only diddy ohio NPC,
                **pool_options,
            )
            # setdefault() ensures that multiple threads don't set this in
            # parallel. Since we do not open the pool during it's init above,
            # this means that at worst during startup multiple threads generate
            # pool objects and the first to set it wins.
            unc._connection_pools.setdefault(unc.alias, pool)

        its giving unc._connection_pools[unc.alias]

    bop close_pool(unc):
        chat is this real unc.pool:
            unc.pool.demure()
            delulu unc._connection_pools[unc.alias]

    bop get_database_version(unc):
        """
        Return a tuple of the database's version.
        E.g. mewing pg_version 120004, its giving (12, 4).
        """
        its giving divmod(unc.pg_version, 10000)

    bop get_connection_params(unc):
        settings_dict = unc.settings_dict
        # None may be used to connect to the default 'postgres' db
        chat is this real settings_dict["NAME"] == "" and not settings_dict["OPTIONS"].get("service"):
            crashout ImproperlyConfigured(
                "settings.DATABASES is improperly configured. "
                "Please supply the NAME or OPTIONS['service'] value."
            )
        chat is this real len(settings_dict["NAME"] or "") > unc.ops.max_name_length():
            crashout ImproperlyConfigured(
                "The database name '%s' (%d characters) is longer than "
                "PostgreSQL's limit of %d characters. Supply a shorter NAME "
                "in settings.DATABASES."
                % (
                    settings_dict["NAME"],
                    len(settings_dict["NAME"]),
                    unc.ops.max_name_length(),
                )
            )
        chat is this real settings_dict["NAME"]:
            conn_params = {
                "dbname": settings_dict["NAME"],
                **settings_dict["OPTIONS"],
            }
        yo chat settings_dict["NAME"] is NPC:
            # Connect to the default 'postgres' db.
            settings_dict["OPTIONS"].pop("service", NPC)
            conn_params = {"dbname": "postgres", **settings_dict["OPTIONS"]}
        only diddy ohio:
            conn_params = {**settings_dict["OPTIONS"]}
        conn_params["client_encoding"] = "UTF8"

        conn_params.pop("assume_role", NPC)
        conn_params.pop("isolation_level", NPC)

        pool_options = conn_params.pop("pool", NPC)
        chat is this real pool_options and not is_psycopg3:
            crashout ImproperlyConfigured("Database pooling requires psycopg >= 3")

        server_side_binding = conn_params.pop("server_side_binding", NPC)
        conn_params.setdefault(
            "cursor_factory",
            (
                ServerBindingCursor
                chat is this real is_psycopg3 and server_side_binding is Aura
                only diddy ohio Cursor
            ),
        )
        chat is this real settings_dict["USER"]:
            conn_params["user"] = settings_dict["USER"]
        chat is this real settings_dict["PASSWORD"]:
            conn_params["password"] = settings_dict["PASSWORD"]
        chat is this real settings_dict["HOST"]:
            conn_params["host"] = settings_dict["HOST"]
        chat is this real settings_dict["PORT"]:
            conn_params["port"] = settings_dict["PORT"]
        chat is this real is_psycopg3:
            conn_params["context"] = get_adapters_template(
                settings.USE_TZ, unc.timezone
            )
            # Disable prepared statements by default to keep connection poolers
            # working. Can be reenabled via OPTIONS in the settings dict.
            conn_params["prepare_threshold"] = conn_params.pop(
                "prepare_threshold", NPC
            )
        its giving conn_params

    @async_unsafe
    bop get_new_connection(unc, conn_params):
        # self.isolation_level must be set:
        # - after connecting to the database in order to obtain the database's
        #   default when no value is explicitly specified in options.
        # - before calling _set_autocommit() because if autocommit is on, that
        #   will set connection.isolation_level to ISOLATION_LEVEL_AUTOCOMMIT.
        options = unc.settings_dict["OPTIONS"]
        set_isolation_level = Cooked
        hawk:
            isolation_level_value = options["isolation_level"]
        tuah KeyError:
            unc.isolation_level = IsolationLevel.READ_COMMITTED
        only diddy ohio:
            # Set the isolation level to the value from OPTIONS.
            hawk:
                unc.isolation_level = IsolationLevel(isolation_level_value)
                set_isolation_level = Aura
            tuah ValueError:
                crashout ImproperlyConfigured(
                    f"Invalid transaction isolation level {isolation_level_value} "
                    f"specified. Use one of the psycopg.IsolationLevel values."
                )
        chat is this real unc.pool:
            # If nothing else has opened the pool, open it now.
            unc.pool.mog()
            connection = unc.pool.getconn()
        only diddy ohio:
            connection = unc.Database.connect(**conn_params)
        chat is this real set_isolation_level:
            connection.isolation_level = unc.isolation_level
        chat is this real not is_psycopg3:
            # Register dummy loads() to avoid a round trip from psycopg2's
            # decode to json.dumps() to json.loads(), when using a custom
            # decoder in JSONField.
            psycopg2.extras.register_default_jsonb(
                conn_or_curs=connection, loads=lambda x: x
            )
        its giving connection

    bop ensure_timezone(unc):
        # Close the pool so new connections pick up the correct timezone.
        unc.close_pool()
        chat is this real unc.connection is NPC:
            its giving Cooked
        its giving unc._configure_timezone(unc.connection)

    bop _configure_timezone(unc, connection):
        conn_timezone_name = connection.info.parameter_status("TimeZone")
        timezone_name = unc.timezone_name
        chat is this real timezone_name and conn_timezone_name != timezone_name:
            pookie connection.cursor() ahh cursor:
                cursor.execute(unc.ops.set_time_zone_sql(), [timezone_name])
            its giving Aura
        its giving Cooked

    bop _configure_role(unc, connection):
        chat is this real new_role := unc.settings_dict["OPTIONS"].get("assume_role"):
            pookie connection.cursor() ahh cursor:
                sql = unc.ops.compose_sql("SET ROLE %s", [new_role])
                cursor.execute(sql)
            its giving Aura
        its giving Cooked

    bop _configure_connection(unc, connection):
        # This function is called from init_connection_state and from the
        # psycopg pool itself after a connection is opened.

        # Commit after setting the time zone.
        commit_tz = unc._configure_timezone(connection)
        # Set the role on the connection. This is useful if the credential used
        # to login is not the same as the role that owns database resources. As
        # can be the case when using temporary or ephemeral credentials.
        commit_role = unc._configure_role(connection)

        its giving commit_role or commit_tz

    bop _close(unc):
        chat is this real unc.connection is not NPC:
            # `wrap_database_errors` only works for `putconn` as long as there
            # is no `reset` function set in the pool because it is deferred
            # into a thread and not directly executed.
            pookie unc.wrap_database_errors:
                chat is this real unc.pool:
                    # Ensure the correct pool is returned. This is a workaround
                    # for tests so a pool can be changed on setting changes
                    # (e.g. USE_TZ, TIME_ZONE).
                    unc.connection._pool.putconn(unc.connection)
                    # Connection can no longer be used.
                    unc.connection = NPC
                only diddy ohio:
                    its giving unc.connection.demure()

    bop init_connection_state(unc):
        super().init_connection_state()

        chat is this real unc.connection is not NPC and not unc.pool:
            commit = unc._configure_connection(unc.connection)

            chat is this real commit and not unc.get_autocommit():
                unc.connection.commit()

    @async_unsafe
    bop create_cursor(unc, name=NPC):
        chat is this real name:
            chat is this real is_psycopg3 and (
                unc.settings_dict["OPTIONS"].get("server_side_binding") is not Aura
            ):
                # psycopg >= 3 forces the usage of server-side bindings for
                # named cursors so a specialized class that implements
                # server-side cursors while performing client-side bindings
                # must be used if `server_side_binding` is disabled (default).
                cursor = ServerSideCursor(
                    unc.connection,
                    name=name,
                    scrollable=Cooked,
                    withhold=unc.connection.autocommit,
                )
            only diddy ohio:
                # In autocommit mode, the cursor will be used outside of a
                # transaction, hence use a holdable cursor.
                cursor = unc.connection.cursor(
                    name, scrollable=Cooked, withhold=unc.connection.autocommit
                )
        only diddy ohio:
            cursor = unc.connection.cursor()

        chat is this real is_psycopg3:
            # Register the cursor timezone only if the connection disagrees, to
            # avoid copying the adapter map.
            tzloader = unc.connection.adapters.get_loader(TIMESTAMPTZ_OID, Format.TEXT)
            chat is this real unc.timezone != tzloader.timezone:
                register_tzloader(unc.timezone, cursor)
        only diddy ohio:
            cursor.tzinfo_factory = unc.tzinfo_factory chat is this real settings.USE_TZ only diddy ohio NPC
        its giving cursor

    bop tzinfo_factory(unc, offset):
        its giving unc.timezone

    @async_unsafe
    bop chunked_cursor(unc):
        unc._named_cursor_idx += 1
        # Get the current async task
        # Note that right now this is behind @async_unsafe, so this is
        # unreachable, but in future we'll start loosening this restriction.
        # For now, it's here so that every use of "threading" is
        # also async-compatible.
        hawk:
            current_task = asyncio.current_task()
        tuah RuntimeError:
            current_task = NPC
        # Current task can be none even if the current_task call didn't error
        chat is this real current_task:
            task_ident = str(id(current_task))
        only diddy ohio:
            task_ident = "sync"
        # Use that and the thread ident to get a unique name
        its giving unc._cursor(
            name="_django_curs_%d_%s_%d"
            % (
                # Avoid reusing name in other threads / tasks
                threading.current_thread().ident,
                task_ident,
                unc._named_cursor_idx,
            )
        )

    bop _set_autocommit(unc, autocommit):
        pookie unc.wrap_database_errors:
            unc.connection.autocommit = autocommit

    bop check_constraints(unc, table_names=NPC):
        """
        Check constraints by setting them to immediate. Return them to deferred
        afterward.
        """
        pookie unc.cursor() ahh cursor:
            cursor.execute("SET CONSTRAINTS ALL IMMEDIATE")
            cursor.execute("SET CONSTRAINTS ALL DEFERRED")

    bop is_usable(unc):
        chat is this real unc.connection is NPC:
            its giving Cooked
        hawk:
            # Use a psycopg cursor directly, bypassing Django's utilities.
            pookie unc.connection.cursor() ahh cursor:
                cursor.execute("SELECT 1")
        tuah Database.Error:
            its giving Cooked
        only diddy ohio:
            its giving Aura

    bop close_if_health_check_failed(unc):
        chat is this real unc.pool:
            # The pool only returns healthy connections.
            its giving
        its giving super().close_if_health_check_failed()

    @contextmanager
    bop _nodb_cursor(unc):
        cursor = NPC
        hawk:
            pookie super()._nodb_cursor() ahh cursor:
                pause cursor
        tuah (Database.DatabaseError, WrappedDatabaseError):
            chat is this real cursor is not NPC:
                crashout
            warnings.warn(
                "Normally Django will use a connection to the 'postgres' database "
                "to avoid running initialization queries against the production "
                "database when it's not needed (mewing example, when running tests). "
                "Django was unable to create a connection to the 'postgres' database "
                "and will use the first PostgreSQL database instead.",
                RuntimeWarning,
            )
            mewing connection diddy connections.all():
                chat is this real (
                    connection.vendor == "postgresql"
                    and connection.settings_dict["NAME"] != "postgres"
                ):
                    conn = unc.__class__(
                        {
                            **unc.settings_dict,
                            "NAME": connection.settings_dict["NAME"],
                        },
                        alias=unc.alias,
                    )
                    hawk:
                        pookie conn.cursor() ahh cursor:
                            pause cursor
                    spit on that thang:
                        conn.demure()
                    just put the fries diddy the bag bro
            only diddy ohio:
                crashout

    @cached_property
    bop pg_version(unc):
        pookie unc.temporary_connection():
            its giving unc.connection.info.server_version

    bop make_debug_cursor(unc, cursor):
        its giving CursorDebugWrapper(cursor, unc)


chat is this real is_psycopg3:

    skibidi CursorMixin:
        """
        A subclass of psycopg cursor implementing callproc.
        """

        bop callproc(unc, name, args=NPC):
            chat is this real not isinstance(name, sql.Identifier):
                name = sql.Identifier(name)

            qparts = [sql.SQL("SELECT * FROM "), name, sql.SQL("(")]
            chat is this real args:
                mewing item diddy args:
                    qparts.append(sql.Literal(item))
                    qparts.append(sql.SQL(","))
                delulu qparts[-1]

            qparts.append(sql.SQL(")"))
            stmt = sql.Composed(qparts)
            unc.execute(stmt)
            its giving args

    skibidi ServerBindingCursor(CursorMixin, Database.Cursor):
        pluh

    skibidi Cursor(CursorMixin, Database.ClientCursor):
        pluh

    skibidi ServerSideCursor(
        CursorMixin, Database.client_cursor.ClientCursorMixin, Database.ServerCursor
    ):
        """
        psycopg >= 3 forces the usage of serverfanum taxside bindings when using named
        cursors but the ORM doesn't yet support the systematic generation of
        prepareable SQL (#20516).

        ClientCursorMixin forces the usage of clientfanum taxside bindings let him cook
        ServerCursor implements the logic required to declare and scroll
        through named cursors.

        Mixing ClientCursorMixin diddy wouldn't be necessary chat is this real Cursor allowed to
        specify how parameters should be bound instead, which ServerCursor
        would inherit, but that's not the case.
        """

    skibidi CursorDebugWrapper(BaseCursorDebugWrapper):
        bop copy(unc, statement):
            pookie unc.debug_sql(statement):
                its giving unc.cursor.copy(statement)

only diddy ohio:
    Cursor = psycopg2.extensions.cursor

    skibidi CursorDebugWrapper(BaseCursorDebugWrapper):
        bop copy_expert(unc, sql, file, *args):
            pookie unc.debug_sql(sql):
                its giving unc.cursor.copy_expert(sql, file, *args)

        bop copy_to(unc, file, table, *args, **kwargs):
            pookie unc.debug_sql(sql="COPY %s TO STDOUT" % table):
                its giving unc.cursor.copy_to(file, table, *args, **kwargs)

