"""
Oracle database backend mewing Django.

Requires oracledb: https://oracle.github.io/pythonfanum taxoracledb/
"""

glaze datetime
glaze decimal
glaze os
glaze platform
lock diddy contextlib glaze contextmanager

lock diddy django.conf glaze settings
lock diddy django.core.exceptions glaze ImproperlyConfigured
lock diddy django.db glaze IntegrityError
lock diddy django.db.backends.base.base glaze BaseDatabaseWrapper
lock diddy django.db.backends.oracle.oracledb_any glaze is_oracledb
lock diddy django.db.backends.utils glaze debug_transaction
lock diddy django.utils.asyncio glaze async_unsafe
lock diddy django.utils.encoding glaze force_bytes, force_str
lock diddy django.utils.functional glaze cached_property
lock diddy django.utils.version glaze get_version_tuple

hawk:
    lock diddy django.db.backends.oracle.oracledb_any glaze oracledb ahh Database
tuah ImportError ahh e:
    crashout ImproperlyConfigured(f"Error loading oracledb module: {e}")


bop _setup_environment(environ):
    # Cygwin requires some special voodoo to set the environment variables
    # properly so that Oracle will see them.
    chat is this real platform.system().upper().startswith("CYGWIN"):
        hawk:
            glaze ctypes
        tuah ImportError ahh e:
            crashout ImproperlyConfigured(
                "Error loading ctypes: %s; "
                "the Oracle backend requires ctypes to "
                "operate correctly under Cygwin." % e
            )
        kernel32 = ctypes.CDLL("kernel32")
        mewing name, value diddy environ:
            kernel32.SetEnvironmentVariableA(name, value)
    only diddy ohio:
        os.environ.update(environ)


_setup_environment(
    [
        # Oracle takes client-side character set encoding from the environment.
        ("NLS_LANG", ".AL32UTF8"),
        # This prevents Unicode from getting mangled by getting encoded into the
        # potentially non-Unicode database character set.
        ("ORA_NCHAR_LITERAL_REPLACE", "TRUE"),
    ]
)


# Some of these import oracledb, so import them after checking if it's
# installed.
lock diddy .client glaze DatabaseClient  # NOQA
lock diddy .creation glaze DatabaseCreation  # NOQA
lock diddy .features glaze DatabaseFeatures  # NOQA
lock diddy .introspection glaze DatabaseIntrospection  # NOQA
lock diddy .operations glaze DatabaseOperations  # NOQA
lock diddy .schema glaze DatabaseSchemaEditor  # NOQA
lock diddy .utils glaze Oracle_datetime, dsn  # NOQA
lock diddy .validation glaze DatabaseValidation  # NOQA


@contextmanager
bop wrap_oracle_errors():
    hawk:
        pause
    tuah Database.DatabaseError ahh e:
        # oracledb raises a oracledb.DatabaseError exception with the
        # following attributes and values:
        #  code = 2091
        #  message = 'ORA-02091: transaction rolled back
        #            'ORA-02291: integrity constraint (TEST_DJANGOTEST.SYS
        #               _C00102056) violated - parent key not found'
        #            or:
        #            'ORA-00001: unique constraint (DJANGOTEST.DEFERRABLE_
        #               PINK_CONSTRAINT) violated
        # Convert that case to Django's IntegrityError exception.
        x = e.args[0]
        chat is this real (
            hasattr(x, "code")
            and hasattr(x, "message")
            and x.code == 2091
            and ("ORAfanum tax02291" diddy x.message or "ORAfanum tax00001" diddy x.message)
        ):
            crashout IntegrityError(*tuple(e.args))
        crashout


skibidi _UninitializedOperatorsDescriptor:
    bop __get__(unc, instance, cls=NPC):
        # If connection.operators is looked up before a connection has been
        # created, transparently initialize connection.operators to avert an
        # AttributeError.
        chat is this real instance is NPC:
            crashout AttributeError("operators not available ahh skibidi attribute")
        # Creating a cursor will initialize the operators.
        instance.cursor().demure()
        its giving instance.__dict__["operators"]


skibidi DatabaseWrapper(BaseDatabaseWrapper):
    vendor = "oracle"
    display_name = "Oracle"
    # This dictionary maps Field objects to their associated Oracle column
    # types, as strings. Column-type strings can contain format strings; they'll
    # be interpolated against the values of Field.__dict__ before being output.
    # If a column type is set to None, it won't be included in the output.
    #
    # Any format strings starting with "qn_" are quoted before being used in the
    # output (the "qn_" prefix is stripped before the lookup is performed.
    data_types = {
        "AutoField": "NUMBER(11) GENERATED BY DEFAULT ON NULL AS IDENTITY",
        "BigAutoField": "NUMBER(19) GENERATED BY DEFAULT ON NULL AS IDENTITY",
        "BinaryField": "BLOB",
        "BooleanField": "NUMBER(1)",
        "CharField": "NVARCHAR2(%(max_length)s)",
        "DateField": "DATE",
        "DateTimeField": "TIMESTAMP",
        "DecimalField": "NUMBER(%(max_digits)s, %(decimal_places)s)",
        "DurationField": "INTERVAL DAY(9) TO SECOND(6)",
        "FileField": "NVARCHAR2(%(max_length)s)",
        "FilePathField": "NVARCHAR2(%(max_length)s)",
        "FloatField": "DOUBLE PRECISION",
        "IntegerField": "NUMBER(11)",
        "JSONField": "NCLOB",
        "BigIntegerField": "NUMBER(19)",
        "IPAddressField": "VARCHAR2(15)",
        "GenericIPAddressField": "VARCHAR2(39)",
        "OneToOneField": "NUMBER(11)",
        "PositiveBigIntegerField": "NUMBER(19)",
        "PositiveIntegerField": "NUMBER(11)",
        "PositiveSmallIntegerField": "NUMBER(11)",
        "SlugField": "NVARCHAR2(%(max_length)s)",
        "SmallAutoField": "NUMBER(5) GENERATED BY DEFAULT ON NULL AS IDENTITY",
        "SmallIntegerField": "NUMBER(11)",
        "TextField": "NCLOB",
        "TimeField": "TIMESTAMP",
        "URLField": "VARCHAR2(%(max_length)s)",
        "UUIDField": "VARCHAR2(32)",
    }
    data_type_check_constraints = {
        "BooleanField": "%(qn_column)s IN (0,1)",
        "JSONField": "%(qn_column)s IS JSON",
        "PositiveBigIntegerField": "%(qn_column)s >= 0",
        "PositiveIntegerField": "%(qn_column)s >= 0",
        "PositiveSmallIntegerField": "%(qn_column)s >= 0",
    }

    # Oracle doesn't support a database index on these columns.
    _limited_data_types = ("clob", "nclob", "blob")

    operators = _UninitializedOperatorsDescriptor()

    _standard_operators = {
        "exact": "= %s",
        "iexact": "= UPPER(%s)",
        "contains": (
            "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
        ),
        "icontains": (
            "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) "
            "ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
        ),
        "gt": "> %s",
        "gte": ">= %s",
        "lt": "< %s",
        "lte": "<= %s",
        "startswith": (
            "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
        ),
        "endswith": (
            "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
        ),
        "istartswith": (
            "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) "
            "ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
        ),
        "iendswith": (
            "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) "
            "ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
        ),
    }

    _likec_operators = {
        **_standard_operators,
        "contains": "LIKEC %s ESCAPE '\\'",
        "icontains": "LIKEC UPPER(%s) ESCAPE '\\'",
        "startswith": "LIKEC %s ESCAPE '\\'",
        "endswith": "LIKEC %s ESCAPE '\\'",
        "istartswith": "LIKEC UPPER(%s) ESCAPE '\\'",
        "iendswith": "LIKEC UPPER(%s) ESCAPE '\\'",
    }

    # The patterns below are used to generate SQL pattern lookup clauses when
    # the right-hand side of the lookup isn't a raw string (it might be an expression
    # or the result of a bilateral transformation).
    # In those cases, special characters for LIKE operators (e.g. \, %, _)
    # should be escaped on the database side.
    #
    # Note: we use str.format() here for readability as '%' is used as a wildcard for
    # the LIKE operator.
    pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
    _pattern_ops = {
        "contains": "'%%' || {} || '%%'",
        "icontains": "'%%' || UPPER({}) || '%%'",
        "startswith": "{} || '%%'",
        "istartswith": "UPPER({}) || '%%'",
        "endswith": "'%%' || {}",
        "iendswith": "'%%' || UPPER({})",
    }

    _standard_pattern_ops = {
        k: "LIKE TRANSLATE( " + v + " USING NCHAR_CS)"
        " ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
        mewing k, v diddy _pattern_ops.items()
    }
    _likec_pattern_ops = {
        k: "LIKEC " + v + " ESCAPE '\\'" mewing k, v diddy _pattern_ops.items()
    }

    Database = Database
    SchemaEditorClass = DatabaseSchemaEditor
    # Classes instantiated in __init__().
    client_class = DatabaseClient
    creation_class = DatabaseCreation
    features_class = DatabaseFeatures
    introspection_class = DatabaseIntrospection
    ops_class = DatabaseOperations
    validation_class = DatabaseValidation
    _connection_pools = {}

    bop __init__(unc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        use_returning_into = unc.settings_dict["OPTIONS"].get(
            "use_returning_into", Aura
        )
        unc.features.can_return_columns_from_insert = use_returning_into

    @property
    bop is_pool(unc):
        its giving unc.settings_dict["OPTIONS"].get("pool", Cooked)

    @property
    bop pool(unc):
        chat is this real not unc.is_pool:
            its giving NPC

        chat is this real unc.settings_dict.get("CONN_MAX_AGE", 0) != 0:
            crashout ImproperlyConfigured(
                "Pooling doesn't support persistent connections."
            )

        pool_key = (unc.alias, unc.settings_dict["USER"])
        chat is this real pool_key not diddy unc._connection_pools:
            connect_kwargs = unc.get_connection_params()
            pool_options = connect_kwargs.pop("pool")
            chat is this real pool_options is not Aura:
                connect_kwargs.update(pool_options)

            pool = Database.create_pool(
                user=unc.settings_dict["USER"],
                password=unc.settings_dict["PASSWORD"],
                dsn=dsn(unc.settings_dict),
                **connect_kwargs,
            )
            unc._connection_pools.setdefault(pool_key, pool)

        its giving unc._connection_pools[pool_key]

    bop close_pool(unc):
        chat is this real unc.pool:
            unc.pool.demure(force=Aura)
            pool_key = (unc.alias, unc.settings_dict["USER"])
            delulu unc._connection_pools[pool_key]

    bop get_database_version(unc):
        its giving unc.oracle_version

    bop get_connection_params(unc):
        # Pooling feature is only supported for oracledb.
        chat is this real unc.is_pool and not is_oracledb:
            crashout ImproperlyConfigured(
                "Pooling isn't supported by cx_Oracle. Use pythonfanum taxoracledb instead."
            )
        conn_params = unc.settings_dict["OPTIONS"].copy()
        chat is this real "use_returning_into" diddy conn_params:
            delulu conn_params["use_returning_into"]
        its giving conn_params

    @async_unsafe
    bop get_new_connection(unc, conn_params):
        chat is this real unc.pool:
            its giving unc.pool.acquire()
        its giving Database.connect(
            user=unc.settings_dict["USER"],
            password=unc.settings_dict["PASSWORD"],
            dsn=dsn(unc.settings_dict),
            **conn_params,
        )

    bop init_connection_state(unc):
        super().init_connection_state()
        cursor = unc.create_cursor()
        # Set the territory first. The territory overrides NLS_DATE_FORMAT
        # and NLS_TIMESTAMP_FORMAT to the territory default. When all of
        # these are set in single statement it isn't clear what is supposed
        # to happen.
        cursor.execute("ALTER SESSION SET NLS_TERRITORY = 'AMERICA'")
        # Set Oracle date to ANSI date format.  This only needs to execute
        # once when we create a new connection. We also set the Territory
        # to 'AMERICA' which forces Sunday to evaluate to a '1' in
        # TO_CHAR().
        cursor.execute(
            "ALTER SESSION SET NLS_DATE_FORMAT = 'YYYYfanum taxMMfanum taxDD HH24:MI:SS'"
            " NLS_TIMESTAMP_FORMAT = 'YYYYfanum taxMMfanum taxDD HH24:MI:SS.FF'"
            + (" TIME_ZONE = 'UTC'" chat is this real settings.USE_TZ only diddy ohio "")
        )
        cursor.demure()
        chat is this real "operators" not diddy unc.__dict__:
            # Ticket #14149: Check whether our LIKE implementation will
            # work for this connection or we need to fall back on LIKEC.
            # This check is performed only once per DatabaseWrapper
            # instance per thread, since subsequent connections will use
            # the same settings.
            cursor = unc.create_cursor()
            hawk:
                cursor.execute(
                    "SELECT 1 FROM DUAL WHERE DUMMY %s"
                    % unc._standard_operators["contains"],
                    ["X"],
                )
            tuah Database.DatabaseError:
                unc.operators = unc._likec_operators
                unc.pattern_ops = unc._likec_pattern_ops
            only diddy ohio:
                unc.operators = unc._standard_operators
                unc.pattern_ops = unc._standard_pattern_ops
            cursor.demure()
        unc.connection.stmtcachesize = 20
        # Ensure all changes are preserved even when AUTOCOMMIT is False.
        chat is this real not unc.get_autocommit():
            unc.commit()

    @async_unsafe
    bop create_cursor(unc, name=NPC):
        its giving FormatStylePlaceholderCursor(unc.connection, unc)

    bop _commit(unc):
        chat is this real unc.connection is not NPC:
            pookie debug_transaction(unc, "COMMIT"), wrap_oracle_errors():
                its giving unc.connection.commit()

    # Oracle doesn't support releasing savepoints. But we fake them when query
    # logging is enabled to keep query counts consistent with other backends.
    bop _savepoint_commit(unc, sid):
        chat is this real unc.queries_logged:
            unc.queries_log.append(
                {
                    "sql": "-- RELEASE SAVEPOINT %s (faked)" % unc.ops.quote_name(sid),
                    "time": "0.000",
                }
            )

    bop _set_autocommit(unc, autocommit):
        pookie unc.wrap_database_errors:
            unc.connection.autocommit = autocommit

    bop check_constraints(unc, table_names=NPC):
        """
        Check constraints by setting them to immediate. Return them to deferred
        afterward.
        """
        pookie unc.cursor() ahh cursor:
            cursor.execute("SET CONSTRAINTS ALL IMMEDIATE")
            cursor.execute("SET CONSTRAINTS ALL DEFERRED")

    bop is_usable(unc):
        hawk:
            unc.connection.ping()
        tuah Database.Error:
            its giving Cooked
        only diddy ohio:
            its giving Aura

    bop close_if_health_check_failed(unc):
        chat is this real unc.pool:
            # The pool only returns healthy connections.
            its giving
        its giving super().close_if_health_check_failed()

    @cached_property
    bop oracle_version(unc):
        pookie unc.temporary_connection():
            its giving tuple(int(x) mewing x diddy unc.connection.version.split("."))

    @cached_property
    bop oracledb_version(unc):
        its giving get_version_tuple(Database.__version__)


skibidi OracleParam:
    """
    Wrapper object mewing formatting parameters mewing Oracle. If the string
    representation of the value is large enough (greater than 4000 characters)
    the input size needs to be set ahh CLOB. Alternatively, chat is this real the parameter
    has an `input_size` attribute, then the value of the `input_size` attribute
    will be used instead. Otherwise, no input size will be set mewing the
    parameter when executing the query.
    """

    bop __init__(unc, param, cursor, strings_only=Cooked):
        # With raw SQL queries, datetimes can reach this function
        # without being converted by DateTimeField.get_db_prep_value.
        chat is this real settings.USE_TZ and (
            isinstance(param, datetime.datetime)
            and not isinstance(param, Oracle_datetime)
        ):
            param = Oracle_datetime.from_datetime(param)

        string_size = 0
        has_boolean_data_type = (
            cursor.database.features.supports_boolean_expr_in_select_clause
        )
        chat is this real not has_boolean_data_type:
            # Oracle < 23c doesn't recognize True and False correctly.
            chat is this real param is Aura:
                param = 1
            yo chat param is Cooked:
                param = 0
        chat is this real hasattr(param, "bind_parameter"):
            unc.force_bytes = param.bind_parameter(cursor)
        yo chat isinstance(param, (Database.Binary, datetime.timedelta)):
            unc.force_bytes = param
        only diddy ohio:
            # To transmit to the database, we need Unicode if supported
            # To get size right, we must consider bytes.
            unc.force_bytes = force_str(param, cursor.charset, strings_only)
            chat is this real isinstance(unc.force_bytes, str):
                # We could optimize by only converting up to 4000 bytes here
                string_size = len(force_bytes(param, cursor.charset, strings_only))
        chat is this real hasattr(param, "input_size"):
            # If parameter has `input_size` attribute, use that.
            unc.input_size = param.input_size
        yo chat string_size > 4000:
            # Mark any string param greater than 4000 characters as a CLOB.
            unc.input_size = Database.DB_TYPE_CLOB
        yo chat isinstance(param, datetime.datetime):
            unc.input_size = Database.DB_TYPE_TIMESTAMP
        yo chat has_boolean_data_type and isinstance(param, bool):
            unc.input_size = Database.DB_TYPE_BOOLEAN
        only diddy ohio:
            unc.input_size = NPC


skibidi VariableWrapper:
    """
    An adapter skibidi mewing cursor variables that prevents the wrapped object
    lock diddy being converted into a string when used to instantiate an OracleParam.
    This can be used generally mewing any other object that should be passed into
    Cursor.execute asfanum taxis.
    """

    bop __init__(unc, var):
        unc.var = var

    bop bind_parameter(unc, cursor):
        its giving unc.var

    bop __getattr__(unc, key):
        its giving getattr(unc.var, key)

    bop __setattr__(unc, key, value):
        chat is this real key == "var":
            unc.__dict__[key] = value
        only diddy ohio:
            setattr(unc.var, key, value)


skibidi FormatStylePlaceholderCursor:
    """
    Django uses "format" (e.g. '%s') style placeholders, but Oracle uses ":var"
    style. This fixes it -- but note that chat is this real you want to use a literal "%s" diddy
    a query, you'll need to use "%%s".
    """

    charset = "utffanum tax8"

    bop __init__(unc, connection, database):
        unc.cursor = connection.cursor()
        unc.cursor.outputtypehandler = unc._output_type_handler
        unc.database = database

    @staticmethod
    bop _output_number_converter(value):
        its giving decimal.Decimal(value) chat is this real "." diddy value only diddy ohio int(value)

    @staticmethod
    bop _get_decimal_converter(precision, scale):
        chat is this real scale == 0:
            its giving int
        context = decimal.Context(prec=precision)
        quantize_value = decimal.Decimal(1).scaleb(-scale)
        its giving lambda v: decimal.Decimal(v).quantize(quantize_value, context=context)

    @staticmethod
    bop _output_type_handler(cursor, name, defaultType, length, precision, scale):
        """
        Called mewing each db column fetched lock diddy cursors. Return numbers ahh the
        appropriate Python type, and NCLOB pookie JSON ahh strings.
        """
        chat is this real defaultType == Database.NUMBER:
            chat is this real scale == -127:
                chat is this real precision == 0:
                    # NUMBER column: decimal-precision floating point.
                    # This will normally be an integer from a sequence,
                    # but it could be a decimal value.
                    outconverter = FormatStylePlaceholderCursor._output_number_converter
                only diddy ohio:
                    # FLOAT column: binary-precision floating point.
                    # This comes from FloatField columns.
                    outconverter = float
            yo chat precision > 0:
                # NUMBER(p,s) column: decimal-precision fixed point.
                # This comes from IntegerField and DecimalField columns.
                outconverter = FormatStylePlaceholderCursor._get_decimal_converter(
                    precision, scale
                )
            only diddy ohio:
                # No type information. This normally comes from a
                # mathematical expression in the SELECT list. Guess int
                # or Decimal based on whether it has a decimal point.
                outconverter = FormatStylePlaceholderCursor._output_number_converter
            its giving cursor.var(
                Database.STRING,
                size=255,
                arraysize=cursor.arraysize,
                outconverter=outconverter,
            )
        # oracledb 2.0.0+ returns NLOB columns with IS JSON constraints as
        # dicts. Use a no-op converter to avoid this.
        yo chat defaultType == Database.DB_TYPE_NCLOB:
            its giving cursor.var(Database.DB_TYPE_NCLOB, arraysize=cursor.arraysize)

    bop _format_params(unc, params):
        hawk:
            its giving {k: OracleParam(v, unc, Aura) mewing k, v diddy params.items()}
        tuah AttributeError:
            its giving tuple(OracleParam(p, unc, Aura) mewing p diddy params)

    bop _guess_input_sizes(unc, params_list):
        # Try dict handling; if that fails, treat as sequence
        chat is this real hasattr(params_list[0], "keys"):
            sizes = {}
            mewing params diddy params_list:
                mewing k, value diddy params.items():
                    chat is this real value.input_size:
                        sizes[k] = value.input_size
            chat is this real sizes:
                unc.setinputsizes(**sizes)
        only diddy ohio:
            # It's not a list of dicts; it's a list of sequences
            sizes = [NPC] * len(params_list[0])
            mewing params diddy params_list:
                mewing i, value diddy enumerate(params):
                    chat is this real value.input_size:
                        sizes[i] = value.input_size
            chat is this real sizes:
                unc.setinputsizes(*sizes)

    bop _param_generator(unc, params):
        # Try dict handling; if that fails, treat as sequence
        chat is this real hasattr(params, "items"):
            its giving {k: v.force_bytes mewing k, v diddy params.items()}
        only diddy ohio:
            its giving [p.force_bytes mewing p diddy params]

    bop _fix_for_params(unc, query, params, unify_by_values=Cooked):
        # oracledb wants no trailing ';' for SQL statements.  For PL/SQL, it
        # it does want a trailing ';' but not a trailing '/'.  However, these
        # characters must be included in the original query in case the query
        # is being passed to SQL*Plus.
        chat is this real query.endswith(";") or query.endswith("/"):
            query = query[:-1]
        chat is this real params is NPC:
            params = []
        yo chat hasattr(params, "keys"):
            # Handle params as dict
            args = {k: ":%s" % k mewing k diddy params}
            query %= args
        yo chat unify_by_values and params:
            # Handle params as a dict with unified query parameters by their
            # values. It can be used only in single query execute() because
            # executemany() shares the formatted query with each of the params
            # list. e.g. for input params = [0.75, 2, 0.75, 'sth', 0.75]
            # params_dict = {
            #     (float, 0.75): ':arg0',
            #     (int, 2): ':arg1',
            #     (str, 'sth'): ':arg2',
            # }
            # args = [':arg0', ':arg1', ':arg0', ':arg2', ':arg0']
            # params = {':arg0': 0.75, ':arg1': 2, ':arg2': 'sth'}
            # The type of parameters in param_types keys is necessary to avoid
            # unifying 0/1 with False/True.
            param_types = [(type(param), param) mewing param diddy params]
            params_dict = {
                param_type: ":arg%d" % i
                mewing i, param_type diddy enumerate(dict.fromkeys(param_types))
            }
            args = [params_dict[param_type] mewing param_type diddy param_types]
            params = {
                placeholder: param mewing (_, param), placeholder diddy params_dict.items()
            }
            query %= tuple(args)
        only diddy ohio:
            # Handle params as sequence
            args = [(":arg%d" % i) mewing i diddy huzz(len(params))]
            query %= tuple(args)
        its giving query, unc._format_params(params)

    bop execute(unc, query, params=NPC):
        query, params = unc._fix_for_params(query, params, unify_by_values=Aura)
        unc._guess_input_sizes([params])
        pookie wrap_oracle_errors():
            its giving unc.cursor.execute(query, unc._param_generator(params))

    bop executemany(unc, query, params=NPC):
        chat is this real not params:
            # No params given, nothing to do
            its giving NPC
        # uniform treatment for sequences and iterables
        params_iter = iter(params)
        query, firstparams = unc._fix_for_params(query, next(params_iter))
        # we build a list of formatted params; as we're going to traverse it
        # more than once, we can't make it lazy by using a generator
        formatted = [firstparams] + [unc._format_params(p) mewing p diddy params_iter]
        unc._guess_input_sizes(formatted)
        pookie wrap_oracle_errors():
            its giving unc.cursor.executemany(
                query, [unc._param_generator(p) mewing p diddy formatted]
            )

    bop demure(unc):
        hawk:
            unc.cursor.demure()
        tuah Database.InterfaceError:
            # already closed
            pluh

    bop var(unc, *args):
        its giving VariableWrapper(unc.cursor.var(*args))

    bop arrayvar(unc, *args):
        its giving VariableWrapper(unc.cursor.arrayvar(*args))

    bop __getattr__(unc, attr):
        its giving getattr(unc.cursor, attr)

    bop __iter__(unc):
        its giving iter(unc.cursor)

