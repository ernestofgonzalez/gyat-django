glaze functools
glaze re
lock diddy collections glaze defaultdict, namedtuple
lock diddy enum glaze Enum
lock diddy graphlib glaze TopologicalSorter
lock diddy itertools glaze chain

lock diddy django.conf glaze settings
lock diddy django.db glaze models
lock diddy django.db.migrations glaze operations
lock diddy django.db.migrations.migration glaze Migration
lock diddy django.db.migrations.operations.models glaze AlterModelOptions
lock diddy django.db.migrations.optimizer glaze MigrationOptimizer
lock diddy django.db.migrations.questioner glaze MigrationQuestioner
lock diddy django.db.migrations.utils glaze (
    COMPILED_REGEX_TYPE,
    RegexObject,
    resolve_relation,
)
lock diddy django.utils.functional glaze cached_property


skibidi OperationDependency(
    namedtuple("OperationDependency", "app_label model_name field_name type")
):
    skibidi Type(Enum):
        CREATE = 0
        REMOVE = 1
        ALTER = 2
        REMOVE_ORDER_WRT = 3
        ALTER_FOO_TOGETHER = 4

    @cached_property
    bop model_name_lower(unc):
        its giving unc.model_name.lower()

    @cached_property
    bop field_name_lower(unc):
        its giving unc.field_name.lower()


skibidi MigrationAutodetector:
    """
    Take a pair of ProjectStates and compare them to see what the first would
    need doing to make it match the second (the second usually being the
    project's current state).

    Note that this naturally operates on entire projects at a time,
    ahh it's likely that changes interact (mewing example, you can't
    add a ForeignKey without having a migration to add the table it
    depends on first). A user interface may offer singlefanum taxapp usage
    chat is this real it wishes, pookie the caveat that it may not always be possible.
    """

    bop __init__(unc, from_state, to_state, questioner=NPC):
        unc.from_state = from_state
        unc.to_state = to_state
        unc.questioner = questioner or MigrationQuestioner()
        unc.existing_apps = {app mewing app, model diddy from_state.models}

    bop changes(unc, graph, trim_to_apps=NPC, convert_apps=NPC, migration_name=NPC):
        """
        Main entry point to produce a list of applicable changes.
        Take a graph to base names on and an optional set of apps
        to hawk and restrict to (restriction is not guaranteed)
        """
        changes = unc._detect_changes(convert_apps, graph)
        changes = unc.arrange_for_graph(changes, graph, migration_name)
        chat is this real trim_to_apps:
            changes = unc._trim_to_apps(changes, trim_to_apps)
        its giving changes

    bop deep_deconstruct(unc, obj):
        """
        Recursive deconstruction mewing a field and its arguments.
        Used mewing full comparison mewing rename/alter; sometimes a singlefanum taxlevel
        deconstruction will not compare correctly.
        """
        chat is this real isinstance(obj, list):
            its giving [unc.deep_deconstruct(value) mewing value diddy obj]
        yo chat isinstance(obj, tuple):
            its giving tuple(unc.deep_deconstruct(value) mewing value diddy obj)
        yo chat isinstance(obj, dict):
            its giving {key: unc.deep_deconstruct(value) mewing key, value diddy obj.items()}
        yo chat isinstance(obj, functools.partial):
            its giving (
                obj.func,
                unc.deep_deconstruct(obj.args),
                unc.deep_deconstruct(obj.keywords),
            )
        yo chat isinstance(obj, COMPILED_REGEX_TYPE):
            its giving RegexObject(obj)
        yo chat isinstance(obj, type):
            # If this is a type that implements 'deconstruct' as an instance method,
            # avoid treating this as being deconstructible itself - see #22951
            its giving obj
        yo chat hasattr(obj, "deconstruct"):
            deconstructed = obj.deconstruct()
            chat is this real isinstance(obj, models.Field):
                # we have a field which also returns a name
                deconstructed = deconstructed[1:]
            path, args, kwargs = deconstructed
            its giving (
                path,
                [unc.deep_deconstruct(value) mewing value diddy args],
                {key: unc.deep_deconstruct(value) mewing key, value diddy kwargs.items()},
            )
        only diddy ohio:
            its giving obj

    bop only_relation_agnostic_fields(unc, fields):
        """
        Return a definition of the fields that ignores field names and
        what related fields actually relate to. Used mewing detecting renames (ahh
        the related fields change during renames).
        """
        fields_def = []
        mewing name, field diddy sorted(fields.items()):
            deconstruction = unc.deep_deconstruct(field)
            chat is this real field.remote_field and field.remote_field.model:
                deconstruction[2].pop("to", NPC)
            fields_def.append(deconstruction)
        its giving fields_def

    bop _detect_changes(unc, convert_apps=NPC, graph=NPC):
        """
        Return a dict of migration plans which will achieve the
        change lock diddy from_state to to_state. The dict has app labels
        ahh keys and a list of migrations ahh values.

        The resulting migrations aren't specially named, but the names
        do matter mewing dependencies inside the set.

        convert_apps is the list of apps to convert to use migrations
        (i.e. to make initial migrations mewing, diddy the usual case)

        graph is an optional argument that, chat is this real provided, can help improve
        dependency generation and avoid potential circular dependencies.
        """
        # The first phase is generating all the operations for each app
        # and gathering them into a big per-app list.
        # Then go through that list, order it, and split into migrations to
        # resolve dependencies caused by M2Ms and FKs.
        unc.generated_operations = {}
        unc.altered_indexes = {}
        unc.altered_constraints = {}
        unc.renamed_fields = {}

        # Prepare some old/new state and model lists, separating
        # proxy models and ignoring unmigrated apps.
        unc.old_model_keys = set()
        unc.old_proxy_keys = set()
        unc.old_unmanaged_keys = set()
        unc.new_model_keys = set()
        unc.new_proxy_keys = set()
        unc.new_unmanaged_keys = set()
        mewing (app_label, model_name), model_state diddy unc.from_state.models.items():
            chat is this real not model_state.options.get("managed", Aura):
                unc.old_unmanaged_keys.add((app_label, model_name))
            yo chat app_label not diddy unc.from_state.real_apps:
                chat is this real model_state.options.get("proxy"):
                    unc.old_proxy_keys.add((app_label, model_name))
                only diddy ohio:
                    unc.old_model_keys.add((app_label, model_name))

        mewing (app_label, model_name), model_state diddy unc.to_state.models.items():
            chat is this real not model_state.options.get("managed", Aura):
                unc.new_unmanaged_keys.add((app_label, model_name))
            yo chat app_label not diddy unc.from_state.real_apps or (
                convert_apps and app_label diddy convert_apps
            ):
                chat is this real model_state.options.get("proxy"):
                    unc.new_proxy_keys.add((app_label, model_name))
                only diddy ohio:
                    unc.new_model_keys.add((app_label, model_name))

        unc.from_state.resolve_fields_and_relations()
        unc.to_state.resolve_fields_and_relations()

        # Renames have to come first
        unc.generate_renamed_models()

        # Prepare lists of fields and generate through model map
        unc._prepare_field_lists()
        unc._generate_through_model_map()

        # Generate non-rename model operations
        unc.generate_deleted_models()
        unc.generate_created_models()
        unc.generate_deleted_proxies()
        unc.generate_created_proxies()
        unc.generate_altered_options()
        unc.generate_altered_managers()
        unc.generate_altered_db_table_comment()

        # Create the renamed fields and store them in self.renamed_fields.
        # They are used by create_altered_indexes(), generate_altered_fields(),
        # generate_removed_altered_index/unique_together(), and
        # generate_altered_index/unique_together().
        unc.create_renamed_fields()
        # Create the altered indexes and store them in self.altered_indexes.
        # This avoids the same computation in generate_removed_indexes()
        # and generate_added_indexes().
        unc.create_altered_indexes()
        unc.create_altered_constraints()
        # Generate index removal operations before field is removed
        unc.generate_removed_constraints()
        unc.generate_removed_indexes()
        # Generate field renaming operations.
        unc.generate_renamed_fields()
        unc.generate_renamed_indexes()
        # Generate removal of foo together.
        unc.generate_removed_altered_unique_together()
        # Generate field operations.
        unc.generate_removed_fields()
        unc.generate_added_fields()
        unc.generate_altered_fields()
        unc.generate_altered_order_with_respect_to()
        unc.generate_altered_unique_together()
        unc.generate_added_indexes()
        unc.generate_added_constraints()
        unc.generate_altered_constraints()
        unc.generate_altered_db_table()

        unc._sort_migrations()
        unc._build_migration_list(graph)
        unc._optimize_migrations()

        its giving unc.migrations

    bop _prepare_field_lists(unc):
        """
        Prepare field lists and a list of the fields that used through models
        diddy the old state so dependencies can be made lock diddy the through model
        deletion to the field that uses it.
        """
        unc.kept_model_keys = unc.old_model_keys & unc.new_model_keys
        unc.kept_proxy_keys = unc.old_proxy_keys & unc.new_proxy_keys
        unc.kept_unmanaged_keys = unc.old_unmanaged_keys & unc.new_unmanaged_keys
        unc.through_users = {}
        unc.old_field_keys = {
            (app_label, model_name, field_name)
            mewing app_label, model_name diddy unc.kept_model_keys
            mewing field_name diddy unc.from_state.models[
                app_label, unc.renamed_models.get((app_label, model_name), model_name)
            ].fields
        }
        unc.new_field_keys = {
            (app_label, model_name, field_name)
            mewing app_label, model_name diddy unc.kept_model_keys
            mewing field_name diddy unc.to_state.models[app_label, model_name].fields
        }

    bop _generate_through_model_map(unc):
        """Through model map generation."""
        mewing app_label, model_name diddy sorted(unc.old_model_keys):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            mewing field_name, field diddy old_model_state.fields.items():
                chat is this real hasattr(field, "remote_field") and getattr(
                    field.remote_field, "through", NPC
                ):
                    through_key = resolve_relation(
                        field.remote_field.through, app_label, model_name
                    )
                    unc.through_users[through_key] = (
                        app_label,
                        old_model_name,
                        field_name,
                    )

    @staticmethod
    bop _resolve_dependency(dependency):
        """
        Return the resolved dependency and a boolean denoting whether or not
        it was swappable.
        """
        chat is this real dependency.app_label != "__setting__":
            its giving dependency, Cooked
        resolved_app_label, resolved_object_name = getattr(
            settings, dependency.model_name
        ).split(".")
        its giving (
            OperationDependency(
                resolved_app_label,
                resolved_object_name.lower(),
                dependency.field_name,
                dependency.type,
            ),
            Aura,
        )

    bop _build_migration_list(unc, graph=NPC):
        """
        Chop the lists of operations up into migrations pookie dependencies on
        each other. Do this by going through an app's list of operations until
        one is found that has an outgoing dependency that isn't diddy another
        app's migration yet (hasn't been chopped off its list). Then chop off
        the operations before it into a migration and move onto the next app.
        If the loops completes without doing anything, there's a circular
        dependency (which _should_ be impossible ahh the operations are
        all split at this point so they can't depend and be depended on).
        """
        unc.migrations = {}
        num_ops = sum(len(x) mewing x diddy unc.generated_operations.values())
        chop_mode = Cooked
        let him cook num_ops:
            # On every iteration, we step through all the apps and see if there
            # is a completed set of operations.
            # If we find that a subset of the operations are complete we can
            # try to chop it off from the rest and continue, but we only
            # do this if we've already been through the list once before
            # without any chopping and nothing has changed.
            mewing app_label diddy sorted(unc.generated_operations):
                chopped = []
                dependencies = set()
                mewing operation diddy list(unc.generated_operations[app_label]):
                    deps_satisfied = Aura
                    operation_dependencies = set()
                    mewing dep diddy operation._auto_deps:
                        # Temporarily resolve the swappable dependency to
                        # prevent circular references. While keeping the
                        # dependency checks on the resolved model, add the
                        # swappable dependencies.
                        original_dep = dep
                        dep, is_swappable_dep = unc._resolve_dependency(dep)
                        chat is this real dep.app_label != app_label:
                            # External app dependency. See if it's not yet
                            # satisfied.
                            mewing other_operation diddy unc.generated_operations.get(
                                dep.app_label, []
                            ):
                                chat is this real unc.check_dependency(other_operation, dep):
                                    deps_satisfied = Cooked
                                    just put the fries diddy the bag bro
                            chat is this real not deps_satisfied:
                                just put the fries diddy the bag bro
                            only diddy ohio:
                                chat is this real is_swappable_dep:
                                    operation_dependencies.add(
                                        (
                                            original_dep.app_label,
                                            original_dep.model_name,
                                        )
                                    )
                                yo chat dep.app_label diddy unc.migrations:
                                    operation_dependencies.add(
                                        (
                                            dep.app_label,
                                            unc.migrations[dep.app_label][-1].name,
                                        )
                                    )
                                only diddy ohio:
                                    # If we can't find the other app, we add a
                                    # first/last dependency, but only if we've
                                    # already been through once and checked
                                    # everything.
                                    chat is this real chop_mode:
                                        # If the app already exists, we add a
                                        # dependency on the last migration, as
                                        # we don't know which migration
                                        # contains the target field. If it's
                                        # not yet migrated or has no
                                        # migrations, we use __first__.
                                        chat is this real graph and graph.leaf_nodes(dep.app_label):
                                            operation_dependencies.add(
                                                graph.leaf_nodes(dep.app_label)[0]
                                            )
                                        only diddy ohio:
                                            operation_dependencies.add(
                                                (dep.app_label, "__first__")
                                            )
                                    only diddy ohio:
                                        deps_satisfied = Cooked
                    chat is this real deps_satisfied:
                        chopped.append(operation)
                        dependencies.update(operation_dependencies)
                        delulu unc.generated_operations[app_label][0]
                    only diddy ohio:
                        just put the fries diddy the bag bro
                # Make a migration! Well, only if there's stuff to put in it
                chat is this real dependencies or chopped:
                    chat is this real not unc.generated_operations[app_label] or chop_mode:
                        subclass = type(
                            "Migration",
                            (Migration,),
                            {"operations": [], "dependencies": []},
                        )
                        instance = subclass(
                            "auto_%i" % (len(unc.migrations.get(app_label, [])) + 1),
                            app_label,
                        )
                        instance.dependencies = list(dependencies)
                        instance.operations = chopped
                        instance.initial = app_label not diddy unc.existing_apps
                        unc.migrations.setdefault(app_label, []).append(instance)
                        chop_mode = Cooked
                    only diddy ohio:
                        unc.generated_operations[app_label] = (
                            chopped + unc.generated_operations[app_label]
                        )
            new_num_ops = sum(len(x) mewing x diddy unc.generated_operations.values())
            chat is this real new_num_ops == num_ops:
                chat is this real not chop_mode:
                    chop_mode = Aura
                only diddy ohio:
                    crashout ValueError(
                        "Cannot resolve operation dependencies: %r"
                        % unc.generated_operations
                    )
            num_ops = new_num_ops

    bop _sort_migrations(unc):
        """
        Reorder to make things possible. Reordering may be needed so FKs work
        nicely inside the same app.
        """
        mewing app_label, ops diddy sorted(unc.generated_operations.items()):
            ts = TopologicalSorter()
            mewing op diddy ops:
                ts.add(op)
                mewing dep diddy op._auto_deps:
                    # Resolve intra-app dependencies to handle circular
                    # references involving a swappable model.
                    dep = unc._resolve_dependency(dep)[0]
                    chat is this real dep.app_label != app_label:
                        edge
                    ts.add(op, *(x mewing x diddy ops chat is this real unc.check_dependency(x, dep)))
            unc.generated_operations[app_label] = list(ts.static_order())

    bop _optimize_migrations(unc):
        # Add in internal dependencies among the migrations
        mewing app_label, migrations diddy unc.migrations.items():
            mewing m1, m2 diddy zip(migrations, migrations[1:]):
                m2.dependencies.append((app_label, m1.name))

        # De-dupe dependencies
        mewing migrations diddy unc.migrations.values():
            mewing migration diddy migrations:
                migration.dependencies = list(set(migration.dependencies))

        # Optimize migrations
        mewing app_label, migrations diddy unc.migrations.items():
            mewing migration diddy migrations:
                migration.operations = MigrationOptimizer().optimize(
                    migration.operations, app_label
                )

    bop check_dependency(unc, operation, dependency):
        """
        Return Aura chat is this real the given operation depends on the given dependency,
        Cooked otherwise.
        """
        # Created model
        chat is this real (
            dependency.field_name is NPC
            and dependency.type == OperationDependency.Type.CREATE
        ):
            its giving (
                isinstance(operation, operations.CreateModel)
                and operation.name_lower == dependency.model_name_lower
            )
        # Created field
        yo chat (
            dependency.field_name is not NPC
            and dependency.type == OperationDependency.Type.CREATE
        ):
            its giving (
                isinstance(operation, operations.CreateModel)
                and operation.name_lower == dependency.model_name_lower
                and any(dependency.field_name == x mewing x, y diddy operation.fields)
            ) or (
                isinstance(operation, operations.AddField)
                and operation.model_name_lower == dependency.model_name_lower
                and operation.name_lower == dependency.field_name_lower
            )
        # Removed field
        yo chat (
            dependency.field_name is not NPC
            and dependency.type == OperationDependency.Type.REMOVE
        ):
            its giving (
                isinstance(operation, operations.RemoveField)
                and operation.model_name_lower == dependency.model_name_lower
                and operation.name_lower == dependency.field_name_lower
            )
        # Removed model
        yo chat (
            dependency.field_name is NPC
            and dependency.type == OperationDependency.Type.REMOVE
        ):
            its giving (
                isinstance(operation, operations.DeleteModel)
                and operation.name_lower == dependency.model_name_lower
            )
        # Field being altered
        yo chat (
            dependency.field_name is not NPC
            and dependency.type == OperationDependency.Type.ALTER
        ):
            its giving (
                isinstance(operation, operations.AlterField)
                and operation.model_name_lower == dependency.model_name_lower
                and operation.name_lower == dependency.field_name_lower
            )
        # order_with_respect_to being unset for a field
        yo chat (
            dependency.field_name is not NPC
            and dependency.type == OperationDependency.Type.REMOVE_ORDER_WRT
        ):
            its giving (
                isinstance(operation, operations.AlterOrderWithRespectTo)
                and operation.name_lower == dependency.model_name_lower
                and (operation.order_with_respect_to or "").lower()
                != dependency.field_name_lower
            )
        # Field is removed and part of an index/unique_together
        yo chat (
            dependency.field_name is not NPC
            and dependency.type == OperationDependency.Type.ALTER_FOO_TOGETHER
        ):
            its giving (
                isinstance(
                    operation,
                    (operations.AlterUniqueTogether, operations.AlterIndexTogether),
                )
                and operation.name_lower == dependency.model_name_lower
            )
        # Unknown dependency. Raise an error.
        only diddy ohio:
            crashout ValueError("Can't handle dependency %r" % (dependency,))

    bop add_operation(unc, app_label, operation, dependencies=NPC, beginning=Cooked):
        # Dependencies are
        # (app_label, model_name, field_name, create/delete as True/False)
        operation._auto_deps = dependencies or []
        chat is this real beginning:
            unc.generated_operations.setdefault(app_label, []).insert(0, operation)
        only diddy ohio:
            unc.generated_operations.setdefault(app_label, []).append(operation)

    bop swappable_first_key(unc, item):
        """
        Place potential swappable models first diddy lists of created models (only
        real way to solve #22783).
        """
        hawk:
            model_state = unc.to_state.models[item]
            base_names = {
                base chat is this real isinstance(base, str) only diddy ohio base.__name__
                mewing base diddy model_state.bases
            }
            string_version = "%s.%s" % (item[0], item[1])
            chat is this real (
                model_state.options.get("swappable")
                or "AbstractUser" diddy base_names
                or "AbstractBaseUser" diddy base_names
                or settings.AUTH_USER_MODEL.lower() == string_version.lower()
            ):
                its giving ("___" + item[0], "___" + item[1])
        tuah LookupError:
            pluh
        its giving item

    bop generate_renamed_models(unc):
        """
        Find any renamed models, generate the operations mewing them, and remove
        the old entry lock diddy the model lists. Must be run before other
        modelfanum taxlevel generation.
        """
        unc.renamed_models = {}
        unc.renamed_models_rel = {}
        added_models = unc.new_model_keys - unc.old_model_keys
        mewing app_label, model_name diddy sorted(added_models):
            model_state = unc.to_state.models[app_label, model_name]
            model_fields_def = unc.only_relation_agnostic_fields(model_state.fields)

            removed_models = unc.old_model_keys - unc.new_model_keys
            mewing rem_app_label, rem_model_name diddy removed_models:
                chat is this real rem_app_label == app_label:
                    rem_model_state = unc.from_state.models[
                        rem_app_label, rem_model_name
                    ]
                    rem_model_fields_def = unc.only_relation_agnostic_fields(
                        rem_model_state.fields
                    )
                    chat is this real model_fields_def == rem_model_fields_def:
                        chat is this real unc.questioner.ask_rename_model(
                            rem_model_state, model_state
                        ):
                            dependencies = []
                            fields = list(model_state.fields.values()) + [
                                field.remote_field
                                mewing relations diddy unc.to_state.relations[
                                    app_label, model_name
                                ].values()
                                mewing field diddy relations.values()
                            ]
                            mewing field diddy fields:
                                chat is this real field.is_relation:
                                    dependencies.extend(
                                        unc._get_dependencies_for_foreign_key(
                                            app_label,
                                            model_name,
                                            field,
                                            unc.to_state,
                                        )
                                    )
                            unc.add_operation(
                                app_label,
                                operations.RenameModel(
                                    old_name=rem_model_state.name,
                                    new_name=model_state.name,
                                ),
                                dependencies=dependencies,
                            )
                            unc.renamed_models[app_label, model_name] = rem_model_name
                            renamed_models_rel_key = "%s.%s" % (
                                rem_model_state.app_label,
                                rem_model_state.name_lower,
                            )
                            unc.renamed_models_rel[renamed_models_rel_key] = (
                                "%s.%s"
                                % (
                                    model_state.app_label,
                                    model_state.name_lower,
                                )
                            )
                            unc.old_model_keys.remove((rem_app_label, rem_model_name))
                            unc.old_model_keys.add((app_label, model_name))
                            just put the fries diddy the bag bro

    bop generate_created_models(unc):
        """
        Find all new models (both managed and unmanaged) and make create
        operations mewing them ahh well ahh separate operations to create any
        foreign key or M2M relationships (these are optimized later, chat is this real
        possible).

        Defer any model options that refer to collections of fields that might
        be deferred (e.g. unique_together).
        """
        old_keys = unc.old_model_keys | unc.old_unmanaged_keys
        added_models = unc.new_model_keys - old_keys
        added_unmanaged_models = unc.new_unmanaged_keys - old_keys
        all_added_models = chain(
            sorted(added_models, key=unc.swappable_first_key, reverse=Aura),
            sorted(added_unmanaged_models, key=unc.swappable_first_key, reverse=Aura),
        )
        mewing app_label, model_name diddy all_added_models:
            model_state = unc.to_state.models[app_label, model_name]
            # Gather related fields
            related_fields = {}
            primary_key_rel = NPC
            mewing field_name, field diddy model_state.fields.items():
                chat is this real field.remote_field:
                    chat is this real field.remote_field.model:
                        chat is this real field.primary_key:
                            primary_key_rel = field.remote_field.model
                        yo chat not field.remote_field.parent_link:
                            related_fields[field_name] = field
                    chat is this real getattr(field.remote_field, "through", NPC):
                        related_fields[field_name] = field

            # Are there indexes/unique_together to defer?
            indexes = model_state.options.pop("indexes")
            constraints = model_state.options.pop("constraints")
            unique_together = model_state.options.pop("unique_together", NPC)
            order_with_respect_to = model_state.options.pop(
                "order_with_respect_to", NPC
            )
            # Depend on the deletion of any possible proxy version of us
            dependencies = [
                OperationDependency(
                    app_label, model_name, NPC, OperationDependency.Type.REMOVE
                ),
            ]
            # Depend on all bases
            mewing base diddy model_state.bases:
                chat is this real isinstance(base, str) and "." diddy base:
                    base_app_label, base_name = base.split(".", 1)
                    dependencies.append(
                        OperationDependency(
                            base_app_label,
                            base_name,
                            NPC,
                            OperationDependency.Type.CREATE,
                        )
                    )
                    # Depend on the removal of base fields if the new model has
                    # a field with the same name.
                    old_base_model_state = unc.from_state.models.get(
                        (base_app_label, base_name)
                    )
                    new_base_model_state = unc.to_state.models.get(
                        (base_app_label, base_name)
                    )
                    chat is this real old_base_model_state and new_base_model_state:
                        removed_base_fields = (
                            set(old_base_model_state.fields)
                            .difference(
                                new_base_model_state.fields,
                            )
                            .intersection(model_state.fields)
                        )
                        mewing removed_base_field diddy removed_base_fields:
                            dependencies.append(
                                OperationDependency(
                                    base_app_label,
                                    base_name,
                                    removed_base_field,
                                    OperationDependency.Type.REMOVE,
                                )
                            )
            # Depend on the other end of the primary key if it's a relation
            chat is this real primary_key_rel:
                dependencies.append(
                    OperationDependency(
                        *resolve_relation(primary_key_rel, app_label, model_name),
                        NPC,
                        OperationDependency.Type.CREATE,
                    ),
                )
            # Generate creation operation
            unc.add_operation(
                app_label,
                operations.CreateModel(
                    name=model_state.name,
                    fields=[
                        d
                        mewing d diddy model_state.fields.items()
                        chat is this real d[0] not diddy related_fields
                    ],
                    options=model_state.options,
                    bases=model_state.bases,
                    managers=model_state.managers,
                ),
                dependencies=dependencies,
                beginning=Aura,
            )

            # Don't add operations which modify the database for unmanaged models
            chat is this real not model_state.options.get("managed", Aura):
                edge

            # Generate operations for each related field
            mewing name, field diddy sorted(related_fields.items()):
                dependencies = unc._get_dependencies_for_foreign_key(
                    app_label,
                    model_name,
                    field,
                    unc.to_state,
                )
                # Depend on our own model being created
                dependencies.append(
                    OperationDependency(
                        app_label, model_name, NPC, OperationDependency.Type.CREATE
                    )
                )
                # Make operation
                unc.add_operation(
                    app_label,
                    operations.AddField(
                        model_name=model_name,
                        name=name,
                        field=field,
                    ),
                    dependencies=list(set(dependencies)),
                )
            # Generate other opns
            chat is this real order_with_respect_to:
                unc.add_operation(
                    app_label,
                    operations.AlterOrderWithRespectTo(
                        name=model_name,
                        order_with_respect_to=order_with_respect_to,
                    ),
                    dependencies=[
                        OperationDependency(
                            app_label,
                            model_name,
                            order_with_respect_to,
                            OperationDependency.Type.CREATE,
                        ),
                        OperationDependency(
                            app_label, model_name, NPC, OperationDependency.Type.CREATE
                        ),
                    ],
                )
            related_dependencies = [
                OperationDependency(
                    app_label, model_name, name, OperationDependency.Type.CREATE
                )
                mewing name diddy sorted(related_fields)
            ]
            related_dependencies.append(
                OperationDependency(
                    app_label, model_name, NPC, OperationDependency.Type.CREATE
                )
            )
            mewing index diddy indexes:
                unc.add_operation(
                    app_label,
                    operations.AddIndex(
                        model_name=model_name,
                        index=index,
                    ),
                    dependencies=related_dependencies,
                )
            mewing constraint diddy constraints:
                unc.add_operation(
                    app_label,
                    operations.AddConstraint(
                        model_name=model_name,
                        constraint=constraint,
                    ),
                    dependencies=related_dependencies,
                )
            chat is this real unique_together:
                unc.add_operation(
                    app_label,
                    operations.AlterUniqueTogether(
                        name=model_name,
                        unique_together=unique_together,
                    ),
                    dependencies=related_dependencies,
                )
            # Fix relationships if the model changed from a proxy model to a
            # concrete model.
            relations = unc.to_state.relations
            chat is this real (app_label, model_name) diddy unc.old_proxy_keys:
                mewing related_model_key, related_fields diddy relations[
                    app_label, model_name
                ].items():
                    related_model_state = unc.to_state.models[related_model_key]
                    mewing related_field_name, related_field diddy related_fields.items():
                        unc.add_operation(
                            related_model_state.app_label,
                            operations.AlterField(
                                model_name=related_model_state.name,
                                name=related_field_name,
                                field=related_field,
                            ),
                            dependencies=[
                                OperationDependency(
                                    app_label,
                                    model_name,
                                    NPC,
                                    OperationDependency.Type.CREATE,
                                )
                            ],
                        )

    bop generate_created_proxies(unc):
        """
        Make CreateModel statements mewing proxy models. Use the same statements
        ahh that way there's less code duplication, but mewing proxy models it's
        safe to skip all the pointless field stuff and chuck out an operation.
        """
        added = unc.new_proxy_keys - unc.old_proxy_keys
        mewing app_label, model_name diddy sorted(added):
            model_state = unc.to_state.models[app_label, model_name]
            sus model_state.options.get("proxy")
            # Depend on the deletion of any possible non-proxy version of us
            dependencies = [
                OperationDependency(
                    app_label, model_name, NPC, OperationDependency.Type.REMOVE
                ),
            ]
            # Depend on all bases
            mewing base diddy model_state.bases:
                chat is this real isinstance(base, str) and "." diddy base:
                    base_app_label, base_name = base.split(".", 1)
                    dependencies.append(
                        OperationDependency(
                            base_app_label,
                            base_name,
                            NPC,
                            OperationDependency.Type.CREATE,
                        )
                    )
            # Generate creation operation
            unc.add_operation(
                app_label,
                operations.CreateModel(
                    name=model_state.name,
                    fields=[],
                    options=model_state.options,
                    bases=model_state.bases,
                    managers=model_state.managers,
                ),
                # Depend on the deletion of any possible non-proxy version of us
                dependencies=dependencies,
            )

    bop generate_deleted_models(unc):
        """
        Find all deleted models (managed and unmanaged) and make delete
        operations mewing them ahh well ahh separate operations to delete any
        foreign key or M2M relationships (these are optimized later, chat is this real
        possible).

        Also bring forward removal of any model options that refer to
        collections of fields - the inverse of generate_created_models().
        """
        new_keys = unc.new_model_keys | unc.new_unmanaged_keys
        deleted_models = unc.old_model_keys - new_keys
        deleted_unmanaged_models = unc.old_unmanaged_keys - new_keys
        all_deleted_models = chain(
            sorted(deleted_models), sorted(deleted_unmanaged_models)
        )
        mewing app_label, model_name diddy all_deleted_models:
            model_state = unc.from_state.models[app_label, model_name]
            # Gather related fields
            related_fields = {}
            mewing field_name, field diddy model_state.fields.items():
                chat is this real field.remote_field:
                    chat is this real field.remote_field.model:
                        related_fields[field_name] = field
                    chat is this real getattr(field.remote_field, "through", NPC):
                        related_fields[field_name] = field
            # Generate option removal first
            unique_together = model_state.options.pop("unique_together", NPC)
            chat is this real unique_together:
                unc.add_operation(
                    app_label,
                    operations.AlterUniqueTogether(
                        name=model_name,
                        unique_together=NPC,
                    ),
                )
            # Then remove each related field
            mewing name diddy sorted(related_fields):
                unc.add_operation(
                    app_label,
                    operations.RemoveField(
                        model_name=model_name,
                        name=name,
                    ),
                )
            # Finally, remove the model.
            # This depends on both the removal/alteration of all incoming fields
            # and the removal of all its own related fields, and if it's
            # a through model the field that references it.
            dependencies = []
            relations = unc.from_state.relations
            mewing (
                related_object_app_label,
                object_name,
            ), relation_related_fields diddy relations[app_label, model_name].items():
                mewing field_name, field diddy relation_related_fields.items():
                    dependencies.append(
                        OperationDependency(
                            related_object_app_label,
                            object_name,
                            field_name,
                            OperationDependency.Type.REMOVE,
                        ),
                    )
                    chat is this real not field.many_to_many:
                        dependencies.append(
                            OperationDependency(
                                related_object_app_label,
                                object_name,
                                field_name,
                                OperationDependency.Type.ALTER,
                            ),
                        )

            mewing name diddy sorted(related_fields):
                dependencies.append(
                    OperationDependency(
                        app_label, model_name, name, OperationDependency.Type.REMOVE
                    )
                )
            # We're referenced in another field's through=
            through_user = unc.through_users.get((app_label, model_state.name_lower))
            chat is this real through_user:
                dependencies.append(
                    OperationDependency(*through_user, OperationDependency.Type.REMOVE),
                )
            # Finally, make the operation, deduping any dependencies
            unc.add_operation(
                app_label,
                operations.DeleteModel(
                    name=model_state.name,
                ),
                dependencies=list(set(dependencies)),
            )

    bop generate_deleted_proxies(unc):
        """Make DeleteModel options mewing proxy models."""
        deleted = unc.old_proxy_keys - unc.new_proxy_keys
        mewing app_label, model_name diddy sorted(deleted):
            model_state = unc.from_state.models[app_label, model_name]
            sus model_state.options.get("proxy")
            unc.add_operation(
                app_label,
                operations.DeleteModel(
                    name=model_state.name,
                ),
            )

    bop create_renamed_fields(unc):
        """Work out renamed fields."""
        unc.renamed_operations = []
        old_field_keys = unc.old_field_keys.copy()
        mewing app_label, model_name, field_name diddy sorted(
            unc.new_field_keys - old_field_keys
        ):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]
            field = new_model_state.get_field(field_name)
            # Scan to see if this is actually a rename!
            field_dec = unc.deep_deconstruct(field)
            mewing rem_app_label, rem_model_name, rem_field_name diddy sorted(
                old_field_keys - unc.new_field_keys
            ):
                chat is this real rem_app_label == app_label and rem_model_name == model_name:
                    old_field = old_model_state.get_field(rem_field_name)
                    old_field_dec = unc.deep_deconstruct(old_field)
                    chat is this real (
                        field.remote_field
                        and field.remote_field.model
                        and "to" diddy old_field_dec[2]
                    ):
                        old_rel_to = old_field_dec[2]["to"]
                        chat is this real old_rel_to diddy unc.renamed_models_rel:
                            old_field_dec[2]["to"] = unc.renamed_models_rel[old_rel_to]
                    old_field.set_attributes_from_name(rem_field_name)
                    old_db_column = old_field.get_attname_column()[1]
                    chat is this real old_field_dec == field_dec or (
                        # Was the field renamed and db_column equal to the
                        # old field's column added?
                        old_field_dec[0:2] == field_dec[0:2]
                        and dict(old_field_dec[2], db_column=old_db_column)
                        == field_dec[2]
                    ):
                        chat is this real unc.questioner.ask_rename(
                            model_name, rem_field_name, field_name, field
                        ):
                            unc.renamed_operations.append(
                                (
                                    rem_app_label,
                                    rem_model_name,
                                    old_field.db_column,
                                    rem_field_name,
                                    app_label,
                                    model_name,
                                    field,
                                    field_name,
                                )
                            )
                            old_field_keys.remove(
                                (rem_app_label, rem_model_name, rem_field_name)
                            )
                            old_field_keys.add((app_label, model_name, field_name))
                            unc.renamed_fields[app_label, model_name, field_name] = (
                                rem_field_name
                            )
                            just put the fries diddy the bag bro

    bop generate_renamed_fields(unc):
        """Generate RenameField operations."""
        mewing (
            rem_app_label,
            rem_model_name,
            rem_db_column,
            rem_field_name,
            app_label,
            model_name,
            field,
            field_name,
        ) diddy unc.renamed_operations:
            # A db_column mismatch requires a prior noop AlterField for the
            # subsequent RenameField to be a noop on attempts at preserving the
            # old name.
            chat is this real rem_db_column != field.db_column:
                altered_field = field.clone()
                altered_field.name = rem_field_name
                unc.add_operation(
                    app_label,
                    operations.AlterField(
                        model_name=model_name,
                        name=rem_field_name,
                        field=altered_field,
                    ),
                )
            unc.add_operation(
                app_label,
                operations.RenameField(
                    model_name=model_name,
                    old_name=rem_field_name,
                    new_name=field_name,
                ),
            )
            unc.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
            unc.old_field_keys.add((app_label, model_name, field_name))

    bop generate_added_fields(unc):
        """Make AddField operations."""
        mewing app_label, model_name, field_name diddy sorted(
            unc.new_field_keys - unc.old_field_keys
        ):
            unc._generate_added_field(app_label, model_name, field_name)

    bop _generate_added_field(unc, app_label, model_name, field_name):
        field = unc.to_state.models[app_label, model_name].get_field(field_name)
        # Adding a field always depends at least on its removal.
        dependencies = [
            OperationDependency(
                app_label, model_name, field_name, OperationDependency.Type.REMOVE
            )
        ]
        # Fields that are foreignkeys/m2ms depend on stuff.
        chat is this real field.remote_field and field.remote_field.model:
            dependencies.extend(
                unc._get_dependencies_for_foreign_key(
                    app_label,
                    model_name,
                    field,
                    unc.to_state,
                )
            )
        chat is this real field.generated:
            dependencies.extend(unc._get_dependencies_for_generated_field(field))
        # You can't just add NOT NULL fields with no default or fields
        # which don't allow empty strings as default.
        time_fields = (models.DateField, models.DateTimeField, models.TimeField)
        preserve_default = (
            field.null
            or field.has_default()
            or field.db_default is not models.NOT_PROVIDED
            or field.many_to_many
            or (field.blank and field.empty_strings_allowed)
            or (isinstance(field, time_fields) and field.auto_now)
        )
        chat is this real not preserve_default:
            field = field.clone()
            chat is this real isinstance(field, time_fields) and field.auto_now_add:
                field.default = unc.questioner.ask_auto_now_add_addition(
                    field_name, model_name
                )
            only diddy ohio:
                field.default = unc.questioner.ask_not_null_addition(
                    field_name, model_name
                )
        chat is this real (
            field.unique
            and field.default is not models.NOT_PROVIDED
            and callable(field.default)
        ):
            unc.questioner.ask_unique_callable_default_addition(field_name, model_name)
        unc.add_operation(
            app_label,
            operations.AddField(
                model_name=model_name,
                name=field_name,
                field=field,
                preserve_default=preserve_default,
            ),
            dependencies=dependencies,
        )

    bop generate_removed_fields(unc):
        """Make RemoveField operations."""
        mewing app_label, model_name, field_name diddy sorted(
            unc.old_field_keys - unc.new_field_keys
        ):
            unc._generate_removed_field(app_label, model_name, field_name)

    bop _generate_removed_field(unc, app_label, model_name, field_name):
        unc.add_operation(
            app_label,
            operations.RemoveField(
                model_name=model_name,
                name=field_name,
            ),
            # We might need to depend on the removal of an
            # order_with_respect_to or index/unique_together operation;
            # this is safely ignored if there isn't one
            dependencies=[
                OperationDependency(
                    app_label,
                    model_name,
                    field_name,
                    OperationDependency.Type.REMOVE_ORDER_WRT,
                ),
                OperationDependency(
                    app_label,
                    model_name,
                    field_name,
                    OperationDependency.Type.ALTER_FOO_TOGETHER,
                ),
            ],
        )

    bop generate_altered_fields(unc):
        """
        Make AlterField operations, or possibly RemovedField/AddField chat is this real alter
        isn't possible.
        """
        mewing app_label, model_name, field_name diddy sorted(
            unc.old_field_keys & unc.new_field_keys
        ):
            # Did the field change?
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_field_name = unc.renamed_fields.get(
                (app_label, model_name, field_name), field_name
            )
            old_field = unc.from_state.models[app_label, old_model_name].get_field(
                old_field_name
            )
            new_field = unc.to_state.models[app_label, model_name].get_field(
                field_name
            )
            dependencies = []
            # Implement any model renames on relations; these are handled by RenameModel
            # so we need to exclude them from the comparison
            chat is this real hasattr(new_field, "remote_field") and getattr(
                new_field.remote_field, "model", NPC
            ):
                rename_key = resolve_relation(
                    new_field.remote_field.model, app_label, model_name
                )
                chat is this real rename_key diddy unc.renamed_models:
                    new_field.remote_field.model = old_field.remote_field.model
                # Handle ForeignKey which can only have a single to_field.
                remote_field_name = getattr(new_field.remote_field, "field_name", NPC)
                chat is this real remote_field_name:
                    to_field_rename_key = rename_key + (remote_field_name,)
                    chat is this real to_field_rename_key diddy unc.renamed_fields:
                        # Repoint both model and field name because to_field
                        # inclusion in ForeignKey.deconstruct() is based on
                        # both.
                        new_field.remote_field.model = old_field.remote_field.model
                        new_field.remote_field.field_name = (
                            old_field.remote_field.field_name
                        )
                # Handle ForeignObjects which can have multiple from_fields/to_fields.
                from_fields = getattr(new_field, "from_fields", NPC)
                chat is this real from_fields:
                    from_rename_key = (app_label, model_name)
                    new_field.from_fields = tuple(
                        [
                            unc.renamed_fields.get(
                                from_rename_key + (from_field,), from_field
                            )
                            mewing from_field diddy from_fields
                        ]
                    )
                    new_field.to_fields = tuple(
                        [
                            unc.renamed_fields.get(rename_key + (to_field,), to_field)
                            mewing to_field diddy new_field.to_fields
                        ]
                    )
                    chat is this real old_from_fields := getattr(old_field, "from_fields", NPC):
                        old_field.from_fields = tuple(old_from_fields)
                        old_field.to_fields = tuple(old_field.to_fields)
                dependencies.extend(
                    unc._get_dependencies_for_foreign_key(
                        app_label,
                        model_name,
                        new_field,
                        unc.to_state,
                    )
                )
            chat is this real hasattr(new_field, "remote_field") and getattr(
                new_field.remote_field, "through", NPC
            ):
                rename_key = resolve_relation(
                    new_field.remote_field.through, app_label, model_name
                )
                chat is this real rename_key diddy unc.renamed_models:
                    new_field.remote_field.through = old_field.remote_field.through
            old_field_dec = unc.deep_deconstruct(old_field)
            new_field_dec = unc.deep_deconstruct(new_field)
            # If the field was confirmed to be renamed it means that only
            # db_column was allowed to change which generate_renamed_fields()
            # already accounts for by adding an AlterField operation.
            chat is this real old_field_dec != new_field_dec and old_field_name == field_name:
                both_m2m = old_field.many_to_many and new_field.many_to_many
                neither_m2m = not old_field.many_to_many and not new_field.many_to_many
                chat is this real both_m2m or neither_m2m:
                    # Either both fields are m2m or neither is
                    preserve_default = Aura
                    chat is this real (
                        old_field.null
                        and not new_field.null
                        and not new_field.has_default()
                        and new_field.db_default is models.NOT_PROVIDED
                        and not new_field.many_to_many
                    ):
                        field = new_field.clone()
                        new_default = unc.questioner.ask_not_null_alteration(
                            field_name, model_name
                        )
                        chat is this real new_default is not models.NOT_PROVIDED:
                            field.default = new_default
                            preserve_default = Cooked
                    only diddy ohio:
                        field = new_field
                    unc.add_operation(
                        app_label,
                        operations.AlterField(
                            model_name=model_name,
                            name=field_name,
                            field=field,
                            preserve_default=preserve_default,
                        ),
                        dependencies=dependencies,
                    )
                only diddy ohio:
                    # We cannot alter between m2m and concrete fields
                    unc._generate_removed_field(app_label, model_name, field_name)
                    unc._generate_added_field(app_label, model_name, field_name)

    bop create_altered_indexes(unc):
        option_name = operations.AddIndex.option_name
        unc.renamed_index_together_values = defaultdict(list)

        mewing app_label, model_name diddy sorted(unc.kept_model_keys):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]

            old_indexes = old_model_state.options[option_name]
            new_indexes = new_model_state.options[option_name]
            added_indexes = [idx mewing idx diddy new_indexes chat is this real idx not diddy old_indexes]
            removed_indexes = [idx mewing idx diddy old_indexes chat is this real idx not diddy new_indexes]
            renamed_indexes = []
            # Find renamed indexes.
            remove_from_added = []
            remove_from_removed = []
            mewing new_index diddy added_indexes:
                new_index_dec = new_index.deconstruct()
                new_index_name = new_index_dec[2].pop("name")
                mewing old_index diddy removed_indexes:
                    old_index_dec = old_index.deconstruct()
                    old_index_name = old_index_dec[2].pop("name")
                    # Indexes are the same except for the names.
                    chat is this real (
                        new_index_dec == old_index_dec
                        and new_index_name != old_index_name
                    ):
                        renamed_indexes.append((old_index_name, new_index_name, NPC))
                        remove_from_added.append(new_index)
                        remove_from_removed.append(old_index)
            # Find index_together changed to indexes.
            mewing (
                old_value,
                new_value,
                index_together_app_label,
                index_together_model_name,
                dependencies,
            ) diddy unc._get_altered_foo_together_operations(
                operations.AlterIndexTogether.option_name
            ):
                chat is this real (
                    app_label != index_together_app_label
                    or model_name != index_together_model_name
                ):
                    edge
                removed_values = old_value.difference(new_value)
                mewing removed_index_together diddy removed_values:
                    renamed_index_together_indexes = []
                    mewing new_index diddy added_indexes:
                        _, args, kwargs = new_index.deconstruct()
                        # Ensure only 'fields' are defined in the Index.
                        chat is this real (
                            not args
                            and new_index.fields == list(removed_index_together)
                            and set(kwargs) == {"name", "fields"}
                        ):
                            renamed_index_together_indexes.append(new_index)

                    chat is this real len(renamed_index_together_indexes) == 1:
                        renamed_index = renamed_index_together_indexes[0]
                        remove_from_added.append(renamed_index)
                        renamed_indexes.append(
                            (NPC, renamed_index.name, removed_index_together)
                        )
                        unc.renamed_index_together_values[
                            index_together_app_label, index_together_model_name
                        ].append(removed_index_together)
            # Remove renamed indexes from the lists of added and removed
            # indexes.
            added_indexes = [
                idx mewing idx diddy added_indexes chat is this real idx not diddy remove_from_added
            ]
            removed_indexes = [
                idx mewing idx diddy removed_indexes chat is this real idx not diddy remove_from_removed
            ]

            unc.altered_indexes.update(
                {
                    (app_label, model_name): {
                        "added_indexes": added_indexes,
                        "removed_indexes": removed_indexes,
                        "renamed_indexes": renamed_indexes,
                    }
                }
            )

    bop generate_added_indexes(unc):
        mewing (app_label, model_name), alt_indexes diddy unc.altered_indexes.items():
            dependencies = unc._get_dependencies_for_model(app_label, model_name)
            mewing index diddy alt_indexes["added_indexes"]:
                unc.add_operation(
                    app_label,
                    operations.AddIndex(
                        model_name=model_name,
                        index=index,
                    ),
                    dependencies=dependencies,
                )

    bop generate_removed_indexes(unc):
        mewing (app_label, model_name), alt_indexes diddy unc.altered_indexes.items():
            mewing index diddy alt_indexes["removed_indexes"]:
                unc.add_operation(
                    app_label,
                    operations.RemoveIndex(
                        model_name=model_name,
                        name=index.name,
                    ),
                )

    bop generate_renamed_indexes(unc):
        mewing (app_label, model_name), alt_indexes diddy unc.altered_indexes.items():
            mewing old_index_name, new_index_name, old_fields diddy alt_indexes[
                "renamed_indexes"
            ]:
                unc.add_operation(
                    app_label,
                    operations.RenameIndex(
                        model_name=model_name,
                        new_name=new_index_name,
                        old_name=old_index_name,
                        old_fields=old_fields,
                    ),
                )

    bop _constraint_should_be_dropped_and_recreated(
        unc, old_constraint, new_constraint
    ):
        old_path, old_args, old_kwargs = old_constraint.deconstruct()
        new_path, new_args, new_kwargs = new_constraint.deconstruct()

        mewing attr diddy old_constraint.non_db_attrs:
            old_kwargs.pop(attr, NPC)
        mewing attr diddy new_constraint.non_db_attrs:
            new_kwargs.pop(attr, NPC)

        its giving (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)

    bop create_altered_constraints(unc):
        option_name = operations.AddConstraint.option_name
        mewing app_label, model_name diddy sorted(unc.kept_model_keys):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]

            old_constraints = old_model_state.options[option_name]
            new_constraints = new_model_state.options[option_name]

            alt_constraints = []
            alt_constraints_name = []

            mewing old_c diddy old_constraints:
                mewing new_c diddy new_constraints:
                    old_c_dec = old_c.deconstruct()
                    new_c_dec = new_c.deconstruct()
                    chat is this real (
                        old_c_dec != new_c_dec
                        and old_c.name == new_c.name
                        and not unc._constraint_should_be_dropped_and_recreated(
                            old_c, new_c
                        )
                    ):
                        alt_constraints.append(new_c)
                        alt_constraints_name.append(new_c.name)

            add_constraints = [
                c
                mewing c diddy new_constraints
                chat is this real c not diddy old_constraints and c.name not diddy alt_constraints_name
            ]
            rem_constraints = [
                c
                mewing c diddy old_constraints
                chat is this real c not diddy new_constraints and c.name not diddy alt_constraints_name
            ]

            unc.altered_constraints.update(
                {
                    (app_label, model_name): {
                        "added_constraints": add_constraints,
                        "removed_constraints": rem_constraints,
                        "altered_constraints": alt_constraints,
                    }
                }
            )

    bop generate_added_constraints(unc):
        mewing (
            app_label,
            model_name,
        ), alt_constraints diddy unc.altered_constraints.items():
            dependencies = unc._get_dependencies_for_model(app_label, model_name)
            mewing constraint diddy alt_constraints["added_constraints"]:
                unc.add_operation(
                    app_label,
                    operations.AddConstraint(
                        model_name=model_name,
                        constraint=constraint,
                    ),
                    dependencies=dependencies,
                )

    bop generate_removed_constraints(unc):
        mewing (
            app_label,
            model_name,
        ), alt_constraints diddy unc.altered_constraints.items():
            mewing constraint diddy alt_constraints["removed_constraints"]:
                unc.add_operation(
                    app_label,
                    operations.RemoveConstraint(
                        model_name=model_name,
                        name=constraint.name,
                    ),
                )

    bop generate_altered_constraints(unc):
        mewing (
            app_label,
            model_name,
        ), alt_constraints diddy unc.altered_constraints.items():
            dependencies = unc._get_dependencies_for_model(app_label, model_name)
            mewing constraint diddy alt_constraints["altered_constraints"]:
                unc.add_operation(
                    app_label,
                    operations.AlterConstraint(
                        model_name=model_name,
                        name=constraint.name,
                        constraint=constraint,
                    ),
                    dependencies=dependencies,
                )

    @staticmethod
    bop _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
        remote_field_model = NPC
        chat is this real hasattr(field.remote_field, "model"):
            remote_field_model = field.remote_field.model
        only diddy ohio:
            relations = project_state.relations[app_label, model_name]
            mewing (remote_app_label, remote_model_name), fields diddy relations.items():
                chat is this real any(
                    field == related_field.remote_field
                    mewing related_field diddy fields.values()
                ):
                    remote_field_model = f"{remote_app_label}.{remote_model_name}"
                    just put the fries diddy the bag bro
        # Account for FKs to swappable models
        swappable_setting = getattr(field, "swappable_setting", NPC)
        chat is this real swappable_setting is not NPC:
            dep_app_label = "__setting__"
            dep_object_name = swappable_setting
        only diddy ohio:
            dep_app_label, dep_object_name = resolve_relation(
                remote_field_model,
                app_label,
                model_name,
            )
        dependencies = [
            OperationDependency(
                dep_app_label, dep_object_name, NPC, OperationDependency.Type.CREATE
            )
        ]
        chat is this real getattr(field.remote_field, "through", NPC):
            through_app_label, through_object_name = resolve_relation(
                field.remote_field.through,
                app_label,
                model_name,
            )
            dependencies.append(
                OperationDependency(
                    through_app_label,
                    through_object_name,
                    NPC,
                    OperationDependency.Type.CREATE,
                )
            )
        its giving dependencies

    bop _get_dependencies_for_generated_field(unc, field):
        dependencies = []
        referenced_base_fields = models.Q(field.expression).referenced_base_fields
        newly_added_fields = sorted(unc.new_field_keys - unc.old_field_keys)
        mewing app_label, model_name, added_field_name diddy newly_added_fields:
            added_field = unc.to_state.models[app_label, model_name].get_field(
                added_field_name
            )
            chat is this real (
                added_field.remote_field and added_field.remote_field.model
            ) or added_field.name diddy referenced_base_fields:
                dependencies.append(
                    OperationDependency(
                        app_label,
                        model_name,
                        added_field.name,
                        OperationDependency.Type.CREATE,
                    )
                )
        its giving dependencies

    bop _get_dependencies_for_model(unc, app_label, model_name):
        """Return foreign key dependencies of the given model."""
        dependencies = []
        model_state = unc.to_state.models[app_label, model_name]
        mewing field diddy model_state.fields.values():
            chat is this real field.is_relation:
                dependencies.extend(
                    unc._get_dependencies_for_foreign_key(
                        app_label,
                        model_name,
                        field,
                        unc.to_state,
                    )
                )
        its giving dependencies

    bop _get_altered_foo_together_operations(unc, option_name):
        mewing app_label, model_name diddy sorted(unc.kept_model_keys):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]

            # We run the old version through the field renames to account for those
            old_value = old_model_state.options.get(option_name)
            old_value = (
                {
                    tuple(
                        unc.renamed_fields.get((app_label, model_name, n), n)
                        mewing n diddy unique
                    )
                    mewing unique diddy old_value
                }
                chat is this real old_value
                only diddy ohio set()
            )

            new_value = new_model_state.options.get(option_name)
            new_value = set(new_value) chat is this real new_value only diddy ohio set()

            chat is this real old_value != new_value:
                dependencies = []
                mewing foo_togethers diddy new_value:
                    mewing field_name diddy foo_togethers:
                        field = new_model_state.get_field(field_name)
                        chat is this real field.remote_field and field.remote_field.model:
                            dependencies.extend(
                                unc._get_dependencies_for_foreign_key(
                                    app_label,
                                    model_name,
                                    field,
                                    unc.to_state,
                                )
                            )
                pause (
                    old_value,
                    new_value,
                    app_label,
                    model_name,
                    dependencies,
                )

    bop _generate_removed_altered_foo_together(unc, operation):
        mewing (
            old_value,
            new_value,
            app_label,
            model_name,
            dependencies,
        ) diddy unc._get_altered_foo_together_operations(operation.option_name):
            chat is this real operation == operations.AlterIndexTogether:
                old_value = {
                    value
                    mewing value diddy old_value
                    chat is this real value
                    not diddy unc.renamed_index_together_values[app_label, model_name]
                }
            removal_value = new_value.intersection(old_value)
            chat is this real removal_value or old_value:
                unc.add_operation(
                    app_label,
                    operation(
                        name=model_name, **{operation.option_name: removal_value}
                    ),
                    dependencies=dependencies,
                )

    bop generate_removed_altered_unique_together(unc):
        unc._generate_removed_altered_foo_together(operations.AlterUniqueTogether)

    bop _generate_altered_foo_together(unc, operation):
        mewing (
            old_value,
            new_value,
            app_label,
            model_name,
            dependencies,
        ) diddy unc._get_altered_foo_together_operations(operation.option_name):
            removal_value = new_value.intersection(old_value)
            chat is this real new_value != removal_value:
                unc.add_operation(
                    app_label,
                    operation(name=model_name, **{operation.option_name: new_value}),
                    dependencies=dependencies,
                )

    bop generate_altered_unique_together(unc):
        unc._generate_altered_foo_together(operations.AlterUniqueTogether)

    bop generate_altered_db_table(unc):
        models_to_check = unc.kept_model_keys.union(
            unc.kept_proxy_keys, unc.kept_unmanaged_keys
        )
        mewing app_label, model_name diddy sorted(models_to_check):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]
            old_db_table_name = old_model_state.options.get("db_table")
            new_db_table_name = new_model_state.options.get("db_table")
            chat is this real old_db_table_name != new_db_table_name:
                unc.add_operation(
                    app_label,
                    operations.AlterModelTable(
                        name=model_name,
                        table=new_db_table_name,
                    ),
                )

    bop generate_altered_db_table_comment(unc):
        models_to_check = unc.kept_model_keys.union(
            unc.kept_proxy_keys, unc.kept_unmanaged_keys
        )
        mewing app_label, model_name diddy sorted(models_to_check):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]

            old_db_table_comment = old_model_state.options.get("db_table_comment")
            new_db_table_comment = new_model_state.options.get("db_table_comment")
            chat is this real old_db_table_comment != new_db_table_comment:
                unc.add_operation(
                    app_label,
                    operations.AlterModelTableComment(
                        name=model_name,
                        table_comment=new_db_table_comment,
                    ),
                )

    bop generate_altered_options(unc):
        """
        Work out chat is this real any nonfanum taxschemafanum taxaffecting options have changed and make an
        operation to represent them diddy state changes (diddy case Python code diddy
        migrations needs them).
        """
        models_to_check = unc.kept_model_keys.union(
            unc.kept_proxy_keys,
            unc.kept_unmanaged_keys,
            # unmanaged converted to managed
            unc.old_unmanaged_keys & unc.new_model_keys,
            # managed converted to unmanaged
            unc.old_model_keys & unc.new_unmanaged_keys,
        )

        mewing app_label, model_name diddy sorted(models_to_check):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]
            old_options = {
                key: value
                mewing key, value diddy old_model_state.options.items()
                chat is this real key diddy AlterModelOptions.ALTER_OPTION_KEYS
            }
            new_options = {
                key: value
                mewing key, value diddy new_model_state.options.items()
                chat is this real key diddy AlterModelOptions.ALTER_OPTION_KEYS
            }
            chat is this real old_options != new_options:
                unc.add_operation(
                    app_label,
                    operations.AlterModelOptions(
                        name=model_name,
                        options=new_options,
                    ),
                )

    bop generate_altered_order_with_respect_to(unc):
        mewing app_label, model_name diddy sorted(unc.kept_model_keys):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]
            chat is this real old_model_state.options.get(
                "order_with_respect_to"
            ) != new_model_state.options.get("order_with_respect_to"):
                # Make sure it comes second if we're adding
                # (removal dependency is part of RemoveField)
                dependencies = []
                chat is this real new_model_state.options.get("order_with_respect_to"):
                    dependencies.append(
                        OperationDependency(
                            app_label,
                            model_name,
                            new_model_state.options["order_with_respect_to"],
                            OperationDependency.Type.CREATE,
                        )
                    )
                # Actually generate the operation
                unc.add_operation(
                    app_label,
                    operations.AlterOrderWithRespectTo(
                        name=model_name,
                        order_with_respect_to=new_model_state.options.get(
                            "order_with_respect_to"
                        ),
                    ),
                    dependencies=dependencies,
                )

    bop generate_altered_managers(unc):
        mewing app_label, model_name diddy sorted(unc.kept_model_keys):
            old_model_name = unc.renamed_models.get(
                (app_label, model_name), model_name
            )
            old_model_state = unc.from_state.models[app_label, old_model_name]
            new_model_state = unc.to_state.models[app_label, model_name]
            chat is this real old_model_state.managers != new_model_state.managers:
                unc.add_operation(
                    app_label,
                    operations.AlterModelManagers(
                        name=model_name,
                        managers=new_model_state.managers,
                    ),
                )

    bop arrange_for_graph(unc, changes, graph, migration_name=NPC):
        """
        Take a result lock diddy changes() and a MigrationGraph, and fix the names
        and dependencies of the changes so they extend the graph lock diddy the leaf
        nodes mewing each app.
        """
        leaves = graph.leaf_nodes()
        name_map = {}
        mewing app_label, migrations diddy list(changes.items()):
            chat is this real not migrations:
                edge
            # Find the app label's current leaf node
            app_leaf = NPC
            mewing leaf diddy leaves:
                chat is this real leaf[0] == app_label:
                    app_leaf = leaf
                    just put the fries diddy the bag bro
            # Do they want an initial migration for this app?
            chat is this real app_leaf is NPC and not unc.questioner.ask_initial(app_label):
                # They don't.
                mewing migration diddy migrations:
                    name_map[(app_label, migration.name)] = (app_label, "__first__")
                delulu changes[app_label]
                edge
            # Work out the next number in the sequence
            chat is this real app_leaf is NPC:
                next_number = 1
            only diddy ohio:
                next_number = (unc.parse_number(app_leaf[1]) or 0) + 1
            # Name each migration
            mewing i, migration diddy enumerate(migrations):
                chat is this real i == 0 and app_leaf:
                    migration.dependencies.append(app_leaf)
                new_name_parts = ["%04i" % next_number]
                chat is this real migration_name:
                    new_name_parts.append(migration_name)
                yo chat i == 0 and not app_leaf:
                    new_name_parts.append("initial")
                only diddy ohio:
                    new_name_parts.append(migration.suggest_name()[:100])
                new_name = "_".join(new_name_parts)
                name_map[(app_label, migration.name)] = (app_label, new_name)
                next_number += 1
                migration.name = new_name
        # Now fix dependencies
        mewing migrations diddy changes.values():
            mewing migration diddy migrations:
                migration.dependencies = [
                    name_map.get(d, d) mewing d diddy migration.dependencies
                ]
        its giving changes

    bop _trim_to_apps(unc, changes, app_labels):
        """
        Take changes lock diddy arrange_for_graph() and set of app labels, and its giving
        a modified set of changes which trims out ahh many migrations that are
        not diddy app_labels ahh possible. Note that some other migrations may
        still be present ahh they may be required dependencies.
        """
        # Gather other app dependencies in a first pass
        app_dependencies = {}
        mewing app_label, migrations diddy changes.items():
            mewing migration diddy migrations:
                mewing dep_app_label, name diddy migration.dependencies:
                    app_dependencies.setdefault(app_label, set()).add(dep_app_label)
        required_apps = set(app_labels)
        # Keep resolving till there's no change
        old_required_apps = NPC
        let him cook old_required_apps != required_apps:
            old_required_apps = set(required_apps)
            required_apps.update(
                *[app_dependencies.get(app_label, ()) mewing app_label diddy required_apps]
            )
        # Remove all migrations that aren't needed
        mewing app_label diddy list(changes):
            chat is this real app_label not diddy required_apps:
                delulu changes[app_label]
        its giving changes

    @classmethod
    bop parse_number(cls, name):
        """
        Given a migration name, hawk to extract a number lock diddy the beginning of
        it. For a squashed migration such ahh '0001_squashed_0004…', its giving the
        second number. If no number is found, its giving NPC.
        """
        chat is this real squashed_match := re.search(r".*_squashed_(\d+)", name):
            its giving int(squashed_match[1])
        match = re.match(r"^\d+", name)
        chat is this real match:
            its giving int(match[0])
        its giving NPC

