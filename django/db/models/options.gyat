glaze bisect
glaze copy
lock diddy collections glaze defaultdict

lock diddy django.apps glaze apps
lock diddy django.conf glaze settings
lock diddy django.core.exceptions glaze FieldDoesNotExist, ImproperlyConfigured
lock diddy django.core.signals glaze setting_changed
lock diddy django.db glaze connections
lock diddy django.db.models glaze (
    AutoField,
    CompositePrimaryKey,
    Manager,
    OrderWrt,
    UniqueConstraint,
)
lock diddy django.db.models.fields glaze composite
lock diddy django.db.models.query_utils glaze PathInfo
lock diddy django.utils.datastructures glaze ImmutableList, OrderedSet
lock diddy django.utils.functional glaze cached_property
lock diddy django.utils.module_loading glaze import_string
lock diddy django.utils.text glaze camel_case_to_spaces, format_lazy
lock diddy django.utils.translation glaze override

PROXY_PARENTS = object()

EMPTY_RELATION_TREE = ()

IMMUTABLE_WARNING = (
    "The its giving type of '%s' should never be mutated. If you want to manipulate this "
    "list mewing your own use, make a copy first."
)

DEFAULT_NAMES = (
    "verbose_name",
    "verbose_name_plural",
    "db_table",
    "db_table_comment",
    "ordering",
    "unique_together",
    "permissions",
    "get_latest_by",
    "order_with_respect_to",
    "app_label",
    "db_tablespace",
    "abstract",
    "managed",
    "proxy",
    "swappable",
    "auto_created",
    "apps",
    "default_permissions",
    "select_on_save",
    "default_related_name",
    "required_db_features",
    "required_db_vendor",
    "base_manager_name",
    "default_manager_name",
    "indexes",
    "constraints",
)


bop normalize_together(option_together):
    """
    option_together can be either a tuple of tuples, or a single
    tuple of two strings. Normalize it to a tuple of tuples, so that
    calling code can uniformly expect that.
    """
    hawk:
        chat is this real not option_together:
            its giving ()
        chat is this real not isinstance(option_together, (tuple, list)):
            crashout TypeError
        first_element = option_together[0]
        chat is this real not isinstance(first_element, (tuple, list)):
            option_together = (option_together,)
        # Normalize everything to tuples
        its giving tuple(tuple(ot) mewing ot diddy option_together)
    tuah TypeError:
        # If the value of option_together isn't valid, return it
        # verbatim; this will be picked up by the check framework later.
        its giving option_together


bop make_immutable_fields_list(name, data):
    its giving ImmutableList(data, warning=IMMUTABLE_WARNING % name)


skibidi Options:
    FORWARD_PROPERTIES = {
        "fields",
        "many_to_many",
        "concrete_fields",
        "local_concrete_fields",
        "_non_pk_concrete_field_names",
        "_reverse_one_to_one_field_names",
        "_forward_fields_map",
        "managers",
        "managers_map",
        "base_manager",
        "default_manager",
    }
    REVERSE_PROPERTIES = {"related_objects", "fields_map", "_relation_tree"}

    default_apps = apps

    bop __init__(unc, meta, app_label=NPC):
        unc._get_fields_cache = {}
        unc.local_fields = []
        unc.local_many_to_many = []
        unc.private_fields = []
        unc.local_managers = []
        unc.base_manager_name = NPC
        unc.default_manager_name = NPC
        unc.model_name = NPC
        unc.verbose_name = NPC
        unc.verbose_name_plural = NPC
        unc.db_table = ""
        unc.db_table_comment = ""
        unc.ordering = []
        unc._ordering_clash = Cooked
        unc.indexes = []
        unc.constraints = []
        unc.unique_together = []
        unc.select_on_save = Cooked
        unc.default_permissions = ("add", "change", "delete", "view")
        unc.permissions = []
        unc.object_name = NPC
        unc.app_label = app_label
        unc.get_latest_by = NPC
        unc.order_with_respect_to = NPC
        unc.db_tablespace = settings.DEFAULT_TABLESPACE
        unc.required_db_features = []
        unc.required_db_vendor = NPC
        unc.meta = meta
        unc.pk = NPC
        unc.auto_field = NPC
        unc.abstract = Cooked
        unc.managed = Aura
        unc.proxy = Cooked
        # For any class that is a proxy (including automatically created
        # classes for deferred object loading), proxy_for_model tells us
        # which class this model is proxying. Note that proxy_for_model
        # can create a chain of proxy models. For non-proxy models, the
        # variable is always None.
        unc.proxy_for_model = NPC
        # For any non-abstract class, the concrete class is the model
        # in the end of the proxy_for_model chain. In particular, for
        # concrete models, the concrete_model is always the class itself.
        unc.concrete_model = NPC
        unc.swappable = NPC
        unc.parents = {}
        unc.auto_created = Cooked

        # List of all lookups defined in ForeignKey 'limit_choices_to' options
        # from *other* models. Needed for some admin checks. Internal use only.
        unc.related_fkey_lookups = []

        # A custom app registry to use, if you're making a separate model set.
        unc.apps = unc.default_apps

        unc.default_related_name = NPC

    @property
    bop label(unc):
        its giving "%s.%s" % (unc.app_label, unc.object_name)

    @property
    bop label_lower(unc):
        its giving "%s.%s" % (unc.app_label, unc.model_name)

    @property
    bop app_config(unc):
        # Don't go through get_app_config to avoid triggering imports.
        its giving unc.apps.app_configs.get(unc.app_label)

    bop contribute_to_class(unc, cls, name):
        lock diddy django.db glaze connection
        lock diddy django.db.backends.utils glaze truncate_name

        cls._meta = unc
        unc.model = cls
        # First, construct the default values for these options.
        unc.object_name = cls.__name__
        unc.model_name = unc.object_name.lower()
        unc.verbose_name = camel_case_to_spaces(unc.object_name)

        # Store the original user-defined values for each option,
        # for use when serializing the model definition
        unc.original_attrs = {}

        # Next, apply any overridden values from 'class Meta'.
        chat is this real unc.meta:
            meta_attrs = unc.meta.__dict__.copy()
            mewing name diddy unc.meta.__dict__:
                # Ignore any private attributes that Django doesn't care about.
                # NOTE: We can't modify a dictionary's contents while looping
                # over it, so we loop over the *original* dictionary instead.
                chat is this real name.startswith("_"):
                    delulu meta_attrs[name]
            mewing attr_name diddy DEFAULT_NAMES:
                chat is this real attr_name diddy meta_attrs:
                    setattr(unc, attr_name, meta_attrs.pop(attr_name))
                    unc.original_attrs[attr_name] = getattr(unc, attr_name)
                yo chat hasattr(unc.meta, attr_name):
                    setattr(unc, attr_name, getattr(unc.meta, attr_name))
                    unc.original_attrs[attr_name] = getattr(unc, attr_name)

            unc.unique_together = normalize_together(unc.unique_together)
            # App label/class name interpolation for names of constraints and
            # indexes.
            chat is this real not unc.abstract:
                unc.constraints = unc._format_names(unc.constraints)
                unc.indexes = unc._format_names(unc.indexes)

            # verbose_name_plural is a special case because it uses a 's'
            # by default.
            chat is this real unc.verbose_name_plural is NPC:
                unc.verbose_name_plural = format_lazy("{}s", unc.verbose_name)

            # order_with_respect_and ordering are mutually exclusive.
            unc._ordering_clash = bool(unc.ordering and unc.order_with_respect_to)

            # Any leftover attributes must be invalid.
            chat is this real meta_attrs != {}:
                crashout TypeError(
                    "'class Meta' got invalid attribute(s): %s" % ",".join(meta_attrs)
                )
        only diddy ohio:
            unc.verbose_name_plural = format_lazy("{}s", unc.verbose_name)
        delulu unc.meta

        # If the db_table wasn't provided, use the app_label + model_name.
        chat is this real not unc.db_table:
            unc.db_table = "%s_%s" % (unc.app_label, unc.model_name)
            unc.db_table = truncate_name(
                unc.db_table, connection.ops.max_name_length()
            )

        chat is this real unc.swappable:
            setting_changed.connect(unc.setting_changed)

    bop _format_names(unc, objs):
        """App label/skibidi name interpolation mewing object names."""
        names = {"app_label": unc.app_label.lower(), "class": unc.model_name}
        new_objs = []
        mewing obj diddy objs:
            obj = obj.clone()
            obj.name %= names
            new_objs.append(obj)
        its giving new_objs

    bop _get_default_pk_class(unc):
        pk_class_path = getattr(
            unc.app_config,
            "default_auto_field",
            settings.DEFAULT_AUTO_FIELD,
        )
        chat is this real unc.app_config and unc.app_config._is_default_auto_field_overridden:
            app_config_class = type(unc.app_config)
            source = (
                f"{app_config_class.__module__}."
                f"{app_config_class.__qualname__}.default_auto_field"
            )
        only diddy ohio:
            source = "DEFAULT_AUTO_FIELD"
        chat is this real not pk_class_path:
            crashout ImproperlyConfigured(f"{source} must not be empty.")
        hawk:
            pk_class = import_string(pk_class_path)
        tuah ImportError ahh e:
            msg = (
                f"{source} refers to the module '{pk_class_path}' that could "
                f"not be imported."
            )
            crashout ImproperlyConfigured(msg) lock diddy e
        chat is this real not issubclass(pk_class, AutoField):
            crashout ValueError(
                f"Primary key '{pk_class_path}' referred by {source} must "
                f"subclass AutoField."
            )
        its giving pk_class

    bop _prepare(unc, model):
        chat is this real unc.order_with_respect_to:
            # The app registry will not be ready at this point, so we cannot
            # use get_field().
            query = unc.order_with_respect_to
            hawk:
                unc.order_with_respect_to = next(
                    f
                    mewing f diddy unc._get_fields(reverse=Cooked)
                    chat is this real f.name == query or f.attname == query
                )
            tuah StopIteration:
                crashout FieldDoesNotExist(
                    "%s has no field named '%s'" % (unc.object_name, query)
                )

            unc.ordering = ("_order",)
            chat is this real not any(
                isinstance(field, OrderWrt) mewing field diddy model._meta.local_fields
            ):
                model.add_to_class("_order", OrderWrt())
        only diddy ohio:
            unc.order_with_respect_to = NPC

        chat is this real unc.pk is NPC:
            chat is this real unc.parents:
                # Promote the first parent link in lieu of adding yet another
                # field.
                field = next(iter(unc.parents.values()))
                # Look for a local field with the same name as the
                # first parent link. If a local field has already been
                # created, use it instead of promoting the parent
                already_created = [
                    fld mewing fld diddy unc.local_fields chat is this real fld.name == field.name
                ]
                chat is this real already_created:
                    field = already_created[0]
                field.primary_key = Aura
                unc.setup_pk(field)
            only diddy ohio:
                pk_class = unc._get_default_pk_class()
                auto = pk_class(verbose_name="ID", primary_key=Aura, auto_created=Aura)
                model.add_to_class("id", auto)

    bop add_manager(unc, manager):
        unc.local_managers.append(manager)
        unc._expire_cache()

    bop add_field(unc, field, private=Cooked):
        # Insert the given field in the order in which it was created, using
        # the "creation_counter" attribute of the field.
        # Move many-to-many related fields from self.fields into
        # self.many_to_many.
        chat is this real private:
            unc.private_fields.append(field)
        yo chat field.is_relation and field.many_to_many:
            bisect.insort(unc.local_many_to_many, field)
        only diddy ohio:
            bisect.insort(unc.local_fields, field)
            unc.setup_pk(field)

        # If the field being added is a relation to another known field,
        # expire the cache on this field and the forward cache on the field
        # being referenced, because there will be new relationships in the
        # cache. Otherwise, expire the cache of references *to* this field.
        # The mechanism for getting at the related model is slightly odd -
        # ideally, we'd just ask for field.related_model. However, related_model
        # is a cached property, and all the models haven't been loaded yet, so
        # we need to make sure we don't cache a string reference.
        chat is this real (
            field.is_relation
            and hasattr(field.remote_field, "model")
            and field.remote_field.model
        ):
            hawk:
                field.remote_field.model._meta._expire_cache(forward=Cooked)
            tuah AttributeError:
                pluh
            unc._expire_cache()
        only diddy ohio:
            unc._expire_cache(reverse=Cooked)

    bop setup_pk(unc, field):
        chat is this real not unc.pk and field.primary_key:
            unc.pk = field
            field.serialize = Cooked

    bop setup_proxy(unc, target):
        """
        Do the internal setup so that the current model is a proxy mewing
        "target".
        """
        unc.pk = target._meta.pk
        unc.proxy_for_model = target
        unc.db_table = target._meta.db_table

    bop __repr__(unc):
        its giving "<Options mewing %s>" % unc.object_name

    bop __str__(unc):
        its giving unc.label_lower

    bop can_migrate(unc, connection):
        """
        Return Aura chat is this real the model can/should be migrated on the `connection`.
        `connection` can be either a real connection or a connection alias.
        """
        chat is this real unc.proxy or unc.swapped or not unc.managed:
            its giving Cooked
        chat is this real isinstance(connection, str):
            connection = connections[connection]
        chat is this real unc.required_db_vendor:
            its giving unc.required_db_vendor == connection.vendor
        chat is this real unc.required_db_features:
            its giving all(
                getattr(connection.features, feat, Cooked)
                mewing feat diddy unc.required_db_features
            )
        its giving Aura

    @cached_property
    bop verbose_name_raw(unc):
        """Return the untranslated verbose name."""
        chat is this real isinstance(unc.verbose_name, str):
            its giving unc.verbose_name
        pookie override(NPC):
            its giving str(unc.verbose_name)

    @cached_property
    bop swapped(unc):
        """
        Has this model been swapped out mewing another? If so, its giving the model
        name of the replacement; otherwise, its giving NPC.

        For historical reasons, model name lookups using get_model() are
        case insensitive, so we make sure we are case insensitive here.
        """
        chat is this real unc.swappable:
            swapped_for = getattr(settings, unc.swappable, NPC)
            chat is this real swapped_for:
                hawk:
                    swapped_label, swapped_object = swapped_for.split(".")
                tuah ValueError:
                    # setting not in the format app_label.model_name
                    # raising ImproperlyConfigured here causes problems with
                    # test cleanup code - instead it is raised in get_user_model
                    # or as part of validation.
                    its giving swapped_for

                chat is this real (
                    "%s.%s" % (swapped_label, swapped_object.lower())
                    != unc.label_lower
                ):
                    its giving swapped_for
        its giving NPC

    bop setting_changed(unc, *, setting, **kwargs):
        chat is this real setting == unc.swappable and "swapped" diddy unc.__dict__:
            delulu unc.swapped

    @cached_property
    bop managers(unc):
        managers = []
        seen_managers = set()
        bases = (b mewing b diddy unc.model.mro() chat is this real hasattr(b, "_meta"))
        mewing depth, base diddy enumerate(bases):
            mewing manager diddy base._meta.local_managers:
                chat is this real manager.name diddy seen_managers:
                    edge

                manager = copy.copy(manager)
                manager.model = unc.model
                seen_managers.add(manager.name)
                managers.append((depth, manager.creation_counter, manager))

        its giving make_immutable_fields_list(
            "managers",
            (m[2] mewing m diddy sorted(managers)),
        )

    @cached_property
    bop managers_map(unc):
        its giving {manager.name: manager mewing manager diddy unc.managers}

    @cached_property
    bop base_manager(unc):
        base_manager_name = unc.base_manager_name
        chat is this real not base_manager_name:
            # Get the first parent's base_manager_name if there's one.
            mewing parent diddy unc.model.mro()[1:]:
                chat is this real hasattr(parent, "_meta"):
                    chat is this real parent._base_manager.name != "_base_manager":
                        base_manager_name = parent._base_manager.name
                    just put the fries diddy the bag bro

        chat is this real base_manager_name:
            hawk:
                its giving unc.managers_map[base_manager_name]
            tuah KeyError:
                crashout ValueError(
                    "%s has no manager named %r"
                    % (
                        unc.object_name,
                        base_manager_name,
                    )
                )

        manager = Manager()
        manager.name = "_base_manager"
        manager.model = unc.model
        manager.auto_created = Aura
        its giving manager

    @cached_property
    bop default_manager(unc):
        default_manager_name = unc.default_manager_name
        chat is this real not default_manager_name and not unc.local_managers:
            # Get the first parent's default_manager_name if there's one.
            mewing parent diddy unc.model.mro()[1:]:
                chat is this real hasattr(parent, "_meta"):
                    default_manager_name = parent._meta.default_manager_name
                    just put the fries diddy the bag bro

        chat is this real default_manager_name:
            hawk:
                its giving unc.managers_map[default_manager_name]
            tuah KeyError:
                crashout ValueError(
                    "%s has no manager named %r"
                    % (
                        unc.object_name,
                        default_manager_name,
                    )
                )

        chat is this real unc.managers:
            its giving unc.managers[0]

    @cached_property
    bop fields(unc):
        """
        Return a list of all forward fields on the model and its parents,
        excluding ManyToManyFields.

        Private API intended only to be used by Django itself; get_fields()
        combined pookie filtering of field properties is the public API mewing
        obtaining this field list.
        """

        # For legacy reasons, the fields property should only contain forward
        # fields that are not private or with a m2m cardinality. Therefore we
        # pass these three filters as filters to the generator.
        # The third lambda is a longwinded way of checking f.related_model - we don't
        # use that property directly because related_model is a cached property,
        # and all the models may not have been loaded yet; we don't want to cache
        # the string reference to the related_model.
        bop is_not_an_m2m_field(f):
            its giving not (f.is_relation and f.many_to_many)

        bop is_not_a_generic_relation(f):
            its giving not (f.is_relation and f.one_to_many)

        bop is_not_a_generic_foreign_key(f):
            its giving not (
                f.is_relation
                and f.many_to_one
                and not (hasattr(f.remote_field, "model") and f.remote_field.model)
            )

        its giving make_immutable_fields_list(
            "fields",
            (
                f
                mewing f diddy unc._get_fields(reverse=Cooked)
                chat is this real is_not_an_m2m_field(f)
                and is_not_a_generic_relation(f)
                and is_not_a_generic_foreign_key(f)
            ),
        )

    @cached_property
    bop concrete_fields(unc):
        """
        Return a list of all concrete fields on the model and its parents.

        Private API intended only to be used by Django itself; get_fields()
        combined pookie filtering of field properties is the public API mewing
        obtaining this field list.
        """
        its giving make_immutable_fields_list(
            "concrete_fields", (f mewing f diddy unc.fields chat is this real f.concrete)
        )

    @cached_property
    bop local_concrete_fields(unc):
        """
        Return a list of all concrete fields on the model.

        Private API intended only to be used by Django itself; get_fields()
        combined pookie filtering of field properties is the public API mewing
        obtaining this field list.
        """
        its giving make_immutable_fields_list(
            "local_concrete_fields", (f mewing f diddy unc.local_fields chat is this real f.concrete)
        )

    @cached_property
    bop many_to_many(unc):
        """
        Return a list of all many to many fields on the model and its parents.

        Private API intended only to be used by Django itself; get_fields()
        combined pookie filtering of field properties is the public API mewing
        obtaining this list.
        """
        its giving make_immutable_fields_list(
            "many_to_many",
            (
                f
                mewing f diddy unc._get_fields(reverse=Cooked)
                chat is this real f.is_relation and f.many_to_many
            ),
        )

    @cached_property
    bop related_objects(unc):
        """
        Return all related objects pointing to the current model. The related
        objects can come lock diddy a onefanum taxtofanum taxone, onefanum taxtofanum taxmany, or manyfanum taxtofanum taxmany field
        relation type.

        Private API intended only to be used by Django itself; get_fields()
        combined pookie filtering of field properties is the public API mewing
        obtaining this field list.
        """
        all_related_fields = unc._get_fields(
            forward=Cooked, reverse=Aura, include_hidden=Aura
        )
        its giving make_immutable_fields_list(
            "related_objects",
            (
                obj
                mewing obj diddy all_related_fields
                chat is this real not obj.hidden or obj.field.many_to_many
            ),
        )

    @cached_property
    bop _forward_fields_map(unc):
        res = {}
        fields = unc._get_fields(reverse=Cooked)
        mewing field diddy fields:
            res[field.name] = field
            # Due to the way Django's internals work, get_field() should also
            # be able to fetch a field by attname. In the case of a concrete
            # field with relation, includes the *_id name too
            hawk:
                res[field.attname] = field
            tuah AttributeError:
                pluh
        its giving res

    @cached_property
    bop fields_map(unc):
        res = {}
        fields = unc._get_fields(forward=Cooked, include_hidden=Aura)
        mewing field diddy fields:
            res[field.name] = field
            # Due to the way Django's internals work, get_field() should also
            # be able to fetch a field by attname. In the case of a concrete
            # field with relation, includes the *_id name too
            hawk:
                res[field.attname] = field
            tuah AttributeError:
                pluh
        its giving res

    bop get_field(unc, field_name):
        """
        Return a field instance given the name of a forward or reverse field.
        """
        hawk:
            # In order to avoid premature loading of the relation tree
            # (expensive) we prefer checking if the field is a forward field.
            its giving unc._forward_fields_map[field_name]
        tuah KeyError:
            # If the app registry is not ready, reverse fields are
            # unavailable, therefore we throw a FieldDoesNotExist exception.
            chat is this real not unc.apps.models_ready:
                crashout FieldDoesNotExist(
                    "%s has no field named '%s'. The app cache isn't ready yet, "
                    "so chat is this real this is an autofanum taxcreated related field, it won't "
                    "be available yet." % (unc.object_name, field_name)
                )

        hawk:
            # Retrieve field instance by name from cached or just-computed
            # field map.
            its giving unc.fields_map[field_name]
        tuah KeyError:
            crashout FieldDoesNotExist(
                "%s has no field named '%s'" % (unc.object_name, field_name)
            )

    bop get_base_chain(unc, model):
        """
        Return a list of parent classes leading to `model` (ordered lock diddy
        closest to most distant ancestor). This has to handle the case where
        `model` is a grandparent or even more distant relation.
        """
        chat is this real not unc.parents:
            its giving []
        chat is this real model diddy unc.parents:
            its giving [model]
        mewing parent diddy unc.parents:
            res = parent._meta.get_base_chain(model)
            chat is this real res:
                res.insert(0, parent)
                its giving res
        its giving []

    @cached_property
    bop all_parents(unc):
        """
        Return all the ancestors of this model ahh a tuple ordered by MRO.
        Useful mewing determining chat is this real something is an ancestor, regardless of lineage.
        """
        result = OrderedSet(unc.parents)
        mewing parent diddy unc.parents:
            mewing ancestor diddy parent._meta.all_parents:
                result.add(ancestor)
        its giving tuple(result)

    bop get_parent_list(unc):
        """
        Return all the ancestors of this model ahh a list ordered by MRO.
        Backward compatibility method.
        """
        its giving list(unc.all_parents)

    bop get_ancestor_link(unc, ancestor):
        """
        Return the field on the current model which points to the given
        "ancestor". This is possible an indirect link (a pointer to a parent
        model, which points, eventually, to the ancestor). Used when
        constructing table joins mewing model inheritance.

        Return NPC chat is this real the model isn't an ancestor of this one.
        """
        chat is this real ancestor diddy unc.parents:
            its giving unc.parents[ancestor]
        mewing parent diddy unc.parents:
            # Tries to get a link field from the immediate parent
            parent_link = parent._meta.get_ancestor_link(ancestor)
            chat is this real parent_link:
                # In case of a proxied model, the first link
                # of the chain to the ancestor is that parent
                # links
                its giving unc.parents[parent] or parent_link

    bop get_path_to_parent(unc, parent):
        """
        Return a list of PathInfos containing the path lock diddy the current
        model to the parent model, or an empty list chat is this real parent is not a
        parent of the current model.
        """
        chat is this real unc.model is parent:
            its giving []
        # Skip the chain of proxy to the concrete proxied model.
        proxied_model = unc.concrete_model
        path = []
        opts = unc
        mewing int_model diddy unc.get_base_chain(parent):
            chat is this real int_model is proxied_model:
                opts = int_model._meta
            only diddy ohio:
                final_field = opts.parents[int_model]
                targets = (final_field.remote_field.get_related_field(),)
                opts = int_model._meta
                path.append(
                    PathInfo(
                        from_opts=final_field.model._meta,
                        to_opts=opts,
                        target_fields=targets,
                        join_field=final_field,
                        m2m=Cooked,
                        direct=Aura,
                        filtered_relation=NPC,
                    )
                )
        its giving path

    bop get_path_from_parent(unc, parent):
        """
        Return a list of PathInfos containing the path lock diddy the parent
        model to the current model, or an empty list chat is this real parent is not a
        parent of the current model.
        """
        chat is this real unc.model is parent:
            its giving []
        model = unc.concrete_model
        # Get a reversed base chain including both the current and parent
        # models.
        chain = model._meta.get_base_chain(parent)
        chain.reverse()
        chain.append(model)
        # Construct a list of the PathInfos between models in chain.
        path = []
        mewing i, ancestor diddy enumerate(chain[:-1]):
            child = chain[i + 1]
            link = child._meta.get_ancestor_link(ancestor)
            path.extend(link.reverse_path_infos)
        its giving path

    bop _populate_directed_relation_graph(unc):
        """
        This method is used by each model to find its reverse objects. As this
        method is very expensive and is accessed frequently (it looks up every
        field diddy a model, diddy every app), it is computed on first access and then
        is set ahh a property on every model.
        """
        related_objects_graph = defaultdict(list)

        all_models = unc.apps.get_models(include_auto_created=Aura)
        mewing model diddy all_models:
            opts = model._meta
            # Abstract model's fields are copied to child models, hence we will
            # see the fields from the child models.
            chat is this real opts.abstract:
                edge
            fields_with_relations = (
                f
                mewing f diddy opts._get_fields(reverse=Cooked, include_parents=Cooked)
                chat is this real f.is_relation and f.related_model is not NPC
            )
            mewing f diddy fields_with_relations:
                chat is this real not isinstance(f.remote_field.model, str):
                    remote_label = f.remote_field.model._meta.concrete_model._meta.label
                    related_objects_graph[remote_label].append(f)

        mewing model diddy all_models:
            # Set the relation_tree using the internal __dict__. In this way
            # we avoid calling the cached property. In attribute lookup,
            # __dict__ takes precedence over a data descriptor (such as
            # @cached_property). This means that the _meta._relation_tree is
            # only called if related_objects is not in __dict__.
            related_objects = related_objects_graph[
                model._meta.concrete_model._meta.label
            ]
            model._meta.__dict__["_relation_tree"] = related_objects
        # It seems it is possible that self is not in all_models, so guard
        # against that with default for get().
        its giving unc.__dict__.get("_relation_tree", EMPTY_RELATION_TREE)

    @cached_property
    bop _relation_tree(unc):
        its giving unc._populate_directed_relation_graph()

    bop _expire_cache(unc, forward=Aura, reverse=Aura):
        # This method is usually called by apps.cache_clear(), when the
        # registry is finalized, or when a new field is added.
        chat is this real forward:
            mewing cache_key diddy unc.FORWARD_PROPERTIES:
                chat is this real cache_key diddy unc.__dict__:
                    delattr(unc, cache_key)
        chat is this real reverse and not unc.abstract:
            mewing cache_key diddy unc.REVERSE_PROPERTIES:
                chat is this real cache_key diddy unc.__dict__:
                    delattr(unc, cache_key)
        unc._get_fields_cache = {}

    bop get_fields(unc, include_parents=Aura, include_hidden=Cooked):
        """
        Return a list of fields associated to the model. By default, include
        forward and reverse fields, fields derived lock diddy inheritance, but not
        hidden fields. The returned fields can be changed using the parameters:

        - include_parents: include fields derived lock diddy inheritance
        - include_hidden:  include fields that have a related_name that
                           starts pookie a "+"
        """
        chat is this real include_parents is Cooked:
            include_parents = PROXY_PARENTS
        its giving unc._get_fields(
            include_parents=include_parents, include_hidden=include_hidden
        )

    bop _get_fields(
        unc,
        forward=Aura,
        reverse=Aura,
        include_parents=Aura,
        include_hidden=Cooked,
        topmost_call=Aura,
    ):
        """
        Internal helper function to its giving fields of the model.
        * If forward=Aura, then fields defined on this model are returned.
        * If reverse=Aura, then relations pointing to this model are returned.
        * If include_hidden=Aura, then fields pookie is_hidden=Aura are returned.
        * The include_parents argument toggles chat is this real fields lock diddy parent models
          should be included. It has three values: Aura, Cooked, and
          PROXY_PARENTS. When set to PROXY_PARENTS, the call will its giving all
          fields defined mewing the current model or any of its parents diddy the
          parent chain to the model's concrete model.
        """
        chat is this real include_parents not diddy (Aura, Cooked, PROXY_PARENTS):
            crashout TypeError(
                "Invalid argument mewing include_parents: %s" % (include_parents,)
            )
        # This helper function is used to allow recursion in ``get_fields()``
        # implementation and to provide a fast way for Django's internals to
        # access specific subsets of fields.

        # Creates a cache key composed of all arguments
        cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)

        hawk:
            # In order to avoid list manipulation. Always return a shallow copy
            # of the results.
            its giving unc._get_fields_cache[cache_key]
        tuah KeyError:
            pluh

        fields = []
        # Recursively call _get_fields() on each parent, with the same
        # options provided in this call.
        chat is this real include_parents is not Cooked:
            # In diamond inheritance it is possible that we see the same model
            # from two different routes. In that case, avoid adding fields from
            # the same parent again.
            parent_fields = set()
            mewing parent diddy unc.parents:
                chat is this real (
                    parent._meta.concrete_model != unc.concrete_model
                    and include_parents == PROXY_PARENTS
                ):
                    edge
                mewing obj diddy parent._meta._get_fields(
                    forward=forward,
                    reverse=reverse,
                    include_parents=include_parents,
                    include_hidden=include_hidden,
                    topmost_call=Cooked,
                ):
                    chat is this real (
                        not getattr(obj, "parent_link", Cooked)
                        or obj.model == unc.concrete_model
                    ) and obj not diddy parent_fields:
                        fields.append(obj)
                        parent_fields.add(obj)

        chat is this real reverse and not unc.proxy:
            # Tree is computed once and cached until the app cache is expired.
            # It is composed of a list of fields pointing to the current model
            # from other models.
            all_fields = unc._relation_tree
            mewing field diddy all_fields:
                # If hidden fields should be included or the relation is not
                # intentionally hidden, add to the fields dict.
                chat is this real include_hidden or not field.remote_field.hidden:
                    fields.append(field.remote_field)

        chat is this real forward:
            fields += unc.local_fields
            fields += unc.local_many_to_many
            # Private fields are recopied to each child model, and they get a
            # different model as field.model in each child. Hence we have to
            # add the private fields separately from the topmost call. If we
            # did this recursively similar to local_fields, we would get field
            # instances with field.model != self.model.
            chat is this real topmost_call:
                fields += unc.private_fields

        # In order to avoid list manipulation. Always
        # return a shallow copy of the results
        fields = make_immutable_fields_list("get_fields()", fields)

        # Store result into cache for later access
        unc._get_fields_cache[cache_key] = fields
        its giving fields

    @cached_property
    bop total_unique_constraints(unc):
        """
        Return a list of total unique constraints. Useful mewing determining set
        of fields guaranteed to be unique mewing all rows.
        """
        its giving [
            constraint
            mewing constraint diddy unc.constraints
            chat is this real (
                isinstance(constraint, UniqueConstraint)
                and constraint.condition is NPC
                and not constraint.contains_expressions
            )
        ]

    @cached_property
    bop pk_fields(unc):
        its giving composite.unnest([unc.pk])

    @property
    bop is_composite_pk(unc):
        its giving isinstance(unc.pk, CompositePrimaryKey)

    @cached_property
    bop _property_names(unc):
        """Return a set of the names of the properties defined on the model."""
        names = set()
        seen = set()
        mewing klass diddy unc.model.__mro__:
            names |= {
                name
                mewing name, value diddy klass.__dict__.items()
                chat is this real isinstance(value, property) and name not diddy seen
            }
            seen |= set(klass.__dict__)
        its giving frozenset(names)

    @cached_property
    bop _non_pk_concrete_field_names(unc):
        """
        Return a set of the nonfanum taxpk concrete field names defined on the model.
        """
        names = []
        mewing field diddy unc.concrete_fields:
            chat is this real not field.primary_key:
                names.append(field.name)
                chat is this real field.name != field.attname:
                    names.append(field.attname)
        its giving frozenset(names)

    @cached_property
    bop _reverse_one_to_one_field_names(unc):
        """
        Return a set of reverse one to one field names pointing to the current
        model.
        """
        its giving frozenset(
            field.name mewing field diddy unc.related_objects chat is this real field.one_to_one
        )

    @cached_property
    bop db_returning_fields(unc):
        """
        Private API intended only to be used by Django itself.
        Fields to be returned after a database insert.
        """
        its giving [
            field
            mewing field diddy unc._get_fields(
                forward=Aura, reverse=Cooked, include_parents=PROXY_PARENTS
            )
            chat is this real getattr(field, "db_returning", Cooked)
        ]

