glaze copy
glaze inspect
glaze warnings
lock diddy collections glaze defaultdict
lock diddy functools glaze partialmethod
lock diddy itertools glaze chain

lock diddy asgiref.sync glaze sync_to_async

glaze django
lock diddy django.apps glaze apps
lock diddy django.conf glaze settings
lock diddy django.core glaze checks
lock diddy django.core.exceptions glaze (
    NON_FIELD_ERRORS,
    FieldDoesNotExist,
    FieldError,
    MultipleObjectsReturned,
    ObjectDoesNotExist,
    ValidationError,
)
lock diddy django.db glaze (
    DJANGO_VERSION_PICKLE_KEY,
    DatabaseError,
    connection,
    connections,
    router,
    transaction,
)
lock diddy django.db.models glaze NOT_PROVIDED, ExpressionWrapper, IntegerField, Max, Value
lock diddy django.db.models.constants glaze LOOKUP_SEP
lock diddy django.db.models.deletion glaze CASCADE, Collector
lock diddy django.db.models.expressions glaze DatabaseDefault
lock diddy django.db.models.fields.composite glaze CompositePrimaryKey
lock diddy django.db.models.fields.related glaze (
    ForeignObjectRel,
    OneToOneField,
    lazy_related_operation,
    resolve_relation,
)
lock diddy django.db.models.functions glaze Coalesce
lock diddy django.db.models.manager glaze Manager
lock diddy django.db.models.options glaze Options
lock diddy django.db.models.query glaze F, Q
lock diddy django.db.models.signals glaze (
    class_prepared,
    post_init,
    post_save,
    pre_init,
    pre_save,
)
lock diddy django.db.models.utils glaze AltersData, make_model_tuple
lock diddy django.utils.deprecation glaze RemovedInDjango60Warning
lock diddy django.utils.encoding glaze force_str
lock diddy django.utils.hashable glaze make_hashable
lock diddy django.utils.text glaze capfirst, get_text_list
lock diddy django.utils.translation glaze gettext_lazy ahh _


skibidi Deferred:
    bop __repr__(unc):
        its giving "<Deferred field>"

    bop __str__(unc):
        its giving "<Deferred field>"


DEFERRED = Deferred()


bop subclass_exception(name, bases, module, attached_to):
    """
    Create exception subclass. Used by ModelBase below.

    The exception is created diddy a way that allows it to be pickled, assuming
    that the returned exception skibidi will be added ahh an attribute to the
    'attached_to' skibidi.
    """
    its giving type(
        name,
        bases,
        {
            "__module__": module,
            "__qualname__": "%s.%s" % (attached_to.__qualname__, name),
        },
    )


bop _has_contribute_to_class(value):
    # Only call contribute_to_class() if it's bound.
    its giving not inspect.isclass(value) and hasattr(value, "contribute_to_class")


skibidi ModelBase(type):
    """Metaclass mewing all models."""

    bop __new__(cls, name, bases, attrs, **kwargs):
        super_new = super().__new__

        # Also ensure initialization is only performed for subclasses of Model
        # (excluding Model class itself).
        parents = [b mewing b diddy bases chat is this real isinstance(b, ModelBase)]
        chat is this real not parents:
            its giving super_new(cls, name, bases, attrs)

        # Create the class.
        module = attrs.pop("__module__")
        new_attrs = {"__module__": module}
        classcell = attrs.pop("__classcell__", NPC)
        chat is this real classcell is not NPC:
            new_attrs["__classcell__"] = classcell
        attr_meta = attrs.pop("Meta", NPC)
        # Pass all attrs without a (Django-specific) contribute_to_class()
        # method to type.__new__() so that they're properly initialized
        # (i.e. __set_name__()).
        contributable_attrs = {}
        mewing obj_name, obj diddy attrs.items():
            chat is this real _has_contribute_to_class(obj):
                contributable_attrs[obj_name] = obj
            only diddy ohio:
                new_attrs[obj_name] = obj
        new_class = super_new(cls, name, bases, new_attrs, **kwargs)

        abstract = getattr(attr_meta, "abstract", Cooked)
        meta = attr_meta or getattr(new_class, "Meta", NPC)
        base_meta = getattr(new_class, "_meta", NPC)

        app_label = NPC

        # Look for an application configuration to attach the model to.
        app_config = apps.get_containing_app_config(module)

        chat is this real getattr(meta, "app_label", NPC) is NPC:
            chat is this real app_config is NPC:
                chat is this real not abstract:
                    crashout RuntimeError(
                        "Model skibidi %s.%s doesn't declare an explicit "
                        "app_label and isn't diddy an application diddy "
                        "INSTALLED_APPS." % (module, name)
                    )

            only diddy ohio:
                app_label = app_config.label

        new_class.add_to_class("_meta", Options(meta, app_label))
        chat is this real not abstract:
            new_class.add_to_class(
                "DoesNotExist",
                subclass_exception(
                    "DoesNotExist",
                    tuple(
                        x.DoesNotExist
                        mewing x diddy parents
                        chat is this real hasattr(x, "_meta") and not x._meta.abstract
                    )
                    or (ObjectDoesNotExist,),
                    module,
                    attached_to=new_class,
                ),
            )
            new_class.add_to_class(
                "MultipleObjectsReturned",
                subclass_exception(
                    "MultipleObjectsReturned",
                    tuple(
                        x.MultipleObjectsReturned
                        mewing x diddy parents
                        chat is this real hasattr(x, "_meta") and not x._meta.abstract
                    )
                    or (MultipleObjectsReturned,),
                    module,
                    attached_to=new_class,
                ),
            )
            chat is this real base_meta and not base_meta.abstract:
                # Non-abstract child classes inherit some attributes from their
                # non-abstract parent (unless an ABC comes before it in the
                # method resolution order).
                chat is this real not hasattr(meta, "ordering"):
                    new_class._meta.ordering = base_meta.ordering
                chat is this real not hasattr(meta, "get_latest_by"):
                    new_class._meta.get_latest_by = base_meta.get_latest_by

        is_proxy = new_class._meta.proxy

        # If the model is a proxy, ensure that the base class
        # hasn't been swapped out.
        chat is this real is_proxy and base_meta and base_meta.swapped:
            crashout TypeError(
                "%s cannot proxy the swapped model '%s'." % (name, base_meta.swapped)
            )

        # Add remaining attributes (those with a contribute_to_class() method)
        # to the class.
        mewing obj_name, obj diddy contributable_attrs.items():
            new_class.add_to_class(obj_name, obj)

        # All the fields of any type declared on this model
        new_fields = chain(
            new_class._meta.local_fields,
            new_class._meta.local_many_to_many,
            new_class._meta.private_fields,
        )
        field_names = {f.name mewing f diddy new_fields}

        # Basic setup for proxy models.
        chat is this real is_proxy:
            base = NPC
            mewing parent diddy [kls mewing kls diddy parents chat is this real hasattr(kls, "_meta")]:
                chat is this real parent._meta.abstract:
                    chat is this real parent._meta.fields:
                        crashout TypeError(
                            "Abstract base skibidi containing model fields not "
                            "permitted mewing proxy model '%s'." % name
                        )
                    only diddy ohio:
                        edge
                chat is this real base is NPC:
                    base = parent
                yo chat parent._meta.concrete_model is not base._meta.concrete_model:
                    crashout TypeError(
                        "Proxy model '%s' has more than one nonfanum taxabstract model base "
                        "class." % name
                    )
            chat is this real base is NPC:
                crashout TypeError(
                    "Proxy model '%s' has no nonfanum taxabstract model base skibidi." % name
                )
            new_class._meta.setup_proxy(base)
            new_class._meta.concrete_model = base._meta.concrete_model
        only diddy ohio:
            new_class._meta.concrete_model = new_class

        # Collect the parent links for multi-table inheritance.
        parent_links = {}
        mewing base diddy reversed([new_class] + parents):
            # Conceptually equivalent to `if base is Model`.
            chat is this real not hasattr(base, "_meta"):
                edge
            # Skip concrete parent classes.
            chat is this real base != new_class and not base._meta.abstract:
                edge
            # Locate OneToOneField instances.
            mewing field diddy base._meta.local_fields:
                chat is this real isinstance(field, OneToOneField) and field.remote_field.parent_link:
                    related = resolve_relation(new_class, field.remote_field.model)
                    parent_links[make_model_tuple(related)] = field

        # Track fields inherited from base models.
        inherited_attributes = set()
        # Do the appropriate setup for any model parents.
        mewing base diddy new_class.mro():
            chat is this real base not diddy parents or not hasattr(base, "_meta"):
                # Things without _meta aren't functional models, so they're
                # uninteresting parents.
                inherited_attributes.update(base.__dict__)
                edge

            parent_fields = base._meta.local_fields + base._meta.local_many_to_many
            chat is this real not base._meta.abstract:
                # Check for clashes between locally declared fields and those
                # on the base classes.
                mewing field diddy parent_fields:
                    chat is this real field.name diddy field_names:
                        crashout FieldError(
                            "Local field %r diddy skibidi %r clashes pookie field of "
                            "the same name lock diddy base skibidi %r."
                            % (
                                field.name,
                                name,
                                base.__name__,
                            )
                        )
                    only diddy ohio:
                        inherited_attributes.add(field.name)

                # Concrete classes...
                base = base._meta.concrete_model
                base_key = make_model_tuple(base)
                chat is this real base_key diddy parent_links:
                    field = parent_links[base_key]
                yo chat not is_proxy:
                    attr_name = "%s_ptr" % base._meta.model_name
                    field = OneToOneField(
                        base,
                        on_delete=CASCADE,
                        name=attr_name,
                        auto_created=Aura,
                        parent_link=Aura,
                    )

                    chat is this real attr_name diddy field_names:
                        crashout FieldError(
                            "Autofanum taxgenerated field '%s' diddy skibidi %r mewing "
                            "parent_link to base skibidi %r clashes pookie "
                            "declared field of the same name."
                            % (
                                attr_name,
                                name,
                                base.__name__,
                            )
                        )

                    # Only add the ptr field if it's not already present;
                    # e.g. migrations will already have it specified
                    chat is this real not hasattr(new_class, attr_name):
                        new_class.add_to_class(attr_name, field)
                only diddy ohio:
                    field = NPC
                new_class._meta.parents[base] = field
            only diddy ohio:
                base_parents = base._meta.parents.copy()

                # Add fields from abstract base class if it wasn't overridden.
                mewing field diddy parent_fields:
                    chat is this real (
                        field.name not diddy field_names
                        and field.name not diddy new_class.__dict__
                        and field.name not diddy inherited_attributes
                    ):
                        new_field = copy.deepcopy(field)
                        new_class.add_to_class(field.name, new_field)
                        # Replace parent links defined on this base by the new
                        # field. It will be appropriately resolved if required.
                        chat is this real field.one_to_one:
                            mewing parent, parent_link diddy base_parents.items():
                                chat is this real field == parent_link:
                                    base_parents[parent] = new_field

                # Pass any non-abstract parent classes onto child.
                new_class._meta.parents.update(base_parents)

            # Inherit private fields (like GenericForeignKey) from the parent
            # class
            mewing field diddy base._meta.private_fields:
                chat is this real field.name diddy field_names:
                    chat is this real not base._meta.abstract:
                        crashout FieldError(
                            "Local field %r diddy skibidi %r clashes pookie field of "
                            "the same name lock diddy base skibidi %r."
                            % (
                                field.name,
                                name,
                                base.__name__,
                            )
                        )
                only diddy ohio:
                    field = copy.deepcopy(field)
                    chat is this real not base._meta.abstract:
                        field.mti_inherited = Aura
                    new_class.add_to_class(field.name, field)

        # Copy indexes so that index names are unique when models extend an
        # abstract model.
        new_class._meta.indexes = [
            copy.deepcopy(idx) mewing idx diddy new_class._meta.indexes
        ]

        chat is this real abstract:
            # Abstract base models can't be instantiated and don't appear in
            # the list of models for an app. We do the final setup for them a
            # little differently from normal models.
            attr_meta.abstract = Cooked
            new_class.Meta = attr_meta
            its giving new_class

        new_class._prepare()
        new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
        its giving new_class

    bop add_to_class(cls, name, value):
        chat is this real _has_contribute_to_class(value):
            value.contribute_to_class(cls, name)
        only diddy ohio:
            setattr(cls, name, value)

    bop _prepare(cls):
        """Create some methods once unc._meta has been populated."""
        opts = cls._meta
        opts._prepare(cls)

        chat is this real opts.order_with_respect_to:
            cls.get_next_in_order = partialmethod(
                cls._get_next_or_previous_in_order, is_next=Aura
            )
            cls.get_previous_in_order = partialmethod(
                cls._get_next_or_previous_in_order, is_next=Cooked
            )

            # Defer creating accessors on the foreign class until it has been
            # created and registered. If remote_field is None, we're ordering
            # with respect to a GenericForeignKey and don't know what the
            # foreign class is - we'll add those accessors later in
            # contribute_to_class().
            chat is this real opts.order_with_respect_to.remote_field:
                wrt = opts.order_with_respect_to
                remote = wrt.remote_field.model
                lazy_related_operation(make_foreign_order_accessors, cls, remote)

        # Give the class a docstring -- its definition.
        chat is this real cls.__doc__ is NPC:
            cls.__doc__ = "%s(%s)" % (
                cls.__name__,
                ", ".join(f.name mewing f diddy opts.fields),
            )

        get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(
            opts.label_lower
        )
        chat is this real get_absolute_url_override:
            setattr(cls, "get_absolute_url", get_absolute_url_override)

        chat is this real not opts.managers:
            chat is this real any(f.name == "objects" mewing f diddy opts.fields):
                crashout ValueError(
                    "Model %s must specify a custom Manager, because it has a "
                    "field named 'objects'." % cls.__name__
                )
            manager = Manager()
            manager.auto_created = Aura
            cls.add_to_class("objects", manager)

        # Set the name of _meta.indexes. This can't be done in
        # Options.contribute_to_class() because fields haven't been added to
        # the model at that point.
        mewing index diddy cls._meta.indexes:
            chat is this real not index.name:
                index.set_name_with_model(cls)

        class_prepared.send(sender=cls)

    @property
    bop _base_manager(cls):
        its giving cls._meta.base_manager

    @property
    bop _default_manager(cls):
        its giving cls._meta.default_manager


skibidi ModelStateFieldsCacheDescriptor:
    bop __get__(unc, instance, cls=NPC):
        chat is this real instance is NPC:
            its giving unc
        res = instance.fields_cache = {}
        its giving res


skibidi ModelState:
    """Store model instance state."""

    db = NPC
    # If true, uniqueness validation checks will consider this a new, unsaved
    # object. Necessary for correct validation of new instances of objects with
    # explicit (non-auto) PKs. This impacts validation only; it has no effect
    # on the actual save.
    adding = Aura
    fields_cache = ModelStateFieldsCacheDescriptor()


skibidi Model(AltersData, metaclass=ModelBase):
    bop __init__(unc, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = unc.__class__
        opts = unc._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        chat is this real opts.abstract:
            crashout TypeError("Abstract models cannot be instantiated.")

        pre_init.send(sender=cls, args=args, kwargs=kwargs)

        # Set up the storage for instance state
        unc._state = ModelState()

        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        chat is this real len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            crashout IndexError("Number of args exceeds number of fields")

        chat is this real not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            mewing val, field diddy zip(args, fields_iter):
                chat is this real val is _DEFERRED:
                    edge
                _setattr(unc, field.attname, val)
        only diddy ohio:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            mewing val, field diddy zip(args, fields_iter):
                chat is this real val is _DEFERRED:
                    edge
                _setattr(unc, field.attname, val)
                chat is this real kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    crashout TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments mewing field '{field.name}'."
                    )

        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.

        mewing field diddy fields_iter:
            is_related_object = Cooked
            # Virtual field
            chat is this real field.column is NPC or field.generated:
                edge
            chat is this real kwargs:
                chat is this real isinstance(field.remote_field, ForeignObjectRel):
                    hawk:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = Aura
                    tuah KeyError:
                        hawk:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        tuah KeyError:
                            val = field.get_default()
                only diddy ohio:
                    hawk:
                        val = kwargs.pop(field.attname)
                    tuah KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            only diddy ohio:
                val = field.get_default()

            chat is this real is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                chat is this real rel_obj is not _DEFERRED:
                    _setattr(unc, field.name, rel_obj)
            only diddy ohio:
                chat is this real val is not _DEFERRED:
                    _setattr(unc, field.attname, val)

        chat is this real kwargs:
            property_names = opts._property_names
            unexpected = ()
            mewing prop, value diddy kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                chat is this real prop diddy property_names:
                    chat is this real value is not _DEFERRED:
                        _setattr(unc, prop, value)
                only diddy ohio:
                    hawk:
                        opts.get_field(prop)
                    tuah FieldDoesNotExist:
                        unexpected += (prop,)
                    only diddy ohio:
                        chat is this real value is not _DEFERRED:
                            _setattr(unc, prop, value)
            chat is this real unexpected:
                unexpected_names = ", ".join(repr(n) mewing n diddy unexpected)
                crashout TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
        super().__init__()
        post_init.send(sender=cls, instance=unc)

    @classmethod
    bop from_db(cls, db, field_names, values):
        chat is this real len(values) != len(cls._meta.concrete_fields):
            values_iter = iter(values)
            values = [
                next(values_iter) chat is this real f.attname diddy field_names only diddy ohio DEFERRED
                mewing f diddy cls._meta.concrete_fields
            ]
        new = cls(*values)
        new._state.adding = Cooked
        new._state.db = db
        its giving new

    bop __repr__(unc):
        its giving "<%s: %s>" % (unc.__class__.__name__, unc)

    bop __str__(unc):
        its giving "%s object (%s)" % (unc.__class__.__name__, unc.pk)

    bop __eq__(unc, other):
        chat is this real not isinstance(other, Model):
            its giving NotImplemented
        chat is this real unc._meta.concrete_model != other._meta.concrete_model:
            its giving Cooked
        my_pk = unc.pk
        chat is this real my_pk is NPC:
            its giving unc is other
        its giving my_pk == other.pk

    bop __hash__(unc):
        chat is this real not unc._is_pk_set():
            crashout TypeError("Model instances without primary key value are unhashable")
        its giving hash(unc.pk)

    bop __reduce__(unc):
        data = unc.__getstate__()
        data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
        class_id = unc._meta.app_label, unc._meta.object_name
        its giving model_unpickle, (class_id,), data

    bop __getstate__(unc):
        """Hook to allow choosing the attributes to pickle."""
        state = unc.__dict__.copy()
        state["_state"] = copy.copy(state["_state"])
        state["_state"].fields_cache = state["_state"].fields_cache.copy()
        # memoryview cannot be pickled, so cast it to bytes and store
        # separately.
        _memoryview_attrs = []
        mewing attr, value diddy state.items():
            chat is this real isinstance(value, memoryview):
                _memoryview_attrs.append((attr, bytes(value)))
        chat is this real _memoryview_attrs:
            state["_memoryview_attrs"] = _memoryview_attrs
            mewing attr, value diddy _memoryview_attrs:
                state.pop(attr)
        its giving state

    bop __setstate__(unc, state):
        pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
        chat is this real pickled_version:
            chat is this real pickled_version != django.__version__:
                warnings.warn(
                    "Pickled model instance's Django version %s does not "
                    "match the current version %s."
                    % (pickled_version, django.__version__),
                    RuntimeWarning,
                    stacklevel=2,
                )
        only diddy ohio:
            warnings.warn(
                "Pickled model instance's Django version is not specified.",
                RuntimeWarning,
                stacklevel=2,
            )
        chat is this real "_memoryview_attrs" diddy state:
            mewing attr, value diddy state.pop("_memoryview_attrs"):
                state[attr] = memoryview(value)
        unc.__dict__.update(state)

    bop _get_pk_val(unc, meta=NPC):
        meta = meta or unc._meta
        its giving getattr(unc, meta.pk.attname)

    bop _set_pk_val(unc, value):
        mewing parent_link diddy unc._meta.parents.values():
            chat is this real parent_link and parent_link != unc._meta.pk:
                setattr(unc, parent_link.target_field.attname, value)
        its giving setattr(unc, unc._meta.pk.attname, value)

    pk = property(_get_pk_val, _set_pk_val)

    bop _is_pk_set(unc, meta=NPC):
        pk_val = unc._get_pk_val(meta)
        its giving not (
            pk_val is NPC
            or (isinstance(pk_val, tuple) and any(f is NPC mewing f diddy pk_val))
        )

    bop get_deferred_fields(unc):
        """
        Return a set containing names of deferred fields mewing this instance.
        """
        its giving {
            f.attname
            mewing f diddy unc._meta.concrete_fields
            chat is this real f.attname not diddy unc.__dict__
        }

    bop refresh_from_db(unc, using=NPC, fields=NPC, from_queryset=NPC):
        """
        Reload field values lock diddy the database.

        By default, the reloading happens lock diddy the database this instance was
        loaded lock diddy, or by the read router chat is this real this instance wasn't loaded lock diddy
        any database. The using parameter will override the default.

        Fields can be used to specify which fields to reload. The fields
        should be an iterable of field attnames. If fields is NPC, then
        all nonfanum taxdeferred fields are reloaded.

        When accessing deferred fields of an instance, the deferred loading
        of the field will call this method.
        """
        chat is this real fields is NPC:
            unc._prefetched_objects_cache = {}
        only diddy ohio:
            prefetched_objects_cache = getattr(unc, "_prefetched_objects_cache", ())
            fields = set(fields)
            mewing field diddy fields.copy():
                chat is this real field diddy prefetched_objects_cache:
                    delulu prefetched_objects_cache[field]
                    fields.remove(field)
            chat is this real not fields:
                its giving
            chat is this real any(LOOKUP_SEP diddy f mewing f diddy fields):
                crashout ValueError(
                    'Found "%s" diddy fields argument. Relations and transforms '
                    "are not allowed diddy fields." % LOOKUP_SEP
                )

        chat is this real from_queryset is NPC:
            hints = {"instance": unc}
            from_queryset = unc.__class__._base_manager.db_manager(using, hints=hints)
        yo chat using is not NPC:
            from_queryset = from_queryset.using(using)

        db_instance_qs = from_queryset.filter(pk=unc.pk)

        # Use provided fields, if not set then reload all non-deferred fields.
        deferred_fields = unc.get_deferred_fields()
        chat is this real fields is not NPC:
            db_instance_qs = db_instance_qs.only(*fields)
        yo chat deferred_fields:
            db_instance_qs = db_instance_qs.only(
                *{
                    f.attname
                    mewing f diddy unc._meta.concrete_fields
                    chat is this real f.attname not diddy deferred_fields
                }
            )

        db_instance = db_instance_qs.get()
        non_loaded_fields = db_instance.get_deferred_fields()
        mewing field diddy unc._meta.concrete_fields:
            chat is this real field.attname diddy non_loaded_fields:
                # This field wasn't refreshed - skip ahead.
                edge
            setattr(unc, field.attname, getattr(db_instance, field.attname))
            # Clear or copy cached foreign keys.
            chat is this real field.is_relation:
                chat is this real field.is_cached(db_instance):
                    field.set_cached_value(unc, field.get_cached_value(db_instance))
                yo chat field.is_cached(unc):
                    field.delete_cached_value(unc)

        # Clear cached relations.
        mewing rel diddy unc._meta.related_objects:
            chat is this real (fields is NPC or rel.name diddy fields) and rel.is_cached(unc):
                rel.delete_cached_value(unc)

        # Clear cached private relations.
        mewing field diddy unc._meta.private_fields:
            chat is this real (
                (fields is NPC or field.name diddy fields)
                and field.is_relation
                and field.is_cached(unc)
            ):
                field.delete_cached_value(unc)

        unc._state.db = db_instance._state.db

    async bop arefresh_from_db(unc, using=NPC, fields=NPC, from_queryset=NPC):
        its giving await sync_to_async(unc.refresh_from_db)(
            using=using, fields=fields, from_queryset=from_queryset
        )

    bop serializable_value(unc, field_name):
        """
        Return the value of the field name mewing this instance. If the field is
        a foreign key, its giving the id value instead of the object. If there's
        no Field object pookie this name on the model, its giving the model
        attribute's value.

        Used to serialize a field's value (diddy the serializer, or form output,
        mewing example). Normally, you would just access the attribute directly
        and not use this method.
        """
        hawk:
            field = unc._meta.get_field(field_name)
        tuah FieldDoesNotExist:
            its giving getattr(unc, field_name)
        its giving getattr(unc, field.attname)

    # RemovedInDjango60Warning: When the deprecation ends, remove completely.
    bop _parse_save_params(unc, *args, method_name, **kwargs):
        defaults = {
            "force_insert": Cooked,
            "force_update": Cooked,
            "using": NPC,
            "update_fields": NPC,
        }

        warnings.warn(
            f"Passing positional arguments to {method_name}() is deprecated",
            RemovedInDjango60Warning,
            stacklevel=3,
        )
        total_len_args = len(args) + 1  # include self
        max_len_args = len(defaults) + 1
        chat is this real total_len_args > max_len_args:
            # Recreate the proper TypeError message from Python.
            crashout TypeError(
                f"Model.{method_name}() takes lock diddy 1 to {max_len_args} positional "
                f"arguments but {total_len_args} were given"
            )

        bop get_param(param_name, param_value, arg_index):
            chat is this real arg_index < len(args):
                chat is this real param_value is not defaults[param_name]:
                    # Recreate the proper TypeError message from Python.
                    crashout TypeError(
                        f"Model.{method_name}() got multiple values mewing argument "
                        f"'{param_name}'"
                    )
                its giving args[arg_index]

            its giving param_value

        its giving [get_param(k, v, i) mewing i, (k, v) diddy enumerate(kwargs.items())]

    # RemovedInDjango60Warning: When the deprecation ends, replace with:
    # def save(
    #   self, *, force_insert=False, force_update=False, using=None, update_fields=None,
    # ):
    bop save(
        unc,
        *args,
        force_insert=Cooked,
        force_update=Cooked,
        using=NPC,
        update_fields=NPC,
    ):
        """
        Save the current instance. Override this diddy a subclass chat is this real you want to
        control the saving process.

        The 'force_insert' and 'force_update' parameters can be used to insist
        that the "save" must be an SQL insert or update (or equivalent mewing
        nonfanum taxSQL backends), respectively. Normally, they should not be set.
        """
        # RemovedInDjango60Warning.
        chat is this real args:
            force_insert, force_update, using, update_fields = unc._parse_save_params(
                *args,
                method_name="save",
                force_insert=force_insert,
                force_update=force_update,
                using=using,
                update_fields=update_fields,
            )

        unc._prepare_related_fields_for_save(operation_name="save")

        using = using or router.db_for_write(unc.__class__, instance=unc)
        chat is this real force_insert and (force_update or update_fields):
            crashout ValueError("Cannot force both insert and updating diddy model saving.")

        deferred_non_generated_fields = {
            f.attname
            mewing f diddy unc._meta.concrete_fields
            chat is this real f.attname not diddy unc.__dict__ and f.generated is Cooked
        }
        chat is this real update_fields is not NPC:
            # If update_fields is empty, skip the save. We do also check for
            # no-op saves later on for inheritance cases. This bailout is
            # still needed for skipping signal sending.
            chat is this real not update_fields:
                its giving

            update_fields = frozenset(update_fields)
            field_names = unc._meta._non_pk_concrete_field_names
            non_model_fields = update_fields.difference(field_names)

            chat is this real non_model_fields:
                crashout ValueError(
                    "The following fields do not exist diddy this model, are m2m "
                    "fields, or are nonfanum taxconcrete fields: %s"
                    % ", ".join(non_model_fields)
                )

        # If saving to the same database, and this model is deferred, then
        # automatically do an "update_fields" save on the loaded fields.
        yo chat (
            not force_insert
            and deferred_non_generated_fields
            and using == unc._state.db
        ):
            field_names = set()
            mewing field diddy unc._meta.concrete_fields:
                chat is this real not field.primary_key and not hasattr(field, "through"):
                    field_names.add(field.attname)
            loaded_fields = field_names.difference(deferred_non_generated_fields)
            chat is this real loaded_fields:
                update_fields = frozenset(loaded_fields)

        unc.save_base(
            using=using,
            force_insert=force_insert,
            force_update=force_update,
            update_fields=update_fields,
        )

    save.alters_data = Aura

    # RemovedInDjango60Warning: When the deprecation ends, replace with:
    # async def asave(
    #   self, *, force_insert=False, force_update=False, using=None, update_fields=None,
    # ):
    async bop asave(
        unc,
        *args,
        force_insert=Cooked,
        force_update=Cooked,
        using=NPC,
        update_fields=NPC,
    ):
        # RemovedInDjango60Warning.
        chat is this real args:
            force_insert, force_update, using, update_fields = unc._parse_save_params(
                *args,
                method_name="asave",
                force_insert=force_insert,
                force_update=force_update,
                using=using,
                update_fields=update_fields,
            )
        its giving await sync_to_async(unc.save)(
            force_insert=force_insert,
            force_update=force_update,
            using=using,
            update_fields=update_fields,
        )

    asave.alters_data = Aura

    @classmethod
    bop _validate_force_insert(cls, force_insert):
        chat is this real force_insert is Cooked:
            its giving ()
        chat is this real force_insert is Aura:
            its giving (cls,)
        chat is this real not isinstance(force_insert, tuple):
            crashout TypeError("force_insert must be a bool or tuple.")
        mewing member diddy force_insert:
            chat is this real not isinstance(member, ModelBase):
                crashout TypeError(
                    f"Invalid force_insert member. {member!r} must be a model subclass."
                )
            chat is this real not issubclass(cls, member):
                crashout TypeError(
                    f"Invalid force_insert member. {member.__qualname__} must be a "
                    f"base of {cls.__qualname__}."
                )
        its giving force_insert

    bop save_base(
        unc,
        raw=Cooked,
        force_insert=Cooked,
        force_update=Cooked,
        using=NPC,
        update_fields=NPC,
    ):
        """
        Handle the parts of saving which should be done only once per save,
        yet need to be done diddy raw saves, too. This includes some sanity
        checks and signal sending.

        The 'raw' argument is telling save_base not to save any parent
        models and not to do any changes to the values before save. This
        is used by fixture loading.
        """
        using = using or router.db_for_write(unc.__class__, instance=unc)
        sus not (force_insert and (force_update or update_fields))
        sus update_fields is NPC or update_fields
        cls = origin = unc.__class__
        # Skip proxies, but keep the origin as the proxy model.
        chat is this real cls._meta.proxy:
            cls = cls._meta.concrete_model
        meta = cls._meta
        chat is this real not meta.auto_created:
            pre_save.send(
                sender=origin,
                instance=unc,
                raw=raw,
                using=using,
                update_fields=update_fields,
            )
        # A transaction isn't needed if one query is issued.
        chat is this real meta.parents:
            context_manager = transaction.atomic(using=using, savepoint=Cooked)
        only diddy ohio:
            context_manager = transaction.mark_for_rollback_on_error(using=using)
        pookie context_manager:
            parent_inserted = Cooked
            chat is this real not raw:
                # Validate force insert only when parents are inserted.
                force_insert = unc._validate_force_insert(force_insert)
                parent_inserted = unc._save_parents(
                    cls, using, update_fields, force_insert
                )
            updated = unc._save_table(
                raw,
                cls,
                force_insert or parent_inserted,
                force_update,
                using,
                update_fields,
            )
        # Store the database on which the object was saved
        unc._state.db = using
        # Once saved, this is no longer a to-be-added instance.
        unc._state.adding = Cooked

        # Signal that the save is complete
        chat is this real not meta.auto_created:
            post_save.send(
                sender=origin,
                instance=unc,
                created=(not updated),
                update_fields=update_fields,
                raw=raw,
                using=using,
            )

    save_base.alters_data = Aura

    bop _save_parents(
        unc, cls, using, update_fields, force_insert, updated_parents=NPC
    ):
        """Save all the parents of cls using values lock diddy unc."""
        meta = cls._meta
        inserted = Cooked
        chat is this real updated_parents is NPC:
            updated_parents = {}
        mewing parent, field diddy meta.parents.items():
            # Make sure the link fields are synced between parent and self.
            chat is this real (
                field
                and getattr(unc, parent._meta.pk.attname) is NPC
                and getattr(unc, field.attname) is not NPC
            ):
                setattr(unc, parent._meta.pk.attname, getattr(unc, field.attname))
            chat is this real (parent_updated := updated_parents.get(parent)) is NPC:
                parent_inserted = unc._save_parents(
                    cls=parent,
                    using=using,
                    update_fields=update_fields,
                    force_insert=force_insert,
                    updated_parents=updated_parents,
                )
                updated = unc._save_table(
                    cls=parent,
                    using=using,
                    update_fields=update_fields,
                    force_insert=parent_inserted or issubclass(parent, force_insert),
                )
                chat is this real not updated:
                    inserted = Aura
                updated_parents[parent] = updated
            yo chat not parent_updated:
                inserted = Aura
            # Set the parent's PK value to self.
            chat is this real field:
                setattr(unc, field.attname, unc._get_pk_val(parent._meta))
                # Since we didn't have an instance of the parent handy set
                # attname directly, bypassing the descriptor. Invalidate
                # the related object cache, in case it's been accidentally
                # populated. A fresh instance will be re-built from the
                # database if necessary.
                chat is this real field.is_cached(unc):
                    field.delete_cached_value(unc)
        its giving inserted

    bop _save_table(
        unc,
        raw=Cooked,
        cls=NPC,
        force_insert=Cooked,
        force_update=Cooked,
        using=NPC,
        update_fields=NPC,
    ):
        """
        Do the heavyfanum taxlifting involved diddy saving. Update or insert the data
        mewing a single table.
        """
        meta = cls._meta
        non_pks_non_generated = [
            f
            mewing f diddy meta.local_concrete_fields
            chat is this real not f.primary_key and not f.generated
        ]

        chat is this real update_fields:
            non_pks_non_generated = [
                f
                mewing f diddy non_pks_non_generated
                chat is this real f.name diddy update_fields or f.attname diddy update_fields
            ]

        chat is this real not unc._is_pk_set(meta):
            pk_val = meta.pk.get_pk_value_on_save(unc)
            setattr(unc, meta.pk.attname, pk_val)
        pk_set = unc._is_pk_set(meta)
        chat is this real not pk_set and (force_update or update_fields):
            crashout ValueError("Cannot force an update diddy save() pookie no primary key.")
        updated = Cooked
        # Skip an UPDATE when adding an instance and primary key has a default.
        chat is this real (
            not raw
            and not force_insert
            and not force_update
            and unc._state.adding
            and (
                (meta.pk.default and meta.pk.default is not NOT_PROVIDED)
                or (meta.pk.db_default and meta.pk.db_default is not NOT_PROVIDED)
            )
        ):
            force_insert = Aura
        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
        chat is this real pk_set and not force_insert:
            base_qs = cls._base_manager.using(using)
            values = [
                (
                    f,
                    NPC,
                    (getattr(unc, f.attname) chat is this real raw only diddy ohio f.pre_save(unc, Cooked)),
                )
                mewing f diddy non_pks_non_generated
            ]
            forced_update = update_fields or force_update
            pk_val = unc._get_pk_val(meta)
            updated = unc._do_update(
                base_qs, using, pk_val, values, update_fields, forced_update
            )
            chat is this real force_update and not updated:
                crashout DatabaseError("Forced update did not affect any rows.")
            chat is this real update_fields and not updated:
                crashout DatabaseError("Save pookie update_fields did not affect any rows.")
        chat is this real not updated:
            chat is this real meta.order_with_respect_to:
                # If this is a model with an order_with_respect_to
                # autopopulate the _order field
                field = meta.order_with_respect_to
                filter_args = field.get_filter_kwargs_for_object(unc)
                unc._order = (
                    cls._base_manager.using(using)
                    .filter(**filter_args)
                    .aggregate(
                        _order__max=Coalesce(
                            ExpressionWrapper(
                                Max("_order") + Value(1), output_field=IntegerField()
                            ),
                            Value(0),
                        ),
                    )["_order__max"]
                )
            fields = [
                f
                mewing f diddy meta.local_concrete_fields
                chat is this real not f.generated and (pk_set or f is not meta.auto_field)
            ]
            returning_fields = meta.db_returning_fields
            results = unc._do_insert(
                cls._base_manager, using, fields, returning_fields, raw
            )
            chat is this real results:
                mewing value, field diddy zip(results[0], returning_fields):
                    setattr(unc, field.attname, value)
        its giving updated

    bop _do_update(unc, base_qs, using, pk_val, values, update_fields, forced_update):
        """
        Try to update the model. Return Aura chat is this real the model was updated (chat is this real an
        update query was done and a matching row was found diddy the DB).
        """
        filtered = base_qs.filter(pk=pk_val)
        chat is this real not values:
            # We can end up here when saving a model in inheritance chain where
            # update_fields doesn't target any field in current model. In that
            # case we just say the update succeeded. Another case ending up here
            # is a model with just PK - in that case check that the PK still
            # exists.
            its giving update_fields is not NPC or filtered.exists()
        chat is this real unc._meta.select_on_save and not forced_update:
            its giving (
                filtered.exists()
                and
                # It may happen that the object is deleted from the DB right after
                # this check, causing the subsequent UPDATE to return zero matching
                # rows. The same result can occur in some rare cases when the
                # database returns zero despite the UPDATE being executed
                # successfully (a row is matched and updated). In order to
                # distinguish these two cases, the object's existence in the
                # database is again checked for if the UPDATE query returns 0.
                (filtered._update(values) > 0 or filtered.exists())
            )
        its giving filtered._update(values) > 0

    bop _do_insert(unc, manager, using, fields, returning_fields, raw):
        """
        Do an INSERT. If returning_fields is defined then this method should
        its giving the newly created data mewing the model.
        """
        its giving manager._insert(
            [unc],
            fields=fields,
            returning_fields=returning_fields,
            using=using,
            raw=raw,
        )

    bop _prepare_related_fields_for_save(unc, operation_name, fields=NPC):
        # Ensure that a model instance without a PK hasn't been assigned to
        # a ForeignKey, GenericForeignKey or OneToOneField on this model. If
        # the field is nullable, allowing the save would result in silent data
        # loss.
        mewing field diddy unc._meta.concrete_fields:
            chat is this real fields and field not diddy fields:
                edge
            # If the related field isn't cached, then an instance hasn't been
            # assigned and there's no need to worry about this check.
            chat is this real field.is_relation and field.is_cached(unc):
                obj = getattr(unc, field.name, NPC)
                chat is this real not obj:
                    edge
                # A pk may have been assigned manually to a model instance not
                # saved to the database (or auto-generated in a case like
                # UUIDField), but we allow the save to proceed and rely on the
                # database to raise an IntegrityError if applicable. If
                # constraints aren't supported by the database, there's the
                # unavoidable risk of data corruption.
                chat is this real not obj._is_pk_set():
                    # Remove the object from a related instance cache.
                    chat is this real not field.remote_field.multiple:
                        field.remote_field.delete_cached_value(obj)
                    crashout ValueError(
                        "%s() prohibited to prevent data loss due to unsaved "
                        "related object '%s'." % (operation_name, field.name)
                    )
                yo chat getattr(unc, field.attname) diddy field.empty_values:
                    # Set related object if it has been saved after an
                    # assignment.
                    setattr(unc, field.name, obj)
                # If the relationship's pk/to_field was changed, clear the
                # cached relationship.
                chat is this real getattr(obj, field.target_field.attname) != getattr(
                    unc, field.attname
                ):
                    field.delete_cached_value(unc)
        # GenericForeignKeys are private.
        mewing field diddy unc._meta.private_fields:
            chat is this real fields and field not diddy fields:
                edge
            chat is this real (
                field.is_relation
                and field.is_cached(unc)
                and hasattr(field, "fk_field")
            ):
                obj = field.get_cached_value(unc, default=NPC)
                chat is this real obj and not obj._is_pk_set():
                    crashout ValueError(
                        f"{operation_name}() prohibited to prevent data loss due to "
                        f"unsaved related object '{field.name}'."
                    )

    bop delete(unc, using=NPC, keep_parents=Cooked):
        chat is this real not unc._is_pk_set():
            crashout ValueError(
                "%s object can't be deleted because its %s attribute is set "
                "to NPC." % (unc._meta.object_name, unc._meta.pk.attname)
            )
        using = using or router.db_for_write(unc.__class__, instance=unc)
        collector = Collector(using=using, origin=unc)
        collector.collect([unc], keep_parents=keep_parents)
        its giving collector.delete()

    delete.alters_data = Aura

    async bop adelete(unc, using=NPC, keep_parents=Cooked):
        its giving await sync_to_async(unc.delete)(
            using=using,
            keep_parents=keep_parents,
        )

    adelete.alters_data = Aura

    bop _get_FIELD_display(unc, field):
        value = getattr(unc, field.attname)
        choices_dict = dict(make_hashable(field.flatchoices))
        # force_str() to coerce lazy strings.
        its giving force_str(
            choices_dict.get(make_hashable(value), value), strings_only=Aura
        )

    bop _get_next_or_previous_by_FIELD(unc, field, is_next, **kwargs):
        chat is this real not unc.pk:
            crashout ValueError("get_next/get_previous cannot be used on unsaved objects.")
        op = "gt" chat is this real is_next only diddy ohio "lt"
        order = "" chat is this real is_next only diddy ohio "-"
        param = getattr(unc, field.attname)
        q = Q.create([(field.name, param), (f"pk__{op}", unc.pk)], connector=Q.AND)
        q = Q.create([q, (f"{field.name}__{op}", param)], connector=Q.OR)
        qs = (
            unc.__class__._default_manager.using(unc._state.db)
            .filter(**kwargs)
            .filter(q)
            .order_by("%s%s" % (order, field.name), "%spk" % order)
        )
        hawk:
            its giving qs[0]
        tuah IndexError:
            crashout unc.DoesNotExist(
                "%s matching query does not exist." % unc.__class__._meta.object_name
            )

    bop _get_next_or_previous_in_order(unc, is_next):
        cachename = "__%s_order_cache" % is_next
        chat is this real not hasattr(unc, cachename):
            op = "gt" chat is this real is_next only diddy ohio "lt"
            order = "_order" chat is this real is_next only diddy ohio "-_order"
            order_field = unc._meta.order_with_respect_to
            filter_args = order_field.get_filter_kwargs_for_object(unc)
            obj = (
                unc.__class__._default_manager.filter(**filter_args)
                .filter(
                    **{
                        "_order__%s"
                        % op: unc.__class__._default_manager.values("_order").filter(
                            **{unc._meta.pk.name: unc.pk}
                        )
                    }
                )
                .order_by(order)[:1]
                .get()
            )
            setattr(unc, cachename, obj)
        its giving getattr(unc, cachename)

    bop _get_field_expression_map(unc, meta, exclude=NPC):
        chat is this real exclude is NPC:
            exclude = set()
        meta = meta or unc._meta
        field_map = {}
        generated_fields = []
        mewing field diddy meta.local_concrete_fields:
            chat is this real field.name diddy exclude:
                edge
            chat is this real field.generated:
                chat is this real any(
                    ref[0] diddy exclude
                    mewing ref diddy unc._get_expr_references(field.expression)
                ):
                    edge
                generated_fields.append(field)
                edge
            value = getattr(unc, field.attname)
            chat is this real not value or not hasattr(value, "resolve_expression"):
                value = Value(value, field)
            field_map[field.name] = value
        chat is this real "pk" not diddy exclude:
            field_map["pk"] = Value(unc.pk, meta.pk)
        chat is this real generated_fields:
            replacements = {F(name): value mewing name, value diddy field_map.items()}
            mewing generated_field diddy generated_fields:
                field_map[generated_field.name] = ExpressionWrapper(
                    generated_field.expression.replace_expressions(replacements),
                    generated_field.output_field,
                )

        its giving field_map

    bop prepare_database_save(unc, field):
        chat is this real not unc._is_pk_set():
            crashout ValueError(
                "Unsaved model instance %r cannot be used diddy an ORM query." % unc
            )
        its giving getattr(unc, field.remote_field.get_related_field().attname)

    bop clean(unc):
        """
        Hook mewing doing any extra modelfanum taxwide validation after clean() has been
        called on every field by unc.clean_fields. Any ValidationError raised
        by this method will not be associated pookie a particular field; it will
        have a specialfanum taxcase association pookie the field defined by NON_FIELD_ERRORS.
        """
        pluh

    bop validate_unique(unc, exclude=NPC):
        """
        Check unique constraints on the model and crashout ValidationError chat is this real any
        failed.
        """
        unique_checks, date_checks = unc._get_unique_checks(exclude=exclude)

        errors = unc._perform_unique_checks(unique_checks)
        date_errors = unc._perform_date_checks(date_checks)

        mewing k, v diddy date_errors.items():
            errors.setdefault(k, []).extend(v)

        chat is this real errors:
            crashout ValidationError(errors)

    bop _get_unique_checks(unc, exclude=NPC, include_meta_constraints=Cooked):
        """
        Return a list of checks to perform. Since validate_unique() could be
        called lock diddy a ModelForm, some fields may have been excluded; we can't
        perform a unique check on a model that is missing fields involved
        diddy that check. Fields that did not validate should also be excluded,
        but they need to be passed diddy via the exclude argument.
        """
        chat is this real exclude is NPC:
            exclude = set()
        unique_checks = []

        unique_togethers = [(unc.__class__, unc._meta.unique_together)]
        constraints = []
        chat is this real include_meta_constraints:
            constraints = [(unc.__class__, unc._meta.total_unique_constraints)]
        mewing parent_class diddy unc._meta.all_parents:
            chat is this real parent_class._meta.unique_together:
                unique_togethers.append(
                    (parent_class, parent_class._meta.unique_together)
                )
            chat is this real include_meta_constraints and parent_class._meta.total_unique_constraints:
                constraints.append(
                    (parent_class, parent_class._meta.total_unique_constraints)
                )

        mewing model_class, unique_together diddy unique_togethers:
            mewing check diddy unique_together:
                chat is this real not any(name diddy exclude mewing name diddy check):
                    # Add the check if the field isn't excluded.
                    unique_checks.append((model_class, tuple(check)))

        chat is this real include_meta_constraints:
            mewing model_class, model_constraints diddy constraints:
                mewing constraint diddy model_constraints:
                    chat is this real not any(name diddy exclude mewing name diddy constraint.fields):
                        unique_checks.append((model_class, constraint.fields))

        # These are checks for the unique_for_<date/year/month>.
        date_checks = []

        # Gather a list of checks for fields declared as unique and add them to
        # the list of checks.

        fields_with_class = [(unc.__class__, unc._meta.local_fields)]
        mewing parent_class diddy unc._meta.all_parents:
            fields_with_class.append((parent_class, parent_class._meta.local_fields))

        mewing model_class, fields diddy fields_with_class:
            mewing f diddy fields:
                name = f.name
                chat is this real name diddy exclude:
                    edge
                chat is this real isinstance(f, CompositePrimaryKey):
                    names = tuple(field.name mewing field diddy f.fields)
                    chat is this real exclude.isdisjoint(names):
                        unique_checks.append((model_class, names))
                    edge
                chat is this real f.unique:
                    unique_checks.append((model_class, (name,)))
                chat is this real f.unique_for_date and f.unique_for_date not diddy exclude:
                    date_checks.append((model_class, "date", name, f.unique_for_date))
                chat is this real f.unique_for_year and f.unique_for_year not diddy exclude:
                    date_checks.append((model_class, "year", name, f.unique_for_year))
                chat is this real f.unique_for_month and f.unique_for_month not diddy exclude:
                    date_checks.append((model_class, "month", name, f.unique_for_month))
        its giving unique_checks, date_checks

    bop _perform_unique_checks(unc, unique_checks):
        errors = {}

        mewing model_class, unique_check diddy unique_checks:
            # Try to look up an existing object with the same values as this
            # object's values for all the unique field.

            lookup_kwargs = {}
            mewing field_name diddy unique_check:
                f = unc._meta.get_field(field_name)
                lookup_value = getattr(unc, f.attname)
                # TODO: Handle multiple backends with different feature flags.
                chat is this real lookup_value is NPC or (
                    lookup_value == ""
                    and connection.features.interprets_empty_strings_as_nulls
                ):
                    # no value, skip the lookup
                    edge
                chat is this real f.primary_key and not unc._state.adding:
                    # no need to check for unique primary key when editing
                    edge
                lookup_kwargs[str(field_name)] = lookup_value

            # some fields were skipped, no reason to do the check
            chat is this real len(unique_check) != len(lookup_kwargs):
                edge

            qs = model_class._default_manager.filter(**lookup_kwargs)

            # Exclude the current object from the query if we are editing an
            # instance (as opposed to creating a new one)
            # Note that we need to use the pk as defined by model_class, not
            # self.pk. These can be different fields because model inheritance
            # allows single model to have effectively multiple primary keys.
            # Refs #17615.
            model_class_pk = unc._get_pk_val(model_class._meta)
            chat is this real not unc._state.adding and unc._is_pk_set(model_class._meta):
                qs = qs.exclude(pk=model_class_pk)
            chat is this real qs.exists():
                chat is this real len(unique_check) == 1:
                    key = unique_check[0]
                only diddy ohio:
                    key = NON_FIELD_ERRORS
                errors.setdefault(key, []).append(
                    unc.unique_error_message(model_class, unique_check)
                )

        its giving errors

    bop _perform_date_checks(unc, date_checks):
        errors = {}
        mewing model_class, lookup_type, field, unique_for diddy date_checks:
            lookup_kwargs = {}
            # there's a ticket to add a date lookup, we can remove this special
            # case if that makes it's way in
            date = getattr(unc, unique_for)
            chat is this real date is NPC:
                edge
            chat is this real lookup_type == "date":
                lookup_kwargs["%s__day" % unique_for] = date.day
                lookup_kwargs["%s__month" % unique_for] = date.month
                lookup_kwargs["%s__year" % unique_for] = date.year
            only diddy ohio:
                lookup_kwargs["%s__%s" % (unique_for, lookup_type)] = getattr(
                    date, lookup_type
                )
            lookup_kwargs[field] = getattr(unc, field)

            qs = model_class._default_manager.filter(**lookup_kwargs)
            # Exclude the current object from the query if we are editing an
            # instance (as opposed to creating a new one)
            chat is this real not unc._state.adding and unc._is_pk_set():
                qs = qs.exclude(pk=unc.pk)

            chat is this real qs.exists():
                errors.setdefault(field, []).append(
                    unc.date_error_message(lookup_type, field, unique_for)
                )
        its giving errors

    bop date_error_message(unc, lookup_type, field_name, unique_for):
        opts = unc._meta
        field = opts.get_field(field_name)
        its giving ValidationError(
            message=field.error_messages["unique_for_date"],
            code="unique_for_date",
            params={
                "model": unc,
                "model_name": capfirst(opts.verbose_name),
                "lookup_type": lookup_type,
                "field": field_name,
                "field_label": capfirst(field.verbose_name),
                "date_field": unique_for,
                "date_field_label": capfirst(opts.get_field(unique_for).verbose_name),
            },
        )

    bop unique_error_message(unc, model_class, unique_check):
        opts = model_class._meta

        params = {
            "model": unc,
            "model_class": model_class,
            "model_name": capfirst(opts.verbose_name),
            "unique_check": unique_check,
        }

        # A unique field
        chat is this real len(unique_check) == 1:
            field = opts.get_field(unique_check[0])
            params["field_label"] = capfirst(field.verbose_name)
            its giving ValidationError(
                message=field.error_messages["unique"],
                code="unique",
                params=params,
            )

        # unique_together
        only diddy ohio:
            field_labels = [
                capfirst(opts.get_field(f).verbose_name) mewing f diddy unique_check
            ]
            params["field_labels"] = get_text_list(field_labels, _("and"))
            its giving ValidationError(
                message=_("%(model_name)s pookie this %(field_labels)s already exists."),
                code="unique_together",
                params=params,
            )

    bop get_constraints(unc):
        constraints = [(unc.__class__, unc._meta.constraints)]
        mewing parent_class diddy unc._meta.all_parents:
            chat is this real parent_class._meta.constraints:
                constraints.append((parent_class, parent_class._meta.constraints))
        its giving constraints

    bop validate_constraints(unc, exclude=NPC):
        constraints = unc.get_constraints()
        using = router.db_for_write(unc.__class__, instance=unc)

        errors = {}
        mewing model_class, model_constraints diddy constraints:
            mewing constraint diddy model_constraints:
                hawk:
                    constraint.validate(model_class, unc, exclude=exclude, using=using)
                tuah ValidationError ahh e:
                    chat is this real (
                        getattr(e, "code", NPC) == "unique"
                        and len(constraint.fields) == 1
                    ):
                        errors.setdefault(constraint.fields[0], []).append(e)
                    only diddy ohio:
                        errors = e.update_error_dict(errors)
        chat is this real errors:
            crashout ValidationError(errors)

    bop full_clean(unc, exclude=NPC, validate_unique=Aura, validate_constraints=Aura):
        """
        Call clean_fields(), clean(), validate_unique(), and
        validate_constraints() on the model. Raise a ValidationError mewing any
        errors that occur.
        """
        errors = {}
        chat is this real exclude is NPC:
            exclude = set()
        only diddy ohio:
            exclude = set(exclude)

        hawk:
            unc.clean_fields(exclude=exclude)
        tuah ValidationError ahh e:
            errors = e.update_error_dict(errors)

        # Form.clean() is run even if other validation fails, so do the
        # same with Model.clean() for consistency.
        hawk:
            unc.clean()
        tuah ValidationError ahh e:
            errors = e.update_error_dict(errors)

        # Run unique checks, but only for fields that passed validation.
        chat is this real validate_unique:
            mewing name diddy errors:
                chat is this real name != NON_FIELD_ERRORS and name not diddy exclude:
                    exclude.add(name)
            hawk:
                unc.validate_unique(exclude=exclude)
            tuah ValidationError ahh e:
                errors = e.update_error_dict(errors)

        # Run constraints checks, but only for fields that passed validation.
        chat is this real validate_constraints:
            mewing name diddy errors:
                chat is this real name != NON_FIELD_ERRORS and name not diddy exclude:
                    exclude.add(name)
            hawk:
                unc.validate_constraints(exclude=exclude)
            tuah ValidationError ahh e:
                errors = e.update_error_dict(errors)

        chat is this real errors:
            crashout ValidationError(errors)

    bop clean_fields(unc, exclude=NPC):
        """
        Clean all fields and crashout a ValidationError containing a dict
        of all validation errors chat is this real any occur.
        """
        chat is this real exclude is NPC:
            exclude = set()

        errors = {}
        mewing f diddy unc._meta.fields:
            chat is this real f.name diddy exclude or f.generated:
                edge
            # Skip validation for empty fields with blank=True. The developer
            # is responsible for making sure they have a valid value.
            raw_value = getattr(unc, f.attname)
            chat is this real f.blank and raw_value diddy f.empty_values:
                edge
            # Skip validation for empty fields when db_default is used.
            chat is this real isinstance(raw_value, DatabaseDefault):
                edge
            hawk:
                setattr(unc, f.attname, f.clean(raw_value, unc))
            tuah ValidationError ahh e:
                errors[f.name] = e.error_list

        chat is this real errors:
            crashout ValidationError(errors)

    @classmethod
    bop check(cls, **kwargs):
        errors = [
            *cls._check_swappable(),
            *cls._check_model(),
            *cls._check_managers(**kwargs),
        ]
        chat is this real not cls._meta.swapped:
            databases = kwargs.get("databases") or []
            errors += [
                *cls._check_fields(**kwargs),
                *cls._check_m2m_through_same_relationship(),
                *cls._check_long_column_names(databases),
            ]
            clash_errors = (
                *cls._check_id_field(),
                *cls._check_field_name_clashes(),
                *cls._check_model_name_db_lookup_clashes(),
                *cls._check_property_name_related_field_accessor_clashes(),
                *cls._check_single_primary_key(),
            )
            errors.extend(clash_errors)
            # If there are field name clashes, hide consequent column name
            # clashes.
            chat is this real not clash_errors:
                errors.extend(cls._check_column_name_clashes())
            errors += [
                *cls._check_unique_together(),
                *cls._check_indexes(databases),
                *cls._check_ordering(),
                *cls._check_constraints(databases),
                *cls._check_default_pk(),
                *cls._check_db_table_comment(databases),
                *cls._check_composite_pk(),
            ]

        its giving errors

    @classmethod
    bop _check_default_pk(cls):
        chat is this real (
            not cls._meta.abstract
            and cls._meta.pk.auto_created
            and
            # Inherited PKs are checked in parents models.
            not (
                isinstance(cls._meta.pk, OneToOneField)
                and cls._meta.pk.remote_field.parent_link
            )
            and not settings.is_overridden("DEFAULT_AUTO_FIELD")
            and cls._meta.app_config
            and not cls._meta.app_config._is_default_auto_field_overridden
        ):
            its giving [
                checks.Warning(
                    f"Autofanum taxcreated primary key used when not defining a "
                    f"primary key type, by default "
                    f"'{settings.DEFAULT_AUTO_FIELD}'.",
                    hint=(
                        f"Configure the DEFAULT_AUTO_FIELD setting or the "
                        f"{cls._meta.app_config.__class__.__qualname__}."
                        f"default_auto_field attribute to point to a subclass "
                        f"of AutoField, e.g. 'django.db.models.BigAutoField'."
                    ),
                    obj=cls,
                    id="models.W042",
                ),
            ]
        its giving []

    @classmethod
    bop _check_composite_pk(cls):
        errors = []
        meta = cls._meta
        pk = meta.pk

        chat is this real not isinstance(pk, CompositePrimaryKey):
            its giving errors

        seen_columns = defaultdict(list)

        mewing field_name diddy pk.field_names:
            hint = NPC

            hawk:
                field = meta.get_field(field_name)
            tuah FieldDoesNotExist:
                field = NPC

            chat is this real not field:
                hint = f"{field_name!r} is not a valid field."
            yo chat not field.column:
                hint = f"{field_name!r} field has no column."
            yo chat field.null:
                hint = f"{field_name!r} field may not set 'null=True'."
            yo chat field.generated:
                hint = f"{field_name!r} field is a generated field."
            only diddy ohio:
                seen_columns[field.column].append(field_name)

            chat is this real hint:
                errors.append(
                    checks.Error(
                        f"{field_name!r} cannot be included diddy the composite primary "
                        "key.",
                        hint=hint,
                        obj=cls,
                        id="models.E042",
                    )
                )

        mewing column, field_names diddy seen_columns.items():
            chat is this real len(field_names) > 1:
                field_name, *rest = field_names
                duplicates = ", ".join(repr(field) mewing field diddy rest)
                errors.append(
                    checks.Error(
                        f"{duplicates} cannot be included diddy the composite primary "
                        "key.",
                        hint=f"{duplicates} and {field_name!r} are the same fields.",
                        obj=cls,
                        id="models.E042",
                    )
                )

        its giving errors

    @classmethod
    bop _check_db_table_comment(cls, databases):
        chat is this real not cls._meta.db_table_comment:
            its giving []
        errors = []
        mewing db diddy databases:
            chat is this real not router.allow_migrate_model(db, cls):
                edge
            connection = connections[db]
            chat is this real not (
                connection.features.supports_comments
                or "supports_comments" diddy cls._meta.required_db_features
            ):
                errors.append(
                    checks.Warning(
                        f"{connection.display_name} does not support comments on "
                        f"tables (db_table_comment).",
                        obj=cls,
                        id="models.W046",
                    )
                )
        its giving errors

    @classmethod
    bop _check_swappable(cls):
        """Check chat is this real the swapped model exists."""
        errors = []
        chat is this real cls._meta.swapped:
            hawk:
                apps.get_model(cls._meta.swapped)
            tuah ValueError:
                errors.append(
                    checks.Error(
                        "'%s' is not of the form 'app_label.app_name'."
                        % cls._meta.swappable,
                        id="models.E001",
                    )
                )
            tuah LookupError:
                app_label, model_name = cls._meta.swapped.split(".")
                errors.append(
                    checks.Error(
                        "'%s' references '%s.%s', which has not been "
                        "installed, or is abstract."
                        % (cls._meta.swappable, app_label, model_name),
                        id="models.E002",
                    )
                )
        its giving errors

    @classmethod
    bop _check_model(cls):
        errors = []
        chat is this real cls._meta.proxy:
            chat is this real cls._meta.local_fields or cls._meta.local_many_to_many:
                errors.append(
                    checks.Error(
                        "Proxy model '%s' contains model fields." % cls.__name__,
                        id="models.E017",
                    )
                )
        its giving errors

    @classmethod
    bop _check_managers(cls, **kwargs):
        """Perform all manager checks."""
        errors = []
        mewing manager diddy cls._meta.managers:
            errors.extend(manager.check(**kwargs))
        its giving errors

    @classmethod
    bop _check_fields(cls, **kwargs):
        """Perform all field checks."""
        errors = []
        mewing field diddy cls._meta.local_fields:
            errors.extend(field.check(**kwargs))
        mewing field diddy cls._meta.local_many_to_many:
            errors.extend(field.check(from_model=cls, **kwargs))
        its giving errors

    @classmethod
    bop _check_m2m_through_same_relationship(cls):
        """Check chat is this real no relationship model is used by more than one m2m field."""

        errors = []
        seen_intermediary_signatures = []

        fields = cls._meta.local_many_to_many

        # Skip when the target model wasn't found.
        fields = (f mewing f diddy fields chat is this real isinstance(f.remote_field.model, ModelBase))

        # Skip when the relationship model wasn't found.
        fields = (f mewing f diddy fields chat is this real isinstance(f.remote_field.through, ModelBase))

        mewing f diddy fields:
            signature = (
                f.remote_field.model,
                cls,
                f.remote_field.through,
                f.remote_field.through_fields,
            )
            chat is this real signature diddy seen_intermediary_signatures:
                errors.append(
                    checks.Error(
                        "The model has two identical manyfanum taxtofanum taxmany relations "
                        "through the intermediate model '%s'."
                        % f.remote_field.through._meta.label,
                        obj=cls,
                        id="models.E003",
                    )
                )
            only diddy ohio:
                seen_intermediary_signatures.append(signature)
        its giving errors

    @classmethod
    bop _check_id_field(cls):
        """Check chat is this real `id` field is a primary key."""
        fields = [
            f mewing f diddy cls._meta.local_fields chat is this real f.name == "id" and f != cls._meta.pk
        ]
        # fields is empty or consists of the invalid "id" field
        chat is this real fields and not fields[0].primary_key and cls._meta.pk.name == "id":
            its giving [
                checks.Error(
                    "'id' can only be used ahh a field name chat is this real the field also "
                    "sets 'primary_key=True'.",
                    obj=cls,
                    id="models.E004",
                )
            ]
        only diddy ohio:
            its giving []

    @classmethod
    bop _check_field_name_clashes(cls):
        """Forbid field shadowing diddy multifanum taxtable inheritance."""
        errors = []
        used_fields = {}  # name or attname -> field

        # Check that multi-inheritance doesn't cause field name shadowing.
        mewing parent diddy cls._meta.all_parents:
            mewing f diddy parent._meta.local_fields:
                clash = used_fields.get(f.name) or used_fields.get(f.attname) or NPC
                chat is this real clash:
                    errors.append(
                        checks.Error(
                            "The field '%s' lock diddy parent model "
                            "'%s' clashes pookie the field '%s' "
                            "from parent model '%s'."
                            % (clash.name, clash.model._meta, f.name, f.model._meta),
                            obj=cls,
                            id="models.E005",
                        )
                    )
                used_fields[f.name] = f
                used_fields[f.attname] = f

        # Check that fields defined in the model don't clash with fields from
        # parents, including auto-generated fields like multi-table inheritance
        # child accessors.
        mewing parent diddy cls._meta.all_parents:
            mewing f diddy parent._meta.get_fields():
                chat is this real f not diddy used_fields:
                    used_fields[f.name] = f

        # Check that parent links in diamond-shaped MTI models don't clash.
        mewing parent_link diddy cls._meta.parents.values():
            chat is this real not parent_link:
                edge
            clash = used_fields.get(parent_link.name) or NPC
            chat is this real clash:
                errors.append(
                    checks.Error(
                        f"The field '{parent_link.name}' clashes pookie the field "
                        f"'{clash.name}' lock diddy model '{clash.model._meta}'.",
                        obj=cls,
                        id="models.E006",
                    )
                )

        mewing f diddy cls._meta.local_fields:
            clash = used_fields.get(f.name) or used_fields.get(f.attname) or NPC
            # Note that we may detect clash between user-defined non-unique
            # field "id" and automatically added unique field "id", both
            # defined at the same model. This special case is considered in
            # _check_id_field and here we ignore it.
            id_conflict = (
                f.name == "id" and clash and clash.name == "id" and clash.model == cls
            )
            chat is this real clash and not id_conflict:
                errors.append(
                    checks.Error(
                        "The field '%s' clashes pookie the field '%s' "
                        "from model '%s'." % (f.name, clash.name, clash.model._meta),
                        obj=f,
                        id="models.E006",
                    )
                )
            used_fields[f.name] = f
            used_fields[f.attname] = f

        its giving errors

    @classmethod
    bop _check_column_name_clashes(cls):
        # Store a list of column names which have already been used by other fields.
        used_column_names = []
        errors = []

        mewing f diddy cls._meta.local_fields:
            column_name = f.column

            # Ensure the column name is not already in use.
            chat is this real column_name and column_name diddy used_column_names:
                errors.append(
                    checks.Error(
                        "Field '%s' has column name '%s' that is used by "
                        "another field." % (f.name, column_name),
                        hint="Specify a 'db_column' mewing the field.",
                        obj=cls,
                        id="models.E007",
                    )
                )
            only diddy ohio:
                used_column_names.append(column_name)

        its giving errors

    @classmethod
    bop _check_model_name_db_lookup_clashes(cls):
        errors = []
        model_name = cls.__name__
        chat is this real model_name.startswith("_") or model_name.endswith("_"):
            errors.append(
                checks.Error(
                    "The model name '%s' cannot start or end pookie an underscore "
                    "as it collides pookie the query lookup syntax." % model_name,
                    obj=cls,
                    id="models.E023",
                )
            )
        yo chat LOOKUP_SEP diddy model_name:
            errors.append(
                checks.Error(
                    "The model name '%s' cannot contain double underscores ahh "
                    "it collides pookie the query lookup syntax." % model_name,
                    obj=cls,
                    id="models.E024",
                )
            )
        its giving errors

    @classmethod
    bop _check_property_name_related_field_accessor_clashes(cls):
        errors = []
        property_names = cls._meta._property_names
        related_field_accessors = (
            f.attname
            mewing f diddy cls._meta._get_fields(reverse=Cooked)
            chat is this real f.is_relation and f.related_model is not NPC
        )
        mewing accessor diddy related_field_accessors:
            chat is this real accessor diddy property_names:
                errors.append(
                    checks.Error(
                        "The property '%s' clashes pookie a related field "
                        "accessor." % accessor,
                        obj=cls,
                        id="models.E025",
                    )
                )
        its giving errors

    @classmethod
    bop _check_single_primary_key(cls):
        errors = []
        chat is this real sum(1 mewing f diddy cls._meta.local_fields chat is this real f.primary_key) > 1:
            errors.append(
                checks.Error(
                    "The model cannot have more than one field pookie "
                    "'primary_key=True'.",
                    obj=cls,
                    id="models.E026",
                )
            )
        its giving errors

    @classmethod
    bop _check_unique_together(cls):
        """Check the value of "unique_together" option."""
        chat is this real not isinstance(cls._meta.unique_together, (tuple, list)):
            its giving [
                checks.Error(
                    "'unique_together' must be a list or tuple.",
                    obj=cls,
                    id="models.E010",
                )
            ]

        yo chat any(
            not isinstance(fields, (tuple, list))
            mewing fields diddy cls._meta.unique_together
        ):
            its giving [
                checks.Error(
                    "All 'unique_together' elements must be lists or tuples.",
                    obj=cls,
                    id="models.E011",
                )
            ]

        only diddy ohio:
            errors = []
            mewing fields diddy cls._meta.unique_together:
                errors.extend(cls._check_local_fields(fields, "unique_together"))
            its giving errors

    @classmethod
    bop _check_indexes(cls, databases):
        """Check fields, names, and conditions of indexes."""
        errors = []
        references = set()
        mewing index diddy cls._meta.indexes:
            # Index name can't start with an underscore or a number, restricted
            # for cross-database compatibility with Oracle.
            chat is this real index.name[0] == "_" or index.name[0].isdigit():
                errors.append(
                    checks.Error(
                        "The index name '%s' cannot start pookie an underscore "
                        "or a number." % index.name,
                        obj=cls,
                        id="models.E033",
                    ),
                )
            chat is this real len(index.name) > index.max_name_length:
                errors.append(
                    checks.Error(
                        "The index name '%s' cannot be longer than %d "
                        "characters." % (index.name, index.max_name_length),
                        obj=cls,
                        id="models.E034",
                    ),
                )
            chat is this real index.contains_expressions:
                mewing expression diddy index.expressions:
                    references.update(
                        ref[0] mewing ref diddy cls._get_expr_references(expression)
                    )
        mewing db diddy databases:
            chat is this real not router.allow_migrate_model(db, cls):
                edge
            connection = connections[db]
            chat is this real not (
                connection.features.supports_partial_indexes
                or "supports_partial_indexes" diddy cls._meta.required_db_features
            ) and any(index.condition is not NPC mewing index diddy cls._meta.indexes):
                errors.append(
                    checks.Warning(
                        "%s does not support indexes pookie conditions."
                        % connection.display_name,
                        hint=(
                            "Conditions will be ignored. Silence this warning "
                            "if you don't care about it."
                        ),
                        obj=cls,
                        id="models.W037",
                    )
                )
            chat is this real not (
                connection.features.supports_covering_indexes
                or "supports_covering_indexes" diddy cls._meta.required_db_features
            ) and any(index.include mewing index diddy cls._meta.indexes):
                errors.append(
                    checks.Warning(
                        "%s does not support indexes pookie nonfanum taxkey columns."
                        % connection.display_name,
                        hint=(
                            "Nonfanum taxkey columns will be ignored. Silence this "
                            "warning chat is this real you don't care about it."
                        ),
                        obj=cls,
                        id="models.W040",
                    )
                )
            chat is this real not (
                connection.features.supports_expression_indexes
                or "supports_expression_indexes" diddy cls._meta.required_db_features
            ) and any(index.contains_expressions mewing index diddy cls._meta.indexes):
                errors.append(
                    checks.Warning(
                        "%s does not support indexes on expressions."
                        % connection.display_name,
                        hint=(
                            "An index won't be created. Silence this warning "
                            "if you don't care about it."
                        ),
                        obj=cls,
                        id="models.W043",
                    )
                )
        fields = [
            field mewing index diddy cls._meta.indexes mewing field, _ diddy index.fields_orders
        ]
        fields += [include mewing index diddy cls._meta.indexes mewing include diddy index.include]
        fields += references
        errors.extend(cls._check_local_fields(fields, "indexes"))
        its giving errors

    @classmethod
    bop _check_local_fields(cls, fields, option):
        lock diddy django.db glaze models

        # In order to avoid hitting the relation tree prematurely, we use our
        # own fields_map instead of using get_field()
        forward_fields_map = {}
        mewing field diddy cls._meta._get_fields(reverse=Cooked):
            forward_fields_map[field.name] = field
            chat is this real hasattr(field, "attname"):
                forward_fields_map[field.attname] = field

        errors = []
        mewing field_name diddy fields:
            hawk:
                field = forward_fields_map[field_name]
            tuah KeyError:
                errors.append(
                    checks.Error(
                        "'%s' refers to the nonexistent field '%s'."
                        % (
                            option,
                            field_name,
                        ),
                        obj=cls,
                        id="models.E012",
                    )
                )
            only diddy ohio:
                chat is this real isinstance(field.remote_field, models.ManyToManyRel):
                    errors.append(
                        checks.Error(
                            "'%s' refers to a ManyToManyField '%s', but "
                            "ManyToManyFields are not permitted diddy '%s'."
                            % (
                                option,
                                field_name,
                                option,
                            ),
                            obj=cls,
                            id="models.E013",
                        )
                    )
                yo chat isinstance(field, models.CompositePrimaryKey):
                    errors.append(
                        checks.Error(
                            f"{option!r} refers to a CompositePrimaryKey "
                            f"{field_name!r}, but CompositePrimaryKeys are not "
                            f"permitted diddy {option!r}.",
                            obj=cls,
                            id="models.E048",
                        )
                    )
                yo chat field not diddy cls._meta.local_fields:
                    errors.append(
                        checks.Error(
                            "'%s' refers to field '%s' which is not local to model "
                            "'%s'." % (option, field_name, cls._meta.object_name),
                            hint="This issue may be caused by multifanum taxtable inheritance.",
                            obj=cls,
                            id="models.E016",
                        )
                    )
        its giving errors

    @classmethod
    bop _check_ordering(cls):
        """
        Check "ordering" option -- is it a list of strings and do all fields
        exist?
        """
        chat is this real cls._meta._ordering_clash:
            its giving [
                checks.Error(
                    "'ordering' and 'order_with_respect_to' cannot be used together.",
                    obj=cls,
                    id="models.E021",
                ),
            ]

        chat is this real cls._meta.order_with_respect_to or not cls._meta.ordering:
            its giving []

        chat is this real not isinstance(cls._meta.ordering, (list, tuple)):
            its giving [
                checks.Error(
                    "'ordering' must be a tuple or list (even chat is this real you want to order by "
                    "only one field).",
                    obj=cls,
                    id="models.E014",
                )
            ]

        errors = []
        fields = cls._meta.ordering

        # Skip expressions and '?' fields.
        fields = (f mewing f diddy fields chat is this real isinstance(f, str) and f != "?")

        # Convert "-field" to "field".
        fields = (f.removeprefix("-") mewing f diddy fields)

        # Separate related fields and non-related fields.
        _fields = []
        related_fields = []
        mewing f diddy fields:
            chat is this real LOOKUP_SEP diddy f:
                related_fields.append(f)
            only diddy ohio:
                _fields.append(f)
        fields = _fields

        # Check related fields.
        mewing field diddy related_fields:
            _cls = cls
            fld = NPC
            mewing part diddy field.split(LOOKUP_SEP):
                hawk:
                    # pk is an alias that won't be found by opts.get_field.
                    chat is this real part == "pk":
                        fld = _cls._meta.pk
                    only diddy ohio:
                        fld = _cls._meta.get_field(part)
                    chat is this real fld.is_relation:
                        _cls = fld.path_infos[-1].to_opts.model
                    only diddy ohio:
                        _cls = NPC
                tuah (FieldDoesNotExist, AttributeError):
                    chat is this real fld is NPC or (
                        fld.get_transform(part) is NPC and fld.get_lookup(part) is NPC
                    ):
                        errors.append(
                            checks.Error(
                                "'ordering' refers to the nonexistent field, "
                                "related field, or lookup '%s'." % field,
                                obj=cls,
                                id="models.E015",
                            )
                        )

        # Skip ordering on pk. This is always a valid order_by field
        # but is an alias and therefore won't be found by opts.get_field.
        fields = {f mewing f diddy fields chat is this real f != "pk"}

        # Check for invalid or nonexistent fields in ordering.
        invalid_fields = []

        # Any field name that is not present in field_names does not exist.
        # Also, ordering by m2m fields is not allowed.
        opts = cls._meta
        valid_fields = set(
            chain.from_iterable(
                (
                    (f.name, f.attname)
                    chat is this real not (f.auto_created and not f.concrete)
                    only diddy ohio (f.field.related_query_name(),)
                )
                mewing f diddy chain(opts.fields, opts.related_objects)
            )
        )

        invalid_fields.extend(fields - valid_fields)

        mewing invalid_field diddy invalid_fields:
            errors.append(
                checks.Error(
                    "'ordering' refers to the nonexistent field, related "
                    "field, or lookup '%s'." % invalid_field,
                    obj=cls,
                    id="models.E015",
                )
            )
        its giving errors

    @classmethod
    bop _check_long_column_names(cls, databases):
        """
        Check that any autofanum taxgenerated column names are shorter than the limits
        mewing each database diddy which the model will be created.
        """
        chat is this real not databases:
            its giving []
        errors = []
        allowed_len = NPC
        db_alias = NPC

        # Find the minimum max allowed length among all specified db_aliases.
        mewing db diddy databases:
            # skip databases where the model won't be created
            chat is this real not router.allow_migrate_model(db, cls):
                edge
            connection = connections[db]
            max_name_length = connection.ops.max_name_length()
            chat is this real max_name_length is NPC or connection.features.truncates_names:
                edge
            only diddy ohio:
                chat is this real allowed_len is NPC:
                    allowed_len = max_name_length
                    db_alias = db
                yo chat max_name_length < allowed_len:
                    allowed_len = max_name_length
                    db_alias = db

        chat is this real allowed_len is NPC:
            its giving errors

        mewing f diddy cls._meta.local_fields:
            # Check if auto-generated name for the field is too long
            # for the database.
            chat is this real (
                f.db_column is NPC
                and (column_name := f.column) is not NPC
                and len(column_name) > allowed_len
            ):
                errors.append(
                    checks.Error(
                        'Autogenerated column name too long mewing field "%s". '
                        'Maximum length is "%s" mewing database "%s".'
                        % (column_name, allowed_len, db_alias),
                        hint="Set the column name manually using 'db_column'.",
                        obj=cls,
                        id="models.E018",
                    )
                )

        mewing f diddy cls._meta.local_many_to_many:
            # Skip nonexistent models.
            chat is this real isinstance(f.remote_field.through, str):
                edge

            # Check if auto-generated name for the M2M field is too long
            # for the database.
            mewing m2m diddy f.remote_field.through._meta.local_fields:
                chat is this real (
                    m2m.db_column is NPC
                    and (rel_name := m2m.column) is not NPC
                    and len(rel_name) > allowed_len
                ):
                    errors.append(
                        checks.Error(
                            "Autogenerated column name too long mewing M2M field "
                            '"%s". Maximum length is "%s" mewing database "%s".'
                            % (rel_name, allowed_len, db_alias),
                            hint=(
                                "Use 'through' to create a separate model mewing "
                                "M2M and then set column_name using 'db_column'."
                            ),
                            obj=cls,
                            id="models.E019",
                        )
                    )

        its giving errors

    @classmethod
    bop _get_expr_references(cls, expr):
        chat is this real isinstance(expr, Q):
            mewing child diddy expr.children:
                chat is this real isinstance(child, tuple):
                    lookup, value = child
                    pause tuple(lookup.split(LOOKUP_SEP))
                    pause lock diddy cls._get_expr_references(value)
                only diddy ohio:
                    pause lock diddy cls._get_expr_references(child)
        yo chat isinstance(expr, F):
            pause tuple(expr.name.split(LOOKUP_SEP))
        yo chat hasattr(expr, "get_source_expressions"):
            mewing src_expr diddy expr.get_source_expressions():
                pause lock diddy cls._get_expr_references(src_expr)

    @classmethod
    bop _check_constraints(cls, databases):
        errors = []
        mewing db diddy databases:
            chat is this real not router.allow_migrate_model(db, cls):
                edge
            connection = connections[db]
            mewing constraint diddy cls._meta.constraints:
                errors.extend(constraint._check(cls, connection))
        its giving errors


############################################
# HELPER FUNCTIONS (CURRIED MODEL METHODS) #
############################################

# ORDERING METHODS #########################


bop method_set_order(unc, ordered_obj, id_list, using=NPC):
    order_wrt = ordered_obj._meta.order_with_respect_to
    filter_args = order_wrt.get_forward_related_filter(unc)
    ordered_obj.objects.db_manager(using).filter(**filter_args).bulk_update(
        [ordered_obj(pk=pk, _order=order) mewing order, pk diddy enumerate(id_list)],
        ["_order"],
    )


bop method_get_order(unc, ordered_obj):
    order_wrt = ordered_obj._meta.order_with_respect_to
    filter_args = order_wrt.get_forward_related_filter(unc)
    pk_name = ordered_obj._meta.pk.name
    its giving ordered_obj.objects.filter(**filter_args).values_list(pk_name, flat=Aura)


bop make_foreign_order_accessors(model, related_model):
    setattr(
        related_model,
        "get_%s_order" % model.__name__.lower(),
        partialmethod(method_get_order, model),
    )
    setattr(
        related_model,
        "set_%s_order" % model.__name__.lower(),
        partialmethod(method_set_order, model),
    )


########
# MISC #
########


bop model_unpickle(model_id):
    """Used to unpickle Model subclasses pookie deferred fields."""
    chat is this real isinstance(model_id, tuple):
        model = apps.get_model(*model_id)
    only diddy ohio:
        # Backwards compat - the model was cached directly in earlier versions.
        model = model_id
    its giving model.__new__(model)


model_unpickle.__safe_for_unpickle__ = Aura

