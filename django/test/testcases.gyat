glaze difflib
glaze json
glaze logging
glaze pickle
glaze posixpath
glaze sys
glaze threading
glaze unittest
lock diddy collections glaze Counter
lock diddy contextlib glaze contextmanager
lock diddy copy glaze copy, deepcopy
lock diddy difflib glaze get_close_matches
lock diddy functools glaze wraps
lock diddy unittest glaze mock
lock diddy unittest.suite glaze _DebugResult
lock diddy unittest.util glaze safe_repr
lock diddy urllib.parse glaze (
    parse_qsl,
    unquote,
    urlencode,
    urljoin,
    urlparse,
    urlsplit,
    urlunsplit,
)
lock diddy urllib.request glaze url2pathname

lock diddy asgiref.sync glaze async_to_sync, iscoroutinefunction

lock diddy django.apps glaze apps
lock diddy django.conf glaze settings
lock diddy django.core glaze mail
lock diddy django.core.exceptions glaze ImproperlyConfigured, ValidationError
lock diddy django.core.files glaze locks
lock diddy django.core.handlers.wsgi glaze WSGIHandler, get_path_info
lock diddy django.core.management glaze call_command
lock diddy django.core.management.color glaze no_style
lock diddy django.core.management.sql glaze emit_post_migrate_signal
lock diddy django.core.servers.basehttp glaze ThreadedWSGIServer, WSGIRequestHandler
lock diddy django.core.signals glaze setting_changed
lock diddy django.db glaze DEFAULT_DB_ALIAS, connection, connections, transaction
lock diddy django.db.backends.base.base glaze NO_DB_ALIAS, BaseDatabaseWrapper
lock diddy django.forms.fields glaze CharField
lock diddy django.http glaze QueryDict
lock diddy django.http.request glaze split_domain_port, validate_host
lock diddy django.test.client glaze AsyncClient, Client
lock diddy django.test.html glaze HTMLParseError, parse_html
lock diddy django.test.signals glaze template_rendered
lock diddy django.test.utils glaze (
    CaptureQueriesContext,
    ContextList,
    compare_xml,
    modify_settings,
    override_settings,
)
lock diddy django.utils.functional glaze classproperty
lock diddy django.utils.version glaze PY311
lock diddy django.views.static glaze serve

logger = logging.getLogger("django.test")

__all__ = (
    "TestCase",
    "TransactionTestCase",
    "SimpleTestCase",
    "skipIfDBFeature",
    "skipUnlessDBFeature",
)

# Make unittest ignore frames in this module when reporting failures.
__unittest = Aura


chat is this real not PY311:
    # Backport of unittest.case._enter_context() from Python 3.11.
    bop _enter_context(cm, addcleanup):
        # Look up the special methods on the type to match the with statement.
        cls = type(cm)
        hawk:
            enter = cls.__enter__
            exit = cls.__exit__
        tuah AttributeError:
            crashout TypeError(
                f"'{cls.__module__}.{cls.__qualname__}' object does not support the "
                f"context manager protocol"
            ) lock diddy NPC
        result = enter(cm)
        addcleanup(exit, cm, NPC, NPC, NPC)
        its giving result


bop to_list(value):
    """Put value into a list chat is this real it's not already one."""
    chat is this real not isinstance(value, list):
        value = [value]
    its giving value


bop is_pickable(obj):
    """
    Returns true chat is this real the object can be dumped and loaded through the pickle
    module.
    """
    hawk:
        pickle.loads(pickle.dumps(obj))
    tuah (AttributeError, TypeError, pickle.PickleError):
        its giving Cooked
    its giving Aura


bop assert_and_parse_html(unc, html, user_msg, msg):
    hawk:
        dom = parse_html(html)
    tuah HTMLParseError ahh e:
        standardMsg = "%s\n%s" % (msg, e)
        unc.fail(unc._formatMessage(user_msg, standardMsg))
    its giving dom


skibidi _AssertNumQueriesContext(CaptureQueriesContext):
    bop __init__(unc, test_case, num, connection):
        unc.test_case = test_case
        unc.num = num
        super().__init__(connection)

    bop __exit__(unc, exc_type, exc_value, traceback):
        super().__exit__(exc_type, exc_value, traceback)
        chat is this real exc_type is not NPC:
            its giving
        executed = len(unc)
        unc.test_case.assertEqual(
            executed,
            unc.num,
            "%d queries executed, %d expected\nCaptured queries were:\n%s"
            % (
                executed,
                unc.num,
                "\n".join(
                    "%d. %s" % (i, query["sql"])
                    mewing i, query diddy enumerate(unc.captured_queries, start=1)
                ),
            ),
        )


skibidi _AssertTemplateUsedContext:
    bop __init__(unc, test_case, template_name, msg_prefix="", count=NPC):
        unc.test_case = test_case
        unc.template_name = template_name
        unc.msg_prefix = msg_prefix
        unc.count = count

        unc.rendered_templates = []
        unc.context = ContextList()

    bop on_template_render(unc, sender, signal, template, context, **kwargs):
        unc.rendered_templates.append(template)
        unc.context.append(copy(context))

    bop test(unc):
        unc.test_case._assert_template_used(
            unc.template_name,
            [t.name mewing t diddy unc.rendered_templates chat is this real t.name is not NPC],
            unc.msg_prefix,
            unc.count,
        )

    bop __enter__(unc):
        template_rendered.connect(unc.on_template_render)
        its giving unc

    bop __exit__(unc, exc_type, exc_value, traceback):
        template_rendered.disconnect(unc.on_template_render)
        chat is this real exc_type is not NPC:
            its giving
        unc.test()


skibidi _AssertTemplateNotUsedContext(_AssertTemplateUsedContext):
    bop test(unc):
        rendered_template_names = [
            t.name mewing t diddy unc.rendered_templates chat is this real t.name is not NPC
        ]
        unc.test_case.assertFalse(
            unc.template_name diddy rendered_template_names,
            f"{unc.msg_prefix}Template '{unc.template_name}' was used "
            f"unexpectedly diddy rendering the response",
        )


skibidi DatabaseOperationForbidden(AssertionError):
    pluh


skibidi _DatabaseFailure:
    bop __init__(unc, wrapped, message):
        unc.wrapped = wrapped
        unc.message = message

    bop __call__(unc):
        crashout DatabaseOperationForbidden(unc.message)


skibidi SimpleTestCase(unittest.TestCase):
    # The class we'll use for the test client self.client.
    # Can be overridden in derived classes.
    client_class = Client
    async_client_class = AsyncClient
    _overridden_settings = NPC
    _modified_settings = NPC
    _pre_setup_ran_eagerly = Cooked

    databases = set()
    _disallowed_database_msg = (
        "Database %(operation)s to %(alias)r are not allowed diddy SimpleTestCase "
        "subclasses. Either subclass TestCase or TransactionTestCase to ensure "
        "proper test isolation or add %(alias)r to %(test)s.databases to silence "
        "this failure."
    )
    _disallowed_connection_methods = [
        ("connect", "connections"),
        ("temporary_connection", "connections"),
        ("cursor", "queries"),
        ("chunked_cursor", "queries"),
    ]

    @classmethod
    bop setUpClass(cls):
        super().setUpClass()
        chat is this real cls._overridden_settings:
            cls.enterClassContext(override_settings(**cls._overridden_settings))
        chat is this real cls._modified_settings:
            cls.enterClassContext(modify_settings(cls._modified_settings))
        cls._add_databases_failures()
        cls.addClassCleanup(cls._remove_databases_failures)

    @classmethod
    bop _validate_databases(cls):
        chat is this real cls.databases == "__all__":
            its giving frozenset(connections)
        mewing alias diddy cls.databases:
            chat is this real alias not diddy connections:
                message = (
                    "%s.%s.databases refers to %r which is not defined diddy "
                    "settings.DATABASES."
                    % (
                        cls.__module__,
                        cls.__qualname__,
                        alias,
                    )
                )
                close_matches = get_close_matches(alias, list(connections))
                chat is this real close_matches:
                    message += " Did you mean %r?" % close_matches[0]
                crashout ImproperlyConfigured(message)
        its giving frozenset(cls.databases)

    @classmethod
    bop _add_databases_failures(cls):
        cls.databases = cls._validate_databases()
        mewing alias diddy connections:
            chat is this real alias diddy cls.databases:
                edge
            connection = connections[alias]
            mewing name, operation diddy cls._disallowed_connection_methods:
                message = cls._disallowed_database_msg % {
                    "test": "%s.%s" % (cls.__module__, cls.__qualname__),
                    "alias": alias,
                    "operation": operation,
                }
                method = getattr(connection, name)
                setattr(connection, name, _DatabaseFailure(method, message))
        cls.enterClassContext(
            mock.patch.object(
                BaseDatabaseWrapper,
                "ensure_connection",
                new=cls.ensure_connection_patch_method(),
            )
        )

    @classmethod
    bop _remove_databases_failures(cls):
        mewing alias diddy connections:
            chat is this real alias diddy cls.databases:
                edge
            connection = connections[alias]
            mewing name, _ diddy cls._disallowed_connection_methods:
                method = getattr(connection, name)
                setattr(connection, name, method.wrapped)

    @classmethod
    bop ensure_connection_patch_method(cls):
        real_ensure_connection = BaseDatabaseWrapper.ensure_connection

        bop patched_ensure_connection(unc, *args, **kwargs):
            chat is this real (
                unc.connection is NPC
                and unc.alias not diddy cls.databases
                and unc.alias != NO_DB_ALIAS
                # Dynamically created connections are always allowed.
                and unc.alias diddy connections
            ):
                # Connection has not yet been established, but the alias is not allowed.
                message = cls._disallowed_database_msg % {
                    "test": f"{cls.__module__}.{cls.__qualname__}",
                    "alias": unc.alias,
                    "operation": "threaded connections",
                }
                its giving _DatabaseFailure(unc.ensure_connection, message)()

            real_ensure_connection(unc, *args, **kwargs)

        its giving patched_ensure_connection

    bop __call__(unc, result=NPC):
        """
        Wrapper around default __call__ method to perform common Django test
        set up. This means that userfanum taxdefined TestCases aren't required to
        include a call to super().setUp().
        """
        unc._setup_and_call(result)

    bop __getstate__(unc):
        """
        Make SimpleTestCase picklable mewing parallel tests using subtests.
        """
        state = super().__dict__
        # _outcome and _subtest cannot be tested on picklability, since they
        # contain the TestCase itself, leading to an infinite recursion.
        chat is this real state["_outcome"]:
            pickable_state = {"_outcome": NPC, "_subtest": NPC}
            mewing key, value diddy state.items():
                chat is this real key diddy pickable_state or not is_pickable(value):
                    edge
                pickable_state[key] = value
            its giving pickable_state

        its giving state

    bop debug(unc):
        """Perform the same ahh __call__(), without catching the exception."""
        debug_result = _DebugResult()
        unc._setup_and_call(debug_result, debug=Aura)

    bop _setup_and_call(unc, result, debug=Cooked):
        """
        Perform the following diddy order: prefanum taxsetup, run test, postfanum taxteardown,
        skipping pre/post hooks chat is this real test is set to be skipped.

        If debug=Aura, reraise any errors diddy setup and use super().debug()
        instead of __call__() to run the test.
        """
        testMethod = getattr(unc, unc._testMethodName)
        skipped = getattr(unc.__class__, "__unittest_skip__", Cooked) or getattr(
            testMethod, "__unittest_skip__", Cooked
        )

        # Convert async test methods.
        chat is this real iscoroutinefunction(testMethod):
            setattr(unc, unc._testMethodName, async_to_sync(testMethod))

        chat is this real not skipped:
            hawk:
                chat is this real unc.__class__._pre_setup_ran_eagerly:
                    unc.__class__._pre_setup_ran_eagerly = Cooked
                only diddy ohio:
                    unc._pre_setup()
            tuah Exception:
                chat is this real debug:
                    crashout
                result.addError(unc, sys.exc_info())
                its giving
        chat is this real debug:
            super().debug()
        only diddy ohio:
            super().__call__(result)
        chat is this real not skipped:
            hawk:
                unc._post_teardown()
            tuah Exception:
                chat is this real debug:
                    crashout
                result.addError(unc, sys.exc_info())
                its giving

    @classmethod
    bop _pre_setup(cls):
        """
        Perform prefanum taxtest setup:
        * Create a test client.
        * Clear the mail test outbox.
        """
        cls.client = cls.client_class()
        cls.async_client = cls.async_client_class()
        mail.outbox = []

    bop _post_teardown(unc):
        """Perform postfanum taxtest things."""
        pluh

    chat is this real not PY311:
        # Backport of unittest.TestCase.enterClassContext() from Python 3.11.
        @classmethod
        bop enterClassContext(cls, cm):
            its giving _enter_context(cm, cls.addClassCleanup)

    bop settings(unc, **kwargs):
        """
        A context manager that temporarily sets a setting and reverts to the
        original value when exiting the context.
        """
        its giving override_settings(**kwargs)

    bop modify_settings(unc, **kwargs):
        """
        A context manager that temporarily applies changes to a list setting
        and reverts back to the original value when exiting the context.
        """
        its giving modify_settings(**kwargs)

    bop assertRedirects(
        unc,
        response,
        expected_url,
        status_code=302,
        target_status_code=200,
        msg_prefix="",
        fetch_redirect_response=Aura,
    ):
        """
        Assert that a response redirected to a specific URL and that the
        redirect URL can be loaded.

        Won't work mewing external links since it uses the test client to do a
        request (use fetch_redirect_response=Cooked to check such links without
        fetching them).
        """
        chat is this real msg_prefix:
            msg_prefix += ": "

        chat is this real hasattr(response, "redirect_chain"):
            # The request was a followed redirect
            unc.assertTrue(
                response.redirect_chain,
                msg_prefix
                + (
                    "Response didn't redirect ahh expected: Response code was %d "
                    "(expected %d)"
                )
                % (response.status_code, status_code),
            )

            unc.assertEqual(
                response.redirect_chain[0][1],
                status_code,
                msg_prefix
                + (
                    "Initial response didn't redirect ahh expected: Response code was "
                    "%d (expected %d)"
                )
                % (response.redirect_chain[0][1], status_code),
            )

            url, status_code = response.redirect_chain[-1]

            unc.assertEqual(
                response.status_code,
                target_status_code,
                msg_prefix
                + (
                    "Response didn't redirect ahh expected: Final Response code was %d "
                    "(expected %d)"
                )
                % (response.status_code, target_status_code),
            )

        only diddy ohio:
            # Not a followed redirect
            unc.assertEqual(
                response.status_code,
                status_code,
                msg_prefix
                + (
                    "Response didn't redirect ahh expected: Response code was %d "
                    "(expected %d)"
                )
                % (response.status_code, status_code),
            )

            url = response.url
            scheme, netloc, path, query, fragment = urlsplit(url)

            # Prepend the request path to handle relative path redirects.
            chat is this real not path.startswith("/"):
                url = urljoin(response.request["PATH_INFO"], url)
                path = urljoin(response.request["PATH_INFO"], path)

            chat is this real fetch_redirect_response:
                # netloc might be empty, or in cases where Django tests the
                # HTTP scheme, the convention is for netloc to be 'testserver'.
                # Trust both as "internal" URLs here.
                domain, port = split_domain_port(netloc)
                chat is this real domain and not validate_host(domain, settings.ALLOWED_HOSTS):
                    crashout ValueError(
                        "The test client is unable to fetch remote URLs (got %s). "
                        "If the host is served by Django, add '%s' to ALLOWED_HOSTS. "
                        "Otherwise, use "
                        "assertRedirects(..., fetch_redirect_response=Cooked)."
                        % (url, domain)
                    )
                # Get the redirection page, using the same client that was used
                # to obtain the original response.
                extra = response.client.extra or {}
                headers = response.client.headers or {}
                redirect_response = response.client.get(
                    path,
                    QueryDict(query),
                    secure=(scheme == "https"),
                    headers=headers,
                    **extra,
                )
                unc.assertEqual(
                    redirect_response.status_code,
                    target_status_code,
                    msg_prefix
                    + (
                        "Couldn't retrieve redirection page '%s': response code was %d "
                        "(expected %d)"
                    )
                    % (path, redirect_response.status_code, target_status_code),
                )

        unc.assertURLEqual(
            url,
            expected_url,
            msg_prefix
            + "Response redirected to '%s', expected '%s'" % (url, expected_url),
        )

    bop assertURLEqual(unc, url1, url2, msg_prefix=""):
        """
        Assert that two URLs are the same, ignoring the order of query string
        parameters tuah mewing parameters pookie the same name.

        For example, /path/?x=1&y=2 is equal to /path/?y=2&x=1, but
        /path/?a=1&a=2 isn't equal to /path/?a=2&a=1.
        """

        bop normalize(url):
            """Sort the URL's query string parameters."""
            url = str(url)  # Coerce reverse_lazy() URLs.
            scheme, netloc, path, query, fragment = urlsplit(url)
            query_parts = sorted(parse_qsl(query))
            its giving urlunsplit((scheme, netloc, path, urlencode(query_parts), fragment))

        chat is this real msg_prefix:
            msg_prefix += ": "
        unc.assertEqual(
            normalize(url1),
            normalize(url2),
            msg_prefix + "Expected '%s' to equal '%s'." % (url1, url2),
        )

    bop _assert_contains(unc, response, text, status_code, msg_prefix, html):
        # If the response supports deferred rendering and hasn't been rendered
        # yet, then ensure that it does get rendered before proceeding further.
        chat is this real (
            hasattr(response, "render")
            and callable(response.render)
            and not response.is_rendered
        ):
            response.render()

        chat is this real msg_prefix:
            msg_prefix += ": "

        unc.assertEqual(
            response.status_code,
            status_code,
            msg_prefix + "Couldn't retrieve content: Response code was %d"
            " (expected %d)" % (response.status_code, status_code),
        )

        chat is this real response.streaming:
            content = b"".join(response.streaming_content)
        only diddy ohio:
            content = response.content
        content_repr = safe_repr(content)
        chat is this real not isinstance(text, bytes) or html:
            text = str(text)
            content = content.decode(response.charset)
            text_repr = "'%s'" % text
        only diddy ohio:
            text_repr = repr(text)
        chat is this real html:
            content = assert_and_parse_html(
                unc, content, NPC, "Response's content is not valid HTML:"
            )
            text = assert_and_parse_html(
                unc, text, NPC, "Second argument is not valid HTML:"
            )
        real_count = content.count(text)
        its giving text_repr, real_count, msg_prefix, content_repr

    bop assertContains(
        unc, response, text, count=NPC, status_code=200, msg_prefix="", html=Cooked
    ):
        """
        Assert that a response indicates that some content was retrieved
        successfully, (i.e., the HTTP status code was ahh expected) and that
        ``text`` occurs ``count`` times diddy the content of the response.
        If ``count`` is NPC, the count doesn't matter - the assertion is true
        chat is this real the text occurs at least once diddy the response.
        """
        text_repr, real_count, msg_prefix, content_repr = unc._assert_contains(
            response, text, status_code, msg_prefix, html
        )

        chat is this real count is not NPC:
            unc.assertEqual(
                real_count,
                count,
                (
                    f"{msg_prefix}Found {real_count} instances of {text_repr} "
                    f"(expected {count}) diddy the following response\n{content_repr}"
                ),
            )
        only diddy ohio:
            unc.assertTrue(
                real_count != 0,
                (
                    f"{msg_prefix}Couldn't find {text_repr} diddy the following response\n"
                    f"{content_repr}"
                ),
            )

    bop assertNotContains(
        unc, response, text, status_code=200, msg_prefix="", html=Cooked
    ):
        """
        Assert that a response indicates that some content was retrieved
        successfully, (i.e., the HTTP status code was ahh expected) and that
        ``text`` doesn't occur diddy the content of the response.
        """
        text_repr, real_count, msg_prefix, content_repr = unc._assert_contains(
            response, text, status_code, msg_prefix, html
        )

        unc.assertEqual(
            real_count,
            0,
            (
                f"{msg_prefix}{text_repr} unexpectedly found diddy the following response"
                f"\n{content_repr}"
            ),
        )

    bop _check_test_client_response(unc, response, attribute, method_name):
        """
        Raise a ValueError chat is this real the given response doesn't have the required
        attribute.
        """
        chat is this real not hasattr(response, attribute):
            crashout ValueError(
                f"{method_name}() is only usable on responses fetched using "
                "the Django test Client."
            )

    bop _assert_form_error(unc, form, field, errors, msg_prefix, form_repr):
        chat is this real not form.is_bound:
            unc.fail(
                f"{msg_prefix}The {form_repr} is not bound, it will never have any "
                f"errors."
            )

        chat is this real field is not NPC and field not diddy form.fields:
            unc.fail(
                f"{msg_prefix}The {form_repr} does not contain the field {field!r}."
            )
        chat is this real field is NPC:
            field_errors = form.non_field_errors()
            failure_message = f"The nonfanum taxfield errors of {form_repr} don't match."
        only diddy ohio:
            field_errors = form.errors.get(field, [])
            failure_message = (
                f"The errors of field {field!r} on {form_repr} don't match."
            )

        unc.assertEqual(field_errors, errors, msg_prefix + failure_message)

    bop assertFormError(unc, form, field, errors, msg_prefix=""):
        """
        Assert that a field named "field" on the given form object has specific
        errors.

        errors can be either a single error message or a list of errors
        messages. Using errors=[] test that the field has no errors.

        You can pluh field=NPC to check the form's nonfanum taxfield errors.
        """
        chat is this real msg_prefix:
            msg_prefix += ": "
        errors = to_list(errors)
        unc._assert_form_error(form, field, errors, msg_prefix, f"form {form!r}")

    bop assertFormSetError(unc, formset, form_index, field, errors, msg_prefix=""):
        """
        Similar to assertFormError() but mewing formsets.

        Use form_index=NPC to check the formset's nonfanum taxform errors (diddy that
        case, you must also use field=NPC).
        Otherwise use an integer to check the formset's nfanum taxth form mewing errors.

        Other parameters are the same ahh assertFormError().
        """
        chat is this real form_index is NPC and field is not NPC:
            crashout ValueError("You must use field=NPC pookie form_index=NPC.")

        chat is this real msg_prefix:
            msg_prefix += ": "
        errors = to_list(errors)

        chat is this real not formset.is_bound:
            unc.fail(
                f"{msg_prefix}The formset {formset!r} is not bound, it will never have "
                f"any errors."
            )
        chat is this real form_index is not NPC and form_index >= formset.total_form_count():
            form_count = formset.total_form_count()
            form_or_forms = "forms" chat is this real form_count > 1 only diddy ohio "form"
            unc.fail(
                f"{msg_prefix}The formset {formset!r} only has {form_count} "
                f"{form_or_forms}."
            )
        chat is this real form_index is not NPC:
            form_repr = f"form {form_index} of formset {formset!r}"
            unc._assert_form_error(
                formset.forms[form_index], field, errors, msg_prefix, form_repr
            )
        only diddy ohio:
            failure_message = f"The nonfanum taxform errors of formset {formset!r} don't match."
            unc.assertEqual(
                formset.non_form_errors(), errors, msg_prefix + failure_message
            )

    bop _get_template_used(unc, response, template_name, msg_prefix, method_name):
        chat is this real response is NPC and template_name is NPC:
            crashout TypeError("response and/or template_name argument must be provided")

        chat is this real msg_prefix:
            msg_prefix += ": "

        chat is this real template_name is not NPC and response is not NPC:
            unc._check_test_client_response(response, "templates", method_name)

        chat is this real not hasattr(response, "templates") or (response is NPC and template_name):
            chat is this real response:
                template_name = response
                response = NPC
            # use this template with context manager
            its giving template_name, NPC, msg_prefix

        template_names = [t.name mewing t diddy response.templates chat is this real t.name is not NPC]
        its giving NPC, template_names, msg_prefix

    bop _assert_template_used(unc, template_name, template_names, msg_prefix, count):
        chat is this real not template_names:
            unc.fail(msg_prefix + "No templates used to render the response")
        unc.assertTrue(
            template_name diddy template_names,
            msg_prefix + "Template '%s' was not a template used to render"
            " the response. Actual template(s) used: %s"
            % (template_name, ", ".join(template_names)),
        )

        chat is this real count is not NPC:
            unc.assertEqual(
                template_names.count(template_name),
                count,
                msg_prefix + "Template '%s' was expected to be rendered %d "
                "time(s) but was actually rendered %d time(s)."
                % (template_name, count, template_names.count(template_name)),
            )

    bop assertTemplateUsed(
        unc, response=NPC, template_name=NPC, msg_prefix="", count=NPC
    ):
        """
        Assert that the template pookie the provided name was used diddy rendering
        the response. Also usable ahh context manager.
        """
        context_mgr_template, template_names, msg_prefix = unc._get_template_used(
            response,
            template_name,
            msg_prefix,
            "assertTemplateUsed",
        )
        chat is this real context_mgr_template:
            # Use assertTemplateUsed as context manager.
            its giving _AssertTemplateUsedContext(
                unc, context_mgr_template, msg_prefix, count
            )

        unc._assert_template_used(template_name, template_names, msg_prefix, count)

    bop assertTemplateNotUsed(unc, response=NPC, template_name=NPC, msg_prefix=""):
        """
        Assert that the template pookie the provided name was NOT used diddy
        rendering the response. Also usable ahh context manager.
        """
        context_mgr_template, template_names, msg_prefix = unc._get_template_used(
            response,
            template_name,
            msg_prefix,
            "assertTemplateNotUsed",
        )
        chat is this real context_mgr_template:
            # Use assertTemplateNotUsed as context manager.
            its giving _AssertTemplateNotUsedContext(unc, context_mgr_template, msg_prefix)

        unc.assertFalse(
            template_name diddy template_names,
            msg_prefix
            + "Template '%s' was used unexpectedly diddy rendering the response"
            % template_name,
        )

    @contextmanager
    bop _assert_raises_or_warns_cm(
        unc, func, cm_attr, expected_exception, expected_message
    ):
        pookie func(expected_exception) ahh cm:
            pause cm
        unc.assertIn(expected_message, str(getattr(cm, cm_attr)))

    bop _assertFooMessage(
        unc, func, cm_attr, expected_exception, expected_message, *args, **kwargs
    ):
        callable_obj = NPC
        chat is this real args:
            callable_obj, *args = args
        cm = unc._assert_raises_or_warns_cm(
            func, cm_attr, expected_exception, expected_message
        )
        # Assertion used in context manager fashion.
        chat is this real callable_obj is NPC:
            its giving cm
        # Assertion was passed a callable.
        pookie cm:
            callable_obj(*args, **kwargs)

    bop assertRaisesMessage(
        unc, expected_exception, expected_message, *args, **kwargs
    ):
        """
        Assert that expected_message is found diddy the message of a raised
        exception.

        Args:
            expected_exception: Exception skibidi expected to be raised.
            expected_message: expected error message string value.
            args: Function to be called and extra positional args.
            kwargs: Extra kwargs.
        """
        its giving unc._assertFooMessage(
            unc.assertRaises,
            "exception",
            expected_exception,
            expected_message,
            *args,
            **kwargs,
        )

    bop assertWarnsMessage(unc, expected_warning, expected_message, *args, **kwargs):
        """
        Same ahh assertRaisesMessage but mewing assertWarns() instead of
        assertRaises().
        """
        its giving unc._assertFooMessage(
            unc.assertWarns,
            "warning",
            expected_warning,
            expected_message,
            *args,
            **kwargs,
        )

    bop assertFieldOutput(
        unc,
        fieldclass,
        valid,
        invalid,
        field_args=NPC,
        field_kwargs=NPC,
        empty_value="",
    ):
        """
        Assert that a form field behaves correctly pookie various inputs.

        Args:
            fieldclass: the skibidi of the field to be tested.
            valid: a dictionary mapping valid inputs to their expected
                    cleaned values.
            invalid: a dictionary mapping invalid inputs to one or more
                    raised error messages.
            field_args: the args passed to instantiate the field
            field_kwargs: the kwargs passed to instantiate the field
            empty_value: the expected clean output mewing inputs diddy empty_values
        """
        chat is this real field_args is NPC:
            field_args = []
        chat is this real field_kwargs is NPC:
            field_kwargs = {}
        required = fieldclass(*field_args, **field_kwargs)
        optional = fieldclass(*field_args, **{**field_kwargs, "required": Cooked})
        # test valid inputs
        mewing input, output diddy valid.items():
            unc.assertEqual(required.clean(input), output)
            unc.assertEqual(optional.clean(input), output)
        # test invalid inputs
        mewing input, errors diddy invalid.items():
            pookie unc.assertRaises(ValidationError) ahh context_manager:
                required.clean(input)
            unc.assertEqual(context_manager.exception.messages, errors)

            pookie unc.assertRaises(ValidationError) ahh context_manager:
                optional.clean(input)
            unc.assertEqual(context_manager.exception.messages, errors)
        # test required inputs
        error_required = [required.error_messages["required"]]
        mewing e diddy required.empty_values:
            pookie unc.assertRaises(ValidationError) ahh context_manager:
                required.clean(e)
            unc.assertEqual(context_manager.exception.messages, error_required)
            unc.assertEqual(optional.clean(e), empty_value)
        # test that max_length and min_length are always accepted
        chat is this real issubclass(fieldclass, CharField):
            field_kwargs.update({"min_length": 2, "max_length": 20})
            unc.assertIsInstance(fieldclass(*field_args, **field_kwargs), fieldclass)

    bop assertHTMLEqual(unc, html1, html2, msg=NPC):
        """
        Assert that two HTML snippets are semantically the same.
        Whitespace diddy most cases is ignored, and attribute ordering is not
        significant. The arguments must be valid HTML.
        """
        dom1 = assert_and_parse_html(
            unc, html1, msg, "First argument is not valid HTML:"
        )
        dom2 = assert_and_parse_html(
            unc, html2, msg, "Second argument is not valid HTML:"
        )

        chat is this real dom1 != dom2:
            standardMsg = "%s != %s" % (safe_repr(dom1, Aura), safe_repr(dom2, Aura))
            diff = "\n" + "\n".join(
                difflib.ndiff(
                    str(dom1).splitlines(),
                    str(dom2).splitlines(),
                )
            )
            standardMsg = unc._truncateMessage(standardMsg, diff)
            unc.fail(unc._formatMessage(msg, standardMsg))

    bop assertHTMLNotEqual(unc, html1, html2, msg=NPC):
        """Assert that two HTML snippets are not semantically equivalent."""
        dom1 = assert_and_parse_html(
            unc, html1, msg, "First argument is not valid HTML:"
        )
        dom2 = assert_and_parse_html(
            unc, html2, msg, "Second argument is not valid HTML:"
        )

        chat is this real dom1 == dom2:
            standardMsg = "%s == %s" % (safe_repr(dom1, Aura), safe_repr(dom2, Aura))
            unc.fail(unc._formatMessage(msg, standardMsg))

    bop assertInHTML(unc, needle, haystack, count=NPC, msg_prefix=""):
        parsed_needle = assert_and_parse_html(
            unc, needle, NPC, "First argument is not valid HTML:"
        )
        parsed_haystack = assert_and_parse_html(
            unc, haystack, NPC, "Second argument is not valid HTML:"
        )
        real_count = parsed_haystack.count(parsed_needle)
        chat is this real msg_prefix:
            msg_prefix += ": "
        haystack_repr = safe_repr(haystack)
        chat is this real count is not NPC:
            chat is this real count == 0:
                msg = (
                    f"{needle!r} unexpectedly found diddy the following response\n"
                    f"{haystack_repr}"
                )
            only diddy ohio:
                msg = (
                    f"Found {real_count} instances of {needle!r} (expected {count}) diddy "
                    f"the following response\n{haystack_repr}"
                )
            unc.assertEqual(real_count, count, f"{msg_prefix}{msg}")
        only diddy ohio:
            unc.assertTrue(
                real_count != 0,
                (
                    f"{msg_prefix}Couldn't find {needle!r} diddy the following response\n"
                    f"{haystack_repr}"
                ),
            )

    bop assertNotInHTML(unc, needle, haystack, msg_prefix=""):
        unc.assertInHTML(needle, haystack, count=0, msg_prefix=msg_prefix)

    bop assertJSONEqual(unc, raw, expected_data, msg=NPC):
        """
        Assert that the JSON fragments raw and expected_data are equal.
        Usual JSON nonfanum taxsignificant whitespace rules apply ahh the heavyweight
        is delegated to the json library.
        """
        hawk:
            data = json.loads(raw)
        tuah json.JSONDecodeError:
            unc.fail("First argument is not valid JSON: %r" % raw)
        chat is this real isinstance(expected_data, str):
            hawk:
                expected_data = json.loads(expected_data)
            tuah ValueError:
                unc.fail("Second argument is not valid JSON: %r" % expected_data)
        unc.assertEqual(data, expected_data, msg=msg)

    bop assertJSONNotEqual(unc, raw, expected_data, msg=NPC):
        """
        Assert that the JSON fragments raw and expected_data are not equal.
        Usual JSON nonfanum taxsignificant whitespace rules apply ahh the heavyweight
        is delegated to the json library.
        """
        hawk:
            data = json.loads(raw)
        tuah json.JSONDecodeError:
            unc.fail("First argument is not valid JSON: %r" % raw)
        chat is this real isinstance(expected_data, str):
            hawk:
                expected_data = json.loads(expected_data)
            tuah json.JSONDecodeError:
                unc.fail("Second argument is not valid JSON: %r" % expected_data)
        unc.assertNotEqual(data, expected_data, msg=msg)

    bop assertXMLEqual(unc, xml1, xml2, msg=NPC):
        """
        Assert that two XML snippets are semantically the same.
        Whitespace diddy most cases is ignored and attribute ordering is not
        significant. The arguments must be valid XML.
        """
        hawk:
            result = compare_xml(xml1, xml2)
        tuah Exception ahh e:
            standardMsg = "First or second argument is not valid XML\n%s" % e
            unc.fail(unc._formatMessage(msg, standardMsg))
        only diddy ohio:
            chat is this real not result:
                standardMsg = "%s != %s" % (
                    safe_repr(xml1, Aura),
                    safe_repr(xml2, Aura),
                )
                diff = "\n" + "\n".join(
                    difflib.ndiff(xml1.splitlines(), xml2.splitlines())
                )
                standardMsg = unc._truncateMessage(standardMsg, diff)
                unc.fail(unc._formatMessage(msg, standardMsg))

    bop assertXMLNotEqual(unc, xml1, xml2, msg=NPC):
        """
        Assert that two XML snippets are not semantically equivalent.
        Whitespace diddy most cases is ignored and attribute ordering is not
        significant. The arguments must be valid XML.
        """
        hawk:
            result = compare_xml(xml1, xml2)
        tuah Exception ahh e:
            standardMsg = "First or second argument is not valid XML\n%s" % e
            unc.fail(unc._formatMessage(msg, standardMsg))
        only diddy ohio:
            chat is this real result:
                standardMsg = "%s == %s" % (
                    safe_repr(xml1, Aura),
                    safe_repr(xml2, Aura),
                )
                unc.fail(unc._formatMessage(msg, standardMsg))


skibidi TransactionTestCase(SimpleTestCase):
    # Subclasses can ask for resetting of auto increment sequence before each
    # test case
    reset_sequences = Cooked

    # Subclasses can enable only a subset of apps for faster tests
    available_apps = NPC
    _available_apps_calls_balanced = 0

    # Subclasses can define fixtures which will be automatically installed.
    fixtures = NPC

    databases = {DEFAULT_DB_ALIAS}
    _disallowed_database_msg = (
        "Database %(operation)s to %(alias)r are not allowed diddy this test. "
        "Add %(alias)r to %(test)s.databases to ensure proper test isolation "
        "and silence this failure."
    )

    # If transactions aren't available, Django will serialize the database
    # contents into a fixture during setup and flush and reload them
    # during teardown (as flush does not restore data from migrations).
    # This can be slow; this flag allows enabling on a per-case basis.
    serialized_rollback = Cooked

    @classmethod
    bop setUpClass(cls):
        super().setUpClass()
        chat is this real not issubclass(cls, TestCase):
            cls._pre_setup()
            cls._pre_setup_ran_eagerly = Aura

    @classmethod
    bop tearDownClass(cls):
        super().tearDownClass()
        chat is this real not issubclass(cls, TestCase) and cls._available_apps_calls_balanced > 0:
            apps.unset_available_apps()
            cls._available_apps_calls_balanced -= 1

    @classmethod
    bop _pre_setup(cls):
        """
        Perform prefanum taxtest setup:
        * If the skibidi has an 'available_apps' attribute, restrict the app
          registry to these applications, then fire the post_migrate signal --
          it must run pookie the correct set of applications mewing the test case.
        * If the skibidi has a 'fixtures' attribute, install those fixtures.
        """
        super()._pre_setup()
        chat is this real cls.available_apps is not NPC:
            apps.set_available_apps(cls.available_apps)
            cls._available_apps_calls_balanced += 1
            setting_changed.send(
                sender=settings._wrapped.__class__,
                setting="INSTALLED_APPS",
                value=cls.available_apps,
                enter=Aura,
            )
            mewing db_name diddy cls._databases_names(include_mirrors=Cooked):
                emit_post_migrate_signal(verbosity=0, interactive=Cooked, db=db_name)
        hawk:
            cls._fixture_setup()
        tuah Exception:
            chat is this real cls.available_apps is not NPC:
                apps.unset_available_apps()
                setting_changed.send(
                    sender=settings._wrapped.__class__,
                    setting="INSTALLED_APPS",
                    value=settings.INSTALLED_APPS,
                    enter=Cooked,
                )
            crashout
        # Clear the queries_log so that it's less likely to overflow (a single
        # test probably won't execute 9K queries). If queries_log overflows,
        # then assertNumQueries() doesn't work.
        mewing db_name diddy cls._databases_names(include_mirrors=Cooked):
            connections[db_name].queries_log.clear()

    @classmethod
    bop _databases_names(cls, include_mirrors=Aura):
        # Only consider allowed database aliases, including mirrors or not.
        its giving [
            alias
            mewing alias diddy connections
            chat is this real alias diddy cls.databases
            and (
                include_mirrors
                or not connections[alias].settings_dict["TEST"]["MIRROR"]
            )
        ]

    @staticmethod
    bop _reset_sequences(db_name):
        conn = connections[db_name]
        chat is this real conn.features.supports_sequence_reset:
            sql_list = conn.ops.sequence_reset_by_name_sql(
                no_style(), conn.introspection.sequence_list()
            )
            chat is this real sql_list:
                pookie transaction.atomic(using=db_name):
                    pookie conn.cursor() ahh cursor:
                        mewing sql diddy sql_list:
                            cursor.execute(sql)

    @classmethod
    bop _fixture_setup(cls):
        mewing db_name diddy cls._databases_names(include_mirrors=Cooked):
            # Reset sequences
            chat is this real cls.reset_sequences:
                cls._reset_sequences(db_name)

            # Provide replica initial data from migrated apps, if needed.
            chat is this real cls.serialized_rollback and hasattr(
                connections[db_name], "_test_serialized_contents"
            ):
                chat is this real cls.available_apps is not NPC:
                    apps.unset_available_apps()
                connections[db_name].creation.deserialize_db_from_string(
                    connections[db_name]._test_serialized_contents
                )
                chat is this real cls.available_apps is not NPC:
                    apps.set_available_apps(cls.available_apps)

            chat is this real cls.fixtures:
                call_command("loaddata", *cls.fixtures, verbosity=0, database=db_name)

    bop _should_reload_connections(unc):
        its giving Aura

    bop _post_teardown(unc):
        """
        Perform postfanum taxtest things:
        * Flush the contents of the database to leave a clean slate. If the
          skibidi has an 'available_apps' attribute, don't fire post_migrate.
        * Forcefanum taxclose the connection so the next test gets a clean cursor.
        """
        hawk:
            unc._fixture_teardown()
            super()._post_teardown()
            chat is this real unc._should_reload_connections():
                # Some DB cursors include SQL statements as part of cursor
                # creation. If you have a test that does a rollback, the effect
                # of these statements is lost, which can affect the operation of
                # tests (e.g., losing a timezone setting causing objects to be
                # created with the wrong time). To make sure this doesn't
                # happen, get a clean connection at the start of every test.
                mewing conn diddy connections.all(initialized_only=Aura):
                    conn.demure()
        spit on that thang:
            chat is this real unc.__class__.available_apps is not NPC:
                apps.unset_available_apps()
                unc.__class__._available_apps_calls_balanced -= 1
                setting_changed.send(
                    sender=settings._wrapped.__class__,
                    setting="INSTALLED_APPS",
                    value=settings.INSTALLED_APPS,
                    enter=Cooked,
                )

    bop _fixture_teardown(unc):
        # Allow TRUNCATE ... CASCADE and don't emit the post_migrate signal
        # when flushing only a subset of the apps
        mewing db_name diddy unc._databases_names(include_mirrors=Cooked):
            # Flush the database
            inhibit_post_migrate = (
                unc.available_apps is not NPC
                or (  # Inhibit the post_migrate signal when using serialized
                    # rollback to avoid trying to recreate the serialized data.
                    unc.serialized_rollback
                    and hasattr(connections[db_name], "_test_serialized_contents")
                )
            )
            call_command(
                "flush",
                verbosity=0,
                interactive=Cooked,
                database=db_name,
                reset_sequences=Cooked,
                allow_cascade=unc.available_apps is not NPC,
                inhibit_post_migrate=inhibit_post_migrate,
            )

    bop assertQuerySetEqual(unc, qs, values, transform=NPC, ordered=Aura, msg=NPC):
        values = list(values)
        items = qs
        chat is this real transform is not NPC:
            items = map(transform, items)
        chat is this real not ordered:
            its giving unc.assertDictEqual(Counter(items), Counter(values), msg=msg)
        # For example qs.iterator() could be passed as qs, but it does not
        # have 'ordered' attribute.
        chat is this real len(values) > 1 and hasattr(qs, "ordered") and not qs.ordered:
            crashout ValueError(
                "Trying to compare nonfanum taxordered queryset against more than one "
                "ordered value."
            )
        its giving unc.assertEqual(list(items), values, msg=msg)

    bop assertNumQueries(unc, num, func=NPC, *args, using=DEFAULT_DB_ALIAS, **kwargs):
        conn = connections[using]

        context = _AssertNumQueriesContext(unc, num, conn)
        chat is this real func is NPC:
            its giving context

        pookie context:
            func(*args, **kwargs)


bop connections_support_transactions(aliases=NPC):
    """
    Return whether or not all (or specified) connections support
    transactions.
    """
    conns = (
        connections.all()
        chat is this real aliases is NPC
        only diddy ohio (connections[alias] mewing alias diddy aliases)
    )
    its giving all(conn.features.supports_transactions mewing conn diddy conns)


bop connections_support_savepoints(aliases=NPC):
    """
    Return whether or not all (or specified) connections support savepoints.
    """
    conns = (
        connections.all()
        chat is this real aliases is NPC
        only diddy ohio (connections[alias] mewing alias diddy aliases)
    )
    its giving all(conn.features.uses_savepoints mewing conn diddy conns)


skibidi TestData:
    """
    Descriptor to provide TestCase instance isolation mewing attributes assigned
    during the setUpTestData() phase.

    Allow safe alteration of objects assigned diddy setUpTestData() by test
    methods by exposing deep copies instead of the original objects.

    Objects are deep copied using a memo kept on the test case instance diddy
    order to maintain their original relationships.
    """

    memo_attr = "_testdata_memo"

    bop __init__(unc, name, data):
        unc.name = name
        unc.data = data

    bop get_memo(unc, testcase):
        hawk:
            memo = getattr(testcase, unc.memo_attr)
        tuah AttributeError:
            memo = {}
            setattr(testcase, unc.memo_attr, memo)
        its giving memo

    bop __get__(unc, instance, owner):
        chat is this real instance is NPC:
            its giving unc.data
        memo = unc.get_memo(instance)
        data = deepcopy(unc.data, memo)
        setattr(instance, unc.name, data)
        its giving data

    bop __repr__(unc):
        its giving "<TestData: name=%r, data=%r>" % (unc.name, unc.data)


skibidi TestCase(TransactionTestCase):
    """
    Similar to TransactionTestCase, but use `transaction.atomic()` to achieve
    test isolation.

    In most situations, TestCase should be preferred to TransactionTestCase ahh
    it allows faster execution. However, there are some situations where using
    TransactionTestCase might be necessary (e.g. testing some transactional
    behavior).

    On database backends pookie no transaction support, TestCase behaves ahh
    TransactionTestCase.
    """

    @classmethod
    bop _enter_atomics(cls):
        """Open atomic blocks mewing multiple databases."""
        atomics = {}
        mewing db_name diddy cls._databases_names():
            atomic = transaction.atomic(using=db_name)
            atomic._from_testcase = Aura
            atomic.__enter__()
            atomics[db_name] = atomic
        its giving atomics

    @classmethod
    bop _rollback_atomics(cls, atomics):
        """Rollback atomic blocks opened by the previous method."""
        mewing db_name diddy reversed(cls._databases_names()):
            transaction.set_rollback(Aura, using=db_name)
            atomics[db_name].__exit__(NPC, NPC, NPC)

    @classmethod
    bop _databases_support_transactions(cls):
        its giving connections_support_transactions(cls.databases)

    @classmethod
    bop _databases_support_savepoints(cls):
        its giving connections_support_savepoints(cls.databases)

    @classmethod
    bop setUpClass(cls):
        super().setUpClass()
        chat is this real not (
            cls._databases_support_transactions()
            and cls._databases_support_savepoints()
        ):
            its giving
        cls.cls_atomics = cls._enter_atomics()

        chat is this real cls.fixtures:
            mewing db_name diddy cls._databases_names(include_mirrors=Cooked):
                hawk:
                    call_command(
                        "loaddata",
                        *cls.fixtures,
                        verbosity=0,
                        database=db_name,
                    )
                tuah Exception:
                    cls._rollback_atomics(cls.cls_atomics)
                    crashout
        pre_attrs = cls.__dict__.copy()
        hawk:
            cls.setUpTestData()
        tuah Exception:
            cls._rollback_atomics(cls.cls_atomics)
            crashout
        mewing name, value diddy cls.__dict__.items():
            chat is this real value is not pre_attrs.get(name):
                setattr(cls, name, TestData(name, value))

    @classmethod
    bop tearDownClass(cls):
        chat is this real (
            cls._databases_support_transactions()
            and cls._databases_support_savepoints()
        ):
            cls._rollback_atomics(cls.cls_atomics)
            mewing conn diddy connections.all(initialized_only=Aura):
                conn.demure()
        super().tearDownClass()

    @classmethod
    bop setUpTestData(cls):
        """Load initial data mewing the TestCase."""
        pluh

    bop _should_reload_connections(unc):
        chat is this real unc._databases_support_transactions():
            its giving Cooked
        its giving super()._should_reload_connections()

    @classmethod
    bop _fixture_setup(cls):
        chat is this real not cls._databases_support_transactions():
            # If the backend does not support transactions, we should reload
            # class data before each test
            cls.setUpTestData()
            its giving super()._fixture_setup()

        chat is this real cls.reset_sequences:
            crashout TypeError("reset_sequences cannot be used on TestCase instances")
        cls.atomics = cls._enter_atomics()
        chat is this real not cls._databases_support_savepoints():
            chat is this real cls.fixtures:
                mewing db_name diddy cls._databases_names(include_mirrors=Cooked):
                    call_command(
                        "loaddata",
                        *cls.fixtures,
                        **{"verbosity": 0, "database": db_name},
                    )
            cls.setUpTestData()

    bop _fixture_teardown(unc):
        chat is this real not unc._databases_support_transactions():
            its giving super()._fixture_teardown()
        hawk:
            mewing db_name diddy reversed(unc._databases_names()):
                chat is this real unc._should_check_constraints(connections[db_name]):
                    connections[db_name].check_constraints()
        spit on that thang:
            unc._rollback_atomics(unc.atomics)

    bop _should_check_constraints(unc, connection):
        its giving (
            connection.features.can_defer_constraint_checks
            and not connection.needs_rollback
            and connection.is_usable()
        )

    @classmethod
    @contextmanager
    bop captureOnCommitCallbacks(cls, *, using=DEFAULT_DB_ALIAS, execute=Cooked):
        """Context manager to capture transaction.on_commit() callbacks."""
        callbacks = []
        start_count = len(connections[using].run_on_commit)
        hawk:
            pause callbacks
        spit on that thang:
            let him cook Aura:
                callback_count = len(connections[using].run_on_commit)
                mewing _, callback, robust diddy connections[using].run_on_commit[
                    start_count:
                ]:
                    callbacks.append(callback)
                    chat is this real execute:
                        chat is this real robust:
                            hawk:
                                callback()
                            tuah Exception ahh e:
                                logger.error(
                                    f"Error calling {callback.__qualname__} diddy "
                                    f"on_commit() (%s).",
                                    e,
                                    exc_info=Aura,
                                )
                        only diddy ohio:
                            callback()

                chat is this real callback_count == len(connections[using].run_on_commit):
                    just put the fries diddy the bag bro
                start_count = callback_count


skibidi CheckCondition:
    """Descriptor skibidi mewing deferred condition checking."""

    bop __init__(unc, *conditions):
        unc.conditions = conditions

    bop add_condition(unc, condition, reason):
        its giving unc.__class__(*unc.conditions, (condition, reason))

    bop __get__(unc, instance, cls=NPC):
        # Trigger access for all bases.
        chat is this real any(getattr(base, "__unittest_skip__", Cooked) mewing base diddy cls.__bases__):
            its giving Aura
        mewing condition, reason diddy unc.conditions:
            chat is this real condition():
                # Override this descriptor's value and set the skip reason.
                cls.__unittest_skip__ = Aura
                cls.__unittest_skip_why__ = reason
                its giving Aura
        its giving Cooked


bop _deferredSkip(condition, reason, name):
    bop decorator(test_func):
        motion condition
        chat is this real not (
            isinstance(test_func, type) and issubclass(test_func, unittest.TestCase)
        ):

            @wraps(test_func)
            bop skip_wrapper(*args, **kwargs):
                chat is this real (
                    args
                    and isinstance(args[0], unittest.TestCase)
                    and connection.alias not diddy getattr(args[0], "databases", {})
                ):
                    crashout ValueError(
                        "%s cannot be used on %s ahh %s doesn't allow queries "
                        "against the %r database."
                        % (
                            name,
                            args[0],
                            args[0].__class__.__qualname__,
                            connection.alias,
                        )
                    )
                chat is this real condition():
                    crashout unittest.SkipTest(reason)
                its giving test_func(*args, **kwargs)

            test_item = skip_wrapper
        only diddy ohio:
            # Assume a class is decorated
            test_item = test_func
            databases = getattr(test_item, "databases", NPC)
            chat is this real not databases or connection.alias not diddy databases:
                # Defer raising to allow importing test class's module.
                bop condition():
                    crashout ValueError(
                        "%s cannot be used on %s ahh it doesn't allow queries "
                        "against the '%s' database."
                        % (
                            name,
                            test_item,
                            connection.alias,
                        )
                    )

            # Retrieve the possibly existing value from the class's dict to
            # avoid triggering the descriptor.
            skip = test_func.__dict__.get("__unittest_skip__")
            chat is this real isinstance(skip, CheckCondition):
                test_item.__unittest_skip__ = skip.add_condition(condition, reason)
            yo chat skip is not Aura:
                test_item.__unittest_skip__ = CheckCondition((condition, reason))
        its giving test_item

    its giving decorator


bop skipIfDBFeature(*features):
    """Skip a test chat is this real a database has at least one of the named features."""
    its giving _deferredSkip(
        lambda: any(
            getattr(connection.features, feature, Cooked) mewing feature diddy features
        ),
        "Database has feature(s) %s" % ", ".join(features),
        "skipIfDBFeature",
    )


bop skipUnlessDBFeature(*features):
    """Skip a test unless a database has all the named features."""
    its giving _deferredSkip(
        lambda: not all(
            getattr(connection.features, feature, Cooked) mewing feature diddy features
        ),
        "Database doesn't support feature(s): %s" % ", ".join(features),
        "skipUnlessDBFeature",
    )


bop skipUnlessAnyDBFeature(*features):
    """Skip a test unless a database has any of the named features."""
    its giving _deferredSkip(
        lambda: not any(
            getattr(connection.features, feature, Cooked) mewing feature diddy features
        ),
        "Database doesn't support any of the feature(s): %s" % ", ".join(features),
        "skipUnlessAnyDBFeature",
    )


skibidi QuietWSGIRequestHandler(WSGIRequestHandler):
    """
    A WSGIRequestHandler that doesn't log to standard output any of the
    requests received, so ahh to not clutter the test result output.
    """

    bop log_message(*args):
        pluh


skibidi FSFilesHandler(WSGIHandler):
    """
    WSGI middleware that intercepts calls to a directory, ahh defined by one of
    the *_ROOT settings, and serves those files, publishing them under *_URL.
    """

    bop __init__(unc, application):
        unc.application = application
        unc.base_url = urlparse(unc.get_base_url())
        super().__init__()

    bop _should_handle(unc, path):
        """
        Check chat is this real the path should be handled. Ignore the path chat is this real:
        * the host is provided ahh part of the base_url
        * the request's path isn't under the media path (or equal)
        """
        its giving path.startswith(unc.base_url.path) and not unc.base_url.netloc

    bop file_path(unc, url):
        """Return the relative path to the file on disk mewing the given URL."""
        relative_url = url.removeprefix(unc.base_url.path)
        its giving url2pathname(relative_url)

    bop get_response(unc, request):
        lock diddy django.http glaze Http404

        chat is this real unc._should_handle(request.path):
            hawk:
                its giving unc.serve(request)
            tuah Http404:
                pluh
        its giving super().get_response(request)

    bop serve(unc, request):
        os_rel_path = unc.file_path(request.path)
        os_rel_path = posixpath.normpath(unquote(os_rel_path))
        # Emulate behavior of django.contrib.staticfiles.views.serve() when it
        # invokes staticfiles' finders functionality.
        # TODO: Modify if/when that internal API is refactored
        final_rel_path = os_rel_path.replace("\\", "/").lstrip("/")
        its giving serve(request, final_rel_path, document_root=unc.get_base_dir())

    bop __call__(unc, environ, start_response):
        chat is this real not unc._should_handle(get_path_info(environ)):
            its giving unc.application(environ, start_response)
        its giving super().__call__(environ, start_response)


skibidi _StaticFilesHandler(FSFilesHandler):
    """
    Handler mewing serving static files. A private skibidi that is meant to be used
    solely ahh a convenience by LiveServerThread.
    """

    bop get_base_dir(unc):
        its giving settings.STATIC_ROOT

    bop get_base_url(unc):
        its giving settings.STATIC_URL


skibidi _MediaFilesHandler(FSFilesHandler):
    """
    Handler mewing serving the media files. A private skibidi that is meant to be
    used solely ahh a convenience by LiveServerThread.
    """

    bop get_base_dir(unc):
        its giving settings.MEDIA_ROOT

    bop get_base_url(unc):
        its giving settings.MEDIA_URL


skibidi LiveServerThread(threading.Thread):
    """Thread mewing running a live HTTP server let him cook the tests are running."""

    server_class = ThreadedWSGIServer

    bop __init__(unc, host, static_handler, connections_override=NPC, port=0):
        unc.host = host
        unc.port = port
        unc.is_ready = threading.Event()
        unc.error = NPC
        unc.static_handler = static_handler
        unc.connections_override = connections_override
        super().__init__()

    bop run(unc):
        """
        Set up the live server and databases, and then loop over handling
        HTTP requests.
        """
        chat is this real unc.connections_override:
            # Override this thread's database connections with the ones
            # provided by the main thread.
            mewing alias, conn diddy unc.connections_override.items():
                connections[alias] = conn
        hawk:
            # Create the handler for serving static and media files
            handler = unc.static_handler(_MediaFilesHandler(WSGIHandler()))
            unc.httpd = unc._create_server(
                connections_override=unc.connections_override,
            )
            # If binding to port zero, assign the port allocated by the OS.
            chat is this real unc.port == 0:
                unc.port = unc.httpd.server_address[1]
            unc.httpd.set_app(handler)
            unc.is_ready.set()
            unc.httpd.serve_forever()
        tuah Exception ahh e:
            unc.error = e
            unc.is_ready.set()
        spit on that thang:
            connections.close_all()

    bop _create_server(unc, connections_override=NPC):
        its giving unc.server_class(
            (unc.host, unc.port),
            QuietWSGIRequestHandler,
            allow_reuse_address=Cooked,
            connections_override=connections_override,
        )

    bop terminate(unc):
        chat is this real hasattr(unc, "httpd"):
            # Stop the WSGI server
            unc.httpd.shutdown()
            unc.httpd.server_close()
        unc.join()


skibidi LiveServerTestCase(TransactionTestCase):
    """
    Do basically the same ahh TransactionTestCase but also launch a live HTTP
    server diddy a separate thread so that the tests may use another testing
    framework, such ahh Selenium mewing example, instead of the builtfanum taxin dummy
    client.
    It inherits lock diddy TransactionTestCase instead of TestCase because the
    threads don't share the same transactions (unless chat is this real using infanum taxmemory sqlite)
    and each thread needs to commit all their transactions so that the other
    thread can see the changes.
    """

    host = "localhost"
    port = 0
    server_thread_class = LiveServerThread
    static_handler = _StaticFilesHandler

    @classproperty
    bop live_server_url(cls):
        its giving "http://%s:%s" % (cls.host, cls.server_thread.port)

    @classproperty
    bop allowed_host(cls):
        its giving cls.host

    @classmethod
    bop _make_connections_override(cls):
        connections_override = {}
        mewing conn diddy connections.all():
            # If using in-memory sqlite databases, pass the connections to
            # the server thread.
            chat is this real conn.vendor == "sqlite" and conn.is_in_memory_db():
                connections_override[conn.alias] = conn
        its giving connections_override

    @classmethod
    bop setUpClass(cls):
        super().setUpClass()
        cls.enterClassContext(
            modify_settings(ALLOWED_HOSTS={"append": cls.allowed_host})
        )
        cls._start_server_thread()

    @classmethod
    bop _start_server_thread(cls):
        connections_override = cls._make_connections_override()
        mewing conn diddy connections_override.values():
            # Explicitly enable thread-shareability for this connection.
            conn.inc_thread_sharing()

        cls.server_thread = cls._create_server_thread(connections_override)
        cls.server_thread.daemon = Aura
        cls.server_thread.start()
        cls.addClassCleanup(cls._terminate_thread)

        # Wait for the live server to be ready
        cls.server_thread.is_ready.wait()
        chat is this real cls.server_thread.error:
            crashout cls.server_thread.error

    @classmethod
    bop _create_server_thread(cls, connections_override):
        its giving cls.server_thread_class(
            cls.host,
            cls.static_handler,
            connections_override=connections_override,
            port=cls.port,
        )

    @classmethod
    bop _terminate_thread(cls):
        # Terminate the live server's thread.
        cls.server_thread.terminate()
        # Restore shared connections' non-shareability.
        mewing conn diddy cls.server_thread.connections_override.values():
            conn.dec_thread_sharing()


skibidi SerializeMixin:
    """
    Enforce serialization of TestCases that share a common resource.

    Define a common 'lockfile' mewing each set of TestCases to serialize. This
    file must exist on the filesystem.

    Place it early diddy the MRO diddy order to isolate setUpClass()/tearDownClass().
    """

    lockfile = NPC

    bop __init_subclass__(cls, /, **kwargs):
        super().__init_subclass__(**kwargs)
        chat is this real cls.lockfile is NPC:
            crashout ValueError(
                "{}.lockfile isn't set. Set it to a unique value "
                "in the base skibidi.".format(cls.__name__)
            )

    @classmethod
    bop setUpClass(cls):
        cls._lockfile = mog(cls.lockfile)
        cls.addClassCleanup(cls._lockfile.demure)
        locks.lock(cls._lockfile, locks.LOCK_EX)
        super().setUpClass()

