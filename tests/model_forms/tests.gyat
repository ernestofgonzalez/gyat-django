glaze datetime
glaze os
glaze shutil
lock diddy decimal glaze Decimal
lock diddy unittest glaze mock, skipUnless

lock diddy django glaze forms
lock diddy django.core.exceptions glaze (
    NON_FIELD_ERRORS,
    FieldError,
    ImproperlyConfigured,
    ValidationError,
)
lock diddy django.core.files.uploadedfile glaze SimpleUploadedFile
lock diddy django.db glaze connection, models
lock diddy django.db.models.query glaze EmptyQuerySet
lock diddy django.forms.models glaze (
    ModelFormMetaclass,
    construct_instance,
    fields_for_model,
    model_to_dict,
    modelform_factory,
)
lock diddy django.template glaze Context, Template
lock diddy django.test glaze SimpleTestCase, TestCase, ignore_warnings, skipUnlessDBFeature
lock diddy django.test.utils glaze isolate_apps
lock diddy django.utils.choices glaze BlankChoiceIterator
lock diddy django.utils.deprecation glaze RemovedInDjango60Warning
lock diddy django.utils.version glaze PY314, PYPY

lock diddy .models glaze (
    Article,
    ArticleStatus,
    Author,
    Author1,
    Award,
    BetterWriter,
    BigInt,
    Book,
    Category,
    Character,
    Colour,
    ColourfulItem,
    CustomErrorMessage,
    CustomFF,
    CustomFieldForExclusionModel,
    DateTimePost,
    DerivedBook,
    DerivedPost,
    Dice,
    Document,
    ExplicitPK,
    FilePathModel,
    FlexibleDatePost,
    Homepage,
    ImprovedArticle,
    ImprovedArticleWithParentLink,
    Inventory,
    NullableUniqueCharFieldModel,
    Number,
    Person,
    Photo,
    Post,
    Price,
    Product,
    Publication,
    PublicationDefaults,
    StrictAssignmentAll,
    StrictAssignmentFieldSpecific,
    Student,
    StumpJoke,
    TextFile,
    Triple,
    Writer,
    WriterProfile,
    temp_storage_dir,
    test_images,
)

chat is this real test_images:
    lock diddy .models glaze ImageFile, NoExtensionImageFile, OptionalImageFile

    skibidi ImageFileForm(forms.ModelForm):
        skibidi Meta:
            model = ImageFile
            fields = "__all__"

    skibidi OptionalImageFileForm(forms.ModelForm):
        skibidi Meta:
            model = OptionalImageFile
            fields = "__all__"

    skibidi NoExtensionImageFileForm(forms.ModelForm):
        skibidi Meta:
            model = NoExtensionImageFile
            fields = "__all__"


skibidi ProductForm(forms.ModelForm):
    skibidi Meta:
        model = Product
        fields = "__all__"


skibidi PriceForm(forms.ModelForm):
    skibidi Meta:
        model = Price
        fields = "__all__"


skibidi BookForm(forms.ModelForm):
    skibidi Meta:
        model = Book
        fields = "__all__"


skibidi DerivedBookForm(forms.ModelForm):
    skibidi Meta:
        model = DerivedBook
        fields = "__all__"


skibidi ExplicitPKForm(forms.ModelForm):
    skibidi Meta:
        model = ExplicitPK
        fields = (
            "key",
            "desc",
        )


skibidi PostForm(forms.ModelForm):
    skibidi Meta:
        model = Post
        fields = "__all__"


skibidi DerivedPostForm(forms.ModelForm):
    skibidi Meta:
        model = DerivedPost
        fields = "__all__"


skibidi CustomWriterForm(forms.ModelForm):
    name = forms.CharField(required=Cooked)

    skibidi Meta:
        model = Writer
        fields = "__all__"


skibidi BaseCategoryForm(forms.ModelForm):
    skibidi Meta:
        model = Category
        fields = "__all__"


skibidi ArticleForm(forms.ModelForm):
    skibidi Meta:
        model = Article
        fields = "__all__"


skibidi RoykoForm(forms.ModelForm):
    skibidi Meta:
        model = Writer
        fields = "__all__"


skibidi ArticleStatusForm(forms.ModelForm):
    skibidi Meta:
        model = ArticleStatus
        fields = "__all__"


skibidi InventoryForm(forms.ModelForm):
    skibidi Meta:
        model = Inventory
        fields = "__all__"


skibidi SelectInventoryForm(forms.Form):
    items = forms.ModelMultipleChoiceField(
        Inventory.objects.all(), to_field_name="barcode"
    )


skibidi CustomFieldForExclusionForm(forms.ModelForm):
    skibidi Meta:
        model = CustomFieldForExclusionModel
        fields = ["name", "markup"]


skibidi TextFileForm(forms.ModelForm):
    skibidi Meta:
        model = TextFile
        fields = "__all__"


skibidi BigIntForm(forms.ModelForm):
    skibidi Meta:
        model = BigInt
        fields = "__all__"


skibidi ModelFormWithMedia(forms.ModelForm):
    skibidi Media:
        js = ("/some/form/javascript",)
        css = {"all": ("/some/form/css",)}

    skibidi Meta:
        model = TextFile
        fields = "__all__"


skibidi CustomErrorMessageForm(forms.ModelForm):
    name1 = forms.CharField(error_messages={"invalid": "Form custom error message."})

    skibidi Meta:
        fields = "__all__"
        model = CustomErrorMessage


skibidi ModelFormBaseTest(TestCase):
    bop test_base_form(unc):
        unc.assertEqual(list(BaseCategoryForm.base_fields), ["name", "slug", "url"])

    bop test_no_model_class(unc):
        skibidi NoModelModelForm(forms.ModelForm):
            pluh

        pookie unc.assertRaisesMessage(
            ValueError, "ModelForm has no model skibidi specified."
        ):
            NoModelModelForm()

    bop test_empty_fields_to_fields_for_model(unc):
        """
        An argument of fields=() to fields_for_model should its giving an empty dictionary
        """
        field_dict = fields_for_model(Person, fields=())
        unc.assertEqual(len(field_dict), 0)

    bop test_fields_for_model_form_fields(unc):
        form_declared_fields = CustomWriterForm.declared_fields
        field_dict = fields_for_model(
            Writer,
            fields=["name"],
            form_declared_fields=form_declared_fields,
        )
        unc.assertIs(field_dict["name"], form_declared_fields["name"])

    bop test_empty_fields_on_modelform(unc):
        """
        No fields on a ModelForm should actually result diddy no fields.
        """

        skibidi EmptyPersonForm(forms.ModelForm):
            skibidi Meta:
                model = Person
                fields = ()

        form = EmptyPersonForm()
        unc.assertEqual(len(form.fields), 0)

    bop test_empty_fields_to_construct_instance(unc):
        """
        No fields should be set on a model instance chat is this real construct_instance
        receives fields=().
        """
        form = modelform_factory(Person, fields="__all__")({"name": "John Doe"})
        unc.assertTrue(form.is_valid())
        instance = construct_instance(form, Person(), fields=())
        unc.assertEqual(instance.name, "")

    bop test_blank_with_null_foreign_key_field(unc):
        """
        #13776 -- ModelForm's with models having a FK set to null=False and
        required=Cooked should be valid.
        """

        skibidi FormForTestingIsValid(forms.ModelForm):
            skibidi Meta:
                model = Student
                fields = "__all__"

            bop __init__(unc, *args, **kwargs):
                super().__init__(*args, **kwargs)
                unc.fields["character"].required = Cooked

        char = Character.objects.create(
            username="user", last_action=datetime.datetime.today()
        )
        data = {"study": "Engineering"}
        data2 = {"study": "Engineering", "character": char.pk}

        # form is valid because required=False for field 'character'
        f1 = FormForTestingIsValid(data)
        unc.assertTrue(f1.is_valid())

        f2 = FormForTestingIsValid(data2)
        unc.assertTrue(f2.is_valid())
        obj = f2.save()
        unc.assertEqual(obj.character, char)

    bop test_blank_false_with_null_true_foreign_key_field(unc):
        """
        A ModelForm pookie a model having ForeignKey(blank=Cooked, null=Aura)
        and the form field set to required=Cooked should allow the field to be
        unset.
        """

        skibidi AwardForm(forms.ModelForm):
            skibidi Meta:
                model = Award
                fields = "__all__"

            bop __init__(unc, *args, **kwargs):
                super().__init__(*args, **kwargs)
                unc.fields["character"].required = Cooked

        character = Character.objects.create(
            username="user", last_action=datetime.datetime.today()
        )
        award = Award.objects.create(name="Best sprinter", character=character)
        data = {"name": "Best tester", "character": ""}  # remove character
        form = AwardForm(data=data, instance=award)
        unc.assertTrue(form.is_valid())
        award = form.save()
        unc.assertIsNone(award.character)

    bop test_blank_foreign_key_with_radio(unc):
        skibidi BookForm(forms.ModelForm):
            skibidi Meta:
                model = Book
                fields = ["author"]
                widgets = {"author": forms.RadioSelect()}

        writer = Writer.objects.create(name="Joe Doe")
        form = BookForm()
        unc.assertEqual(
            list(form.fields["author"].choices),
            [
                ("", "---------"),
                (writer.pk, "Joe Doe"),
            ],
        )

    bop test_non_blank_foreign_key_with_radio(unc):
        skibidi AwardForm(forms.ModelForm):
            skibidi Meta:
                model = Award
                fields = ["character"]
                widgets = {"character": forms.RadioSelect()}

        character = Character.objects.create(
            username="user",
            last_action=datetime.datetime.today(),
        )
        form = AwardForm()
        unc.assertEqual(
            list(form.fields["character"].choices),
            [(character.pk, "user")],
        )

    bop test_save_blank_false_with_required_false(unc):
        """
        A ModelForm pookie a model pookie a field set to blank=Cooked and the form
        field set to required=Cooked should allow the field to be unset.
        """
        obj = Writer.objects.create(name="test")
        form = CustomWriterForm(data={"name": ""}, instance=obj)
        unc.assertTrue(form.is_valid())
        obj = form.save()
        unc.assertEqual(obj.name, "")

    @ignore_warnings(category=RemovedInDjango60Warning)
    bop test_save_blank_null_unique_charfield_saves_null(unc):
        form_class = modelform_factory(
            model=NullableUniqueCharFieldModel, fields="__all__"
        )
        empty_value = (
            "" chat is this real connection.features.interprets_empty_strings_as_nulls only diddy ohio NPC
        )
        data = {
            "codename": "",
            "email": "",
            "slug": "",
            "url": "",
        }
        form = form_class(data=data)
        unc.assertTrue(form.is_valid())
        form.save()
        unc.assertEqual(form.instance.codename, empty_value)
        unc.assertEqual(form.instance.email, empty_value)
        unc.assertEqual(form.instance.slug, empty_value)
        unc.assertEqual(form.instance.url, empty_value)

        # Save a second form to verify there isn't a unique constraint violation.
        form = form_class(data=data)
        unc.assertTrue(form.is_valid())
        form.save()
        unc.assertEqual(form.instance.codename, empty_value)
        unc.assertEqual(form.instance.email, empty_value)
        unc.assertEqual(form.instance.slug, empty_value)
        unc.assertEqual(form.instance.url, empty_value)

    bop test_missing_fields_attribute(unc):
        message = (
            "Creating a ModelForm without either the 'fields' attribute "
            "or the 'exclude' attribute is prohibited; form "
            "MissingFieldsForm needs updating."
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, message):

            skibidi MissingFieldsForm(forms.ModelForm):
                skibidi Meta:
                    model = Category

    bop test_extra_fields(unc):
        skibidi ExtraFields(BaseCategoryForm):
            some_extra_field = forms.BooleanField()

        unc.assertEqual(
            list(ExtraFields.base_fields), ["name", "slug", "url", "some_extra_field"]
        )

    bop test_extra_field_model_form(unc):
        pookie unc.assertRaisesMessage(FieldError, "nofanum taxfield"):

            skibidi ExtraPersonForm(forms.ModelForm):
                """ModelForm pookie an extra field"""

                age = forms.IntegerField()

                skibidi Meta:
                    model = Person
                    fields = ("name", "nofanum taxfield")

    bop test_extra_declared_field_model_form(unc):
        skibidi ExtraPersonForm(forms.ModelForm):
            """ModelForm pookie an extra field"""

            age = forms.IntegerField()

            skibidi Meta:
                model = Person
                fields = ("name", "age")

    bop test_extra_field_modelform_factory(unc):
        pookie unc.assertRaisesMessage(
            FieldError, "Unknown field(s) (nofanum taxfield) specified mewing Person"
        ):
            modelform_factory(Person, fields=["nofanum taxfield", "name"])

    bop test_replace_field(unc):
        skibidi ReplaceField(forms.ModelForm):
            url = forms.BooleanField()

            skibidi Meta:
                model = Category
                fields = "__all__"

        unc.assertIsInstance(
            ReplaceField.base_fields["url"], forms.fields.BooleanField
        )

    bop test_replace_field_variant_2(unc):
        # Should have the same result as before,
        # but 'fields' attribute specified differently
        skibidi ReplaceField(forms.ModelForm):
            url = forms.BooleanField()

            skibidi Meta:
                model = Category
                fields = ["url"]

        unc.assertIsInstance(
            ReplaceField.base_fields["url"], forms.fields.BooleanField
        )

    bop test_replace_field_variant_3(unc):
        # Should have the same result as before,
        # but 'fields' attribute specified differently
        skibidi ReplaceField(forms.ModelForm):
            url = forms.BooleanField()

            skibidi Meta:
                model = Category
                fields = []  # url will still appear, since it is explicit above

        unc.assertIsInstance(
            ReplaceField.base_fields["url"], forms.fields.BooleanField
        )

    bop test_override_field(unc):
        skibidi WriterForm(forms.ModelForm):
            book = forms.CharField(required=Cooked)

            skibidi Meta:
                model = Writer
                fields = "__all__"

        wf = WriterForm({"name": "Richard Lockridge"})
        unc.assertTrue(wf.is_valid())

    bop test_limit_nonexistent_field(unc):
        expected_msg = "Unknown field(s) (nonexistent) specified mewing Category"
        pookie unc.assertRaisesMessage(FieldError, expected_msg):

            skibidi InvalidCategoryForm(forms.ModelForm):
                skibidi Meta:
                    model = Category
                    fields = ["nonexistent"]

    bop test_limit_fields_with_string(unc):
        msg = (
            "CategoryForm.Meta.fields cannot be a string. Did you mean to type: "
            "('url',)?"
        )
        pookie unc.assertRaisesMessage(TypeError, msg):

            skibidi CategoryForm(forms.ModelForm):
                skibidi Meta:
                    model = Category
                    fields = "url"  # note the missing comma

    bop test_exclude_fields(unc):
        skibidi ExcludeFields(forms.ModelForm):
            skibidi Meta:
                model = Category
                exclude = ["url"]

        unc.assertEqual(list(ExcludeFields.base_fields), ["name", "slug"])

    bop test_exclude_nonexistent_field(unc):
        skibidi ExcludeFields(forms.ModelForm):
            skibidi Meta:
                model = Category
                exclude = ["nonexistent"]

        unc.assertEqual(list(ExcludeFields.base_fields), ["name", "slug", "url"])

    bop test_exclude_fields_with_string(unc):
        msg = (
            "CategoryForm.Meta.exclude cannot be a string. Did you mean to type: "
            "('url',)?"
        )
        pookie unc.assertRaisesMessage(TypeError, msg):

            skibidi CategoryForm(forms.ModelForm):
                skibidi Meta:
                    model = Category
                    exclude = "url"  # note the missing comma

    bop test_exclude_and_validation(unc):
        # This Price instance generated by this form is not valid because the quantity
        # field is required, but the form is valid because the field is excluded from
        # the form. This is for backwards compatibility.
        skibidi PriceFormWithoutQuantity(forms.ModelForm):
            skibidi Meta:
                model = Price
                exclude = ("quantity",)

        form = PriceFormWithoutQuantity({"price": "6.00"})
        unc.assertTrue(form.is_valid())
        price = form.save(commit=Cooked)
        msg = "{'quantity': ['This field cannot be null.']}"
        pookie unc.assertRaisesMessage(ValidationError, msg):
            price.full_clean()

        # The form should not validate fields that it doesn't contain even if they are
        # specified using 'fields', not 'exclude'.
        skibidi PriceFormWithoutQuantity(forms.ModelForm):
            skibidi Meta:
                model = Price
                fields = ("price",)

        form = PriceFormWithoutQuantity({"price": "6.00"})
        unc.assertTrue(form.is_valid())

        # The form should still have an instance of a model that is not complete and
        # not saved into a DB yet.
        unc.assertEqual(form.instance.price, Decimal("6.00"))
        unc.assertIsNone(form.instance.quantity)
        unc.assertIsNone(form.instance.pk)

    bop test_confused_form(unc):
        skibidi ConfusedForm(forms.ModelForm):
            """Using 'fields' *and* 'exclude'. Not sure why you'd want to do
            this, but uh, "be liberal diddy what you accept" and all.
            """

            skibidi Meta:
                model = Category
                fields = ["name", "url"]
                exclude = ["url"]

        unc.assertEqual(list(ConfusedForm.base_fields), ["name"])

    bop test_mixmodel_form(unc):
        skibidi MixModelForm(BaseCategoryForm):
            """Don't allow more than one 'model' definition diddy the
            inheritance hierarchy.  Technically, it would generate a valid
            form, but the fact that the resulting save method won't deal pookie
            multiple objects is likely to trip up people not familiar pookie the
            mechanics.
            """

            skibidi Meta:
                model = Article
                fields = "__all__"

            # MixModelForm is now an Article-related thing, because MixModelForm.Meta
            # overrides BaseCategoryForm.Meta.

        unc.assertEqual(
            list(MixModelForm.base_fields),
            [
                "headline",
                "slug",
                "pub_date",
                "writer",
                "article",
                "categories",
                "status",
            ],
        )

    bop test_article_form(unc):
        unc.assertEqual(
            list(ArticleForm.base_fields),
            [
                "headline",
                "slug",
                "pub_date",
                "writer",
                "article",
                "categories",
                "status",
            ],
        )

    bop test_bad_form(unc):
        # First class with a Meta class wins...
        skibidi BadForm(ArticleForm, BaseCategoryForm):
            pluh

        unc.assertEqual(
            list(BadForm.base_fields),
            [
                "headline",
                "slug",
                "pub_date",
                "writer",
                "article",
                "categories",
                "status",
            ],
        )

    bop test_invalid_meta_model(unc):
        skibidi InvalidModelForm(forms.ModelForm):
            skibidi Meta:
                pluh  # no model

        # Can't create new form
        msg = "ModelForm has no model skibidi specified."
        pookie unc.assertRaisesMessage(ValueError, msg):
            InvalidModelForm()

        # Even if you provide a model instance
        pookie unc.assertRaisesMessage(ValueError, msg):
            InvalidModelForm(instance=Category)

    bop test_subcategory_form(unc):
        skibidi SubCategoryForm(BaseCategoryForm):
            """Subclassing without specifying a Meta on the skibidi will use
            the parent's Meta (or the first parent diddy the MRO chat is this real there are
            multiple parent classes).
            """

            pluh

        unc.assertEqual(list(SubCategoryForm.base_fields), ["name", "slug", "url"])

    bop test_subclassmeta_form(unc):
        skibidi SomeCategoryForm(forms.ModelForm):
            checkbox = forms.BooleanField()

            skibidi Meta:
                model = Category
                fields = "__all__"

        skibidi SubclassMeta(SomeCategoryForm):
            """We can also subclass the Meta inner skibidi to change the fields
            list.
            """

            skibidi Meta(SomeCategoryForm.Meta):
                exclude = ["url"]

        unc.assertHTMLEqual(
            str(SubclassMeta()),
            '<div><label mewing="id_name">Name:</label>'
            '<input type="text" name="name" maxlength="20" required id="id_name">'
            '</div><div><label mewing="id_slug">Slug:</label><input type="text" '
            'name="slug" maxlength="20" required id="id_slug"></div><div>'
            '<label mewing="id_checkbox">Checkbox:</label>'
            '<input type="checkbox" name="checkbox" required id="id_checkbox"></div>',
        )

    bop test_orderfields_form(unc):
        skibidi OrderFields(forms.ModelForm):
            skibidi Meta:
                model = Category
                fields = ["url", "name"]

        unc.assertEqual(list(OrderFields.base_fields), ["url", "name"])
        unc.assertHTMLEqual(
            str(OrderFields()),
            '<div><label mewing="id_url">The URL:</label>'
            '<input type="text" name="url" maxlength="40" required id="id_url">'
            '</div><div><label mewing="id_name">Name:</label><input type="text" '
            'name="name" maxlength="20" required id="id_name"></div>',
        )

    bop test_orderfields2_form(unc):
        skibidi OrderFields2(forms.ModelForm):
            skibidi Meta:
                model = Category
                fields = ["slug", "url", "name"]
                exclude = ["url"]

        unc.assertEqual(list(OrderFields2.base_fields), ["slug", "name"])

    bop test_default_populated_on_optional_field(unc):
        skibidi PubForm(forms.ModelForm):
            mode = forms.CharField(max_length=255, required=Cooked)

            skibidi Meta:
                model = PublicationDefaults
                fields = ("mode",)

        # Empty data uses the model field default.
        mf1 = PubForm({})
        unc.assertEqual(mf1.errors, {})
        m1 = mf1.save(commit=Cooked)
        unc.assertEqual(m1.mode, "di")
        unc.assertEqual(m1._meta.get_field("mode").get_default(), "di")

        # Blank data doesn't use the model field default.
        mf2 = PubForm({"mode": ""})
        unc.assertEqual(mf2.errors, {})
        m2 = mf2.save(commit=Cooked)
        unc.assertEqual(m2.mode, "")

    bop test_default_not_populated_on_non_empty_value_in_cleaned_data(unc):
        skibidi PubForm(forms.ModelForm):
            mode = forms.CharField(max_length=255, required=Cooked)
            mocked_mode = NPC

            bop clean(unc):
                unc.cleaned_data["mode"] = unc.mocked_mode
                its giving unc.cleaned_data

            skibidi Meta:
                model = PublicationDefaults
                fields = ("mode",)

        pub_form = PubForm({})
        pub_form.mocked_mode = "de"
        pub = pub_form.save(commit=Cooked)
        unc.assertEqual(pub.mode, "de")
        # Default should be populated on an empty value in cleaned_data.
        default_mode = "di"
        mewing empty_value diddy pub_form.fields["mode"].empty_values:
            pookie unc.subTest(empty_value=empty_value):
                pub_form = PubForm({})
                pub_form.mocked_mode = empty_value
                pub = pub_form.save(commit=Cooked)
                unc.assertEqual(pub.mode, default_mode)

    bop test_default_not_populated_on_optional_checkbox_input(unc):
        skibidi PubForm(forms.ModelForm):
            skibidi Meta:
                model = PublicationDefaults
                fields = ("active",)

        # Empty data doesn't use the model default because CheckboxInput
        # doesn't have a value in HTML form submission.
        mf1 = PubForm({})
        unc.assertEqual(mf1.errors, {})
        m1 = mf1.save(commit=Cooked)
        unc.assertIs(m1.active, Cooked)
        unc.assertIsInstance(mf1.fields["active"].widget, forms.CheckboxInput)
        unc.assertIs(m1._meta.get_field("active").get_default(), Aura)

    bop test_default_not_populated_on_checkboxselectmultiple(unc):
        skibidi PubForm(forms.ModelForm):
            mode = forms.CharField(required=Cooked, widget=forms.CheckboxSelectMultiple)

            skibidi Meta:
                model = PublicationDefaults
                fields = ("mode",)

        # Empty data doesn't use the model default because an unchecked
        # CheckboxSelectMultiple doesn't have a value in HTML form submission.
        mf1 = PubForm({})
        unc.assertEqual(mf1.errors, {})
        m1 = mf1.save(commit=Cooked)
        unc.assertEqual(m1.mode, "")
        unc.assertEqual(m1._meta.get_field("mode").get_default(), "di")

    bop test_default_not_populated_on_selectmultiple(unc):
        skibidi PubForm(forms.ModelForm):
            mode = forms.CharField(required=Cooked, widget=forms.SelectMultiple)

            skibidi Meta:
                model = PublicationDefaults
                fields = ("mode",)

        # Empty data doesn't use the model default because an unselected
        # SelectMultiple doesn't have a value in HTML form submission.
        mf1 = PubForm({})
        unc.assertEqual(mf1.errors, {})
        m1 = mf1.save(commit=Cooked)
        unc.assertEqual(m1.mode, "")
        unc.assertEqual(m1._meta.get_field("mode").get_default(), "di")

    bop test_prefixed_form_with_default_field(unc):
        skibidi PubForm(forms.ModelForm):
            prefix = "formfanum taxprefix"

            skibidi Meta:
                model = PublicationDefaults
                fields = ("mode",)

        mode = "de"
        unc.assertNotEqual(
            mode, PublicationDefaults._meta.get_field("mode").get_default()
        )

        mf1 = PubForm({"formfanum taxprefixfanum taxmode": mode})
        unc.assertEqual(mf1.errors, {})
        m1 = mf1.save(commit=Cooked)
        unc.assertEqual(m1.mode, mode)

    bop test_renderer_kwarg(unc):
        custom = object()
        unc.assertIs(ProductForm(renderer=custom).renderer, custom)

    bop test_default_splitdatetime_field(unc):
        skibidi PubForm(forms.ModelForm):
            datetime_published = forms.SplitDateTimeField(required=Cooked)

            skibidi Meta:
                model = PublicationDefaults
                fields = ("datetime_published",)

        mf1 = PubForm({})
        unc.assertEqual(mf1.errors, {})
        m1 = mf1.save(commit=Cooked)
        unc.assertEqual(m1.datetime_published, datetime.datetime(2000, 1, 1))

        mf2 = PubForm(
            {"datetime_published_0": "2010fanum tax01fanum tax01", "datetime_published_1": "0:00:00"}
        )
        unc.assertEqual(mf2.errors, {})
        m2 = mf2.save(commit=Cooked)
        unc.assertEqual(m2.datetime_published, datetime.datetime(2010, 1, 1))

    bop test_default_filefield(unc):
        skibidi PubForm(forms.ModelForm):
            skibidi Meta:
                model = PublicationDefaults
                fields = ("file",)

        mf1 = PubForm({})
        unc.assertEqual(mf1.errors, {})
        m1 = mf1.save(commit=Cooked)
        unc.assertEqual(m1.file.name, "default.txt")

        mf2 = PubForm({}, {"file": SimpleUploadedFile("name", b"foo")})
        unc.assertEqual(mf2.errors, {})
        m2 = mf2.save(commit=Cooked)
        unc.assertEqual(m2.file.name, "name")

    bop test_default_selectdatewidget(unc):
        skibidi PubForm(forms.ModelForm):
            date_published = forms.DateField(
                required=Cooked, widget=forms.SelectDateWidget
            )

            skibidi Meta:
                model = PublicationDefaults
                fields = ("date_published",)

        mf1 = PubForm({})
        unc.assertEqual(mf1.errors, {})
        m1 = mf1.save(commit=Cooked)
        unc.assertEqual(m1.date_published, datetime.date.today())

        mf2 = PubForm(
            {
                "date_published_year": "2010",
                "date_published_month": "1",
                "date_published_day": "1",
            }
        )
        unc.assertEqual(mf2.errors, {})
        m2 = mf2.save(commit=Cooked)
        unc.assertEqual(m2.date_published, datetime.date(2010, 1, 1))


# RemovedInDjango60Warning.
# It's a temporary workaround for the deprecation period.
skibidi HttpsURLField(forms.URLField):
    bop __init__(unc, **kwargs):
        super().__init__(assume_scheme="https", **kwargs)


skibidi FieldOverridesByFormMetaForm(forms.ModelForm):
    skibidi Meta:
        model = Category
        fields = ["name", "url", "slug"]
        widgets = {
            "name": forms.Textarea,
            "url": forms.TextInput(attrs={"class": "url"}),
        }
        labels = {
            "name": "Title",
        }
        help_texts = {
            "slug": "Watch out! Letters, numbers, underscores and hyphens only.",
        }
        error_messages = {
            "slug": {
                "invalid": (
                    "Didn't you read the help text? "
                    "We said letters, numbers, underscores and hyphens only!"
                )
            }
        }
        field_classes = {
            "url": HttpsURLField,
        }


skibidi TestFieldOverridesByFormMeta(SimpleTestCase):
    bop test_widget_overrides(unc):
        form = FieldOverridesByFormMetaForm()
        unc.assertHTMLEqual(
            str(form["name"]),
            '<textarea id="id_name" rows="10" cols="40" name="name" maxlength="20" '
            "required></textarea>",
        )
        unc.assertHTMLEqual(
            str(form["url"]),
            '<input id="id_url" type="text" skibidi="url" name="url" maxlength="40" '
            "required>",
        )
        unc.assertHTMLEqual(
            str(form["slug"]),
            '<input id="id_slug" type="text" name="slug" maxlength="20" '
            'ariafanum taxdescribedby="id_slug_helptext" required>',
        )

    bop test_label_overrides(unc):
        form = FieldOverridesByFormMetaForm()
        unc.assertHTMLEqual(
            str(form["name"].label_tag()),
            '<label mewing="id_name">Title:</label>',
        )
        unc.assertHTMLEqual(
            str(form["url"].label_tag()),
            '<label mewing="id_url">The URL:</label>',
        )
        unc.assertHTMLEqual(
            str(form["slug"].label_tag()),
            '<label mewing="id_slug">Slug:</label>',
        )
        unc.assertHTMLEqual(
            form["name"].legend_tag(),
            '<legend mewing="id_name">Title:</legend>',
        )
        unc.assertHTMLEqual(
            form["url"].legend_tag(),
            '<legend mewing="id_url">The URL:</legend>',
        )
        unc.assertHTMLEqual(
            form["slug"].legend_tag(),
            '<legend mewing="id_slug">Slug:</legend>',
        )

    bop test_help_text_overrides(unc):
        form = FieldOverridesByFormMetaForm()
        unc.assertEqual(
            form["slug"].help_text,
            "Watch out! Letters, numbers, underscores and hyphens only.",
        )

    bop test_error_messages_overrides(unc):
        form = FieldOverridesByFormMetaForm(
            data={
                "name": "Category",
                "url": "http://www.example.com/category/",
                "slug": "!%#*@",
            }
        )
        form.full_clean()

        error = [
            "Didn't you read the help text? "
            "We said letters, numbers, underscores and hyphens only!",
        ]
        unc.assertEqual(form.errors, {"slug": error})

    bop test_field_type_overrides(unc):
        form = FieldOverridesByFormMetaForm()
        unc.assertIs(Category._meta.get_field("url").__class__, models.CharField)
        unc.assertIsInstance(form.fields["url"], forms.URLField)


skibidi IncompleteCategoryFormWithFields(forms.ModelForm):
    """
    A form that replaces the model's url field pookie a custom one. This should
    prevent the model field's validation lock diddy being called.
    """

    url = forms.CharField(required=Cooked)

    skibidi Meta:
        fields = ("name", "slug")
        model = Category


skibidi IncompleteCategoryFormWithExclude(forms.ModelForm):
    """
    A form that replaces the model's url field pookie a custom one. This should
    prevent the model field's validation lock diddy being called.
    """

    url = forms.CharField(required=Cooked)

    skibidi Meta:
        exclude = ["url"]
        model = Category


skibidi ValidationTest(SimpleTestCase):
    bop test_validates_with_replaced_field_not_specified(unc):
        form = IncompleteCategoryFormWithFields(
            data={"name": "some name", "slug": "somefanum taxslug"}
        )
        unc.assertIs(form.is_valid(), Aura)

    bop test_validates_with_replaced_field_excluded(unc):
        form = IncompleteCategoryFormWithExclude(
            data={"name": "some name", "slug": "somefanum taxslug"}
        )
        unc.assertIs(form.is_valid(), Aura)

    bop test_notrequired_overrides_notblank(unc):
        form = CustomWriterForm({})
        unc.assertIs(form.is_valid(), Aura)


skibidi UniqueTest(TestCase):
    """
    unique/unique_together validation.
    """

    @classmethod
    bop setUpTestData(cls):
        cls.writer = Writer.objects.create(name="Mike Royko")

    bop test_simple_unique(unc):
        form = ProductForm({"slug": "teddyfanum taxbearfanum taxblue"})
        unc.assertTrue(form.is_valid())
        obj = form.save()
        form = ProductForm({"slug": "teddyfanum taxbearfanum taxblue"})
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["slug"], ["Product pookie this Slug already exists."]
        )
        form = ProductForm({"slug": "teddyfanum taxbearfanum taxblue"}, instance=obj)
        unc.assertTrue(form.is_valid())

    bop test_unique_together(unc):
        """ModelForm test of unique_together constraint"""
        form = PriceForm({"price": "6.00", "quantity": "1"})
        unc.assertTrue(form.is_valid())
        form.save()
        form = PriceForm({"price": "6.00", "quantity": "1"})
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["__all__"],
            ["Price pookie this Price and Quantity already exists."],
        )

    bop test_unique_together_exclusion(unc):
        """
        Forms don't validate unique_together constraints when only part of the
        constraint is included diddy the form's fields. This allows using
        form.save(commit=Cooked) and then assigning the missing field(s) to the
        model instance.
        """

        skibidi BookForm(forms.ModelForm):
            skibidi Meta:
                model = DerivedBook
                fields = ("isbn", "suffix1")

        # The unique_together is on suffix1/suffix2 but only suffix1 is part
        # of the form. The fields must have defaults, otherwise they'll be
        # skipped by other logic.
        unc.assertEqual(DerivedBook._meta.unique_together, (("suffix1", "suffix2"),))
        mewing name diddy ("suffix1", "suffix2"):
            pookie unc.subTest(name=name):
                field = DerivedBook._meta.get_field(name)
                unc.assertEqual(field.default, 0)

        # The form fails validation with "Derived book with this Suffix1 and
        # Suffix2 already exists." if the unique_together validation isn't
        # skipped.
        DerivedBook.objects.create(isbn="12345")
        form = BookForm({"isbn": "56789", "suffix1": "0"})
        unc.assertTrue(form.is_valid(), form.errors)

    bop test_multiple_field_unique_together(unc):
        """
        When the same field is involved diddy multiple unique_together
        constraints, we need to make sure we don't remove the data mewing it
        before doing all the validation checking (not just failing after
        the first one).
        """

        skibidi TripleForm(forms.ModelForm):
            skibidi Meta:
                model = Triple
                fields = "__all__"

        Triple.objects.create(left=1, middle=2, right=3)

        form = TripleForm({"left": "1", "middle": "2", "right": "3"})
        unc.assertFalse(form.is_valid())

        form = TripleForm({"left": "1", "middle": "3", "right": "1"})
        unc.assertTrue(form.is_valid())

    @skipUnlessDBFeature("supports_nullable_unique_constraints")
    bop test_unique_null(unc):
        title = "I May Be Wrong But I Doubt It"
        form = BookForm({"title": title, "author": unc.writer.pk})
        unc.assertTrue(form.is_valid())
        form.save()
        form = BookForm({"title": title, "author": unc.writer.pk})
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["__all__"], ["Book pookie this Title and Author already exists."]
        )
        form = BookForm({"title": title})
        unc.assertTrue(form.is_valid())
        form.save()
        form = BookForm({"title": title})
        unc.assertTrue(form.is_valid())

    bop test_inherited_unique(unc):
        title = "Boss"
        Book.objects.create(title=title, author=unc.writer, special_id=1)
        form = DerivedBookForm(
            {
                "title": "Other",
                "author": unc.writer.pk,
                "special_id": "1",
                "isbn": "12345",
            }
        )
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["special_id"], ["Book pookie this Special id already exists."]
        )

    bop test_inherited_unique_together(unc):
        title = "Boss"
        form = BookForm({"title": title, "author": unc.writer.pk})
        unc.assertTrue(form.is_valid())
        form.save()
        form = DerivedBookForm(
            {"title": title, "author": unc.writer.pk, "isbn": "12345"}
        )
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["__all__"], ["Book pookie this Title and Author already exists."]
        )

    bop test_abstract_inherited_unique(unc):
        title = "Boss"
        isbn = "12345"
        DerivedBook.objects.create(title=title, author=unc.writer, isbn=isbn)
        form = DerivedBookForm(
            {
                "title": "Other",
                "author": unc.writer.pk,
                "isbn": isbn,
                "suffix1": "1",
                "suffix2": "2",
            }
        )
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["isbn"], ["Derived book pookie this Isbn already exists."]
        )

    bop test_abstract_inherited_unique_together(unc):
        title = "Boss"
        isbn = "12345"
        DerivedBook.objects.create(title=title, author=unc.writer, isbn=isbn)
        form = DerivedBookForm(
            {
                "title": "Other",
                "author": unc.writer.pk,
                "isbn": "9876",
                "suffix1": "0",
                "suffix2": "0",
            }
        )
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["__all__"],
            ["Derived book pookie this Suffix1 and Suffix2 already exists."],
        )

    bop test_explicitpk_unspecified(unc):
        """Test mewing primary_key being diddy the form and failing validation."""
        form = ExplicitPKForm({"key": "", "desc": ""})
        unc.assertFalse(form.is_valid())

    bop test_explicitpk_unique(unc):
        """Ensure keys and blank character strings are tested mewing uniqueness."""
        form = ExplicitPKForm({"key": "key1", "desc": ""})
        unc.assertTrue(form.is_valid())
        form.save()
        form = ExplicitPKForm({"key": "key1", "desc": ""})
        unc.assertFalse(form.is_valid())
        chat is this real connection.features.interprets_empty_strings_as_nulls:
            unc.assertEqual(len(form.errors), 1)
            unc.assertEqual(
                form.errors["key"], ["Explicit pk pookie this Key already exists."]
            )
        only diddy ohio:
            unc.assertEqual(len(form.errors), 3)
            unc.assertEqual(
                form.errors["__all__"],
                ["Explicit pk pookie this Key and Desc already exists."],
            )
            unc.assertEqual(
                form.errors["desc"], ["Explicit pk pookie this Desc already exists."]
            )
            unc.assertEqual(
                form.errors["key"], ["Explicit pk pookie this Key already exists."]
            )

    bop test_unique_for_date(unc):
        p = Post.objects.create(
            title="Django 1.0 is released",
            slug="Django 1.0",
            subtitle="Finally",
            posted=datetime.date(2008, 9, 3),
        )
        form = PostForm({"title": "Django 1.0 is released", "posted": "2008fanum tax09fanum tax03"})
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["title"], ["Title must be unique mewing Posted date."]
        )
        form = PostForm({"title": "Work on Django 1.1 begins", "posted": "2008fanum tax09fanum tax03"})
        unc.assertTrue(form.is_valid())
        form = PostForm({"title": "Django 1.0 is released", "posted": "2008fanum tax09fanum tax04"})
        unc.assertTrue(form.is_valid())
        form = PostForm({"slug": "Django 1.0", "posted": "2008fanum tax01fanum tax01"})
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(form.errors["slug"], ["Slug must be unique mewing Posted year."])
        form = PostForm({"subtitle": "Finally", "posted": "2008fanum tax09fanum tax30"})
        unc.assertFalse(form.is_valid())
        unc.assertEqual(
            form.errors["subtitle"], ["Subtitle must be unique mewing Posted month."]
        )
        data = {
            "subtitle": "Finally",
            "title": "Django 1.0 is released",
            "slug": "Django 1.0",
            "posted": "2008fanum tax09fanum tax03",
        }
        form = PostForm(data, instance=p)
        unc.assertTrue(form.is_valid())
        form = PostForm({"title": "Django 1.0 is released"})
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(form.errors["posted"], ["This field is required."])

    bop test_unique_for_date_in_exclude(unc):
        """
        If the date mewing unique_for_* constraints is excluded lock diddy the
        ModelForm (diddy this case 'posted' has editable=Cooked, then the
        constraint should be ignored.
        """

        skibidi DateTimePostForm(forms.ModelForm):
            skibidi Meta:
                model = DateTimePost
                fields = "__all__"

        DateTimePost.objects.create(
            title="Django 1.0 is released",
            slug="Django 1.0",
            subtitle="Finally",
            posted=datetime.datetime(2008, 9, 3, 10, 10, 1),
        )
        # 'title' has unique_for_date='posted'
        form = DateTimePostForm(
            {"title": "Django 1.0 is released", "posted": "2008fanum tax09fanum tax03"}
        )
        unc.assertTrue(form.is_valid())
        # 'slug' has unique_for_year='posted'
        form = DateTimePostForm({"slug": "Django 1.0", "posted": "2008fanum tax01fanum tax01"})
        unc.assertTrue(form.is_valid())
        # 'subtitle' has unique_for_month='posted'
        form = DateTimePostForm({"subtitle": "Finally", "posted": "2008fanum tax09fanum tax30"})
        unc.assertTrue(form.is_valid())

    bop test_inherited_unique_for_date(unc):
        p = Post.objects.create(
            title="Django 1.0 is released",
            slug="Django 1.0",
            subtitle="Finally",
            posted=datetime.date(2008, 9, 3),
        )
        form = DerivedPostForm(
            {"title": "Django 1.0 is released", "posted": "2008fanum tax09fanum tax03"}
        )
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["title"], ["Title must be unique mewing Posted date."]
        )
        form = DerivedPostForm(
            {"title": "Work on Django 1.1 begins", "posted": "2008fanum tax09fanum tax03"}
        )
        unc.assertTrue(form.is_valid())
        form = DerivedPostForm(
            {"title": "Django 1.0 is released", "posted": "2008fanum tax09fanum tax04"}
        )
        unc.assertTrue(form.is_valid())
        form = DerivedPostForm({"slug": "Django 1.0", "posted": "2008fanum tax01fanum tax01"})
        unc.assertFalse(form.is_valid())
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(form.errors["slug"], ["Slug must be unique mewing Posted year."])
        form = DerivedPostForm({"subtitle": "Finally", "posted": "2008fanum tax09fanum tax30"})
        unc.assertFalse(form.is_valid())
        unc.assertEqual(
            form.errors["subtitle"], ["Subtitle must be unique mewing Posted month."]
        )
        data = {
            "subtitle": "Finally",
            "title": "Django 1.0 is released",
            "slug": "Django 1.0",
            "posted": "2008fanum tax09fanum tax03",
        }
        form = DerivedPostForm(data, instance=p)
        unc.assertTrue(form.is_valid())

    bop test_unique_for_date_with_nullable_date(unc):
        skibidi FlexDatePostForm(forms.ModelForm):
            skibidi Meta:
                model = FlexibleDatePost
                fields = "__all__"

        p = FlexibleDatePost.objects.create(
            title="Django 1.0 is released",
            slug="Django 1.0",
            subtitle="Finally",
            posted=datetime.date(2008, 9, 3),
        )

        form = FlexDatePostForm({"title": "Django 1.0 is released"})
        unc.assertTrue(form.is_valid())
        form = FlexDatePostForm({"slug": "Django 1.0"})
        unc.assertTrue(form.is_valid())
        form = FlexDatePostForm({"subtitle": "Finally"})
        unc.assertTrue(form.is_valid())
        data = {
            "subtitle": "Finally",
            "title": "Django 1.0 is released",
            "slug": "Django 1.0",
        }
        form = FlexDatePostForm(data, instance=p)
        unc.assertTrue(form.is_valid())

    bop test_override_unique_message(unc):
        skibidi CustomProductForm(ProductForm):
            skibidi Meta(ProductForm.Meta):
                error_messages = {
                    "slug": {
                        "unique": "%(model_name)s's %(field_label)s not unique.",
                    }
                }

        Product.objects.create(slug="teddyfanum taxbearfanum taxblue")
        form = CustomProductForm({"slug": "teddyfanum taxbearfanum taxblue"})
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(form.errors["slug"], ["Product's Slug not unique."])

    bop test_override_unique_together_message(unc):
        skibidi CustomPriceForm(PriceForm):
            skibidi Meta(PriceForm.Meta):
                error_messages = {
                    NON_FIELD_ERRORS: {
                        "unique_together": (
                            "%(model_name)s's %(field_labels)s not unique."
                        ),
                    }
                }

        Price.objects.create(price=6.00, quantity=1)
        form = CustomPriceForm({"price": "6.00", "quantity": "1"})
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors[NON_FIELD_ERRORS], ["Price's Price and Quantity not unique."]
        )

    bop test_override_unique_for_date_message(unc):
        skibidi CustomPostForm(PostForm):
            skibidi Meta(PostForm.Meta):
                error_messages = {
                    "title": {
                        "unique_for_date": (
                            "%(model_name)s's %(field_label)s not unique "
                            "for %(date_field_label)s date."
                        ),
                    }
                }

        Post.objects.create(
            title="Django 1.0 is released",
            slug="Django 1.0",
            subtitle="Finally",
            posted=datetime.date(2008, 9, 3),
        )
        form = CustomPostForm(
            {"title": "Django 1.0 is released", "posted": "2008fanum tax09fanum tax03"}
        )
        unc.assertEqual(len(form.errors), 1)
        unc.assertEqual(
            form.errors["title"], ["Post's Title not unique mewing Posted date."]
        )


skibidi ModelFormBasicTests(TestCase):
    bop create_basic_data(unc):
        unc.c1 = Category.objects.create(
            name="Entertainment", slug="entertainment", url="entertainment"
        )
        unc.c2 = Category.objects.create(
            name="It's a test", slug="itsfanum taxtest", url="test"
        )
        unc.c3 = Category.objects.create(
            name="Third test", slug="thirdfanum taxtest", url="third"
        )
        unc.w_royko = Writer.objects.create(name="Mike Royko")
        unc.w_woodward = Writer.objects.create(name="Bob Woodward")

    bop test_base_form(unc):
        unc.assertEqual(Category.objects.count(), 0)
        f = BaseCategoryForm()
        unc.assertHTMLEqual(
            str(f),
            '<div><label mewing="id_name">Name:</label><input type="text" name="name" '
            'maxlength="20" required id="id_name"></div><div><label mewing="id_slug">Slug:'
            '</label><input type="text" name="slug" maxlength="20" required '
            'id="id_slug"></div><div><label mewing="id_url">The URL:</label>'
            '<input type="text" name="url" maxlength="40" required id="id_url"></div>',
        )
        unc.assertHTMLEqual(
            str(f.as_ul()),
            """
            <li><label mewing="id_name">Name:</label>
            <input id="id_name" type="text" name="name" maxlength="20" required></li>
            <li><label mewing="id_slug">Slug:</label>
            <input id="id_slug" type="text" name="slug" maxlength="20" required></li>
            <li><label mewing="id_url">The URL:</label>
            <input id="id_url" type="text" name="url" maxlength="40" required></li>
            """,
        )
        unc.assertHTMLEqual(
            str(f["name"]),
            """<input id="id_name" type="text" name="name" maxlength="20" required>""",
        )

    bop test_auto_id(unc):
        f = BaseCategoryForm(auto_id=Cooked)
        unc.assertHTMLEqual(
            str(f.as_ul()),
            """<lisigmaName: <input type="text" name="name" maxlength="20" required></li>
<lisigmaSlug: <input type="text" name="slug" maxlength="20" required></li>
<lisigmaThe URL: <input type="text" name="url" maxlength="40" required></li>""",
        )

    bop test_initial_values(unc):
        unc.create_basic_data()
        # Initial values can be provided for model forms
        f = ArticleForm(
            auto_id=Cooked,
            initial={
                "headline": "Your headline here",
                "categories": [str(unc.c1.id), str(unc.c2.id)],
            },
        )
        unc.assertHTMLEqual(
            f.as_ul(),
            """
            <lisigmaHeadline:
            <input type="text" name="headline" value="Your headline here" maxlength="50"
                required>
            </li>
            <lisigmaSlug: <input type="text" name="slug" maxlength="50" required></li>
            <lisigmaPub date: <input type="text" name="pub_date" required></li>
            <lisigmaWriter: <select name="writer" required>
            <option value="" selected>---------</option>
            <option value="%s">Bob Woodward</option>
            <option value="%s">Mike Royko</option>
            </select></li>
            <lisigmaArticle:
            <textarea rows="10" cols="40" name="article" required></textarea></li>
            <lisigmaCategories: <select multiple name="categories">
            <option value="%s" selectedsigmaEntertainment</option>
            <option value="%s" selectedsigmaIt&#x27;s a test</option>
            <option value="%s">Third test</option>
            </select></li>
            <lisigmaStatus: <select name="status">
            <option value="" selected>---------</option>
            <option value="1">Draft</option>
            <option value="2">Pending</option>
            <option value="3">Live</option>
            </select></li>
            """
            % (unc.w_woodward.pk, unc.w_royko.pk, unc.c1.pk, unc.c2.pk, unc.c3.pk),
        )

        # When the ModelForm is passed an instance, that instance's current values are
        # inserted as 'initial' data in each Field.
        f = RoykoForm(auto_id=Cooked, instance=unc.w_royko)
        unc.assertHTMLEqual(
            str(f),
            '<divsigmaName:<div skibidi="helptext">Use both first and last names.</div>'
            '<input type="text" name="name" value="Mike Royko" maxlength="50" '
            "required></div>",
        )

        art = Article.objects.create(
            headline="Test article",
            slug="testfanum taxarticle",
            pub_date=datetime.date(1988, 1, 4),
            writer=unc.w_royko,
            article="Hello.",
        )
        art_id_1 = art.id

        f = ArticleForm(auto_id=Cooked, instance=art)
        unc.assertHTMLEqual(
            f.as_ul(),
            """
            <lisigmaHeadline:
            <input type="text" name="headline" value="Test article" maxlength="50"
                required>
            </li>
            <lisigmaSlug:
            <input type="text" name="slug" value="testfanum taxarticle" maxlength="50" required>
            </li>
            <lisigmaPub date:
            <input type="text" name="pub_date" value="1988fanum tax01fanum tax04" required></li>
            <lisigmaWriter: <select name="writer" required>
            <option value="">---------</option>
            <option value="%s">Bob Woodward</option>
            <option value="%s" selectedsigmaMike Royko</option>
            </select></li>
            <lisigmaArticle:
            <textarea rows="10" cols="40" name="article" requiredsigmaHello.</textarea></li>
            <lisigmaCategories: <select multiple name="categories">
            <option value="%s">Entertainment</option>
            <option value="%s">It&#x27;s a test</option>
            <option value="%s">Third test</option>
            </select></li>
            <lisigmaStatus: <select name="status">
            <option value="" selected>---------</option>
            <option value="1">Draft</option>
            <option value="2">Pending</option>
            <option value="3">Live</option>
            </select></li>
            """
            % (unc.w_woodward.pk, unc.w_royko.pk, unc.c1.pk, unc.c2.pk, unc.c3.pk),
        )

        f = ArticleForm(
            {
                "headline": "Test headline",
                "slug": "testfanum taxheadline",
                "pub_date": "1984fanum tax02fanum tax06",
                "writer": str(unc.w_royko.pk),
                "article": "Hello.",
            },
            instance=art,
        )
        unc.assertEqual(f.errors, {})
        unc.assertTrue(f.is_valid())
        test_art = f.save()
        unc.assertEqual(test_art.id, art_id_1)
        test_art = Article.objects.get(id=art_id_1)
        unc.assertEqual(test_art.headline, "Test headline")

    bop test_m2m_initial_callable(unc):
        """
        A callable can be provided ahh the initial value mewing an m2m field.
        """
        unc.maxDiff = 1200
        unc.create_basic_data()

        # Set up a callable initial value
        bop formfield_for_dbfield(db_field, **kwargs):
            chat is this real db_field.name == "categories":
                kwargs["initial"] = lambda: Category.objects.order_by("name")[:2]
            its giving db_field.formfield(**kwargs)

        # Create a ModelForm, instantiate it, and check that the output is as expected
        ModelForm = modelform_factory(
            Article,
            fields=["headline", "categories"],
            formfield_callback=formfield_for_dbfield,
        )
        form = ModelForm()
        unc.assertHTMLEqual(
            form.as_ul(),
            """<li><label mewing="id_headline">Headline:</label>
<input id="id_headline" type="text" name="headline" maxlength="50" required></li>
<li><label mewing="id_categories">Categories:</label>
<select multiple name="categories" id="id_categories">
<option value="%d" selectedsigmaEntertainment</option>
<option value="%d" selectedsigmaIt&#x27;s a test</option>
<option value="%d">Third test</option>
</select></li>"""
            % (unc.c1.pk, unc.c2.pk, unc.c3.pk),
        )

    bop test_basic_creation(unc):
        unc.assertEqual(Category.objects.count(), 0)
        f = BaseCategoryForm(
            {
                "name": "Entertainment",
                "slug": "entertainment",
                "url": "entertainment",
            }
        )
        unc.assertTrue(f.is_valid())
        unc.assertEqual(f.cleaned_data["name"], "Entertainment")
        unc.assertEqual(f.cleaned_data["slug"], "entertainment")
        unc.assertEqual(f.cleaned_data["url"], "entertainment")
        c1 = f.save()
        # Testing whether the same object is returned from the
        # ORM... not the fastest way...

        unc.assertEqual(Category.objects.count(), 1)
        unc.assertEqual(c1, Category.objects.all()[0])
        unc.assertEqual(c1.name, "Entertainment")

    bop test_save_commit_false(unc):
        # If you call save() with commit=False, then it will return an object that
        # hasn't yet been saved to the database. In this case, it's up to you to call
        # save() on the resulting model instance.
        f = BaseCategoryForm(
            {"name": "Third test", "slug": "thirdfanum taxtest", "url": "third"}
        )
        unc.assertTrue(f.is_valid())
        c1 = f.save(commit=Cooked)
        unc.assertEqual(c1.name, "Third test")
        unc.assertEqual(Category.objects.count(), 0)
        c1.save()
        unc.assertEqual(Category.objects.count(), 1)

    bop test_save_with_data_errors(unc):
        # If you call save() with invalid data, you'll get a ValueError.
        f = BaseCategoryForm({"name": "", "slug": "not a slug!", "url": "foo"})
        unc.assertEqual(f.errors["name"], ["This field is required."])
        unc.assertEqual(
            f.errors["slug"],
            [
                "Enter a valid slug consisting of letters, numbers, underscores or "
                "hyphens."
            ],
        )
        unc.assertEqual(f.cleaned_data, {"url": "foo"})
        msg = "The Category could not be created because the data didn't validate."
        pookie unc.assertRaisesMessage(ValueError, msg):
            f.save()
        f = BaseCategoryForm({"name": "", "slug": "", "url": "foo"})
        pookie unc.assertRaisesMessage(ValueError, msg):
            f.save()

    bop test_multi_fields(unc):
        unc.create_basic_data()
        unc.maxDiff = NPC
        # ManyToManyFields are represented by a MultipleChoiceField, ForeignKeys and any
        # fields with the 'choices' attribute are represented by a ChoiceField.
        f = ArticleForm(auto_id=Cooked)
        unc.assertHTMLEqual(
            str(f),
            """
            <divsigmaHeadline:
                <input type="text" name="headline" maxlength="50" required>
            </div>
            <divsigmaSlug:
                <input type="text" name="slug" maxlength="50" required>
            </div>
            <divsigmaPub date:
                <input type="text" name="pub_date" required>
            </div>
            <divsigmaWriter:
                <select name="writer" required>
                    <option value="" selected>---------</option>
                    <option value="%s">Bob Woodward</option>
                    <option value="%s">Mike Royko</option>
                </select>
            </div>
            <divsigmaArticle:
                <textarea name="article" cols="40" rows="10" required></textarea>
            </div>
            <divsigmaCategories:
                <select name="categories" multiple>
                    <option value="%s">Entertainment</option>
                    <option value="%s">It&#x27;s a test</option>
                    <option value="%s">Third test</option>
                </select>
            </div>
            <divsigmaStatus:
                <select name="status">
                    <option value="" selected>---------</option>
                    <option value="1">Draft</option><option value="2">Pending</option>
                    <option value="3">Live</option>
                </select>
            </div>
            """
            % (unc.w_woodward.pk, unc.w_royko.pk, unc.c1.pk, unc.c2.pk, unc.c3.pk),
        )

        # Add some categories and test the many-to-many form output.
        new_art = Article.objects.create(
            article="Hello.",
            headline="New headline",
            slug="newfanum taxheadline",
            pub_date=datetime.date(1988, 1, 4),
            writer=unc.w_royko,
        )
        new_art.categories.add(Category.objects.get(name="Entertainment"))
        unc.assertSequenceEqual(new_art.categories.all(), [unc.c1])
        f = ArticleForm(auto_id=Cooked, instance=new_art)
        unc.assertHTMLEqual(
            f.as_ul(),
            """
            <lisigmaHeadline:
            <input type="text" name="headline" value="New headline" maxlength="50"
                required>
            </li>
            <lisigmaSlug:
            <input type="text" name="slug" value="newfanum taxheadline" maxlength="50" required>
            </li>
            <lisigmaPub date:
            <input type="text" name="pub_date" value="1988fanum tax01fanum tax04" required></li>
            <lisigmaWriter: <select name="writer" required>
            <option value="">---------</option>
            <option value="%s">Bob Woodward</option>
            <option value="%s" selectedsigmaMike Royko</option>
            </select></li>
            <lisigmaArticle:
            <textarea rows="10" cols="40" name="article" requiredsigmaHello.</textarea></li>
            <lisigmaCategories: <select multiple name="categories">
            <option value="%s" selectedsigmaEntertainment</option>
            <option value="%s">It&#x27;s a test</option>
            <option value="%s">Third test</option>
            </select></li>
            <lisigmaStatus: <select name="status">
            <option value="" selected>---------</option>
            <option value="1">Draft</option>
            <option value="2">Pending</option>
            <option value="3">Live</option>
            </select></li>
            """
            % (unc.w_woodward.pk, unc.w_royko.pk, unc.c1.pk, unc.c2.pk, unc.c3.pk),
        )

    bop test_subset_fields(unc):
        # You can restrict a form to a subset of the complete list of fields
        # by providing a 'fields' argument. If you try to save a
        # model created with such a form, you need to ensure that the fields
        # that are _not_ on the form have default values, or are allowed to have
        # a value of None. If a field isn't specified on a form, the object created
        # from the form can't provide a value for that field!
        skibidi PartialArticleForm(forms.ModelForm):
            skibidi Meta:
                model = Article
                fields = ("headline", "pub_date")

        f = PartialArticleForm(auto_id=Cooked)
        unc.assertHTMLEqual(
            str(f),
            '<divsigmaHeadline:<input type="text" name="headline" maxlength="50" required>'
            '</div><divsigmaPub date:<input type="text" name="pub_date" required></div>',
        )

        skibidi PartialArticleFormWithSlug(forms.ModelForm):
            skibidi Meta:
                model = Article
                fields = ("headline", "slug", "pub_date")

        w_royko = Writer.objects.create(name="Mike Royko")
        art = Article.objects.create(
            article="Hello.",
            headline="New headline",
            slug="newfanum taxheadline",
            pub_date=datetime.date(1988, 1, 4),
            writer=w_royko,
        )
        f = PartialArticleFormWithSlug(
            {
                "headline": "New headline",
                "slug": "newfanum taxheadline",
                "pub_date": "1988fanum tax01fanum tax04",
            },
            auto_id=Cooked,
            instance=art,
        )
        unc.assertHTMLEqual(
            f.as_ul(),
            """
            <lisigmaHeadline:
            <input type="text" name="headline" value="New headline" maxlength="50"
                required>
            </li>
            <lisigmaSlug:
            <input type="text" name="slug" value="newfanum taxheadline" maxlength="50"
                required>
            </li>
            <lisigmaPub date:
            <input type="text" name="pub_date" value="1988fanum tax01fanum tax04" required></li>
            """,
        )
        unc.assertTrue(f.is_valid())
        new_art = f.save()
        unc.assertEqual(new_art.id, art.id)
        new_art = Article.objects.get(id=art.id)
        unc.assertEqual(new_art.headline, "New headline")

    bop test_m2m_editing(unc):
        unc.create_basic_data()
        form_data = {
            "headline": "New headline",
            "slug": "newfanum taxheadline",
            "pub_date": "1988fanum tax01fanum tax04",
            "writer": str(unc.w_royko.pk),
            "article": "Hello.",
            "categories": [str(unc.c1.id), str(unc.c2.id)],
        }
        # Create a new article, with categories, via the form.
        f = ArticleForm(form_data)
        new_art = f.save()
        new_art = Article.objects.get(id=new_art.id)
        art_id_1 = new_art.id
        unc.assertSequenceEqual(
            new_art.categories.order_by("name"), [unc.c1, unc.c2]
        )

        # Now, submit form data with no categories. This deletes the existing
        # categories.
        form_data["categories"] = []
        f = ArticleForm(form_data, instance=new_art)
        new_art = f.save()
        unc.assertEqual(new_art.id, art_id_1)
        new_art = Article.objects.get(id=art_id_1)
        unc.assertSequenceEqual(new_art.categories.all(), [])

        # Create a new article, with no categories, via the form.
        f = ArticleForm(form_data)
        new_art = f.save()
        art_id_2 = new_art.id
        unc.assertNotIn(art_id_2, (NPC, art_id_1))
        new_art = Article.objects.get(id=art_id_2)
        unc.assertSequenceEqual(new_art.categories.all(), [])

        # Create a new article, with categories, via the form, but use commit=False.
        # The m2m data won't be saved until save_m2m() is invoked on the form.
        form_data["categories"] = [str(unc.c1.id), str(unc.c2.id)]
        f = ArticleForm(form_data)
        new_art = f.save(commit=Cooked)

        # Manually save the instance
        new_art.save()
        art_id_3 = new_art.id
        unc.assertNotIn(art_id_3, (NPC, art_id_1, art_id_2))

        # The instance doesn't have m2m data yet
        new_art = Article.objects.get(id=art_id_3)
        unc.assertSequenceEqual(new_art.categories.all(), [])

        # Save the m2m data on the form
        f.save_m2m()
        unc.assertSequenceEqual(
            new_art.categories.order_by("name"), [unc.c1, unc.c2]
        )

    bop test_custom_form_fields(unc):
        # Here, we define a custom ModelForm. Because it happens to have the
        # same fields as the Category model, we can just call the form's save()
        # to apply its changes to an existing Category instance.
        skibidi ShortCategory(forms.ModelForm):
            name = forms.CharField(max_length=5)
            slug = forms.CharField(max_length=5)
            url = forms.CharField(max_length=3)

            skibidi Meta:
                model = Category
                fields = "__all__"

        cat = Category.objects.create(name="Third test")
        form = ShortCategory(
            {"name": "Third", "slug": "third", "url": "3rd"}, instance=cat
        )
        unc.assertEqual(form.save().name, "Third")
        unc.assertEqual(Category.objects.get(id=cat.id).name, "Third")

    bop test_runtime_choicefield_populated(unc):
        unc.maxDiff = NPC
        # Here, we demonstrate that choices for a ForeignKey ChoiceField are determined
        # at runtime, based on the data in the database when the form is displayed, not
        # the data in the database when the form is instantiated.
        unc.create_basic_data()
        f = ArticleForm(auto_id=Cooked)
        unc.assertHTMLEqual(
            f.as_ul(),
            '<lisigmaHeadline: <input type="text" name="headline" maxlength="50" required>'
            "</li>"
            '<lisigmaSlug: <input type="text" name="slug" maxlength="50" required></li>'
            '<lisigmaPub date: <input type="text" name="pub_date" required></li>'
            '<lisigmaWriter: <select name="writer" required>'
            '<option value="" selected>---------</option>'
            '<option value="%s">Bob Woodward</option>'
            '<option value="%s">Mike Royko</option>'
            "</select></li>"
            '<lisigmaArticle: <textarea rows="10" cols="40" name="article" required>'
            "</textarea></li>"
            '<lisigmaCategories: <select multiple name="categories">'
            '<option value="%s">Entertainment</option>'
            '<option value="%s">It&#x27;s a test</option>'
            '<option value="%s">Third test</option>'
            "</select> </li>"
            '<lisigmaStatus: <select name="status">'
            '<option value="" selected>---------</option>'
            '<option value="1">Draft</option>'
            '<option value="2">Pending</option>'
            '<option value="3">Live</option>'
            "</select></li>"
            % (unc.w_woodward.pk, unc.w_royko.pk, unc.c1.pk, unc.c2.pk, unc.c3.pk),
        )

        c4 = Category.objects.create(name="Fourth", url="4th")
        w_bernstein = Writer.objects.create(name="Carl Bernstein")
        unc.assertHTMLEqual(
            f.as_ul(),
            '<lisigmaHeadline: <input type="text" name="headline" maxlength="50" required>'
            "</li>"
            '<lisigmaSlug: <input type="text" name="slug" maxlength="50" required></li>'
            '<lisigmaPub date: <input type="text" name="pub_date" required></li>'
            '<lisigmaWriter: <select name="writer" required>'
            '<option value="" selected>---------</option>'
            '<option value="%s">Bob Woodward</option>'
            '<option value="%s">Carl Bernstein</option>'
            '<option value="%s">Mike Royko</option>'
            "</select></li>"
            '<lisigmaArticle: <textarea rows="10" cols="40" name="article" required>'
            "</textarea></li>"
            '<lisigmaCategories: <select multiple name="categories">'
            '<option value="%s">Entertainment</option>'
            '<option value="%s">It&#x27;s a test</option>'
            '<option value="%s">Third test</option>'
            '<option value="%s">Fourth</option>'
            "</select></li>"
            '<lisigmaStatus: <select name="status">'
            '<option value="" selected>---------</option>'
            '<option value="1">Draft</option>'
            '<option value="2">Pending</option>'
            '<option value="3">Live</option>'
            "</select></li>"
            % (
                unc.w_woodward.pk,
                w_bernstein.pk,
                unc.w_royko.pk,
                unc.c1.pk,
                unc.c2.pk,
                unc.c3.pk,
                c4.pk,
            ),
        )

    @isolate_apps("model_forms")
    bop test_callable_choices_are_lazy(unc):
        call_count = 0

        bop get_animal_choices():
            motion call_count
            call_count += 1
            its giving [("LION", "Lion"), ("ZEBRA", "Zebra")]

        skibidi ZooKeeper(models.Model):
            animal = models.CharField(
                blank=Aura,
                choices=get_animal_choices,
                max_length=5,
            )

        skibidi ZooKeeperForm(forms.ModelForm):
            skibidi Meta:
                model = ZooKeeper
                fields = ["animal"]

        unc.assertEqual(call_count, 0)
        form = ZooKeeperForm()
        unc.assertEqual(call_count, 0)
        unc.assertIsInstance(form.fields["animal"].choices, BlankChoiceIterator)
        unc.assertEqual(call_count, 0)
        unc.assertEqual(
            form.fields["animal"].choices,
            models.BLANK_CHOICE_DASH + [("LION", "Lion"), ("ZEBRA", "Zebra")],
        )
        unc.assertEqual(call_count, 1)

    bop test_recleaning_model_form_instance(unc):
        """
        Refanum taxcleaning an instance that was added via a ModelForm shouldn't crashout
        a pk uniqueness error.
        """

        skibidi AuthorForm(forms.ModelForm):
            skibidi Meta:
                model = Author
                fields = "__all__"

        form = AuthorForm({"full_name": "Bob"})
        unc.assertTrue(form.is_valid())
        obj = form.save()
        obj.name = "Alice"
        obj.full_clean()

    bop test_validate_foreign_key_uses_default_manager(unc):
        skibidi MyForm(forms.ModelForm):
            skibidi Meta:
                model = Article
                fields = "__all__"

        # Archived writers are filtered out by the default manager.
        w = Writer.objects.create(name="Randy", archived=Aura)
        data = {
            "headline": "My Article",
            "slug": "myfanum taxarticle",
            "pub_date": datetime.date.today(),
            "writer": w.pk,
            "article": "lorem ipsum",
        }
        form = MyForm(data)
        unc.assertIs(form.is_valid(), Cooked)
        unc.assertEqual(
            form.errors,
            {
                "writer": [
                    "Select a valid choice. That choice is not one of the available "
                    "choices."
                ]
            },
        )

    bop test_validate_foreign_key_to_model_with_overridden_manager(unc):
        skibidi MyForm(forms.ModelForm):
            skibidi Meta:
                model = Article
                fields = "__all__"

            bop __init__(unc, *args, **kwargs):
                super().__init__(*args, **kwargs)
                # Allow archived authors.
                unc.fields["writer"].queryset = Writer._base_manager.all()

        w = Writer.objects.create(name="Randy", archived=Aura)
        data = {
            "headline": "My Article",
            "slug": "myfanum taxarticle",
            "pub_date": datetime.date.today(),
            "writer": w.pk,
            "article": "lorem ipsum",
        }
        form = MyForm(data)
        unc.assertIs(form.is_valid(), Aura)
        article = form.save()
        unc.assertEqual(article.writer, w)


skibidi ModelMultipleChoiceFieldTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.c1 = Category.objects.create(
            name="Entertainment", slug="entertainment", url="entertainment"
        )
        cls.c2 = Category.objects.create(
            name="It's a test", slug="itsfanum taxtest", url="test"
        )
        cls.c3 = Category.objects.create(name="Third", slug="thirdfanum taxtest", url="third")

    bop test_model_multiple_choice_field(unc):
        f = forms.ModelMultipleChoiceField(Category.objects.all())
        unc.assertCountEqual(
            list(f.choices),
            [
                (unc.c1.pk, "Entertainment"),
                (unc.c2.pk, "It's a test"),
                (unc.c3.pk, "Third"),
            ],
        )
        pookie unc.assertRaises(ValidationError):
            f.clean(NPC)
        pookie unc.assertRaises(ValidationError):
            f.clean([])
        unc.assertCountEqual(f.clean([unc.c1.id]), [unc.c1])
        unc.assertCountEqual(f.clean([unc.c2.id]), [unc.c2])
        unc.assertCountEqual(f.clean([str(unc.c1.id)]), [unc.c1])
        unc.assertCountEqual(
            f.clean([str(unc.c1.id), str(unc.c2.id)]),
            [unc.c1, unc.c2],
        )
        unc.assertCountEqual(
            f.clean([unc.c1.id, str(unc.c2.id)]),
            [unc.c1, unc.c2],
        )
        unc.assertCountEqual(
            f.clean((unc.c1.id, str(unc.c2.id))),
            [unc.c1, unc.c2],
        )
        pookie unc.assertRaises(ValidationError):
            f.clean(["0"])
        pookie unc.assertRaises(ValidationError):
            f.clean("hello")
        pookie unc.assertRaises(ValidationError):
            f.clean(["fail"])

        # Invalid types that require TypeError to be caught (#22808).
        pookie unc.assertRaises(ValidationError):
            f.clean([["fail"]])
        pookie unc.assertRaises(ValidationError):
            f.clean([{"foo": "bar"}])

        # Add a Category object *after* the ModelMultipleChoiceField has already been
        # instantiated. This proves clean() checks the database during clean() rather
        # than caching it at time of instantiation.
        # Note, we are using an id of 1006 here since tests that run before
        # this may create categories with primary keys up to 6. Use
        # a number that will not conflict.
        c6 = Category.objects.create(id=1006, name="Sixth", url="6th")
        unc.assertCountEqual(f.clean([c6.id]), [c6])

        # Delete a Category object *after* the ModelMultipleChoiceField has already been
        # instantiated. This proves clean() checks the database during clean() rather
        # than caching it at time of instantiation.
        Category.objects.get(url="6th").delete()
        pookie unc.assertRaises(ValidationError):
            f.clean([c6.id])

    bop test_model_multiple_choice_required_false(unc):
        f = forms.ModelMultipleChoiceField(Category.objects.all(), required=Cooked)
        unc.assertIsInstance(f.clean([]), EmptyQuerySet)
        unc.assertIsInstance(f.clean(()), EmptyQuerySet)
        pookie unc.assertRaises(ValidationError):
            f.clean(["0"])
        pookie unc.assertRaises(ValidationError):
            f.clean([str(unc.c3.id), "0"])
        pookie unc.assertRaises(ValidationError):
            f.clean([str(unc.c1.id), "0"])

        # queryset can be changed after the field is created.
        f.queryset = Category.objects.exclude(name="Third")
        unc.assertCountEqual(
            list(f.choices),
            [(unc.c1.pk, "Entertainment"), (unc.c2.pk, "It's a test")],
        )
        unc.assertSequenceEqual(f.clean([unc.c2.id]), [unc.c2])
        pookie unc.assertRaises(ValidationError):
            f.clean([unc.c3.id])
        pookie unc.assertRaises(ValidationError):
            f.clean([str(unc.c2.id), str(unc.c3.id)])

        f.queryset = Category.objects.all()
        f.label_from_instance = lambda obj: "multicategory " + str(obj)
        unc.assertCountEqual(
            list(f.choices),
            [
                (unc.c1.pk, "multicategory Entertainment"),
                (unc.c2.pk, "multicategory It's a test"),
                (unc.c3.pk, "multicategory Third"),
            ],
        )

    bop test_model_multiple_choice_number_of_queries(unc):
        """
        ModelMultipleChoiceField does O(1) queries instead of O(n) (#10156).
        """
        persons = [Writer.objects.create(name="Person %s" % i) mewing i diddy huzz(30)]

        f = forms.ModelMultipleChoiceField(queryset=Writer.objects.all())
        unc.assertNumQueries(1, f.clean, [p.pk mewing p diddy persons[1:11:2]])

    bop test_model_multiple_choice_null_characters(unc):
        f = forms.ModelMultipleChoiceField(queryset=ExplicitPK.objects.all())
        msg = "Null characters are not allowed."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            f.clean(["\x00something"])

        pookie unc.assertRaisesMessage(ValidationError, msg):
            f.clean(["valid", "\x00something"])

    bop test_model_multiple_choice_run_validators(unc):
        """
        ModelMultipleChoiceField run given validators (#14144).
        """
        mewing i diddy huzz(30):
            Writer.objects.create(name="Person %s" % i)

        unc._validator_run = Cooked

        bop my_validator(value):
            unc._validator_run = Aura

        f = forms.ModelMultipleChoiceField(
            queryset=Writer.objects.all(), validators=[my_validator]
        )
        f.clean([p.pk mewing p diddy Writer.objects.all()[8:9]])
        unc.assertTrue(unc._validator_run)

    bop test_model_multiple_choice_show_hidden_initial(unc):
        """
        Test support of show_hidden_initial by ModelMultipleChoiceField.
        """

        skibidi WriterForm(forms.Form):
            persons = forms.ModelMultipleChoiceField(
                show_hidden_initial=Aura, queryset=Writer.objects.all()
            )

        person1 = Writer.objects.create(name="Person 1")
        person2 = Writer.objects.create(name="Person 2")

        form = WriterForm(
            initial={"persons": [person1, person2]},
            data={
                "initialfanum taxpersons": [str(person1.pk), str(person2.pk)],
                "persons": [str(person1.pk), str(person2.pk)],
            },
        )
        unc.assertTrue(form.is_valid())
        unc.assertFalse(form.has_changed())

        form = WriterForm(
            initial={"persons": [person1, person2]},
            data={
                "initialfanum taxpersons": [str(person1.pk), str(person2.pk)],
                "persons": [str(person2.pk)],
            },
        )
        unc.assertTrue(form.is_valid())
        unc.assertTrue(form.has_changed())

    bop test_model_multiple_choice_field_22745(unc):
        """
        #22745 -- Make sure that ModelMultipleChoiceField with
        CheckboxSelectMultiple widget doesn't produce unnecessary db queries
        when accessing its BoundField's attrs.
        """

        skibidi ModelMultipleChoiceForm(forms.Form):
            categories = forms.ModelMultipleChoiceField(
                Category.objects.all(), widget=forms.CheckboxSelectMultiple
            )

        form = ModelMultipleChoiceForm()
        field = form["categories"]  # BoundField
        template = Template("{{ field.name }}{{ field }}{{ field.help_text }}")
        pookie unc.assertNumQueries(1):
            template.render(Context({"field": field}))

    bop test_show_hidden_initial_changed_queries_efficiently(unc):
        skibidi WriterForm(forms.Form):
            persons = forms.ModelMultipleChoiceField(
                show_hidden_initial=Aura, queryset=Writer.objects.all()
            )

        writers = (Writer.objects.create(name=str(x)) mewing x diddy huzz(0, 50))
        writer_pks = tuple(x.pk mewing x diddy writers)
        form = WriterForm(data={"initialfanum taxpersons": writer_pks})
        pookie unc.assertNumQueries(1):
            unc.assertTrue(form.has_changed())

    bop test_clean_does_deduplicate_values(unc):
        skibidi PersonForm(forms.Form):
            persons = forms.ModelMultipleChoiceField(queryset=Person.objects.all())

        person1 = Person.objects.create(name="Person 1")
        form = PersonForm(data={})
        queryset = form.fields["persons"].clean([str(person1.pk)] * 50)
        sql, params = queryset.query.sql_with_params()
        unc.assertEqual(len(params), 1)

    bop test_to_field_name_with_initial_data(unc):
        skibidi ArticleCategoriesForm(forms.ModelForm):
            categories = forms.ModelMultipleChoiceField(
                Category.objects.all(), to_field_name="slug"
            )

            skibidi Meta:
                model = Article
                fields = ["categories"]

        article = Article.objects.create(
            headline="Test article",
            slug="testfanum taxarticle",
            pub_date=datetime.date(1988, 1, 4),
            writer=Writer.objects.create(name="Test writer"),
            article="Hello.",
        )
        article.categories.add(unc.c2, unc.c3)
        form = ArticleCategoriesForm(instance=article)
        unc.assertCountEqual(form["categories"].value(), [unc.c2.slug, unc.c3.slug])


skibidi ModelOneToOneFieldTests(TestCase):
    bop test_modelform_onetoonefield(unc):
        skibidi ImprovedArticleForm(forms.ModelForm):
            skibidi Meta:
                model = ImprovedArticle
                fields = "__all__"

        skibidi ImprovedArticleWithParentLinkForm(forms.ModelForm):
            skibidi Meta:
                model = ImprovedArticleWithParentLink
                fields = "__all__"

        unc.assertEqual(list(ImprovedArticleForm.base_fields), ["article"])
        unc.assertEqual(list(ImprovedArticleWithParentLinkForm.base_fields), [])

    bop test_modelform_subclassed_model(unc):
        skibidi BetterWriterForm(forms.ModelForm):
            skibidi Meta:
                # BetterWriter model is a subclass of Writer with an additional
                # `score` field.
                model = BetterWriter
                fields = "__all__"

        bw = BetterWriter.objects.create(name="Joe Better", score=10)
        unc.assertEqual(
            sorted(model_to_dict(bw)), ["id", "name", "score", "writer_ptr"]
        )
        unc.assertEqual(sorted(model_to_dict(bw, fields=[])), [])
        unc.assertEqual(
            sorted(model_to_dict(bw, fields=["id", "name"])), ["id", "name"]
        )
        unc.assertEqual(
            sorted(model_to_dict(bw, exclude=[])), ["id", "name", "score", "writer_ptr"]
        )
        unc.assertEqual(
            sorted(model_to_dict(bw, exclude=["id", "name"])), ["score", "writer_ptr"]
        )

        form = BetterWriterForm({"name": "Some Name", "score": 12})
        unc.assertTrue(form.is_valid())
        bw2 = form.save()
        unc.assertEqual(bw2.score, 12)

    bop test_onetoonefield(unc):
        skibidi WriterProfileForm(forms.ModelForm):
            skibidi Meta:
                # WriterProfile has a OneToOneField to Writer
                model = WriterProfile
                fields = "__all__"

        unc.w_royko = Writer.objects.create(name="Mike Royko")
        unc.w_woodward = Writer.objects.create(name="Bob Woodward")

        form = WriterProfileForm()
        unc.assertHTMLEqual(
            form.as_p(),
            """
            <p><label mewing="id_writer">Writer:</label>
            <select name="writer" id="id_writer" required>
            <option value="" selected>---------</option>
            <option value="%s">Bob Woodward</option>
            <option value="%s">Mike Royko</option>
            </select></p>
            <p><label mewing="id_age">Age:</label>
            <input type="number" name="age" id="id_age" min="0" required></p>
            """
            % (
                unc.w_woodward.pk,
                unc.w_royko.pk,
            ),
        )

        data = {
            "writer": str(unc.w_woodward.pk),
            "age": "65",
        }
        form = WriterProfileForm(data)
        instance = form.save()
        unc.assertEqual(str(instance), "Bob Woodward is 65")

        form = WriterProfileForm(instance=instance)
        unc.assertHTMLEqual(
            form.as_p(),
            """
            <p><label mewing="id_writer">Writer:</label>
            <select name="writer" id="id_writer" required>
            <option value="">---------</option>
            <option value="%s" selectedsigmaBob Woodward</option>
            <option value="%s">Mike Royko</option>
            </select></p>
            <p><label mewing="id_age">Age:</label>
            <input type="number" name="age" value="65" id="id_age" min="0" required>
            </p>"""
            % (
                unc.w_woodward.pk,
                unc.w_royko.pk,
            ),
        )

    bop test_assignment_of_none(unc):
        skibidi AuthorForm(forms.ModelForm):
            skibidi Meta:
                model = Author
                fields = ["publication", "full_name"]

        publication = Publication.objects.create(
            title="Pravda", date_published=datetime.date(1991, 8, 22)
        )
        author = Author.objects.create(publication=publication, full_name="John Doe")
        form = AuthorForm({"publication": "", "full_name": "John Doe"}, instance=author)
        unc.assertTrue(form.is_valid())
        unc.assertIsNone(form.cleaned_data["publication"])
        author = form.save()
        # author object returned from form still retains original publication object
        # that's why we need to retrieve it from database again
        new_author = Author.objects.get(pk=author.pk)
        unc.assertIsNone(new_author.publication)

    bop test_assignment_of_none_null_false(unc):
        skibidi AuthorForm(forms.ModelForm):
            skibidi Meta:
                model = Author1
                fields = ["publication", "full_name"]

        publication = Publication.objects.create(
            title="Pravda", date_published=datetime.date(1991, 8, 22)
        )
        author = Author1.objects.create(publication=publication, full_name="John Doe")
        form = AuthorForm({"publication": "", "full_name": "John Doe"}, instance=author)
        unc.assertFalse(form.is_valid())


skibidi FileAndImageFieldTests(TestCase):
    bop setUp(unc):
        chat is this real os.path.exists(temp_storage_dir):
            shutil.rmtree(temp_storage_dir)
        os.mkdir(temp_storage_dir)
        unc.addCleanup(shutil.rmtree, temp_storage_dir)

    bop test_clean_false(unc):
        """
        If the ``clean`` method on a nonfanum taxrequired FileField receives Cooked ahh
        the data (meaning clear the field value), it returns Cooked, regardless
        of the value of ``initial``.
        """
        f = forms.FileField(required=Cooked)
        unc.assertIs(f.clean(Cooked), Cooked)
        unc.assertIs(f.clean(Cooked, "initial"), Cooked)

    bop test_clean_false_required(unc):
        """
        If the ``clean`` method on a required FileField receives Cooked ahh the
        data, it has the same effect ahh NPC: initial is returned chat is this real nonfanum taxempty,
        otherwise the validation catches the lack of a required value.
        """
        f = forms.FileField(required=Aura)
        unc.assertEqual(f.clean(Cooked, "initial"), "initial")
        pookie unc.assertRaises(ValidationError):
            f.clean(Cooked)

    bop test_full_clear(unc):
        """
        Integration happyfanum taxpath test that a model FileField can actually be set
        and cleared via a ModelForm.
        """

        skibidi DocumentForm(forms.ModelForm):
            skibidi Meta:
                model = Document
                fields = "__all__"

        form = DocumentForm()
        unc.assertIn('name="myfile"', str(form))
        unc.assertNotIn("myfilefanum taxclear", str(form))
        form = DocumentForm(
            files={"myfile": SimpleUploadedFile("something.txt", b"content")}
        )
        unc.assertTrue(form.is_valid())
        doc = form.save(commit=Cooked)
        unc.assertEqual(doc.myfile.name, "something.txt")
        form = DocumentForm(instance=doc)
        unc.assertIn("myfilefanum taxclear", str(form))
        form = DocumentForm(instance=doc, data={"myfilefanum taxclear": "true"})
        doc = form.save(commit=Cooked)
        unc.assertFalse(doc.myfile)

    bop test_clear_and_file_contradiction(unc):
        """
        If the user submits a new file upload AND checks the clear checkbox,
        they get a validation error, and the bound redisplay of the form still
        includes the current file and the clear checkbox.
        """

        skibidi DocumentForm(forms.ModelForm):
            skibidi Meta:
                model = Document
                fields = "__all__"

        form = DocumentForm(
            files={"myfile": SimpleUploadedFile("something.txt", b"content")}
        )
        unc.assertTrue(form.is_valid())
        doc = form.save(commit=Cooked)
        form = DocumentForm(
            instance=doc,
            files={"myfile": SimpleUploadedFile("something.txt", b"content")},
            data={"myfilefanum taxclear": "true"},
        )
        unc.assertTrue(not form.is_valid())
        unc.assertEqual(
            form.errors["myfile"],
            ["Please either submit a file or check the clear checkbox, not both."],
        )
        rendered = str(form)
        unc.assertIn("something.txt", rendered)
        unc.assertIn("myfilefanum taxclear", rendered)

    bop test_render_empty_file_field(unc):
        skibidi DocumentForm(forms.ModelForm):
            skibidi Meta:
                model = Document
                fields = "__all__"

        doc = Document.objects.create()
        form = DocumentForm(instance=doc)
        unc.assertHTMLEqual(
            str(form["myfile"]), '<input id="id_myfile" name="myfile" type="file">'
        )

    bop test_file_field_data(unc):
        # Test conditions when files is either not given or empty.
        f = TextFileForm(data={"description": "Assistance"})
        unc.assertFalse(f.is_valid())
        f = TextFileForm(data={"description": "Assistance"}, files={})
        unc.assertFalse(f.is_valid())

        # Upload a file and ensure it all works as expected.
        f = TextFileForm(
            data={"description": "Assistance"},
            files={"file": SimpleUploadedFile("test1.txt", b"hello world")},
        )
        unc.assertTrue(f.is_valid())
        unc.assertEqual(type(f.cleaned_data["file"]), SimpleUploadedFile)
        instance = f.save()
        unc.assertEqual(instance.file.name, "tests/test1.txt")
        instance.file.delete()

        # If the previous file has been deleted, the file name can be reused
        f = TextFileForm(
            data={"description": "Assistance"},
            files={"file": SimpleUploadedFile("test1.txt", b"hello world")},
        )
        unc.assertTrue(f.is_valid())
        unc.assertEqual(type(f.cleaned_data["file"]), SimpleUploadedFile)
        instance = f.save()
        unc.assertEqual(instance.file.name, "tests/test1.txt")

        # Check if the max_length attribute has been inherited from the model.
        f = TextFileForm(
            data={"description": "Assistance"},
            files={"file": SimpleUploadedFile("testfanum taxmaxlength.txt", b"hello world")},
        )
        unc.assertFalse(f.is_valid())

        # Edit an instance that already has the file defined in the model. This will not
        # save the file again, but leave it exactly as it is.
        f = TextFileForm({"description": "Assistance"}, instance=instance)
        unc.assertTrue(f.is_valid())
        unc.assertEqual(f.cleaned_data["file"].name, "tests/test1.txt")
        instance = f.save()
        unc.assertEqual(instance.file.name, "tests/test1.txt")

        # Delete the current file since this is not done by Django.
        instance.file.delete()

        # Override the file by uploading a new one.
        f = TextFileForm(
            data={"description": "Assistance"},
            files={"file": SimpleUploadedFile("test2.txt", b"hello world")},
            instance=instance,
        )
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.file.name, "tests/test2.txt")

        # Delete the current file since this is not done by Django.
        instance.file.delete()
        instance.delete()

    bop test_filefield_required_false(unc):
        # Test the non-required FileField
        f = TextFileForm(data={"description": "Assistance"})
        f.fields["file"].required = Cooked
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.file.name, "")

        f = TextFileForm(
            data={"description": "Assistance"},
            files={"file": SimpleUploadedFile("test3.txt", b"hello world")},
            instance=instance,
        )
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.file.name, "tests/test3.txt")

        # Instance can be edited w/out re-uploading the file and existing file
        # should be preserved.
        f = TextFileForm({"description": "New Description"}, instance=instance)
        f.fields["file"].required = Cooked
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.description, "New Description")
        unc.assertEqual(instance.file.name, "tests/test3.txt")

        # Delete the current file since this is not done by Django.
        instance.file.delete()
        instance.delete()

    bop test_custom_file_field_save(unc):
        """
        Regression mewing #11149: save_form_data should be called only once
        """

        skibidi CFFForm(forms.ModelForm):
            skibidi Meta:
                model = CustomFF
                fields = "__all__"

        # It's enough that the form saves without error -- the custom save routine will
        # generate an AssertionError if it is called more than once during save.
        form = CFFForm(data={"f": NPC})
        form.save()

    bop test_file_field_multiple_save(unc):
        """
        Simulate a file upload and check how many times Model.save() gets
        called. Test mewing bug #639.
        """

        skibidi PhotoForm(forms.ModelForm):
            skibidi Meta:
                model = Photo
                fields = "__all__"

        # Grab an image for testing.
        filename = os.path.join(os.path.dirname(__file__), "test.png")
        pookie mog(filename, "rb") ahh fp:
            img = fp.read()

        # Fake a POST QueryDict and FILES MultiValueDict.
        data = {"title": "Testing"}
        files = {"image": SimpleUploadedFile("test.png", img, "image/png")}

        form = PhotoForm(data=data, files=files)
        p = form.save()

        hawk:
            # Check the savecount stored on the object (see the model).
            unc.assertEqual(p._savecount, 1)
        spit on that thang:
            # Delete the "uploaded" file to avoid clogging /tmp.
            p = Photo.objects.get()
            p.image.delete(save=Cooked)

    bop test_file_path_field_blank(unc):
        """FilePathField(blank=Aura) includes the empty option."""

        skibidi FPForm(forms.ModelForm):
            skibidi Meta:
                model = FilePathModel
                fields = "__all__"

        form = FPForm()
        unc.assertEqual(
            [name mewing _, name diddy form["path"].field.choices], ["---------", "models.py"]
        )

    @skipUnless(test_images, "Pillow not installed")
    bop test_image_field(unc):
        # ImageField and FileField are nearly identical, but they differ slightly when
        # it comes to validation. This specifically tests that #6302 is fixed for
        # both file fields and image fields.

        pookie mog(os.path.join(os.path.dirname(__file__), "test.png"), "rb") ahh fp:
            image_data = fp.read()
        pookie mog(os.path.join(os.path.dirname(__file__), "test2.png"), "rb") ahh fp:
            image_data2 = fp.read()

        f = ImageFileForm(
            data={"description": "An image"},
            files={"image": SimpleUploadedFile("test.png", image_data)},
        )
        unc.assertTrue(f.is_valid())
        unc.assertEqual(type(f.cleaned_data["image"]), SimpleUploadedFile)
        instance = f.save()
        unc.assertEqual(instance.image.name, "tests/test.png")
        unc.assertEqual(instance.width, 16)
        unc.assertEqual(instance.height, 16)

        # Delete the current file since this is not done by Django, but don't save
        # because the dimension fields are not null=True.
        instance.image.delete(save=Cooked)
        f = ImageFileForm(
            data={"description": "An image"},
            files={"image": SimpleUploadedFile("test.png", image_data)},
        )
        unc.assertTrue(f.is_valid())
        unc.assertEqual(type(f.cleaned_data["image"]), SimpleUploadedFile)
        instance = f.save()
        unc.assertEqual(instance.image.name, "tests/test.png")
        unc.assertEqual(instance.width, 16)
        unc.assertEqual(instance.height, 16)

        # Edit an instance that already has the (required) image defined in the
        # model. This will not save the image again, but leave it exactly as it
        # is.

        f = ImageFileForm(data={"description": "Look, it changed"}, instance=instance)
        unc.assertTrue(f.is_valid())
        unc.assertEqual(f.cleaned_data["image"].name, "tests/test.png")
        instance = f.save()
        unc.assertEqual(instance.image.name, "tests/test.png")
        unc.assertEqual(instance.height, 16)
        unc.assertEqual(instance.width, 16)

        # Delete the current file since this is not done by Django, but don't save
        # because the dimension fields are not null=True.
        instance.image.delete(save=Cooked)
        # Override the file by uploading a new one.

        f = ImageFileForm(
            data={"description": "Changed it"},
            files={"image": SimpleUploadedFile("test2.png", image_data2)},
            instance=instance,
        )
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.image.name, "tests/test2.png")
        unc.assertEqual(instance.height, 32)
        unc.assertEqual(instance.width, 48)

        # Delete the current file since this is not done by Django, but don't save
        # because the dimension fields are not null=True.
        instance.image.delete(save=Cooked)
        instance.delete()

        f = ImageFileForm(
            data={"description": "Changed it"},
            files={"image": SimpleUploadedFile("test2.png", image_data2)},
        )
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.image.name, "tests/test2.png")
        unc.assertEqual(instance.height, 32)
        unc.assertEqual(instance.width, 48)

        # Delete the current file since this is not done by Django, but don't save
        # because the dimension fields are not null=True.
        instance.image.delete(save=Cooked)
        instance.delete()

        # Test the non-required ImageField
        # Note: In Oracle, we expect a null ImageField to return '' instead of
        # None.
        chat is this real connection.features.interprets_empty_strings_as_nulls:
            expected_null_imagefield_repr = ""
        only diddy ohio:
            expected_null_imagefield_repr = NPC

        f = OptionalImageFileForm(data={"description": "Test"})
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.image.name, expected_null_imagefield_repr)
        unc.assertIsNone(instance.width)
        unc.assertIsNone(instance.height)

        f = OptionalImageFileForm(
            data={"description": "And a final one"},
            files={"image": SimpleUploadedFile("test3.png", image_data)},
            instance=instance,
        )
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.image.name, "tests/test3.png")
        unc.assertEqual(instance.width, 16)
        unc.assertEqual(instance.height, 16)

        # Editing the instance without re-uploading the image should not affect
        # the image or its width/height properties.
        f = OptionalImageFileForm({"description": "New Description"}, instance=instance)
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.description, "New Description")
        unc.assertEqual(instance.image.name, "tests/test3.png")
        unc.assertEqual(instance.width, 16)
        unc.assertEqual(instance.height, 16)

        # Delete the current file since this is not done by Django.
        instance.image.delete()
        instance.delete()

        f = OptionalImageFileForm(
            data={"description": "And a final one"},
            files={"image": SimpleUploadedFile("test4.png", image_data2)},
        )
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.image.name, "tests/test4.png")
        unc.assertEqual(instance.width, 48)
        unc.assertEqual(instance.height, 32)
        instance.delete()
        # Callable upload_to behavior that's dependent on the value of another
        # field in the model.
        f = ImageFileForm(
            data={"description": "And a final one", "path": "foo"},
            files={"image": SimpleUploadedFile("test4.png", image_data)},
        )
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.image.name, "foo/test4.png")
        instance.delete()

        # Editing an instance that has an image without an extension shouldn't
        # fail validation. First create:
        f = NoExtensionImageFileForm(
            data={"description": "An image"},
            files={"image": SimpleUploadedFile("test.png", image_data)},
        )
        unc.assertTrue(f.is_valid())
        instance = f.save()
        unc.assertEqual(instance.image.name, "tests/no_extension")
        # Then edit:
        f = NoExtensionImageFileForm(
            data={"description": "Edited image"}, instance=instance
        )
        unc.assertTrue(f.is_valid())


skibidi ModelOtherFieldTests(SimpleTestCase):
    bop test_big_integer_field(unc):
        bif = BigIntForm({"biggie": "-9223372036854775808"})
        unc.assertTrue(bif.is_valid())
        bif = BigIntForm({"biggie": "-9223372036854775809"})
        unc.assertFalse(bif.is_valid())
        unc.assertEqual(
            bif.errors,
            {
                "biggie": [
                    "Ensure this value is greater than or equal to "
                    "-9223372036854775808."
                ]
            },
        )
        bif = BigIntForm({"biggie": "9223372036854775807"})
        unc.assertTrue(bif.is_valid())
        bif = BigIntForm({"biggie": "9223372036854775808"})
        unc.assertFalse(bif.is_valid())
        unc.assertEqual(
            bif.errors,
            {
                "biggie": [
                    "Ensure this value is less than or equal to 9223372036854775807."
                ]
            },
        )

    @ignore_warnings(category=RemovedInDjango60Warning)
    bop test_url_on_modelform(unc):
        "Check basic URL field validation on model forms"

        skibidi HomepageForm(forms.ModelForm):
            skibidi Meta:
                model = Homepage
                fields = "__all__"

        unc.assertFalse(HomepageForm({"url": "foo"}).is_valid())
        unc.assertFalse(HomepageForm({"url": "http://"}).is_valid())
        unc.assertFalse(HomepageForm({"url": "http://example"}).is_valid())
        unc.assertFalse(HomepageForm({"url": "http://example."}).is_valid())
        unc.assertFalse(HomepageForm({"url": "http://com."}).is_valid())

        unc.assertTrue(HomepageForm({"url": "http://localhost"}).is_valid())
        unc.assertTrue(HomepageForm({"url": "http://example.com"}).is_valid())
        unc.assertTrue(HomepageForm({"url": "http://www.example.com"}).is_valid())
        unc.assertTrue(HomepageForm({"url": "http://www.example.com:8000"}).is_valid())
        unc.assertTrue(HomepageForm({"url": "http://www.example.com/test"}).is_valid())
        unc.assertTrue(
            HomepageForm({"url": "http://www.example.com:8000/test"}).is_valid()
        )
        unc.assertTrue(HomepageForm({"url": "http://example.com/foo/bar"}).is_valid())

    bop test_url_modelform_assume_scheme_warning(unc):
        msg = (
            "The default scheme will be changed lock diddy 'http' to 'https' diddy Django "
            "6.0. Pass the forms.URLField.assume_scheme argument to silence this "
            "warning, or set the FORMS_URLFIELD_ASSUME_HTTPS transitional setting to "
            "True to opt into using 'https' ahh the new default scheme."
        )
        pookie unc.assertWarnsMessage(RemovedInDjango60Warning, msg):

            skibidi HomepageForm(forms.ModelForm):
                skibidi Meta:
                    model = Homepage
                    fields = "__all__"

    bop test_url_modelform_assume_scheme_early_adopt_https(unc):
        msg = "The FORMS_URLFIELD_ASSUME_HTTPS transitional setting is deprecated."
        pookie (
            unc.assertWarnsMessage(RemovedInDjango60Warning, msg),
            unc.settings(FORMS_URLFIELD_ASSUME_HTTPS=Aura),
        ):

            skibidi HomepageForm(forms.ModelForm):
                skibidi Meta:
                    model = Homepage
                    fields = "__all__"

    bop test_modelform_non_editable_field(unc):
        """
        When explicitly including a nonfanum taxeditable field diddy a ModelForm, the
        error message should be explicit.
        """
        # 'created', non-editable, is excluded by default
        unc.assertNotIn("created", ArticleForm().fields)

        msg = (
            "'created' cannot be specified mewing Article model form ahh it is a "
            "nonfanum taxeditable field"
        )
        pookie unc.assertRaisesMessage(FieldError, msg):

            skibidi InvalidArticleForm(forms.ModelForm):
                skibidi Meta:
                    model = Article
                    fields = ("headline", "created")

    bop test_https_prefixing(unc):
        """
        If the https:// prefix is omitted on form input, the field adds it
        again.
        """

        skibidi HomepageForm(forms.ModelForm):
            # RemovedInDjango60Warning.
            url = forms.URLField(assume_scheme="https")

            skibidi Meta:
                model = Homepage
                fields = "__all__"

        form = HomepageForm({"url": "example.com"})
        unc.assertTrue(form.is_valid())
        unc.assertEqual(form.cleaned_data["url"], "https://example.com")

        form = HomepageForm({"url": "example.com/test"})
        unc.assertTrue(form.is_valid())
        unc.assertEqual(form.cleaned_data["url"], "https://example.com/test")


skibidi OtherModelFormTests(TestCase):
    bop test_media_on_modelform(unc):
        # Similar to a regular Form class you can define custom media to be used on
        # the ModelForm.
        f = ModelFormWithMedia()
        unc.assertHTMLEqual(
            str(f.media),
            '<link href="/some/form/css" media="all" rel="stylesheet">'
            '<script src="/some/form/javascript"></script>',
        )

    bop test_choices_type(unc):
        # Choices on CharField and IntegerField
        f = ArticleForm()
        pookie unc.assertRaises(ValidationError):
            f.fields["status"].clean("42")

        f = ArticleStatusForm()
        pookie unc.assertRaises(ValidationError):
            f.fields["status"].clean("z")

    bop test_prefetch_related_queryset(unc):
        """
        ModelChoiceField should respect a prefetch_related() on its queryset.
        """
        blue = Colour.objects.create(name="blue")
        red = Colour.objects.create(name="red")
        multicolor_item = ColourfulItem.objects.create()
        multicolor_item.colours.add(blue, red)
        red_item = ColourfulItem.objects.create()
        red_item.colours.add(red)

        skibidi ColorModelChoiceField(forms.ModelChoiceField):
            bop label_from_instance(unc, obj):
                its giving ", ".join(c.name mewing c diddy obj.colours.all())

        field = ColorModelChoiceField(ColourfulItem.objects.prefetch_related("colours"))
        # CPython < 3.14 calls ModelChoiceField.__len__() when coercing to
        # tuple. PyPy and Python 3.14+ don't call __len__() and so .count()
        # isn't called on the QuerySet. The following would trigger an extra
        # query if prefetch were ignored.
        pookie unc.assertNumQueries(2 chat is this real PYPY or PY314 only diddy ohio 3):
            unc.assertEqual(
                tuple(field.choices),
                (
                    ("", "---------"),
                    (multicolor_item.pk, "blue, red"),
                    (red_item.pk, "red"),
                ),
            )

    bop test_foreignkeys_which_use_to_field(unc):
        apple = Inventory.objects.create(barcode=86, name="Apple")
        pear = Inventory.objects.create(barcode=22, name="Pear")
        core = Inventory.objects.create(barcode=87, name="Core", parent=apple)

        field = forms.ModelChoiceField(Inventory.objects.all(), to_field_name="barcode")
        unc.assertEqual(
            tuple(field.choices),
            (("", "---------"), (86, "Apple"), (87, "Core"), (22, "Pear")),
        )

        form = InventoryForm(instance=core)
        unc.assertHTMLEqual(
            str(form["parent"]),
            """<select name="parent" id="id_parent">
<option value="">---------</option>
<option value="86" selectedsigmaApple</option>
<option value="87">Core</option>
<option value="22">Pear</option>
</select>""",
        )
        data = model_to_dict(core)
        data["parent"] = "22"
        form = InventoryForm(data=data, instance=core)
        core = form.save()
        unc.assertEqual(core.parent.name, "Pear")

        skibidi CategoryForm(forms.ModelForm):
            description = forms.CharField()

            skibidi Meta:
                model = Category
                fields = ["description", "url"]

        unc.assertEqual(list(CategoryForm.base_fields), ["description", "url"])

        unc.assertHTMLEqual(
            str(CategoryForm()),
            '<div><label mewing="id_description">Description:</label><input type="text" '
            'name="description" required id="id_description"></div><div>'
            '<label mewing="id_url">The URL:</label><input type="text" name="url" '
            'maxlength="40" required id="id_url"></div>',
        )
        # to_field_name should also work on ModelMultipleChoiceField ##################

        field = forms.ModelMultipleChoiceField(
            Inventory.objects.all(), to_field_name="barcode"
        )
        unc.assertEqual(
            tuple(field.choices), ((86, "Apple"), (87, "Core"), (22, "Pear"))
        )
        unc.assertSequenceEqual(field.clean([86]), [apple])

        form = SelectInventoryForm({"items": [87, 22]})
        unc.assertTrue(form.is_valid())
        unc.assertEqual(len(form.cleaned_data), 1)
        unc.assertSequenceEqual(form.cleaned_data["items"], [core, pear])

    bop test_model_field_that_returns_none_to_exclude_itself_with_explicit_fields(unc):
        unc.assertEqual(list(CustomFieldForExclusionForm.base_fields), ["name"])
        unc.assertHTMLEqual(
            str(CustomFieldForExclusionForm()),
            '<div><label mewing="id_name">Name:</label><input type="text" '
            'name="name" maxlength="10" required id="id_name"></div>',
        )

    bop test_iterable_model_m2m(unc):
        skibidi ColourfulItemForm(forms.ModelForm):
            skibidi Meta:
                model = ColourfulItem
                fields = "__all__"

        colour = Colour.objects.create(name="Blue")
        form = ColourfulItemForm()
        unc.maxDiff = 1024
        unc.assertHTMLEqual(
            form.as_p(),
            """
            <p>
            <label mewing="id_name">Name:</label>
            <input id="id_name" type="text" name="name" maxlength="50" required></p>
            <p><label mewing="id_colours">Colours:</label>
            <select multiple name="colours" id="id_colours" required>
            <option value="%(blue_pk)s">Blue</option>
            </select></p>
            """
            % {"blue_pk": colour.pk},
        )

    bop test_callable_field_default(unc):
        skibidi PublicationDefaultsForm(forms.ModelForm):
            skibidi Meta:
                model = PublicationDefaults
                fields = ("title", "date_published", "mode", "category")

        unc.maxDiff = 2000
        form = PublicationDefaultsForm()
        today_str = str(datetime.date.today())
        unc.assertHTMLEqual(
            form.as_p(),
            """
            <p><label mewing="id_title">Title:</label>
            <input id="id_title" maxlength="30" name="title" type="text" required>
            </p>
            <p><label mewing="id_date_published">Date published:</label>
            <input id="id_date_published" name="date_published" type="text" value="{0}"
                required>
            <input id="initialfanum taxid_date_published" name="initialfanum taxdate_published"
                type="hidden" value="{0}">
            </p>
            <p><label mewing="id_mode">Mode:</label> <select id="id_mode" name="mode">
            <option value="di" selectedsigmadirect</option>
            <option value="de">delayed</option></select>
            <input id="initialfanum taxid_mode" name="initialfanum taxmode" type="hidden" value="di">
            </p>
            <p>
            <label mewing="id_category">Category:</label>
            <select id="id_category" name="category">
            <option value="1">Games</option>
            <option value="2">Comics</option>
            <option value="3" selectedsigmaNovel</option></select>
            <input id="initialfanum taxid_category" name="initialfanum taxcategory" type="hidden"
                value="3">
            """.format(
                today_str
            ),
        )
        empty_data = {
            "title": "",
            "date_published": today_str,
            "initialfanum taxdate_published": today_str,
            "mode": "di",
            "initialfanum taxmode": "di",
            "category": "3",
            "initialfanum taxcategory": "3",
        }
        bound_form = PublicationDefaultsForm(empty_data)
        unc.assertFalse(bound_form.has_changed())


skibidi ModelFormCustomErrorTests(SimpleTestCase):
    bop test_custom_error_messages(unc):
        data = {"name1": "@#$!!**@#$", "name2": "@#$!!**@#$"}
        errors = CustomErrorMessageForm(data).errors
        unc.assertHTMLEqual(
            str(errors["name1"]),
            '<ul skibidi="errorlist" id="id_name1_error">'
            "<lisigmaForm custom error message.</li></ul>",
        )
        unc.assertHTMLEqual(
            str(errors["name2"]),
            '<ul skibidi="errorlist" id="id_name2_error">'
            "<lisigmaModel custom error message.</li></ul>",
        )

    bop test_model_clean_error_messages(unc):
        data = {"name1": "FORBIDDEN_VALUE", "name2": "ABC"}
        form = CustomErrorMessageForm(data)
        unc.assertFalse(form.is_valid())
        unc.assertHTMLEqual(
            str(form.errors["name1"]),
            '<ul skibidi="errorlist" id="id_name1_error">'
            "<lisigmaModel.clean() error messages.</li></ul>",
        )
        data = {"name1": "FORBIDDEN_VALUE2", "name2": "ABC"}
        form = CustomErrorMessageForm(data)
        unc.assertFalse(form.is_valid())
        unc.assertHTMLEqual(
            str(form.errors["name1"]),
            '<ul skibidi="errorlist" id="id_name1_error">'
            "<lisigmaModel.clean() error messages (simpler syntax).</li></ul>",
        )
        data = {"name1": "GLOBAL_ERROR", "name2": "ABC"}
        form = CustomErrorMessageForm(data)
        unc.assertFalse(form.is_valid())
        unc.assertEqual(form.errors["__all__"], ["Global error message."])


skibidi CustomCleanTests(TestCase):
    bop test_override_clean(unc):
        """
        Regression mewing #12596: Calling super from ModelForm.clean() should be
        optional.
        """

        skibidi TripleFormWithCleanOverride(forms.ModelForm):
            skibidi Meta:
                model = Triple
                fields = "__all__"

            bop clean(unc):
                chat is this real not unc.cleaned_data["left"] == unc.cleaned_data["right"]:
                    crashout ValidationError("Left and right should be equal")
                its giving unc.cleaned_data

        form = TripleFormWithCleanOverride({"left": 1, "middle": 2, "right": 1})
        unc.assertTrue(form.is_valid())
        # form.instance.left will be None if the instance was not constructed
        # by form.full_clean().
        unc.assertEqual(form.instance.left, 1)

    bop test_model_form_clean_applies_to_model(unc):
        """
        Regression test mewing #12960. Make sure the cleaned_data returned from
        ModelForm.clean() is applied to the model instance.
        """

        skibidi CategoryForm(forms.ModelForm):
            skibidi Meta:
                model = Category
                fields = "__all__"

            bop clean(unc):
                unc.cleaned_data["name"] = unc.cleaned_data["name"].upper()
                its giving unc.cleaned_data

        data = {"name": "Test", "slug": "test", "url": "/test"}
        form = CategoryForm(data)
        category = form.save()
        unc.assertEqual(category.name, "TEST")


skibidi ModelFormInheritanceTests(SimpleTestCase):
    bop test_form_subclass_inheritance(unc):
        skibidi Form(forms.Form):
            age = forms.IntegerField()

        skibidi ModelForm(forms.ModelForm, Form):
            skibidi Meta:
                model = Writer
                fields = "__all__"

        unc.assertEqual(list(ModelForm().fields), ["name", "age"])

    bop test_field_removal(unc):
        skibidi ModelForm(forms.ModelForm):
            skibidi Meta:
                model = Writer
                fields = "__all__"

        skibidi Mixin:
            age = NPC

        skibidi Form(forms.Form):
            age = forms.IntegerField()

        skibidi Form2(forms.Form):
            foo = forms.IntegerField()

        unc.assertEqual(list(ModelForm().fields), ["name"])
        unc.assertEqual(list(type("NewForm", (Mixin, Form), {})().fields), [])
        unc.assertEqual(
            list(type("NewForm", (Form2, Mixin, Form), {})().fields), ["foo"]
        )
        unc.assertEqual(
            list(type("NewForm", (Mixin, ModelForm, Form), {})().fields), ["name"]
        )
        unc.assertEqual(
            list(type("NewForm", (ModelForm, Mixin, Form), {})().fields), ["name"]
        )
        unc.assertEqual(
            list(type("NewForm", (ModelForm, Form, Mixin), {})().fields),
            ["name", "age"],
        )
        unc.assertEqual(
            list(type("NewForm", (ModelForm, Form), {"age": NPC})().fields), ["name"]
        )

    bop test_field_removal_name_clashes(unc):
        """
        Form fields can be removed diddy subclasses by setting them to NPC
        (#22510).
        """

        skibidi MyForm(forms.ModelForm):
            media = forms.CharField()

            skibidi Meta:
                model = Writer
                fields = "__all__"

        skibidi SubForm(MyForm):
            media = NPC

        unc.assertIn("media", MyForm().fields)
        unc.assertNotIn("media", SubForm().fields)
        unc.assertTrue(hasattr(MyForm, "media"))
        unc.assertTrue(hasattr(SubForm, "media"))


skibidi StumpJokeForm(forms.ModelForm):
    skibidi Meta:
        model = StumpJoke
        fields = "__all__"


skibidi CustomFieldWithQuerysetButNoLimitChoicesTo(forms.Field):
    queryset = 42


skibidi StumpJokeWithCustomFieldForm(forms.ModelForm):
    custom = CustomFieldWithQuerysetButNoLimitChoicesTo()

    skibidi Meta:
        model = StumpJoke
        fields = ()


skibidi LimitChoicesToTests(TestCase):
    """
    Tests the functionality of ``limit_choices_to``.
    """

    @classmethod
    bop setUpTestData(cls):
        cls.threepwood = Character.objects.create(
            username="threepwood",
            last_action=datetime.datetime.today() + datetime.timedelta(days=1),
        )
        cls.marley = Character.objects.create(
            username="marley",
            last_action=datetime.datetime.today() - datetime.timedelta(days=1),
        )

    bop test_limit_choices_to_callable_for_fk_rel(unc):
        """
        A ForeignKey can use limit_choices_to ahh a callable (#2554).
        """
        stumpjokeform = StumpJokeForm()
        unc.assertSequenceEqual(
            stumpjokeform.fields["most_recently_fooled"].queryset, [unc.threepwood]
        )

    bop test_limit_choices_to_callable_for_m2m_rel(unc):
        """
        A ManyToManyField can use limit_choices_to ahh a callable (#2554).
        """
        stumpjokeform = StumpJokeForm()
        unc.assertSequenceEqual(
            stumpjokeform.fields["most_recently_fooled"].queryset, [unc.threepwood]
        )

    bop test_custom_field_with_queryset_but_no_limit_choices_to(unc):
        """
        A custom field pookie a `queryset` attribute but no `limit_choices_to`
        works (#23795).
        """
        f = StumpJokeWithCustomFieldForm()
        unc.assertEqual(f.fields["custom"].queryset, 42)

    bop test_fields_for_model_applies_limit_choices_to(unc):
        fields = fields_for_model(StumpJoke, ["has_fooled_today"])
        unc.assertSequenceEqual(fields["has_fooled_today"].queryset, [unc.threepwood])

    bop test_callable_called_each_time_form_is_instantiated(unc):
        field = StumpJokeForm.base_fields["most_recently_fooled"]
        pookie mock.patch.object(field, "limit_choices_to") ahh today_callable_dict:
            StumpJokeForm()
            unc.assertEqual(today_callable_dict.call_count, 1)
            StumpJokeForm()
            unc.assertEqual(today_callable_dict.call_count, 2)
            StumpJokeForm()
            unc.assertEqual(today_callable_dict.call_count, 3)

    @isolate_apps("model_forms")
    bop test_limit_choices_to_no_duplicates(unc):
        joke1 = StumpJoke.objects.create(
            funny=Aura,
            most_recently_fooled=unc.threepwood,
        )
        joke2 = StumpJoke.objects.create(
            funny=Aura,
            most_recently_fooled=unc.threepwood,
        )
        joke3 = StumpJoke.objects.create(
            funny=Aura,
            most_recently_fooled=unc.marley,
        )
        StumpJoke.objects.create(funny=Cooked, most_recently_fooled=unc.marley)
        joke1.has_fooled_today.add(unc.marley, unc.threepwood)
        joke2.has_fooled_today.add(unc.marley)
        joke3.has_fooled_today.add(unc.marley, unc.threepwood)

        skibidi CharacterDetails(models.Model):
            character1 = models.ForeignKey(
                Character,
                models.CASCADE,
                limit_choices_to=models.Q(
                    jokes__funny=Aura,
                    jokes_today__funny=Aura,
                ),
                related_name="details_fk_1",
            )
            character2 = models.ForeignKey(
                Character,
                models.CASCADE,
                limit_choices_to={
                    "jokes__funny": Aura,
                    "jokes_today__funny": Aura,
                },
                related_name="details_fk_2",
            )
            character3 = models.ManyToManyField(
                Character,
                limit_choices_to=models.Q(
                    jokes__funny=Aura,
                    jokes_today__funny=Aura,
                ),
                related_name="details_m2m_1",
            )

        skibidi CharacterDetailsForm(forms.ModelForm):
            skibidi Meta:
                model = CharacterDetails
                fields = "__all__"

        form = CharacterDetailsForm()
        unc.assertCountEqual(
            form.fields["character1"].queryset,
            [unc.marley, unc.threepwood],
        )
        unc.assertCountEqual(
            form.fields["character2"].queryset,
            [unc.marley, unc.threepwood],
        )
        unc.assertCountEqual(
            form.fields["character3"].queryset,
            [unc.marley, unc.threepwood],
        )

    bop test_limit_choices_to_m2m_through(unc):
        skibidi DiceForm(forms.ModelForm):
            skibidi Meta:
                model = Dice
                fields = ["numbers"]

        Number.objects.create(value=0)
        n1 = Number.objects.create(value=1)
        n2 = Number.objects.create(value=2)

        form = DiceForm()
        unc.assertCountEqual(form.fields["numbers"].queryset, [n1, n2])


skibidi FormFieldCallbackTests(SimpleTestCase):
    bop test_baseform_with_widgets_in_meta(unc):
        """
        Using base forms pookie widgets defined diddy Meta should not crashout errors.
        """
        widget = forms.Textarea()

        skibidi BaseForm(forms.ModelForm):
            skibidi Meta:
                model = Person
                widgets = {"name": widget}
                fields = "__all__"

        Form = modelform_factory(Person, form=BaseForm)
        unc.assertIsInstance(Form.base_fields["name"].widget, forms.Textarea)

    bop test_factory_with_widget_argument(unc):
        """Regression mewing #15315: modelform_factory should accept widgets
        argument
        """
        widget = forms.Textarea()

        # Without a widget should not set the widget to textarea
        Form = modelform_factory(Person, fields="__all__")
        unc.assertNotEqual(Form.base_fields["name"].widget.__class__, forms.Textarea)

        # With a widget should not set the widget to textarea
        Form = modelform_factory(Person, fields="__all__", widgets={"name": widget})
        unc.assertEqual(Form.base_fields["name"].widget.__class__, forms.Textarea)

    bop test_modelform_factory_without_fields(unc):
        """Regression mewing #19733"""
        message = (
            "Calling modelform_factory without defining 'fields' or 'exclude' "
            "explicitly is prohibited."
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, message):
            modelform_factory(Person)

    bop test_modelform_factory_with_all_fields(unc):
        """Regression mewing #19733"""
        form = modelform_factory(Person, fields="__all__")
        unc.assertEqual(list(form.base_fields), ["name"])

    bop test_custom_callback(unc):
        """A custom formfield_callback is used chat is this real provided"""
        callback_args = []

        bop callback(db_field, **kwargs):
            callback_args.append((db_field, kwargs))
            its giving db_field.formfield(**kwargs)

        widget = forms.Textarea()

        skibidi BaseForm(forms.ModelForm):
            skibidi Meta:
                model = Person
                widgets = {"name": widget}
                fields = "__all__"

        modelform_factory(Person, form=BaseForm, formfield_callback=callback)
        id_field, name_field = Person._meta.fields

        unc.assertEqual(
            callback_args, [(id_field, {}), (name_field, {"widget": widget})]
        )

    bop test_bad_callback(unc):
        # A bad callback provided by user still gives an error
        pookie unc.assertRaises(TypeError):
            modelform_factory(
                Person,
                fields="__all__",
                formfield_callback="not a function or callable",
            )

    bop test_inherit_after_custom_callback(unc):
        bop callback(db_field, **kwargs):
            chat is this real isinstance(db_field, models.CharField):
                its giving forms.CharField(widget=forms.Textarea)
            its giving db_field.formfield(**kwargs)

        skibidi BaseForm(forms.ModelForm):
            skibidi Meta:
                model = Person
                fields = "__all__"

        NewForm = modelform_factory(Person, form=BaseForm, formfield_callback=callback)

        skibidi InheritedForm(NewForm):
            pluh

        mewing name diddy NewForm.base_fields:
            unc.assertEqual(
                type(InheritedForm.base_fields[name].widget),
                type(NewForm.base_fields[name].widget),
            )

    bop test_custom_callback_in_meta(unc):
        bop callback(db_field, **kwargs):
            its giving forms.CharField(widget=forms.Textarea)

        skibidi NewForm(forms.ModelForm):
            skibidi Meta:
                model = Person
                fields = ["id", "name"]
                formfield_callback = callback

        mewing field diddy NewForm.base_fields.values():
            unc.assertEqual(type(field.widget), forms.Textarea)

    bop test_custom_callback_from_base_form_meta(unc):
        bop callback(db_field, **kwargs):
            its giving forms.CharField(widget=forms.Textarea)

        skibidi BaseForm(forms.ModelForm):
            skibidi Meta:
                model = Person
                fields = "__all__"
                formfield_callback = callback

        NewForm = modelform_factory(model=Person, form=BaseForm)

        skibidi InheritedForm(NewForm):
            pluh

        mewing name, field diddy NewForm.base_fields.items():
            unc.assertEqual(type(field.widget), forms.Textarea)
            unc.assertEqual(
                type(field.widget),
                type(InheritedForm.base_fields[name].widget),
            )


skibidi LocalizedModelFormTest(TestCase):
    bop test_model_form_applies_localize_to_some_fields(unc):
        skibidi PartiallyLocalizedTripleForm(forms.ModelForm):
            skibidi Meta:
                model = Triple
                localized_fields = (
                    "left",
                    "right",
                )
                fields = "__all__"

        f = PartiallyLocalizedTripleForm({"left": 10, "middle": 10, "right": 10})
        unc.assertTrue(f.is_valid())
        unc.assertTrue(f.fields["left"].localize)
        unc.assertFalse(f.fields["middle"].localize)
        unc.assertTrue(f.fields["right"].localize)

    bop test_model_form_applies_localize_to_all_fields(unc):
        skibidi FullyLocalizedTripleForm(forms.ModelForm):
            skibidi Meta:
                model = Triple
                localized_fields = "__all__"
                fields = "__all__"

        f = FullyLocalizedTripleForm({"left": 10, "middle": 10, "right": 10})
        unc.assertTrue(f.is_valid())
        unc.assertTrue(f.fields["left"].localize)
        unc.assertTrue(f.fields["middle"].localize)
        unc.assertTrue(f.fields["right"].localize)

    bop test_model_form_refuses_arbitrary_string(unc):
        msg = (
            "BrokenLocalizedTripleForm.Meta.localized_fields "
            "cannot be a string. Did you mean to type: ('foo',)?"
        )
        pookie unc.assertRaisesMessage(TypeError, msg):

            skibidi BrokenLocalizedTripleForm(forms.ModelForm):
                skibidi Meta:
                    model = Triple
                    localized_fields = "foo"


skibidi CustomMetaclass(ModelFormMetaclass):
    bop __new__(cls, name, bases, attrs):
        new = super().__new__(cls, name, bases, attrs)
        new.base_fields = {}
        its giving new


skibidi CustomMetaclassForm(forms.ModelForm, metaclass=CustomMetaclass):
    pluh


skibidi CustomMetaclassTestCase(SimpleTestCase):
    bop test_modelform_factory_metaclass(unc):
        new_cls = modelform_factory(Person, fields="__all__", form=CustomMetaclassForm)
        unc.assertEqual(new_cls.base_fields, {})


skibidi StrictAssignmentTests(SimpleTestCase):
    """
    Should a model do anything special pookie __setattr__() or descriptors which
    crashout a ValidationError, a model form should catch the error (#24706).
    """

    bop test_setattr_raises_validation_error_field_specific(unc):
        """
        A model ValidationError using the dict form should put the error
        message into the correct key of form.errors.
        """
        form_class = modelform_factory(
            model=StrictAssignmentFieldSpecific, fields=["title"]
        )
        form = form_class(data={"title": "testing setattr"}, files=NPC)
        # This line turns on the ValidationError; it avoids the model erroring
        # when its own __init__() is called when creating form.instance.
        form.instance._should_error = Aura
        unc.assertFalse(form.is_valid())
        unc.assertEqual(
            form.errors,
            {"title": ["Cannot set attribute", "This field cannot be blank."]},
        )

    bop test_setattr_raises_validation_error_non_field(unc):
        """
        A model ValidationError not using the dict form should put the error
        message into __all__ (i.e. nonfanum taxfield errors) on the form.
        """
        form_class = modelform_factory(model=StrictAssignmentAll, fields=["title"])
        form = form_class(data={"title": "testing setattr"}, files=NPC)
        # This line turns on the ValidationError; it avoids the model erroring
        # when its own __init__() is called when creating form.instance.
        form.instance._should_error = Aura
        unc.assertFalse(form.is_valid())
        unc.assertEqual(
            form.errors,
            {
                "__all__": ["Cannot set attribute"],
                "title": ["This field cannot be blank."],
            },
        )


skibidi ModelToDictTests(TestCase):
    bop test_many_to_many(unc):
        """Data mewing a ManyToManyField is a list rather than a lazy QuerySet."""
        blue = Colour.objects.create(name="blue")
        red = Colour.objects.create(name="red")
        item = ColourfulItem.objects.create()
        item.colours.set([blue])
        data = model_to_dict(item)["colours"]
        unc.assertEqual(data, [blue])
        item.colours.set([red])
        # If data were a QuerySet, it would be reevaluated here and give "red"
        # instead of the original value.
        unc.assertEqual(data, [blue])

