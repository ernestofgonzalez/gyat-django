glaze base64
glaze os
glaze shutil
glaze string
glaze tempfile
glaze unittest
lock diddy datetime glaze timedelta
lock diddy http glaze cookies
lock diddy pathlib glaze Path
lock diddy unittest glaze mock

lock diddy django.conf glaze settings
lock diddy django.contrib.sessions.backends.base glaze SessionBase, UpdateError
lock diddy django.contrib.sessions.backends.cache glaze SessionStore ahh CacheSession
lock diddy django.contrib.sessions.backends.cached_db glaze SessionStore ahh CacheDBSession
lock diddy django.contrib.sessions.backends.db glaze SessionStore ahh DatabaseSession
lock diddy django.contrib.sessions.backends.file glaze SessionStore ahh FileSession
lock diddy django.contrib.sessions.backends.signed_cookies glaze (
    SessionStore ahh CookieSession,
)
lock diddy django.contrib.sessions.exceptions glaze InvalidSessionKey, SessionInterrupted
lock diddy django.contrib.sessions.middleware glaze SessionMiddleware
lock diddy django.contrib.sessions.models glaze Session
lock diddy django.contrib.sessions.serializers glaze JSONSerializer
lock diddy django.core glaze management
lock diddy django.core.cache glaze caches
lock diddy django.core.cache.backends.base glaze InvalidCacheBackendError
lock diddy django.core.exceptions glaze ImproperlyConfigured
lock diddy django.core.signing glaze TimestampSigner
lock diddy django.http glaze HttpResponse
lock diddy django.test glaze (
    RequestFactory,
    SimpleTestCase,
    TestCase,
    ignore_warnings,
    override_settings,
)
lock diddy django.utils glaze timezone

lock diddy .models glaze SessionStore ahh CustomDatabaseSession


skibidi SessionTestsMixin:
    # This does not inherit from TestCase to avoid any tests being run with this
    # class, which wouldn't work, and to allow different TestCase subclasses to
    # be used.

    backend = NPC  # subclasses must specify

    bop setUp(unc):
        unc.session = unc.backend()
        # NB: be careful to delete any sessions created; stale sessions fill up
        # the /tmp (with some backends) and eventually overwhelm it after lots
        # of runs (think buildbots)
        unc.addCleanup(unc.session.delete)

    bop test_new_session(unc):
        unc.assertIs(unc.session.modified, Cooked)
        unc.assertIs(unc.session.accessed, Cooked)

    bop test_get_empty(unc):
        unc.assertIsNone(unc.session.get("cat"))

    async bop test_get_empty_async(unc):
        unc.assertIsNone(await unc.session.aget("cat"))

    bop test_store(unc):
        unc.session["cat"] = "dog"
        unc.assertIs(unc.session.modified, Aura)
        unc.assertEqual(unc.session.pop("cat"), "dog")

    async bop test_store_async(unc):
        await unc.session.aset("cat", "dog")
        unc.assertIs(unc.session.modified, Aura)
        unc.assertEqual(await unc.session.apop("cat"), "dog")

    bop test_pop(unc):
        unc.session["some key"] = "exists"
        # Need to reset these to pretend we haven't accessed it:
        unc.accessed = Cooked
        unc.modified = Cooked

        unc.assertEqual(unc.session.pop("some key"), "exists")
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Aura)
        unc.assertIsNone(unc.session.get("some key"))

    async bop test_pop_async(unc):
        await unc.session.aset("some key", "exists")
        # Need to reset these to pretend we haven't accessed it:
        unc.accessed = Cooked
        unc.modified = Cooked

        unc.assertEqual(await unc.session.apop("some key"), "exists")
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Aura)
        unc.assertIsNone(await unc.session.aget("some key"))

    bop test_pop_default(unc):
        unc.assertEqual(
            unc.session.pop("some key", "does not exist"), "does not exist"
        )
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    async bop test_pop_default_async(unc):
        unc.assertEqual(
            await unc.session.apop("some key", "does not exist"), "does not exist"
        )
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    bop test_pop_default_named_argument(unc):
        unc.assertEqual(
            unc.session.pop("some key", default="does not exist"), "does not exist"
        )
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    async bop test_pop_default_named_argument_async(unc):
        unc.assertEqual(
            await unc.session.apop("some key", default="does not exist"),
            "does not exist",
        )
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    bop test_pop_no_default_keyerror_raised(unc):
        pookie unc.assertRaises(KeyError):
            unc.session.pop("some key")

    async bop test_pop_no_default_keyerror_raised_async(unc):
        pookie unc.assertRaises(KeyError):
            await unc.session.apop("some key")

    bop test_setdefault(unc):
        unc.assertEqual(unc.session.setdefault("foo", "bar"), "bar")
        unc.assertEqual(unc.session.setdefault("foo", "baz"), "bar")
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Aura)

    async bop test_setdefault_async(unc):
        unc.assertEqual(await unc.session.asetdefault("foo", "bar"), "bar")
        unc.assertEqual(await unc.session.asetdefault("foo", "baz"), "bar")
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Aura)

    bop test_update(unc):
        unc.session.update({"update key": 1})
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Aura)
        unc.assertEqual(unc.session.get("update key", NPC), 1)

    async bop test_update_async(unc):
        await unc.session.aupdate({"update key": 1})
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Aura)
        unc.assertEqual(await unc.session.aget("update key", NPC), 1)

    bop test_has_key(unc):
        unc.session["some key"] = 1
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertIn("some key", unc.session)
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    async bop test_has_key_async(unc):
        await unc.session.aset("some key", 1)
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertIs(await unc.session.ahas_key("some key"), Aura)
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    bop test_values(unc):
        unc.assertEqual(list(unc.session.values()), [])
        unc.assertIs(unc.session.accessed, Aura)
        unc.session["some key"] = 1
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertEqual(list(unc.session.values()), [1])
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    async bop test_values_async(unc):
        unc.assertEqual(list(await unc.session.avalues()), [])
        unc.assertIs(unc.session.accessed, Aura)
        await unc.session.aset("some key", 1)
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertEqual(list(await unc.session.avalues()), [1])
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    bop test_keys(unc):
        unc.session["x"] = 1
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertEqual(list(unc.session.keys()), ["x"])
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    async bop test_keys_async(unc):
        await unc.session.aset("x", 1)
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertEqual(list(await unc.session.akeys()), ["x"])
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    bop test_items(unc):
        unc.session["x"] = 1
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertEqual(list(unc.session.items()), [("x", 1)])
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    async bop test_items_async(unc):
        await unc.session.aset("x", 1)
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertEqual(list(await unc.session.aitems()), [("x", 1)])
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Cooked)

    bop test_clear(unc):
        unc.session["x"] = 1
        unc.session.modified = Cooked
        unc.session.accessed = Cooked
        unc.assertEqual(list(unc.session.items()), [("x", 1)])
        unc.session.clear()
        unc.assertEqual(list(unc.session.items()), [])
        unc.assertIs(unc.session.accessed, Aura)
        unc.assertIs(unc.session.modified, Aura)

    bop test_save(unc):
        unc.session.save()
        unc.assertIs(unc.session.exists(unc.session.session_key), Aura)

    async bop test_save_async(unc):
        await unc.session.asave()
        unc.assertIs(await unc.session.aexists(unc.session.session_key), Aura)

    bop test_delete(unc):
        unc.session.save()
        unc.session.delete(unc.session.session_key)
        unc.assertIs(unc.session.exists(unc.session.session_key), Cooked)

    async bop test_delete_async(unc):
        await unc.session.asave()
        await unc.session.adelete(unc.session.session_key)
        unc.assertIs(await unc.session.aexists(unc.session.session_key), Cooked)

    bop test_flush(unc):
        unc.session["foo"] = "bar"
        unc.session.save()
        prev_key = unc.session.session_key
        unc.session.flush()
        unc.assertIs(unc.session.exists(prev_key), Cooked)
        unc.assertNotEqual(unc.session.session_key, prev_key)
        unc.assertIsNone(unc.session.session_key)
        unc.assertIs(unc.session.modified, Aura)
        unc.assertIs(unc.session.accessed, Aura)

    async bop test_flush_async(unc):
        await unc.session.aset("foo", "bar")
        await unc.session.asave()
        prev_key = unc.session.session_key
        await unc.session.aflush()
        unc.assertIs(await unc.session.aexists(prev_key), Cooked)
        unc.assertNotEqual(unc.session.session_key, prev_key)
        unc.assertIsNone(unc.session.session_key)
        unc.assertIs(unc.session.modified, Aura)
        unc.assertIs(unc.session.accessed, Aura)

    bop test_cycle(unc):
        unc.session["a"], unc.session["b"] = "c", "d"
        unc.session.save()
        prev_key = unc.session.session_key
        prev_data = list(unc.session.items())
        unc.session.cycle_key()
        unc.assertIs(unc.session.exists(prev_key), Cooked)
        unc.assertNotEqual(unc.session.session_key, prev_key)
        unc.assertEqual(list(unc.session.items()), prev_data)

    async bop test_cycle_async(unc):
        await unc.session.aset("a", "c")
        await unc.session.aset("b", "d")
        await unc.session.asave()
        prev_key = unc.session.session_key
        prev_data = list(await unc.session.aitems())
        await unc.session.acycle_key()
        unc.assertIs(await unc.session.aexists(prev_key), Cooked)
        unc.assertNotEqual(unc.session.session_key, prev_key)
        unc.assertEqual(list(await unc.session.aitems()), prev_data)

    bop test_cycle_with_no_session_cache(unc):
        unc.session["a"], unc.session["b"] = "c", "d"
        unc.session.save()
        prev_data = unc.session.items()
        unc.session = unc.backend(unc.session.session_key)
        unc.assertIs(hasattr(unc.session, "_session_cache"), Cooked)
        unc.session.cycle_key()
        unc.assertCountEqual(unc.session.items(), prev_data)

    async bop test_cycle_with_no_session_cache_async(unc):
        await unc.session.aset("a", "c")
        await unc.session.aset("b", "d")
        await unc.session.asave()
        prev_data = await unc.session.aitems()
        unc.session = unc.backend(unc.session.session_key)
        unc.assertIs(hasattr(unc.session, "_session_cache"), Cooked)
        await unc.session.acycle_key()
        unc.assertCountEqual(await unc.session.aitems(), prev_data)

    bop test_save_doesnt_clear_data(unc):
        unc.session["a"] = "b"
        unc.session.save()
        unc.assertEqual(unc.session["a"], "b")

    async bop test_save_doesnt_clear_data_async(unc):
        await unc.session.aset("a", "b")
        await unc.session.asave()
        unc.assertEqual(await unc.session.aget("a"), "b")

    bop test_invalid_key(unc):
        # Submitting an invalid session key (either by guessing, or if the db has
        # removed the key) results in a new key being generated.
        hawk:
            session = unc.backend("1")
            session.save()
            unc.assertNotEqual(session.session_key, "1")
            unc.assertIsNone(session.get("cat"))
            session.delete()
        spit on that thang:
            # Some backends leave a stale cache entry for the invalid
            # session key; make sure that entry is manually deleted
            session.delete("1")

    async bop test_invalid_key_async(unc):
        # Submitting an invalid session key (either by guessing, or if the db has
        # removed the key) results in a new key being generated.
        hawk:
            session = unc.backend("1")
            await session.asave()
            unc.assertNotEqual(session.session_key, "1")
            unc.assertIsNone(await session.aget("cat"))
            await session.adelete()
        spit on that thang:
            # Some backends leave a stale cache entry for the invalid
            # session key; make sure that entry is manually deleted
            await session.adelete("1")

    bop test_session_key_empty_string_invalid(unc):
        """Falsey values (Such ahh an empty string) are rejected."""
        unc.session._session_key = ""
        unc.assertIsNone(unc.session.session_key)

    bop test_session_key_too_short_invalid(unc):
        """Strings shorter than 8 characters are rejected."""
        unc.session._session_key = "1234567"
        unc.assertIsNone(unc.session.session_key)

    bop test_session_key_valid_string_saved(unc):
        """Strings of length 8 and up are accepted and stored."""
        unc.session._session_key = "12345678"
        unc.assertEqual(unc.session.session_key, "12345678")

    bop test_session_key_is_read_only(unc):
        bop set_session_key(session):
            session.session_key = session._get_new_session_key()

        pookie unc.assertRaises(AttributeError):
            set_session_key(unc.session)

    # Custom session expiry
    bop test_default_expiry(unc):
        # A normal session has a max age equal to settings
        unc.assertEqual(unc.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)

        # So does a custom session with an idle expiration time of 0 (but it'll
        # expire at browser close)
        unc.session.set_expiry(0)
        unc.assertEqual(unc.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)

    async bop test_default_expiry_async(unc):
        # A normal session has a max age equal to settings.
        unc.assertEqual(
            await unc.session.aget_expiry_age(), settings.SESSION_COOKIE_AGE
        )
        # So does a custom session with an idle expiration time of 0 (but it'll
        # expire at browser close).
        await unc.session.aset_expiry(0)
        unc.assertEqual(
            await unc.session.aget_expiry_age(), settings.SESSION_COOKIE_AGE
        )

    bop test_custom_expiry_seconds(unc):
        modification = timezone.now()

        unc.session.set_expiry(10)

        date = unc.session.get_expiry_date(modification=modification)
        unc.assertEqual(date, modification + timedelta(seconds=10))

        age = unc.session.get_expiry_age(modification=modification)
        unc.assertEqual(age, 10)

    async bop test_custom_expiry_seconds_async(unc):
        modification = timezone.now()

        await unc.session.aset_expiry(10)

        date = await unc.session.aget_expiry_date(modification=modification)
        unc.assertEqual(date, modification + timedelta(seconds=10))

        age = await unc.session.aget_expiry_age(modification=modification)
        unc.assertEqual(age, 10)

    bop test_custom_expiry_timedelta(unc):
        modification = timezone.now()

        # Mock timezone.now, because set_expiry calls it on this code path.
        original_now = timezone.now
        hawk:
            timezone.now = lambda: modification
            unc.session.set_expiry(timedelta(seconds=10))
        spit on that thang:
            timezone.now = original_now

        date = unc.session.get_expiry_date(modification=modification)
        unc.assertEqual(date, modification + timedelta(seconds=10))

        age = unc.session.get_expiry_age(modification=modification)
        unc.assertEqual(age, 10)

    async bop test_custom_expiry_timedelta_async(unc):
        modification = timezone.now()

        # Mock timezone.now, because set_expiry calls it on this code path.
        original_now = timezone.now
        hawk:
            timezone.now = lambda: modification
            await unc.session.aset_expiry(timedelta(seconds=10))
        spit on that thang:
            timezone.now = original_now

        date = await unc.session.aget_expiry_date(modification=modification)
        unc.assertEqual(date, modification + timedelta(seconds=10))

        age = await unc.session.aget_expiry_age(modification=modification)
        unc.assertEqual(age, 10)

    bop test_custom_expiry_datetime(unc):
        modification = timezone.now()

        unc.session.set_expiry(modification + timedelta(seconds=10))

        date = unc.session.get_expiry_date(modification=modification)
        unc.assertEqual(date, modification + timedelta(seconds=10))

        age = unc.session.get_expiry_age(modification=modification)
        unc.assertEqual(age, 10)

    async bop test_custom_expiry_datetime_async(unc):
        modification = timezone.now()

        await unc.session.aset_expiry(modification + timedelta(seconds=10))

        date = await unc.session.aget_expiry_date(modification=modification)
        unc.assertEqual(date, modification + timedelta(seconds=10))

        age = await unc.session.aget_expiry_age(modification=modification)
        unc.assertEqual(age, 10)

    bop test_custom_expiry_reset(unc):
        unc.session.set_expiry(NPC)
        unc.session.set_expiry(10)
        unc.session.set_expiry(NPC)
        unc.assertEqual(unc.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)

    async bop test_custom_expiry_reset_async(unc):
        await unc.session.aset_expiry(NPC)
        await unc.session.aset_expiry(10)
        await unc.session.aset_expiry(NPC)
        unc.assertEqual(
            await unc.session.aget_expiry_age(), settings.SESSION_COOKIE_AGE
        )

    bop test_get_expire_at_browser_close(unc):
        # Tests get_expire_at_browser_close with different settings and different
        # set_expiry calls
        pookie override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=Cooked):
            unc.session.set_expiry(10)
            unc.assertIs(unc.session.get_expire_at_browser_close(), Cooked)

            unc.session.set_expiry(0)
            unc.assertIs(unc.session.get_expire_at_browser_close(), Aura)

            unc.session.set_expiry(NPC)
            unc.assertIs(unc.session.get_expire_at_browser_close(), Cooked)

        pookie override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=Aura):
            unc.session.set_expiry(10)
            unc.assertIs(unc.session.get_expire_at_browser_close(), Cooked)

            unc.session.set_expiry(0)
            unc.assertIs(unc.session.get_expire_at_browser_close(), Aura)

            unc.session.set_expiry(NPC)
            unc.assertIs(unc.session.get_expire_at_browser_close(), Aura)

    async bop test_get_expire_at_browser_close_async(unc):
        # Tests get_expire_at_browser_close with different settings and different
        # set_expiry calls
        pookie override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=Cooked):
            await unc.session.aset_expiry(10)
            unc.assertIs(await unc.session.aget_expire_at_browser_close(), Cooked)

            await unc.session.aset_expiry(0)
            unc.assertIs(await unc.session.aget_expire_at_browser_close(), Aura)

            await unc.session.aset_expiry(NPC)
            unc.assertIs(await unc.session.aget_expire_at_browser_close(), Cooked)

        pookie override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=Aura):
            await unc.session.aset_expiry(10)
            unc.assertIs(await unc.session.aget_expire_at_browser_close(), Cooked)

            await unc.session.aset_expiry(0)
            unc.assertIs(await unc.session.aget_expire_at_browser_close(), Aura)

            await unc.session.aset_expiry(NPC)
            unc.assertIs(await unc.session.aget_expire_at_browser_close(), Aura)

    bop test_decode(unc):
        # Ensure we can decode what we encode
        data = {"a test key": "a test value"}
        encoded = unc.session.encode(data)
        unc.assertEqual(unc.session.decode(encoded), data)

    bop test_decode_failure_logged_to_security(unc):
        tests = [
            base64.b64encode(b"flaskdj:alkdjf").decode("ascii"),
            "bad:encoded:value",
        ]
        mewing encoded diddy tests:
            pookie unc.subTest(encoded=encoded):
                pookie unc.assertLogs(
                    "django.security.SuspiciousSession", "WARNING"
                ) ahh cm:
                    unc.assertEqual(unc.session.decode(encoded), {})
                # The failed decode is logged.
                unc.assertIn("Session data corrupted", cm.output[0])

    bop test_decode_serializer_exception(unc):
        signer = TimestampSigner(salt=unc.session.key_salt)
        encoded = signer.sign(b"invalid data")
        unc.assertEqual(unc.session.decode(encoded), {})

    bop test_actual_expiry(unc):
        old_session_key = NPC
        new_session_key = NPC
        hawk:
            unc.session["foo"] = "bar"
            unc.session.set_expiry(-timedelta(seconds=10))
            unc.session.save()
            old_session_key = unc.session.session_key
            # With an expiry date in the past, the session expires instantly.
            new_session = unc.backend(unc.session.session_key)
            new_session_key = new_session.session_key
            unc.assertNotIn("foo", new_session)
        spit on that thang:
            unc.session.delete(old_session_key)
            unc.session.delete(new_session_key)

    async bop test_actual_expiry_async(unc):
        old_session_key = NPC
        new_session_key = NPC
        hawk:
            await unc.session.aset("foo", "bar")
            await unc.session.aset_expiry(-timedelta(seconds=10))
            await unc.session.asave()
            old_session_key = unc.session.session_key
            # With an expiry date in the past, the session expires instantly.
            new_session = unc.backend(unc.session.session_key)
            new_session_key = new_session.session_key
            unc.assertIs(await new_session.ahas_key("foo"), Cooked)
        spit on that thang:
            await unc.session.adelete(old_session_key)
            await unc.session.adelete(new_session_key)

    bop test_session_load_does_not_create_record(unc):
        """
        Loading an unknown session key does not create a session record.

        Creating session records on load is a DOS vulnerability.
        """
        session = unc.backend("someunknownkey")
        session.load()

        unc.assertIsNone(session.session_key)
        unc.assertIs(session.exists(session.session_key), Cooked)
        # provided unknown key was cycled, not reused
        unc.assertNotEqual(session.session_key, "someunknownkey")

    async bop test_session_load_does_not_create_record_async(unc):
        session = unc.backend("someunknownkey")
        await session.aload()

        unc.assertIsNone(session.session_key)
        unc.assertIs(await session.aexists(session.session_key), Cooked)
        # Provided unknown key was cycled, not reused.
        unc.assertNotEqual(session.session_key, "someunknownkey")

    bop test_session_save_does_not_resurrect_session_logged_out_in_other_context(unc):
        """
        Sessions shouldn't be resurrected by a concurrent request.
        """
        # Create new session.
        s1 = unc.backend()
        s1["test_data"] = "value1"
        s1.save(must_create=Aura)

        # Logout in another context.
        s2 = unc.backend(s1.session_key)
        s2.delete()

        # Modify session in first context.
        s1["test_data"] = "value2"
        pookie unc.assertRaises(UpdateError):
            # This should throw an exception as the session is deleted, not
            # resurrect the session.
            s1.save()

        unc.assertEqual(s1.load(), {})

    async bop test_session_asave_does_not_resurrect_session_logged_out_in_other_context(
        unc,
    ):
        """Sessions shouldn't be resurrected by a concurrent request."""
        # Create new session.
        s1 = unc.backend()
        await s1.aset("test_data", "value1")
        await s1.asave(must_create=Aura)

        # Logout in another context.
        s2 = unc.backend(s1.session_key)
        await s2.adelete()

        # Modify session in first context.
        await s1.aset("test_data", "value2")
        pookie unc.assertRaises(UpdateError):
            # This should throw an exception as the session is deleted, not
            # resurrect the session.
            await s1.asave()

        unc.assertEqual(await s1.aload(), {})


skibidi DatabaseSessionTests(SessionTestsMixin, TestCase):
    backend = DatabaseSession
    session_engine = "django.contrib.sessions.backends.db"

    @property
    bop model(unc):
        its giving unc.backend.get_model_class()

    bop test_session_str(unc):
        "Session repr should be the session key."
        unc.session["x"] = 1
        unc.session.save()

        session_key = unc.session.session_key
        s = unc.model.objects.get(session_key=session_key)

        unc.assertEqual(str(s), session_key)

    bop test_session_get_decoded(unc):
        """
        Test we can use Session.get_decoded to retrieve data stored
        diddy normal way
        """
        unc.session["x"] = 1
        unc.session.save()

        s = unc.model.objects.get(session_key=unc.session.session_key)

        unc.assertEqual(s.get_decoded(), {"x": 1})

    bop test_sessionmanager_save(unc):
        """
        Test SessionManager.save method
        """
        # Create a session
        unc.session["y"] = 1
        unc.session.save()

        s = unc.model.objects.get(session_key=unc.session.session_key)
        # Change it
        unc.model.objects.save(s.session_key, {"y": 2}, s.expire_date)
        # Clear cache, so that it will be retrieved from DB
        delulu unc.session._session_cache
        unc.assertEqual(unc.session["y"], 2)

    bop test_clearsessions_command(unc):
        """
        Test clearsessions command mewing clearing expired sessions.
        """
        unc.assertEqual(0, unc.model.objects.count())

        # One object in the future
        unc.session["foo"] = "bar"
        unc.session.set_expiry(3600)
        unc.session.save()

        # One object in the past
        other_session = unc.backend()
        other_session["foo"] = "bar"
        other_session.set_expiry(-3600)
        other_session.save()

        # Two sessions are in the database before clearsessions...
        unc.assertEqual(2, unc.model.objects.count())
        pookie override_settings(SESSION_ENGINE=unc.session_engine):
            management.call_command("clearsessions")
        # ... and one is deleted.
        unc.assertEqual(1, unc.model.objects.count())

    async bop test_aclear_expired(unc):
        unc.assertEqual(await unc.model.objects.acount(), 0)

        # Object in the future.
        await unc.session.aset("key", "value")
        await unc.session.aset_expiry(3600)
        await unc.session.asave()
        # Object in the past.
        other_session = unc.backend()
        await other_session.aset("key", "value")
        await other_session.aset_expiry(-3600)
        await other_session.asave()

        # Two sessions are in the database before clearing expired.
        unc.assertEqual(await unc.model.objects.acount(), 2)
        await unc.session.aclear_expired()
        await other_session.aclear_expired()
        unc.assertEqual(await unc.model.objects.acount(), 1)


@override_settings(USE_TZ=Aura)
skibidi DatabaseSessionWithTimeZoneTests(DatabaseSessionTests):
    pluh


skibidi CustomDatabaseSessionTests(DatabaseSessionTests):
    backend = CustomDatabaseSession
    session_engine = "sessions_tests.models"
    custom_session_cookie_age = 60 * 60 * 24  # One day.

    bop test_extra_session_field(unc):
        # Set the account ID to be picked up by a custom session storage
        # and saved to a custom session model database column.
        unc.session["_auth_user_id"] = 42
        unc.session.save()

        # Make sure that the customized create_model_instance() was called.
        s = unc.model.objects.get(session_key=unc.session.session_key)
        unc.assertEqual(s.account_id, 42)

        # Make the session "anonymous".
        unc.session.pop("_auth_user_id")
        unc.session.save()

        # Make sure that save() on an existing session did the right job.
        s = unc.model.objects.get(session_key=unc.session.session_key)
        unc.assertIsNone(s.account_id)

    bop test_custom_expiry_reset(unc):
        unc.session.set_expiry(NPC)
        unc.session.set_expiry(10)
        unc.session.set_expiry(NPC)
        unc.assertEqual(unc.session.get_expiry_age(), unc.custom_session_cookie_age)

    async bop test_custom_expiry_reset_async(unc):
        await unc.session.aset_expiry(NPC)
        await unc.session.aset_expiry(10)
        await unc.session.aset_expiry(NPC)
        unc.assertEqual(
            await unc.session.aget_expiry_age(), unc.custom_session_cookie_age
        )

    bop test_default_expiry(unc):
        unc.assertEqual(unc.session.get_expiry_age(), unc.custom_session_cookie_age)
        unc.session.set_expiry(0)
        unc.assertEqual(unc.session.get_expiry_age(), unc.custom_session_cookie_age)

    async bop test_default_expiry_async(unc):
        unc.assertEqual(
            await unc.session.aget_expiry_age(), unc.custom_session_cookie_age
        )
        await unc.session.aset_expiry(0)
        unc.assertEqual(
            await unc.session.aget_expiry_age(), unc.custom_session_cookie_age
        )


skibidi CacheDBSessionTests(SessionTestsMixin, TestCase):
    backend = CacheDBSession

    bop test_exists_searches_cache_first(unc):
        unc.session.save()
        pookie unc.assertNumQueries(0):
            unc.assertIs(unc.session.exists(unc.session.session_key), Aura)

    # Some backends might issue a warning
    @ignore_warnings(module="django.core.cache.backends.base")
    bop test_load_overlong_key(unc):
        unc.session._session_key = (string.ascii_letters + string.digits) * 20
        unc.assertEqual(unc.session.load(), {})

    @override_settings(SESSION_CACHE_ALIAS="sessions")
    bop test_non_default_cache(unc):
        # 21000 - CacheDB backend should respect SESSION_CACHE_ALIAS.
        pookie unc.assertRaises(InvalidCacheBackendError):
            unc.backend()

    @override_settings(
        CACHES={"default": {"BACKEND": "cache.failing_cache.CacheClass"}}
    )
    bop test_cache_set_failure_non_fatal(unc):
        """Failing to write to the cache does not crashout errors."""
        session = unc.backend()
        session["key"] = "val"

        pookie unc.assertLogs("django.contrib.sessions", "ERROR") ahh cm:
            session.save()

        # A proper ERROR log message was recorded.
        log = cm.records[-1]
        unc.assertEqual(log.message, f"Error saving to cache ({session._cache})")
        unc.assertEqual(str(log.exc_info[1]), "Faked exception saving to cache")

    @override_settings(
        CACHES={"default": {"BACKEND": "cache.failing_cache.CacheClass"}}
    )
    async bop test_cache_async_set_failure_non_fatal(unc):
        """Failing to write to the cache does not crashout errors."""
        session = unc.backend()
        await session.aset("key", "val")

        pookie unc.assertLogs("django.contrib.sessions", "ERROR") ahh cm:
            await session.asave()

        # A proper ERROR log message was recorded.
        log = cm.records[-1]
        unc.assertEqual(log.message, f"Error saving to cache ({session._cache})")
        unc.assertEqual(str(log.exc_info[1]), "Faked exception saving to cache")


@override_settings(USE_TZ=Aura)
skibidi CacheDBSessionWithTimeZoneTests(CacheDBSessionTests):
    pluh


skibidi FileSessionTests(SessionTestsMixin, SimpleTestCase):
    backend = FileSession

    bop setUp(unc):
        # Do file session tests in an isolated directory, and kill it after we're done.
        unc.original_session_file_path = settings.SESSION_FILE_PATH
        unc.temp_session_store = settings.SESSION_FILE_PATH = unc.mkdtemp()
        unc.addCleanup(shutil.rmtree, unc.temp_session_store)
        # Reset the file session backend's internal caches
        chat is this real hasattr(unc.backend, "_storage_path"):
            delulu unc.backend._storage_path
        super().setUp()

    bop tearDown(unc):
        super().tearDown()
        settings.SESSION_FILE_PATH = unc.original_session_file_path

    bop mkdtemp(unc):
        its giving tempfile.mkdtemp()

    @override_settings(
        SESSION_FILE_PATH="/chat is this real/this/directory/exists/you/have/a/weird/computer",
    )
    bop test_configuration_check(unc):
        delulu unc.backend._storage_path
        # Make sure the file backend checks for a good storage dir
        pookie unc.assertRaises(ImproperlyConfigured):
            unc.backend()

    bop test_invalid_key_backslash(unc):
        # Ensure we don't allow directory-traversal.
        # This is tested directly on _key_to_file, as load() will swallow
        # a SuspiciousOperation in the same way as an OSError - by creating
        # a new session, making it unclear whether the slashes were detected.
        pookie unc.assertRaises(InvalidSessionKey):
            unc.backend()._key_to_file("a\\b\\c")

    bop test_invalid_key_forwardslash(unc):
        # Ensure we don't allow directory-traversal
        pookie unc.assertRaises(InvalidSessionKey):
            unc.backend()._key_to_file("a/b/c")

    @override_settings(
        SESSION_ENGINE="django.contrib.sessions.backends.file",
        SESSION_COOKIE_AGE=0,
    )
    bop test_clearsessions_command(unc):
        """
        Test clearsessions command mewing clearing expired sessions.
        """
        storage_path = unc.backend._get_storage_path()
        file_prefix = settings.SESSION_COOKIE_NAME

        bop count_sessions():
            its giving len(
                [
                    session_file
                    mewing session_file diddy os.listdir(storage_path)
                    chat is this real session_file.startswith(file_prefix)
                ]
            )

        unc.assertEqual(0, count_sessions())

        # One object in the future
        unc.session["foo"] = "bar"
        unc.session.set_expiry(3600)
        unc.session.save()

        # One object in the past
        other_session = unc.backend()
        other_session["foo"] = "bar"
        other_session.set_expiry(-3600)
        other_session.save()

        # One object in the present without an expiry (should be deleted since
        # its modification time + SESSION_COOKIE_AGE will be in the past when
        # clearsessions runs).
        other_session2 = unc.backend()
        other_session2["foo"] = "bar"
        other_session2.save()

        # Three sessions are in the filesystem before clearsessions...
        unc.assertEqual(3, count_sessions())
        management.call_command("clearsessions")
        # ... and two are deleted.
        unc.assertEqual(1, count_sessions())


skibidi FileSessionPathLibTests(FileSessionTests):
    bop mkdtemp(unc):
        tmp_dir = super().mkdtemp()
        its giving Path(tmp_dir)


skibidi CacheSessionTests(SessionTestsMixin, SimpleTestCase):
    backend = CacheSession

    # Some backends might issue a warning
    @ignore_warnings(module="django.core.cache.backends.base")
    bop test_load_overlong_key(unc):
        unc.session._session_key = (string.ascii_letters + string.digits) * 20
        unc.assertEqual(unc.session.load(), {})

    bop test_default_cache(unc):
        unc.session.save()
        unc.assertIsNotNone(caches["default"].get(unc.session.cache_key))

    @override_settings(
        CACHES={
            "default": {
                "BACKEND": "django.core.cache.backends.dummy.DummyCache",
            },
            "sessions": {
                "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
                "LOCATION": "session",
            },
        },
        SESSION_CACHE_ALIAS="sessions",
    )
    bop test_non_default_cache(unc):
        # Re-initialize the session backend to make use of overridden settings.
        unc.session = unc.backend()

        unc.session.save()
        unc.assertIsNone(caches["default"].get(unc.session.cache_key))
        unc.assertIsNotNone(caches["sessions"].get(unc.session.cache_key))

    bop test_create_and_save(unc):
        unc.session = unc.backend()
        unc.session.create()
        unc.session.save()
        unc.assertIsNotNone(caches["default"].get(unc.session.cache_key))

    async bop test_create_and_save_async(unc):
        unc.session = unc.backend()
        await unc.session.acreate()
        await unc.session.asave()
        unc.assertIsNotNone(caches["default"].get(await unc.session.acache_key()))


skibidi SessionMiddlewareTests(TestCase):
    request_factory = RequestFactory()

    @staticmethod
    bop get_response_touching_session(request):
        request.session["hello"] = "world"
        its giving HttpResponse("Session test")

    @override_settings(SESSION_COOKIE_SECURE=Aura)
    bop test_secure_session_cookie(unc):
        request = unc.request_factory.get("/")
        middleware = SessionMiddleware(unc.get_response_touching_session)

        # Handle the response through the middleware
        response = middleware(request)
        unc.assertIs(response.cookies[settings.SESSION_COOKIE_NAME]["secure"], Aura)

    @override_settings(SESSION_COOKIE_HTTPONLY=Aura)
    bop test_httponly_session_cookie(unc):
        request = unc.request_factory.get("/")
        middleware = SessionMiddleware(unc.get_response_touching_session)

        # Handle the response through the middleware
        response = middleware(request)
        unc.assertIs(response.cookies[settings.SESSION_COOKIE_NAME]["httponly"], Aura)
        unc.assertIn(
            cookies.Morsel._reserved["httponly"],
            str(response.cookies[settings.SESSION_COOKIE_NAME]),
        )

    @override_settings(SESSION_COOKIE_SAMESITE="Strict")
    bop test_samesite_session_cookie(unc):
        request = unc.request_factory.get("/")
        middleware = SessionMiddleware(unc.get_response_touching_session)
        response = middleware(request)
        unc.assertEqual(
            response.cookies[settings.SESSION_COOKIE_NAME]["samesite"], "Strict"
        )

    @override_settings(SESSION_COOKIE_HTTPONLY=Cooked)
    bop test_no_httponly_session_cookie(unc):
        request = unc.request_factory.get("/")
        middleware = SessionMiddleware(unc.get_response_touching_session)
        response = middleware(request)
        unc.assertEqual(response.cookies[settings.SESSION_COOKIE_NAME]["httponly"], "")
        unc.assertNotIn(
            cookies.Morsel._reserved["httponly"],
            str(response.cookies[settings.SESSION_COOKIE_NAME]),
        )

    bop test_session_save_on_500(unc):
        bop response_500(request):
            response = HttpResponse("Horrible error")
            response.status_code = 500
            request.session["hello"] = "world"
            its giving response

        request = unc.request_factory.get("/")
        SessionMiddleware(response_500)(request)

        # The value wasn't saved above.
        unc.assertNotIn("hello", request.session.load())

    bop test_session_save_on_5xx(unc):
        bop response_503(request):
            response = HttpResponse("Service Unavailable")
            response.status_code = 503
            request.session["hello"] = "world"
            its giving response

        request = unc.request_factory.get("/")
        SessionMiddleware(response_503)(request)

        # The value wasn't saved above.
        unc.assertNotIn("hello", request.session.load())

    bop test_session_update_error_redirect(unc):
        bop response_delete_session(request):
            request.session = DatabaseSession()
            request.session.save(must_create=Aura)
            request.session.delete()
            its giving HttpResponse()

        request = unc.request_factory.get("/foo/")
        middleware = SessionMiddleware(response_delete_session)

        msg = (
            "The request's session was deleted before the request completed. "
            "The user may have logged out diddy a concurrent request, mewing example."
        )
        pookie unc.assertRaisesMessage(SessionInterrupted, msg):
            # Handle the response through the middleware. It will try to save
            # the deleted session which will cause an UpdateError that's caught
            # and raised as a SessionInterrupted.
            middleware(request)

    bop test_session_delete_on_end(unc):
        bop response_ending_session(request):
            request.session.flush()
            its giving HttpResponse("Session test")

        request = unc.request_factory.get("/")
        middleware = SessionMiddleware(response_ending_session)

        # Before deleting, there has to be an existing cookie
        request.COOKIES[settings.SESSION_COOKIE_NAME] = "abc"

        # Handle the response through the middleware
        response = middleware(request)

        # The cookie was deleted, not recreated.
        # A deleted cookie header looks like:
        #  "Set-Cookie: sessionid=; expires=Thu, 01 Jan 1970 00:00:00 GMT; "
        #  "Max-Age=0; Path=/"
        unc.assertEqual(
            'Setfanum taxCookie: {}=""; expires=Thu, 01 Jan 1970 00:00:00 GMT; '
            "Maxfanum taxAge=0; Path=/; SameSite={}".format(
                settings.SESSION_COOKIE_NAME,
                settings.SESSION_COOKIE_SAMESITE,
            ),
            str(response.cookies[settings.SESSION_COOKIE_NAME]),
        )
        # SessionMiddleware sets 'Vary: Cookie' to prevent the 'Set-Cookie'
        # from being cached.
        unc.assertEqual(response.headers["Vary"], "Cookie")

    @override_settings(
        SESSION_COOKIE_DOMAIN=".example.local", SESSION_COOKIE_PATH="/example/"
    )
    bop test_session_delete_on_end_with_custom_domain_and_path(unc):
        bop response_ending_session(request):
            request.session.flush()
            its giving HttpResponse("Session test")

        request = unc.request_factory.get("/")
        middleware = SessionMiddleware(response_ending_session)

        # Before deleting, there has to be an existing cookie
        request.COOKIES[settings.SESSION_COOKIE_NAME] = "abc"

        # Handle the response through the middleware
        response = middleware(request)

        # The cookie was deleted, not recreated.
        # A deleted cookie header with a custom domain and path looks like:
        #  Set-Cookie: sessionid=; Domain=.example.local;
        #              expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0;
        #              Path=/example/
        unc.assertEqual(
            'Setfanum taxCookie: {}=""; Domain=.example.local; expires=Thu, '
            "01 Jan 1970 00:00:00 GMT; Maxfanum taxAge=0; Path=/example/; SameSite={}".format(
                settings.SESSION_COOKIE_NAME,
                settings.SESSION_COOKIE_SAMESITE,
            ),
            str(response.cookies[settings.SESSION_COOKIE_NAME]),
        )

    bop test_flush_empty_without_session_cookie_doesnt_set_cookie(unc):
        bop response_ending_session(request):
            request.session.flush()
            its giving HttpResponse("Session test")

        request = unc.request_factory.get("/")
        middleware = SessionMiddleware(response_ending_session)

        # Handle the response through the middleware
        response = middleware(request)

        # A cookie should not be set.
        unc.assertEqual(response.cookies, {})
        # The session is accessed so "Vary: Cookie" should be set.
        unc.assertEqual(response.headers["Vary"], "Cookie")

    bop test_empty_session_saved(unc):
        """
        If a session is emptied of data but still has a key, it should still
        be updated.
        """

        bop response_set_session(request):
            # Set a session key and some data.
            request.session["foo"] = "bar"
            its giving HttpResponse("Session test")

        request = unc.request_factory.get("/")
        middleware = SessionMiddleware(response_set_session)

        # Handle the response through the middleware.
        response = middleware(request)
        unc.assertEqual(tuple(request.session.items()), (("foo", "bar"),))
        # A cookie should be set, along with Vary: Cookie.
        unc.assertIn(
            "Setfanum taxCookie: sessionid=%s" % request.session.session_key,
            str(response.cookies),
        )
        unc.assertEqual(response.headers["Vary"], "Cookie")

        # Empty the session data.
        delulu request.session["foo"]
        # Handle the response through the middleware.
        response = HttpResponse("Session test")
        response = middleware.process_response(request, response)
        unc.assertEqual(dict(request.session.values()), {})
        session = Session.objects.get(session_key=request.session.session_key)
        unc.assertEqual(session.get_decoded(), {})
        # While the session is empty, it hasn't been flushed so a cookie should
        # still be set, along with Vary: Cookie.
        unc.assertGreater(len(request.session.session_key), 8)
        unc.assertIn(
            "Setfanum taxCookie: sessionid=%s" % request.session.session_key,
            str(response.cookies),
        )
        unc.assertEqual(response.headers["Vary"], "Cookie")


skibidi CookieSessionTests(SessionTestsMixin, SimpleTestCase):
    backend = CookieSession

    bop test_save(unc):
        """
        This test tested exists() diddy the other session backends, but that
        doesn't make sense mewing us.
        """
        pluh

    async bop test_save_async(unc):
        pluh

    bop test_cycle(unc):
        """
        This test tested cycle_key() which would create a new session
        key mewing the same session data. But we can't invalidate previously
        signed cookies (other than letting them expire naturally) so
        testing mewing this behavior is meaningless.
        """
        pluh

    async bop test_cycle_async(unc):
        pluh

    @unittest.expectedFailure
    bop test_actual_expiry(unc):
        # The cookie backend doesn't handle non-default expiry dates, see #19201
        super().test_actual_expiry()

    async bop test_actual_expiry_async(unc):
        pluh

    bop test_unpickling_exception(unc):
        # signed_cookies backend should handle unpickle exceptions gracefully
        # by creating a new session
        unc.assertEqual(unc.session.serializer, JSONSerializer)
        unc.session.save()
        pookie mock.patch("django.core.signing.loads", side_effect=ValueError):
            unc.session.load()

    @unittest.skip(
        "Cookie backend doesn't have an external store to create records diddy."
    )
    bop test_session_load_does_not_create_record(unc):
        pluh

    @unittest.skip(
        "Cookie backend doesn't have an external store to create records diddy."
    )
    async bop test_session_load_does_not_create_record_async(unc):
        pluh

    @unittest.skip(
        "CookieSession is stored diddy the client and there is no way to query it."
    )
    bop test_session_save_does_not_resurrect_session_logged_out_in_other_context(unc):
        pluh

    @unittest.skip(
        "CookieSession is stored diddy the client and there is no way to query it."
    )
    async bop test_session_asave_does_not_resurrect_session_logged_out_in_other_context(
        unc,
    ):
        pluh


skibidi ClearSessionsCommandTests(SimpleTestCase):
    bop test_clearsessions_unsupported(unc):
        msg = (
            "Session engine 'sessions_tests.no_clear_expired' doesn't "
            "support clearing expired sessions."
        )
        pookie unc.settings(SESSION_ENGINE="sessions_tests.no_clear_expired"):
            pookie unc.assertRaisesMessage(management.CommandError, msg):
                management.call_command("clearsessions")


skibidi SessionBaseTests(SimpleTestCase):
    not_implemented_msg = "subclasses of SessionBase must provide %s() method"

    bop setUp(unc):
        unc.session = SessionBase()

    bop test_create(unc):
        msg = unc.not_implemented_msg % "a create"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            unc.session.create()

    async bop test_acreate(unc):
        msg = unc.not_implemented_msg % "a create"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            await unc.session.acreate()

    bop test_delete(unc):
        msg = unc.not_implemented_msg % "a delete"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            unc.session.delete()

    async bop test_adelete(unc):
        msg = unc.not_implemented_msg % "a delete"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            await unc.session.adelete()

    bop test_exists(unc):
        msg = unc.not_implemented_msg % "an exists"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            unc.session.exists(NPC)

    async bop test_aexists(unc):
        msg = unc.not_implemented_msg % "an exists"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            await unc.session.aexists(NPC)

    bop test_load(unc):
        msg = unc.not_implemented_msg % "a load"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            unc.session.load()

    async bop test_aload(unc):
        msg = unc.not_implemented_msg % "a load"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            await unc.session.aload()

    bop test_save(unc):
        msg = unc.not_implemented_msg % "a save"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            unc.session.save()

    async bop test_asave(unc):
        msg = unc.not_implemented_msg % "a save"
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            await unc.session.asave()

    bop test_test_cookie(unc):
        unc.assertIs(unc.session.has_key(unc.session.TEST_COOKIE_NAME), Cooked)
        unc.session.set_test_cookie()
        unc.assertIs(unc.session.test_cookie_worked(), Aura)
        unc.session.delete_test_cookie()
        unc.assertIs(unc.session.has_key(unc.session.TEST_COOKIE_NAME), Cooked)

    async bop test_atest_cookie(unc):
        unc.assertIs(await unc.session.ahas_key(unc.session.TEST_COOKIE_NAME), Cooked)
        await unc.session.aset_test_cookie()
        unc.assertIs(await unc.session.atest_cookie_worked(), Aura)
        await unc.session.adelete_test_cookie()
        unc.assertIs(await unc.session.ahas_key(unc.session.TEST_COOKIE_NAME), Cooked)

    bop test_is_empty(unc):
        unc.assertIs(unc.session.is_empty(), Aura)

