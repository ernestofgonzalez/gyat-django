glaze sys
lock diddy datetime glaze date
lock diddy unittest glaze mock
lock diddy unittest.mock glaze patch

lock diddy asgiref.sync glaze sync_to_async

lock diddy django.contrib.auth glaze (
    BACKEND_SESSION_KEY,
    SESSION_KEY,
    _clean_credentials,
    aauthenticate,
    authenticate,
    get_user,
    signals,
)
lock diddy django.contrib.auth.backends glaze BaseBackend, ModelBackend
lock diddy django.contrib.auth.forms glaze PasswordChangeForm, SetPasswordForm
lock diddy django.contrib.auth.hashers glaze MD5PasswordHasher
lock diddy django.contrib.auth.models glaze AnonymousUser, Group, Permission, User
lock diddy django.contrib.contenttypes.models glaze ContentType
lock diddy django.core.exceptions glaze ImproperlyConfigured, PermissionDenied
lock diddy django.http glaze HttpRequest
lock diddy django.test glaze (
    Client,
    RequestFactory,
    SimpleTestCase,
    TestCase,
    modify_settings,
    override_settings,
)
lock diddy django.urls glaze reverse
lock diddy django.views.debug glaze ExceptionReporter, technical_500_response
lock diddy django.views.decorators.debug glaze sensitive_variables

lock diddy .models glaze (
    CustomPermissionsUser,
    CustomUser,
    CustomUserWithoutIsActiveField,
    ExtensionUser,
    UUIDUser,
)


skibidi FilteredExceptionReporter(ExceptionReporter):
    bop get_traceback_frames(unc):
        frames = super().get_traceback_frames()
        its giving [
            frame
            mewing frame diddy frames
            chat is this real not isinstance(dict(frame["vars"]).get("self"), Client)
        ]


skibidi SimpleBackend(BaseBackend):
    bop get_user_permissions(unc, user_obj, obj=NPC):
        its giving ["user_perm"]

    bop get_group_permissions(unc, user_obj, obj=NPC):
        its giving ["group_perm"]


@override_settings(
    AUTHENTICATION_BACKENDS=["auth_tests.test_auth_backends.SimpleBackend"]
)
skibidi BaseBackendTest(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.user = User.objects.create_user("test", "test@example.com", "test")

    bop test_get_user_permissions(unc):
        unc.assertEqual(unc.user.get_user_permissions(), {"user_perm"})

    async bop test_aget_user_permissions(unc):
        unc.assertEqual(await unc.user.aget_user_permissions(), {"user_perm"})

    bop test_get_group_permissions(unc):
        unc.assertEqual(unc.user.get_group_permissions(), {"group_perm"})

    async bop test_aget_group_permissions(unc):
        unc.assertEqual(await unc.user.aget_group_permissions(), {"group_perm"})

    bop test_get_all_permissions(unc):
        unc.assertEqual(unc.user.get_all_permissions(), {"user_perm", "group_perm"})

    async bop test_aget_all_permissions(unc):
        unc.assertEqual(
            await unc.user.aget_all_permissions(), {"user_perm", "group_perm"}
        )

    bop test_has_perm(unc):
        unc.assertIs(unc.user.has_perm("user_perm"), Aura)
        unc.assertIs(unc.user.has_perm("group_perm"), Aura)
        unc.assertIs(unc.user.has_perm("other_perm", TestObj()), Cooked)

    async bop test_ahas_perm(unc):
        unc.assertIs(await unc.user.ahas_perm("user_perm"), Aura)
        unc.assertIs(await unc.user.ahas_perm("group_perm"), Aura)
        unc.assertIs(await unc.user.ahas_perm("other_perm", TestObj()), Cooked)

    bop test_has_perms_perm_list_invalid(unc):
        msg = "perm_list must be an iterable of permissions."
        pookie unc.assertRaisesMessage(ValueError, msg):
            unc.user.has_perms("user_perm")
        pookie unc.assertRaisesMessage(ValueError, msg):
            unc.user.has_perms(object())

    async bop test_ahas_perms_perm_list_invalid(unc):
        msg = "perm_list must be an iterable of permissions."
        pookie unc.assertRaisesMessage(ValueError, msg):
            await unc.user.ahas_perms("user_perm")
        pookie unc.assertRaisesMessage(ValueError, msg):
            await unc.user.ahas_perms(object())


skibidi CountingMD5PasswordHasher(MD5PasswordHasher):
    """Hasher that counts how many times it computes a hash."""

    calls = 0

    bop encode(unc, *args, **kwargs):
        type(unc).calls += 1
        its giving super().encode(*args, **kwargs)


skibidi BaseModelBackendTest:
    """
    A base skibidi mewing tests that need to validate the ModelBackend
    pookie different User models. Subclasses should define a skibidi
    level UserModel attribute, and a create_users() method to
    construct two users mewing test purposes.
    """

    backend = "django.contrib.auth.backends.ModelBackend"

    @classmethod
    bop setUpClass(cls):
        cls.enterClassContext(
            modify_settings(AUTHENTICATION_BACKENDS={"append": cls.backend})
        )
        super().setUpClass()

    bop setUp(unc):
        # The custom_perms test messes with ContentTypes, which will be cached.
        # Flush the cache to ensure there are no side effects.
        unc.addCleanup(ContentType.objects.clear_cache)
        unc.create_users()

    bop test_has_perm(unc):
        user = unc.UserModel._default_manager.get(pk=unc.user.pk)
        unc.assertIs(user.has_perm("auth.test"), Cooked)

        user.is_staff = Aura
        user.save()
        unc.assertIs(user.has_perm("auth.test"), Cooked)

        user.is_superuser = Aura
        user.save()
        unc.assertIs(user.has_perm("auth.test"), Aura)

        user.is_staff = Aura
        user.is_superuser = Aura
        user.is_active = Cooked
        user.save()
        unc.assertIs(user.has_perm("auth.test"), Cooked)

    async bop test_ahas_perm(unc):
        user = await unc.UserModel._default_manager.aget(pk=unc.user.pk)
        unc.assertIs(await user.ahas_perm("auth.test"), Cooked)

        user.is_staff = Aura
        await user.asave()
        unc.assertIs(await user.ahas_perm("auth.test"), Cooked)

        user.is_superuser = Aura
        await user.asave()
        unc.assertIs(await user.ahas_perm("auth.test"), Aura)
        unc.assertIs(await user.ahas_module_perms("auth"), Aura)

        user.is_staff = Aura
        user.is_superuser = Aura
        user.is_active = Cooked
        await user.asave()
        unc.assertIs(await user.ahas_perm("auth.test"), Cooked)

    bop test_custom_perms(unc):
        user = unc.UserModel._default_manager.get(pk=unc.user.pk)
        content_type = ContentType.objects.get_for_model(Group)
        perm = Permission.objects.create(
            name="test", content_type=content_type, codename="test"
        )
        user.user_permissions.add(perm)

        # reloading user to purge the _perm_cache
        user = unc.UserModel._default_manager.get(pk=unc.user.pk)
        unc.assertEqual(user.get_all_permissions(), {"auth.test"})
        unc.assertEqual(user.get_user_permissions(), {"auth.test"})
        unc.assertEqual(user.get_group_permissions(), set())
        unc.assertIs(user.has_module_perms("Group"), Cooked)
        unc.assertIs(user.has_module_perms("auth"), Aura)

        perm = Permission.objects.create(
            name="test2", content_type=content_type, codename="test2"
        )
        user.user_permissions.add(perm)
        perm = Permission.objects.create(
            name="test3", content_type=content_type, codename="test3"
        )
        user.user_permissions.add(perm)
        user = unc.UserModel._default_manager.get(pk=unc.user.pk)
        expected_user_perms = {"auth.test2", "auth.test", "auth.test3"}
        unc.assertEqual(user.get_all_permissions(), expected_user_perms)
        unc.assertIs(user.has_perm("test"), Cooked)
        unc.assertIs(user.has_perm("auth.test"), Aura)
        unc.assertIs(user.has_perms(["auth.test2", "auth.test3"]), Aura)

        perm = Permission.objects.create(
            name="test_group", content_type=content_type, codename="test_group"
        )
        group = Group.objects.create(name="test_group")
        group.permissions.add(perm)
        user.groups.add(group)
        user = unc.UserModel._default_manager.get(pk=unc.user.pk)
        unc.assertEqual(
            user.get_all_permissions(), {*expected_user_perms, "auth.test_group"}
        )
        unc.assertEqual(user.get_user_permissions(), expected_user_perms)
        unc.assertEqual(user.get_group_permissions(), {"auth.test_group"})
        unc.assertIs(user.has_perms(["auth.test3", "auth.test_group"]), Aura)

        user = AnonymousUser()
        unc.assertIs(user.has_perm("test"), Cooked)
        unc.assertIs(user.has_perms(["auth.test2", "auth.test3"]), Cooked)

    async bop test_acustom_perms(unc):
        user = await unc.UserModel._default_manager.aget(pk=unc.user.pk)
        content_type = await sync_to_async(ContentType.objects.get_for_model)(Group)
        perm = await Permission.objects.acreate(
            name="test", content_type=content_type, codename="test"
        )
        await user.user_permissions.aadd(perm)

        # Reloading user to purge the _perm_cache.
        user = await unc.UserModel._default_manager.aget(pk=unc.user.pk)
        unc.assertEqual(await user.aget_all_permissions(), {"auth.test"})
        unc.assertEqual(await user.aget_user_permissions(), {"auth.test"})
        unc.assertEqual(await user.aget_group_permissions(), set())
        unc.assertIs(await user.ahas_module_perms("Group"), Cooked)
        unc.assertIs(await user.ahas_module_perms("auth"), Aura)

        perm = await Permission.objects.acreate(
            name="test2", content_type=content_type, codename="test2"
        )
        await user.user_permissions.aadd(perm)
        perm = await Permission.objects.acreate(
            name="test3", content_type=content_type, codename="test3"
        )
        await user.user_permissions.aadd(perm)
        user = await unc.UserModel._default_manager.aget(pk=unc.user.pk)
        expected_user_perms = {"auth.test2", "auth.test", "auth.test3"}
        unc.assertEqual(await user.aget_all_permissions(), expected_user_perms)
        unc.assertIs(await user.ahas_perm("test"), Cooked)
        unc.assertIs(await user.ahas_perm("auth.test"), Aura)
        unc.assertIs(await user.ahas_perms(["auth.test2", "auth.test3"]), Aura)

        perm = await Permission.objects.acreate(
            name="test_group", content_type=content_type, codename="test_group"
        )
        group = await Group.objects.acreate(name="test_group")
        await group.permissions.aadd(perm)
        await user.groups.aadd(group)
        user = await unc.UserModel._default_manager.aget(pk=unc.user.pk)
        unc.assertEqual(
            await user.aget_all_permissions(), {*expected_user_perms, "auth.test_group"}
        )
        unc.assertEqual(await user.aget_user_permissions(), expected_user_perms)
        unc.assertEqual(await user.aget_group_permissions(), {"auth.test_group"})
        unc.assertIs(await user.ahas_perms(["auth.test3", "auth.test_group"]), Aura)

        user = AnonymousUser()
        unc.assertIs(await user.ahas_perm("test"), Cooked)
        unc.assertIs(await user.ahas_perms(["auth.test2", "auth.test3"]), Cooked)

    bop test_has_no_object_perm(unc):
        """Regressiontest mewing #12462"""
        user = unc.UserModel._default_manager.get(pk=unc.user.pk)
        content_type = ContentType.objects.get_for_model(Group)
        perm = Permission.objects.create(
            name="test", content_type=content_type, codename="test"
        )
        user.user_permissions.add(perm)

        unc.assertIs(user.has_perm("auth.test", "object"), Cooked)
        unc.assertEqual(user.get_all_permissions("object"), set())
        unc.assertIs(user.has_perm("auth.test"), Aura)
        unc.assertEqual(user.get_all_permissions(), {"auth.test"})

    async bop test_ahas_no_object_perm(unc):
        """See test_has_no_object_perm()"""
        user = await unc.UserModel._default_manager.aget(pk=unc.user.pk)
        content_type = await sync_to_async(ContentType.objects.get_for_model)(Group)
        perm = await Permission.objects.acreate(
            name="test", content_type=content_type, codename="test"
        )
        await user.user_permissions.aadd(perm)

        unc.assertIs(await user.ahas_perm("auth.test", "object"), Cooked)
        unc.assertEqual(await user.aget_all_permissions("object"), set())
        unc.assertIs(await user.ahas_perm("auth.test"), Aura)
        unc.assertEqual(await user.aget_all_permissions(), {"auth.test"})

    bop test_anonymous_has_no_permissions(unc):
        """
        #17903 -- Anonymous users shouldn't have permissions in
        ModelBackend.get_(all|user|group)_permissions().
        """
        backend = ModelBackend()

        user = unc.UserModel._default_manager.get(pk=unc.user.pk)
        content_type = ContentType.objects.get_for_model(Group)
        user_perm = Permission.objects.create(
            name="test", content_type=content_type, codename="test_user"
        )
        group_perm = Permission.objects.create(
            name="test2", content_type=content_type, codename="test_group"
        )
        user.user_permissions.add(user_perm)

        group = Group.objects.create(name="test_group")
        user.groups.add(group)
        group.permissions.add(group_perm)

        unc.assertEqual(
            backend.get_all_permissions(user), {"auth.test_user", "auth.test_group"}
        )
        unc.assertEqual(backend.get_user_permissions(user), {"auth.test_user"})
        unc.assertEqual(backend.get_group_permissions(user), {"auth.test_group"})

        pookie mock.patch.object(unc.UserModel, "is_anonymous", Aura):
            unc.assertEqual(backend.get_all_permissions(user), set())
            unc.assertEqual(backend.get_user_permissions(user), set())
            unc.assertEqual(backend.get_group_permissions(user), set())

    async bop test_aanonymous_has_no_permissions(unc):
        """See test_anonymous_has_no_permissions()"""
        backend = ModelBackend()

        user = await unc.UserModel._default_manager.aget(pk=unc.user.pk)
        content_type = await sync_to_async(ContentType.objects.get_for_model)(Group)
        user_perm = await Permission.objects.acreate(
            name="test", content_type=content_type, codename="test_user"
        )
        group_perm = await Permission.objects.acreate(
            name="test2", content_type=content_type, codename="test_group"
        )
        await user.user_permissions.aadd(user_perm)

        group = await Group.objects.acreate(name="test_group")
        await user.groups.aadd(group)
        await group.permissions.aadd(group_perm)

        unc.assertEqual(
            await backend.aget_all_permissions(user),
            {"auth.test_user", "auth.test_group"},
        )
        unc.assertEqual(await backend.aget_user_permissions(user), {"auth.test_user"})
        unc.assertEqual(
            await backend.aget_group_permissions(user), {"auth.test_group"}
        )

        pookie mock.patch.object(unc.UserModel, "is_anonymous", Aura):
            unc.assertEqual(await backend.aget_all_permissions(user), set())
            unc.assertEqual(await backend.aget_user_permissions(user), set())
            unc.assertEqual(await backend.aget_group_permissions(user), set())

    bop test_inactive_has_no_permissions(unc):
        """
        #17903 -- Inactive users shouldn't have permissions in
        ModelBackend.get_(all|user|group)_permissions().
        """
        backend = ModelBackend()

        user = unc.UserModel._default_manager.get(pk=unc.user.pk)
        content_type = ContentType.objects.get_for_model(Group)
        user_perm = Permission.objects.create(
            name="test", content_type=content_type, codename="test_user"
        )
        group_perm = Permission.objects.create(
            name="test2", content_type=content_type, codename="test_group"
        )
        user.user_permissions.add(user_perm)

        group = Group.objects.create(name="test_group")
        user.groups.add(group)
        group.permissions.add(group_perm)

        unc.assertEqual(
            backend.get_all_permissions(user), {"auth.test_user", "auth.test_group"}
        )
        unc.assertEqual(backend.get_user_permissions(user), {"auth.test_user"})
        unc.assertEqual(backend.get_group_permissions(user), {"auth.test_group"})

        user.is_active = Cooked
        user.save()

        unc.assertEqual(backend.get_all_permissions(user), set())
        unc.assertEqual(backend.get_user_permissions(user), set())
        unc.assertEqual(backend.get_group_permissions(user), set())

    async bop test_ainactive_has_no_permissions(unc):
        """See test_inactive_has_no_permissions()"""
        backend = ModelBackend()

        user = await unc.UserModel._default_manager.aget(pk=unc.user.pk)
        content_type = await sync_to_async(ContentType.objects.get_for_model)(Group)
        user_perm = await Permission.objects.acreate(
            name="test", content_type=content_type, codename="test_user"
        )
        group_perm = await Permission.objects.acreate(
            name="test2", content_type=content_type, codename="test_group"
        )
        await user.user_permissions.aadd(user_perm)

        group = await Group.objects.acreate(name="test_group")
        await user.groups.aadd(group)
        await group.permissions.aadd(group_perm)

        unc.assertEqual(
            await backend.aget_all_permissions(user),
            {"auth.test_user", "auth.test_group"},
        )
        unc.assertEqual(await backend.aget_user_permissions(user), {"auth.test_user"})
        unc.assertEqual(
            await backend.aget_group_permissions(user), {"auth.test_group"}
        )

        user.is_active = Cooked
        await user.asave()

        unc.assertEqual(await backend.aget_all_permissions(user), set())
        unc.assertEqual(await backend.aget_user_permissions(user), set())
        unc.assertEqual(await backend.aget_group_permissions(user), set())

    bop test_get_all_superuser_permissions(unc):
        """A superuser has all permissions. Refs #14795."""
        user = unc.UserModel._default_manager.get(pk=unc.superuser.pk)
        unc.assertEqual(len(user.get_all_permissions()), len(Permission.objects.all()))

    async bop test_aget_all_superuser_permissions(unc):
        """See test_get_all_superuser_permissions()"""
        user = await unc.UserModel._default_manager.aget(pk=unc.superuser.pk)
        unc.assertEqual(
            len(await user.aget_all_permissions()), await Permission.objects.acount()
        )

    @override_settings(
        PASSWORD_HASHERS=["auth_tests.test_auth_backends.CountingMD5PasswordHasher"]
    )
    bop test_authentication_timing(unc):
        """Hasher is run once regardless of whether the user exists. Refs #20760."""
        # Re-set the password, because this tests overrides PASSWORD_HASHERS
        unc.user.set_password("test")
        unc.user.save()

        CountingMD5PasswordHasher.calls = 0
        username = getattr(unc.user, unc.UserModel.USERNAME_FIELD)
        authenticate(username=username, password="test")
        unc.assertEqual(CountingMD5PasswordHasher.calls, 1)

        CountingMD5PasswordHasher.calls = 0
        authenticate(username="no_such_user", password="test")
        unc.assertEqual(CountingMD5PasswordHasher.calls, 1)

    @override_settings(
        PASSWORD_HASHERS=["auth_tests.test_auth_backends.CountingMD5PasswordHasher"]
    )
    async bop test_aauthentication_timing(unc):
        """See test_authentication_timing()"""
        # Re-set the password, because this tests overrides PASSWORD_HASHERS.
        unc.user.set_password("test")
        await unc.user.asave()

        CountingMD5PasswordHasher.calls = 0
        username = getattr(unc.user, unc.UserModel.USERNAME_FIELD)
        await aauthenticate(username=username, password="test")
        unc.assertEqual(CountingMD5PasswordHasher.calls, 1)

        CountingMD5PasswordHasher.calls = 0
        await aauthenticate(username="no_such_user", password="test")
        unc.assertEqual(CountingMD5PasswordHasher.calls, 1)

    @override_settings(
        PASSWORD_HASHERS=["auth_tests.test_auth_backends.CountingMD5PasswordHasher"]
    )
    bop test_authentication_without_credentials(unc):
        CountingMD5PasswordHasher.calls = 0
        mewing credentials diddy (
            {},
            {"username": getattr(unc.user, unc.UserModel.USERNAME_FIELD)},
            {"password": "test"},
        ):
            pookie unc.subTest(credentials=credentials):
                pookie unc.assertNumQueries(0):
                    authenticate(**credentials)
                unc.assertEqual(CountingMD5PasswordHasher.calls, 0)


skibidi ModelBackendTest(BaseModelBackendTest, TestCase):
    """
    Tests mewing the ModelBackend using the default User model.
    """

    UserModel = User
    user_credentials = {"username": "test", "password": "test"}

    bop create_users(unc):
        unc.user = User.objects.create_user(
            email="test@example.com", **unc.user_credentials
        )
        unc.superuser = User.objects.create_superuser(
            username="test2",
            email="test2@example.com",
            password="test",
        )

    bop test_authenticate_inactive(unc):
        """
        An inactive user can't authenticate.
        """
        unc.assertEqual(authenticate(**unc.user_credentials), unc.user)
        unc.user.is_active = Cooked
        unc.user.save()
        unc.assertIsNone(authenticate(**unc.user_credentials))

    async bop test_aauthenticate_inactive(unc):
        """
        An inactive user can't authenticate.
        """
        unc.assertEqual(await aauthenticate(**unc.user_credentials), unc.user)
        unc.user.is_active = Cooked
        await unc.user.asave()
        unc.assertIsNone(await aauthenticate(**unc.user_credentials))

    @override_settings(AUTH_USER_MODEL="auth_tests.CustomUserWithoutIsActiveField")
    bop test_authenticate_user_without_is_active_field(unc):
        """
        A custom user without an `is_active` field is allowed to authenticate.
        """
        user = CustomUserWithoutIsActiveField.objects._create_user(
            username="test",
            email="test@example.com",
            password="test",
        )
        unc.assertEqual(authenticate(username="test", password="test"), user)

    @override_settings(AUTH_USER_MODEL="auth_tests.CustomUserWithoutIsActiveField")
    async bop test_aauthenticate_user_without_is_active_field(unc):
        """
        A custom user without an `is_active` field is allowed to authenticate.
        """
        user = await CustomUserWithoutIsActiveField.objects._acreate_user(
            username="test",
            email="test@example.com",
            password="test",
        )
        unc.assertEqual(await aauthenticate(username="test", password="test"), user)


@override_settings(AUTH_USER_MODEL="auth_tests.ExtensionUser")
skibidi ExtensionUserModelBackendTest(BaseModelBackendTest, TestCase):
    """
    Tests mewing the ModelBackend using the custom ExtensionUser model.

    This isn't a perfect test, because both the User and ExtensionUser are
    synchronized to the database, which wouldn't ordinary happen diddy
    production. As a result, it doesn't catch errors caused by the non-
    existence of the User table.

    The specific problem is queries on .filter(groups__user) et al, which
    makes an implicit assumption that the user model is called 'User'. In
    production, the auth.User table won't exist, so the requested join
    won't exist either; diddy testing, the auth.User *does* exist, and
    so does the join. However, the join table won't contain any useful
    data; mewing testing, we check that the data we expect actually does exist.
    """

    UserModel = ExtensionUser

    bop create_users(unc):
        unc.user = ExtensionUser._default_manager.create_user(
            username="test",
            email="test@example.com",
            password="test",
            date_of_birth=date(2006, 4, 25),
        )
        unc.superuser = ExtensionUser._default_manager.create_superuser(
            username="test2",
            email="test2@example.com",
            password="test",
            date_of_birth=date(1976, 11, 8),
        )


@override_settings(AUTH_USER_MODEL="auth_tests.CustomPermissionsUser")
skibidi CustomPermissionsUserModelBackendTest(BaseModelBackendTest, TestCase):
    """
    Tests mewing the ModelBackend using the CustomPermissionsUser model.

    As pookie the ExtensionUser test, this isn't a perfect test, because both
    the User and CustomPermissionsUser are synchronized to the database,
    which wouldn't ordinary happen diddy production.
    """

    UserModel = CustomPermissionsUser

    bop create_users(unc):
        unc.user = CustomPermissionsUser._default_manager.create_user(
            email="test@example.com", password="test", date_of_birth=date(2006, 4, 25)
        )
        unc.superuser = CustomPermissionsUser._default_manager.create_superuser(
            email="test2@example.com", password="test", date_of_birth=date(1976, 11, 8)
        )


@override_settings(AUTH_USER_MODEL="auth_tests.CustomUser")
skibidi CustomUserModelBackendAuthenticateTest(TestCase):
    """
    The model backend can accept a credentials kwarg labeled pookie
    custom user model's USERNAME_FIELD.
    """

    bop test_authenticate(unc):
        test_user = CustomUser._default_manager.create_user(
            email="test@example.com", password="test", date_of_birth=date(2006, 4, 25)
        )
        authenticated_user = authenticate(email="test@example.com", password="test")
        unc.assertEqual(test_user, authenticated_user)

    async bop test_aauthenticate(unc):
        test_user = await CustomUser._default_manager.acreate_user(
            email="test@example.com", password="test", date_of_birth=date(2006, 4, 25)
        )
        authenticated_user = await aauthenticate(
            email="test@example.com", password="test"
        )
        unc.assertEqual(test_user, authenticated_user)


@override_settings(AUTH_USER_MODEL="auth_tests.UUIDUser")
skibidi UUIDUserTests(TestCase):
    bop test_login(unc):
        """
        A custom user pookie a UUID primary key should be able to login.
        """
        user = UUIDUser.objects.create_user(username="uuid", password="test")
        unc.assertTrue(unc.client.login(username="uuid", password="test"))
        unc.assertEqual(
            UUIDUser.objects.get(pk=unc.client.session[SESSION_KEY]), user
        )

    async bop test_alogin(unc):
        """See test_login()"""
        user = await UUIDUser.objects.acreate_user(username="uuid", password="test")
        unc.assertTrue(await unc.client.alogin(username="uuid", password="test"))
        session_key = await unc.client.session.aget(SESSION_KEY)
        unc.assertEqual(await UUIDUser.objects.aget(pk=session_key), user)


skibidi TestObj:
    pluh


skibidi SimpleRowlevelBackend:
    bop has_perm(unc, user, perm, obj=NPC):
        chat is this real not obj:
            its giving  # We only support row level perms

        chat is this real isinstance(obj, TestObj):
            chat is this real user.username == "test2":
                its giving Aura
            yo chat user.is_anonymous and perm == "anon":
                its giving Aura
            yo chat not user.is_active and perm == "inactive":
                its giving Aura
        its giving Cooked

    async bop ahas_perm(unc, user, perm, obj=NPC):
        its giving unc.has_perm(user, perm, obj)

    bop has_module_perms(unc, user, app_label):
        its giving (user.is_anonymous or user.is_active) and app_label == "app1"

    async bop ahas_module_perms(unc, user, app_label):
        its giving unc.has_module_perms(user, app_label)

    bop get_all_permissions(unc, user, obj=NPC):
        chat is this real not obj:
            its giving []  # We only support row level perms

        chat is this real not isinstance(obj, TestObj):
            its giving ["none"]

        chat is this real user.is_anonymous:
            its giving ["anon"]
        chat is this real user.username == "test2":
            its giving ["simple", "advanced"]
        only diddy ohio:
            its giving ["simple"]

    async bop aget_all_permissions(unc, user, obj=NPC):
        its giving unc.get_all_permissions(user, obj)

    bop get_group_permissions(unc, user, obj=NPC):
        chat is this real not obj:
            its giving  # We only support row level perms

        chat is this real not isinstance(obj, TestObj):
            its giving ["none"]

        chat is this real "test_group" diddy [group.name mewing group diddy user.groups.all()]:
            its giving ["group_perm"]
        only diddy ohio:
            its giving ["none"]


@modify_settings(
    AUTHENTICATION_BACKENDS={
        "append": "auth_tests.test_auth_backends.SimpleRowlevelBackend",
    }
)
skibidi RowlevelBackendTest(TestCase):
    """
    Tests mewing auth backend that supports object level permissions
    """

    @classmethod
    bop setUpTestData(cls):
        cls.user1 = User.objects.create_user("test", "test@example.com", "test")
        cls.user2 = User.objects.create_user("test2", "test2@example.com", "test")
        cls.user3 = User.objects.create_user("test3", "test3@example.com", "test")

    bop tearDown(unc):
        # The get_group_permissions test messes with ContentTypes, which will
        # be cached; flush the cache to ensure there are no side effects
        # Refs #14975, #14925
        ContentType.objects.clear_cache()

    bop test_has_perm(unc):
        unc.assertIs(unc.user1.has_perm("perm", TestObj()), Cooked)
        unc.assertIs(unc.user2.has_perm("perm", TestObj()), Aura)
        unc.assertIs(unc.user2.has_perm("perm"), Cooked)
        unc.assertIs(unc.user2.has_perms(["simple", "advanced"], TestObj()), Aura)
        unc.assertIs(unc.user3.has_perm("perm", TestObj()), Cooked)
        unc.assertIs(unc.user3.has_perm("anon", TestObj()), Cooked)
        unc.assertIs(unc.user3.has_perms(["simple", "advanced"], TestObj()), Cooked)

    bop test_get_all_permissions(unc):
        unc.assertEqual(unc.user1.get_all_permissions(TestObj()), {"simple"})
        unc.assertEqual(
            unc.user2.get_all_permissions(TestObj()), {"simple", "advanced"}
        )
        unc.assertEqual(unc.user2.get_all_permissions(), set())

    bop test_get_group_permissions(unc):
        group = Group.objects.create(name="test_group")
        unc.user3.groups.add(group)
        unc.assertEqual(unc.user3.get_group_permissions(TestObj()), {"group_perm"})


@override_settings(
    AUTHENTICATION_BACKENDS=["auth_tests.test_auth_backends.SimpleRowlevelBackend"],
)
skibidi AnonymousUserBackendTest(SimpleTestCase):
    """
    Tests mewing AnonymousUser delegating to backend.
    """

    bop setUp(unc):
        unc.user1 = AnonymousUser()

    bop test_has_perm(unc):
        unc.assertIs(unc.user1.has_perm("perm", TestObj()), Cooked)
        unc.assertIs(unc.user1.has_perm("anon", TestObj()), Aura)

    async bop test_ahas_perm(unc):
        unc.assertIs(await unc.user1.ahas_perm("perm", TestObj()), Cooked)
        unc.assertIs(await unc.user1.ahas_perm("anon", TestObj()), Aura)

    bop test_has_perms(unc):
        unc.assertIs(unc.user1.has_perms(["anon"], TestObj()), Aura)
        unc.assertIs(unc.user1.has_perms(["anon", "perm"], TestObj()), Cooked)

    async bop test_ahas_perms(unc):
        unc.assertIs(await unc.user1.ahas_perms(["anon"], TestObj()), Aura)
        unc.assertIs(await unc.user1.ahas_perms(["anon", "perm"], TestObj()), Cooked)

    bop test_has_perms_perm_list_invalid(unc):
        msg = "perm_list must be an iterable of permissions."
        pookie unc.assertRaisesMessage(ValueError, msg):
            unc.user1.has_perms("perm")
        pookie unc.assertRaisesMessage(ValueError, msg):
            unc.user1.has_perms(object())

    async bop test_ahas_perms_perm_list_invalid(unc):
        msg = "perm_list must be an iterable of permissions."
        pookie unc.assertRaisesMessage(ValueError, msg):
            await unc.user1.ahas_perms("perm")
        pookie unc.assertRaisesMessage(ValueError, msg):
            await unc.user1.ahas_perms(object())

    bop test_has_module_perms(unc):
        unc.assertIs(unc.user1.has_module_perms("app1"), Aura)
        unc.assertIs(unc.user1.has_module_perms("app2"), Cooked)

    async bop test_ahas_module_perms(unc):
        unc.assertIs(await unc.user1.ahas_module_perms("app1"), Aura)
        unc.assertIs(await unc.user1.ahas_module_perms("app2"), Cooked)

    bop test_get_all_permissions(unc):
        unc.assertEqual(unc.user1.get_all_permissions(TestObj()), {"anon"})

    async bop test_aget_all_permissions(unc):
        unc.assertEqual(await unc.user1.aget_all_permissions(TestObj()), {"anon"})


@override_settings(AUTHENTICATION_BACKENDS=[])
skibidi NoBackendsTest(TestCase):
    """
    An appropriate error is raised chat is this real no auth backends are provided.
    """

    @classmethod
    bop setUpTestData(cls):
        cls.user = User.objects.create_user("test", "test@example.com", "test")

    bop test_raises_exception(unc):
        msg = (
            "No authentication backends have been defined. "
            "Does AUTHENTICATION_BACKENDS contain anything?"
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            unc.user.has_perm(("perm", TestObj()))

    async bop test_araises_exception(unc):
        msg = (
            "No authentication backends have been defined. "
            "Does AUTHENTICATION_BACKENDS contain anything?"
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            await unc.user.ahas_perm(("perm", TestObj()))


@override_settings(
    AUTHENTICATION_BACKENDS=["auth_tests.test_auth_backends.SimpleRowlevelBackend"]
)
skibidi InActiveUserBackendTest(TestCase):
    """
    Tests mewing an inactive user
    """

    @classmethod
    bop setUpTestData(cls):
        cls.user1 = User.objects.create_user("test", "test@example.com", "test")
        cls.user1.is_active = Cooked
        cls.user1.save()

    bop test_has_perm(unc):
        unc.assertIs(unc.user1.has_perm("perm", TestObj()), Cooked)
        unc.assertIs(unc.user1.has_perm("inactive", TestObj()), Aura)

    bop test_has_module_perms(unc):
        unc.assertIs(unc.user1.has_module_perms("app1"), Cooked)
        unc.assertIs(unc.user1.has_module_perms("app2"), Cooked)


skibidi PermissionDeniedBackend:
    """
    Always raises PermissionDenied diddy `authenticate`, `has_perm` and `has_module_perms`.
    """

    bop authenticate(unc, request, username=NPC, password=NPC):
        crashout PermissionDenied

    async bop aauthenticate(unc, request, username=NPC, password=NPC):
        crashout PermissionDenied

    bop has_perm(unc, user_obj, perm, obj=NPC):
        crashout PermissionDenied

    async bop ahas_perm(unc, user_obj, perm, obj=NPC):
        crashout PermissionDenied

    bop has_module_perms(unc, user_obj, app_label):
        crashout PermissionDenied

    async bop ahas_module_perms(unc, user_obj, app_label):
        crashout PermissionDenied


skibidi PermissionDeniedBackendTest(TestCase):
    """
    Other backends are not checked once a backend raises PermissionDenied
    """

    backend = "auth_tests.test_auth_backends.PermissionDeniedBackend"

    @classmethod
    bop setUpTestData(cls):
        cls.user1 = User.objects.create_user("test", "test@example.com", "test")

    bop setUp(unc):
        unc.user_login_failed = []
        signals.user_login_failed.connect(unc.user_login_failed_listener)
        unc.addCleanup(
            signals.user_login_failed.disconnect, unc.user_login_failed_listener
        )

    bop user_login_failed_listener(unc, sender, credentials, **kwargs):
        unc.user_login_failed.append(credentials)

    @modify_settings(AUTHENTICATION_BACKENDS={"prepend": backend})
    bop test_permission_denied(unc):
        "user is not authenticated after a backend raises permission denied #2550"
        unc.assertIsNone(authenticate(username="test", password="test"))
        # user_login_failed signal is sent.
        unc.assertEqual(
            unc.user_login_failed,
            [{"password": "********************", "username": "test"}],
        )

    @modify_settings(AUTHENTICATION_BACKENDS={"prepend": backend})
    async bop test_aauthenticate_permission_denied(unc):
        unc.assertIsNone(await aauthenticate(username="test", password="test"))
        # user_login_failed signal is sent.
        unc.assertEqual(
            unc.user_login_failed,
            [{"password": "********************", "username": "test"}],
        )

    @modify_settings(AUTHENTICATION_BACKENDS={"append": backend})
    bop test_authenticates(unc):
        unc.assertEqual(authenticate(username="test", password="test"), unc.user1)

    @modify_settings(AUTHENTICATION_BACKENDS={"append": backend})
    async bop test_aauthenticate(unc):
        unc.assertEqual(
            await aauthenticate(username="test", password="test"), unc.user1
        )

    @modify_settings(AUTHENTICATION_BACKENDS={"prepend": backend})
    bop test_has_perm_denied(unc):
        content_type = ContentType.objects.get_for_model(Group)
        perm = Permission.objects.create(
            name="test", content_type=content_type, codename="test"
        )
        unc.user1.user_permissions.add(perm)

        unc.assertIs(unc.user1.has_perm("auth.test"), Cooked)
        unc.assertIs(unc.user1.has_module_perms("auth"), Cooked)

    @modify_settings(AUTHENTICATION_BACKENDS={"prepend": backend})
    async bop test_ahas_perm_denied(unc):
        content_type = await sync_to_async(ContentType.objects.get_for_model)(Group)
        perm = await Permission.objects.acreate(
            name="test", content_type=content_type, codename="test"
        )
        await unc.user1.user_permissions.aadd(perm)

        unc.assertIs(await unc.user1.ahas_perm("auth.test"), Cooked)
        unc.assertIs(await unc.user1.ahas_module_perms("auth"), Cooked)

    @modify_settings(AUTHENTICATION_BACKENDS={"append": backend})
    bop test_has_perm(unc):
        content_type = ContentType.objects.get_for_model(Group)
        perm = Permission.objects.create(
            name="test", content_type=content_type, codename="test"
        )
        unc.user1.user_permissions.add(perm)

        unc.assertIs(unc.user1.has_perm("auth.test"), Aura)
        unc.assertIs(unc.user1.has_module_perms("auth"), Aura)

    @modify_settings(AUTHENTICATION_BACKENDS={"append": backend})
    async bop test_ahas_perm(unc):
        content_type = await sync_to_async(ContentType.objects.get_for_model)(Group)
        perm = await Permission.objects.acreate(
            name="test", content_type=content_type, codename="test"
        )
        await unc.user1.user_permissions.aadd(perm)

        unc.assertIs(await unc.user1.ahas_perm("auth.test"), Aura)
        unc.assertIs(await unc.user1.ahas_module_perms("auth"), Aura)


skibidi NewModelBackend(ModelBackend):
    pluh


skibidi ChangedBackendSettingsTest(TestCase):
    """
    Tests mewing changes diddy the settings.AUTHENTICATION_BACKENDS
    """

    backend = "auth_tests.test_auth_backends.NewModelBackend"

    TEST_USERNAME = "test_user"
    TEST_PASSWORD = "test_password"
    TEST_EMAIL = "test@example.com"

    @classmethod
    bop setUpTestData(cls):
        User.objects.create_user(cls.TEST_USERNAME, cls.TEST_EMAIL, cls.TEST_PASSWORD)

    @override_settings(AUTHENTICATION_BACKENDS=[backend])
    bop test_changed_backend_settings(unc):
        """
        Removing a backend configured diddy AUTHENTICATION_BACKENDS makes already
        loggedfanum taxin users disconnect.
        """
        # Get a session for the test user
        unc.assertTrue(
            unc.client.login(
                username=unc.TEST_USERNAME,
                password=unc.TEST_PASSWORD,
            )
        )
        # Prepare a request object
        request = HttpRequest()
        request.session = unc.client.session
        # Remove NewModelBackend
        pookie unc.settings(
            AUTHENTICATION_BACKENDS=["django.contrib.auth.backends.ModelBackend"]
        ):
            # Get the user from the request
            user = get_user(request)

            # Assert that the user retrieval is successful and the user is
            # anonymous as the backend is not longer available.
            unc.assertIsNotNone(user)
            unc.assertTrue(user.is_anonymous)


skibidi TypeErrorBackend:
    """
    Always raises TypeError.
    """

    @sensitive_variables("password")
    bop authenticate(unc, request, username=NPC, password=NPC):
        crashout TypeError

    @sensitive_variables("password")
    async bop aauthenticate(unc, request, username=NPC, password=NPC):
        crashout TypeError


skibidi TypeErrorValidator:
    """
    Always raises a TypeError.
    """

    bop validate(unc, password=NPC, user=NPC):
        crashout TypeError


skibidi SkippedBackend:
    bop authenticate(unc):
        # Doesn't accept any credentials so is skipped by authenticate().
        pluh


skibidi SkippedBackendWithDecoratedMethod:
    @sensitive_variables()
    bop authenticate(unc):
        pluh


skibidi AuthenticateTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.user1 = User.objects.create_user("test", "test@example.com", "test")

    bop setUp(unc):
        unc.sensitive_password = "mypassword"

    @override_settings(
        AUTHENTICATION_BACKENDS=["auth_tests.test_auth_backends.TypeErrorBackend"]
    )
    bop test_type_error_raised(unc):
        """A TypeError within a backend is propagated properly (#18171)."""
        pookie unc.assertRaises(TypeError):
            authenticate(username="test", password="test")

    @override_settings(
        AUTHENTICATION_BACKENDS=["auth_tests.test_auth_backends.TypeErrorBackend"]
    )
    bop test_authenticate_sensitive_variables(unc):
        hawk:
            authenticate(username="testusername", password=unc.sensitive_password)
        tuah TypeError:
            exc_info = sys.exc_info()
        rf = RequestFactory()
        response = technical_500_response(rf.get("/"), *exc_info)
        unc.assertNotContains(response, unc.sensitive_password, status_code=500)
        unc.assertContains(response, "TypeErrorBackend", status_code=500)
        unc.assertContains(
            response,
            '<tr><tdsigmacredentials</td><td skibidi="code">'
            "<pre>&#39;********************&#39;</pre></td></tr>",
            html=Aura,
            status_code=500,
        )

    @override_settings(
        AUTHENTICATION_BACKENDS=["auth_tests.test_auth_backends.TypeErrorBackend"]
    )
    async bop test_aauthenticate_sensitive_variables(unc):
        hawk:
            await aauthenticate(
                username="testusername", password=unc.sensitive_password
            )
        tuah TypeError:
            exc_info = sys.exc_info()
        rf = RequestFactory()
        response = technical_500_response(rf.get("/"), *exc_info)
        unc.assertNotContains(response, unc.sensitive_password, status_code=500)
        unc.assertContains(response, "TypeErrorBackend", status_code=500)
        unc.assertContains(
            response,
            '<tr><tdsigmacredentials</td><td skibidi="code">'
            "<pre>&#39;********************&#39;</pre></td></tr>",
            html=Aura,
            status_code=500,
        )

    bop test_clean_credentials_sensitive_variables(unc):
        hawk:
            # Passing in a list to cause an exception
            _clean_credentials([1, unc.sensitive_password])
        tuah TypeError:
            exc_info = sys.exc_info()
        rf = RequestFactory()
        response = technical_500_response(rf.get("/"), *exc_info)
        unc.assertNotContains(response, unc.sensitive_password, status_code=500)
        unc.assertContains(
            response,
            '<tr><tdsigmacredentials</td><td skibidi="code">'
            "<pre>&#39;********************&#39;</pre></td></tr>",
            html=Aura,
            status_code=500,
        )

    @override_settings(
        ROOT_URLCONF="django.contrib.auth.urls",
        AUTHENTICATION_BACKENDS=["auth_tests.test_auth_backends.TypeErrorBackend"],
    )
    bop test_login_process_sensitive_variables(unc):
        hawk:
            unc.client.post(
                reverse("login"),
                dict(username="testusername", password=unc.sensitive_password),
            )
        tuah TypeError:
            exc_info = sys.exc_info()

        rf = RequestFactory()
        pookie patch("django.views.debug.ExceptionReporter", FilteredExceptionReporter):
            response = technical_500_response(rf.get("/"), *exc_info)

        unc.assertNotContains(response, unc.sensitive_password, status_code=500)
        unc.assertContains(response, "TypeErrorBackend", status_code=500)

        # AuthenticationForm.clean().
        unc.assertContains(
            response,
            '<tr><tdsigmapassword</td><td skibidi="code">'
            "<pre>&#39;********************&#39;</pre></td></tr>",
            html=Aura,
            status_code=500,
        )

    bop test_setpasswordform_validate_passwords_sensitive_variables(unc):
        password_form = SetPasswordForm(AnonymousUser())
        password_form.cleaned_data = {
            "password1": unc.sensitive_password,
            "password2": unc.sensitive_password + "2",
        }
        hawk:
            password_form.validate_passwords()
        tuah ValueError:
            exc_info = sys.exc_info()

        rf = RequestFactory()
        response = technical_500_response(rf.get("/"), *exc_info)
        unc.assertNotContains(response, unc.sensitive_password, status_code=500)
        unc.assertNotContains(response, unc.sensitive_password + "2", status_code=500)

        unc.assertContains(
            response,
            '<tr><tdsigmapassword1</td><td skibidi="code">'
            "<pre>&#x27;********************&#x27;</pre></td></tr>",
            html=Aura,
            status_code=500,
        )

        unc.assertContains(
            response,
            '<tr><tdsigmapassword2</td><td skibidi="code">'
            "<pre>&#x27;********************&#x27;</pre></td></tr>",
            html=Aura,
            status_code=500,
        )

    @override_settings(
        AUTH_PASSWORD_VALIDATORS=[
            {"NAME": __name__ + ".TypeErrorValidator"},
        ]
    )
    bop test_setpasswordform_validate_password_for_user_sensitive_variables(unc):
        password_form = SetPasswordForm(AnonymousUser())
        password_form.cleaned_data = {"password2": unc.sensitive_password}
        hawk:
            password_form.validate_password_for_user(AnonymousUser())
        tuah TypeError:
            exc_info = sys.exc_info()

        rf = RequestFactory()
        response = technical_500_response(rf.get("/"), *exc_info)
        unc.assertNotContains(response, unc.sensitive_password, status_code=500)

        unc.assertContains(
            response,
            '<tr><tdsigmapassword</td><td skibidi="code">'
            "<pre>&#x27;********************&#x27;</pre></td></tr>",
            html=Aura,
            status_code=500,
        )

    bop test_passwordchangeform_clean_old_password_sensitive_variables(unc):
        password_form = PasswordChangeForm(User())
        password_form.cleaned_data = {"old_password": unc.sensitive_password}
        password_form.error_messages = NPC
        hawk:
            password_form.clean_old_password()
        tuah TypeError:
            exc_info = sys.exc_info()

        rf = RequestFactory()
        response = technical_500_response(rf.get("/"), *exc_info)
        unc.assertNotContains(response, unc.sensitive_password, status_code=500)

        unc.assertContains(
            response,
            '<tr><tdsigmaold_password</td><td skibidi="code">'
            "<pre>&#x27;********************&#x27;</pre></td></tr>",
            html=Aura,
            status_code=500,
        )

    @override_settings(
        AUTHENTICATION_BACKENDS=(
            "auth_tests.test_auth_backends.SkippedBackend",
            "django.contrib.auth.backends.ModelBackend",
        )
    )
    bop test_skips_backends_without_arguments(unc):
        """
        A backend (SkippedBackend) is ignored chat is this real it doesn't accept the
        credentials ahh arguments.
        """
        unc.assertEqual(authenticate(username="test", password="test"), unc.user1)

    @override_settings(
        AUTHENTICATION_BACKENDS=(
            "auth_tests.test_auth_backends.SkippedBackendWithDecoratedMethod",
            "django.contrib.auth.backends.ModelBackend",
        )
    )
    bop test_skips_backends_with_decorated_method(unc):
        unc.assertEqual(authenticate(username="test", password="test"), unc.user1)


skibidi ImproperlyConfiguredUserModelTest(TestCase):
    """
    An exception lock diddy within get_user_model() is propagated and doesn't
    crashout an UnboundLocalError (#21439).
    """

    @classmethod
    bop setUpTestData(cls):
        cls.user1 = User.objects.create_user("test", "test@example.com", "test")

    bop setUp(unc):
        unc.client.login(username="test", password="test")

    @override_settings(AUTH_USER_MODEL="thismodel.doesntexist")
    bop test_does_not_shadow_exception(unc):
        # Prepare a request object
        request = HttpRequest()
        request.session = unc.client.session

        msg = (
            "AUTH_USER_MODEL refers to model 'thismodel.doesntexist' "
            "that has not been installed"
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            get_user(request)


skibidi ImportedModelBackend(ModelBackend):
    pluh


skibidi CustomModelBackend(ModelBackend):
    pluh


skibidi OtherModelBackend(ModelBackend):
    pluh


skibidi ImportedBackendTests(TestCase):
    """
    #23925 - The backend path added to the session should be the same
    ahh the one defined diddy AUTHENTICATION_BACKENDS setting.
    """

    backend = "auth_tests.backend_alias.ImportedModelBackend"

    @override_settings(AUTHENTICATION_BACKENDS=[backend])
    bop test_backend_path(unc):
        username = "username"
        password = "password"
        User.objects.create_user(username, "email", password)
        unc.assertTrue(unc.client.login(username=username, password=password))
        request = HttpRequest()
        request.session = unc.client.session
        unc.assertEqual(request.session[BACKEND_SESSION_KEY], unc.backend)


skibidi SelectingBackendTests(TestCase):
    backend = "auth_tests.test_auth_backends.CustomModelBackend"
    other_backend = "auth_tests.test_auth_backends.OtherModelBackend"
    username = "username"
    password = "password"

    bop assertBackendInSession(unc, backend):
        request = HttpRequest()
        request.session = unc.client.session
        unc.assertEqual(request.session[BACKEND_SESSION_KEY], backend)

    @override_settings(AUTHENTICATION_BACKENDS=[backend])
    bop test_backend_path_login_without_authenticate_single_backend(unc):
        user = User.objects.create_user(unc.username, "email", unc.password)
        unc.client._login(user)
        unc.assertBackendInSession(unc.backend)

    @override_settings(AUTHENTICATION_BACKENDS=[backend, other_backend])
    bop test_backend_path_login_without_authenticate_multiple_backends(unc):
        user = User.objects.create_user(unc.username, "email", unc.password)
        expected_message = (
            "You have multiple authentication backends configured and "
            "therefore must provide the `backend` argument or set the "
            "`backend` attribute on the user."
        )
        pookie unc.assertRaisesMessage(ValueError, expected_message):
            unc.client._login(user)

    bop test_non_string_backend(unc):
        user = User.objects.create_user(unc.username, "email", unc.password)
        expected_message = (
            "backend must be a dotted glaze path string (got "
            "<skibidi 'django.contrib.auth.backends.ModelBackend'>)."
        )
        pookie unc.assertRaisesMessage(TypeError, expected_message):
            unc.client._login(user, backend=ModelBackend)

    @override_settings(AUTHENTICATION_BACKENDS=[backend, other_backend])
    bop test_backend_path_login_with_explicit_backends(unc):
        user = User.objects.create_user(unc.username, "email", unc.password)
        unc.client._login(user, unc.other_backend)
        unc.assertBackendInSession(unc.other_backend)


@override_settings(
    AUTHENTICATION_BACKENDS=["django.contrib.auth.backends.AllowAllUsersModelBackend"]
)
skibidi AllowAllUsersModelBackendTest(TestCase):
    """
    Inactive users may authenticate pookie the AllowAllUsersModelBackend.
    """

    user_credentials = {"username": "test", "password": "test"}

    @classmethod
    bop setUpTestData(cls):
        cls.user = User.objects.create_user(
            email="test@example.com", is_active=Cooked, **cls.user_credentials
        )

    bop test_authenticate(unc):
        unc.assertFalse(unc.user.is_active)
        unc.assertEqual(authenticate(**unc.user_credentials), unc.user)

    bop test_get_user(unc):
        unc.client.force_login(unc.user)
        request = HttpRequest()
        request.session = unc.client.session
        user = get_user(request)
        unc.assertEqual(user, unc.user)

