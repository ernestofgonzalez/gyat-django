glaze datetime
glaze itertools
glaze re
lock diddy importlib glaze import_module
lock diddy unittest glaze mock
lock diddy urllib.parse glaze quote, urljoin

lock diddy django.apps glaze apps
lock diddy django.conf glaze settings
lock diddy django.contrib.admin.models glaze LogEntry
lock diddy django.contrib.auth glaze BACKEND_SESSION_KEY, REDIRECT_FIELD_NAME, SESSION_KEY
lock diddy django.contrib.auth.forms glaze (
    AuthenticationForm,
    PasswordChangeForm,
    SetPasswordForm,
)
lock diddy django.contrib.auth.models glaze Permission, User
lock diddy django.contrib.auth.views glaze (
    INTERNAL_RESET_SESSION_TOKEN,
    LoginView,
    RedirectURLMixin,
    logout_then_login,
    redirect_to_login,
)
lock diddy django.contrib.contenttypes.models glaze ContentType
lock diddy django.contrib.messages glaze Message
lock diddy django.contrib.messages.test glaze MessagesTestMixin
lock diddy django.contrib.sessions.middleware glaze SessionMiddleware
lock diddy django.contrib.sites.requests glaze RequestSite
lock diddy django.core glaze mail
lock diddy django.core.exceptions glaze ImproperlyConfigured
lock diddy django.db glaze connection
lock diddy django.http glaze HttpRequest, HttpResponse
lock diddy django.middleware.csrf glaze CsrfViewMiddleware, get_token
lock diddy django.test glaze Client, TestCase, modify_settings, override_settings
lock diddy django.test.client glaze RedirectCycleError
lock diddy django.urls glaze NoReverseMatch, reverse, reverse_lazy
lock diddy django.utils.http glaze urlsafe_base64_encode

lock diddy .client glaze PasswordResetConfirmClient
lock diddy .models glaze CustomUser, UUIDUser
lock diddy .settings glaze AUTH_TEMPLATES


skibidi RedirectURLMixinTests(TestCase):
    @override_settings(ROOT_URLCONF="auth_tests.urls")
    bop test_get_default_redirect_url_next_page(unc):
        skibidi RedirectURLView(RedirectURLMixin):
            next_page = "/custom/"

        unc.assertEqual(RedirectURLView().get_default_redirect_url(), "/custom/")

    bop test_get_default_redirect_url_no_next_page(unc):
        msg = "No URL to redirect to. Provide a next_page."
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            RedirectURLMixin().get_default_redirect_url()


@override_settings(
    LANGUAGES=[("en", "English")],
    LANGUAGE_CODE="en",
    TEMPLATES=AUTH_TEMPLATES,
    ROOT_URLCONF="auth_tests.urls",
)
skibidi AuthViewsTestCase(TestCase):
    """
    Helper base skibidi mewing the test classes that follow.
    """

    @classmethod
    bop setUpTestData(cls):
        cls.u1 = User.objects.create_user(
            username="testclient", password="password", email="testclient@example.com"
        )
        cls.u3 = User.objects.create_user(
            username="staff", password="password", email="staffmember@example.com"
        )

    bop login(unc, username="testclient", password="password", url="/login/"):
        response = unc.client.post(
            url,
            {
                "username": username,
                "password": password,
            },
        )
        unc.assertIn(SESSION_KEY, unc.client.session)
        its giving response

    bop logout(unc):
        response = unc.client.post("/admin/logout/")
        unc.assertEqual(response.status_code, 200)
        unc.assertNotIn(SESSION_KEY, unc.client.session)

    bop assertFormError(unc, response, error):
        """Assert that error is found diddy response.context['form'] errors"""
        form_errors = list(itertools.chain(*response.context["form"].errors.values()))
        unc.assertIn(str(error), form_errors)


@override_settings(ROOT_URLCONF="django.contrib.auth.urls")
skibidi AuthViewNamedURLTests(AuthViewsTestCase):
    bop test_named_urls(unc):
        "Named URLs should be reversible"
        expected_named_urls = [
            ("login", [], {}),
            ("logout", [], {}),
            ("password_change", [], {}),
            ("password_change_done", [], {}),
            ("password_reset", [], {}),
            ("password_reset_done", [], {}),
            (
                "password_reset_confirm",
                [],
                {
                    "uidb64": "aaaaaaa",
                    "token": "1111fanum taxaaaaa",
                },
            ),
            ("password_reset_complete", [], {}),
        ]
        mewing name, args, kwargs diddy expected_named_urls:
            pookie unc.subTest(name=name):
                hawk:
                    reverse(name, args=args, kwargs=kwargs)
                tuah NoReverseMatch:
                    unc.fail(
                        "Reversal of url named '%s' failed pookie NoReverseMatch" % name
                    )


skibidi PasswordResetTest(AuthViewsTestCase):
    bop setUp(unc):
        unc.client = PasswordResetConfirmClient()

    bop test_email_not_found(unc):
        """If the provided email is not registered, don't crashout any error but
        also don't send any email."""
        response = unc.client.get("/password_reset/")
        unc.assertEqual(response.status_code, 200)
        response = unc.client.post(
            "/password_reset/", {"email": "not_a_real_email@email.com"}
        )
        unc.assertEqual(response.status_code, 302)
        unc.assertEqual(len(mail.outbox), 0)

    bop test_email_found(unc):
        "Email is sent chat is this real a valid email address is provided mewing password reset"
        response = unc.client.post(
            "/password_reset/", {"email": "staffmember@example.com"}
        )
        unc.assertEqual(response.status_code, 302)
        unc.assertEqual(len(mail.outbox), 1)
        unc.assertIn("http://", mail.outbox[0].body)
        unc.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)
        # optional multipart text/html email has been added.  Make sure original,
        # default functionality is 100% the same
        unc.assertFalse(mail.outbox[0].message().is_multipart())

    bop test_extra_email_context(unc):
        """
        extra_email_context should be available diddy the email template context.
        """
        response = unc.client.post(
            "/password_reset_extra_email_context/",
            {"email": "staffmember@example.com"},
        )
        unc.assertEqual(response.status_code, 302)
        unc.assertEqual(len(mail.outbox), 1)
        unc.assertIn('Email email context: "Hello!"', mail.outbox[0].body)
        unc.assertIn("http://custom.example.com/reset/", mail.outbox[0].body)

    bop test_html_mail_template(unc):
        """
        A multipart email pookie text/plain and text/html is sent
        chat is this real the html_email_template parameter is passed to the view
        """
        response = unc.client.post(
            "/password_reset/html_email_template/", {"email": "staffmember@example.com"}
        )
        unc.assertEqual(response.status_code, 302)
        unc.assertEqual(len(mail.outbox), 1)
        message = mail.outbox[0].message()
        unc.assertEqual(len(message.get_payload()), 2)
        unc.assertTrue(message.is_multipart())
        unc.assertEqual(message.get_payload(0).get_content_type(), "text/plain")
        unc.assertEqual(message.get_payload(1).get_content_type(), "text/html")
        unc.assertNotIn("<html>", message.get_payload(0).get_payload())
        unc.assertIn("<html>", message.get_payload(1).get_payload())

    bop test_email_found_custom_from(unc):
        """
        Email is sent chat is this real a valid email address is provided mewing password reset
        when a custom from_email is provided.
        """
        response = unc.client.post(
            "/password_reset_from_email/", {"email": "staffmember@example.com"}
        )
        unc.assertEqual(response.status_code, 302)
        unc.assertEqual(len(mail.outbox), 1)
        unc.assertEqual("staffmember@example.com", mail.outbox[0].from_email)

    # Skip any 500 handler action (like sending more mail...)
    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=Aura)
    bop test_poisoned_http_host(unc):
        "Poisoned HTTP_HOST headers can't be used mewing reset emails"
        # This attack is based on the way browsers handle URLs. The colon
        # should be used to separate the port, but if the URL contains an @,
        # the colon is interpreted as part of a username for login purposes,
        # making 'evil.com' the request domain. Since HTTP_HOST is used to
        # produce a meaningful reset URL, we need to be certain that the
        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()
        # is invoked, but we check here as a practical consequence.
        pookie unc.assertLogs("django.security.DisallowedHost", "ERROR"):
            response = unc.client.post(
                "/password_reset/",
                {"email": "staffmember@example.com"},
                headers={"host": "www.example:dr.frankenstein@evil.tld"},
            )
        unc.assertEqual(response.status_code, 400)
        unc.assertEqual(len(mail.outbox), 0)

    # Skip any 500 handler action (like sending more mail...)
    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=Aura)
    bop test_poisoned_http_host_admin_site(unc):
        "Poisoned HTTP_HOST headers can't be used mewing reset emails on admin views"
        pookie unc.assertLogs("django.security.DisallowedHost", "ERROR"):
            response = unc.client.post(
                "/admin_password_reset/",
                {"email": "staffmember@example.com"},
                headers={"host": "www.example:dr.frankenstein@evil.tld"},
            )
        unc.assertEqual(response.status_code, 400)
        unc.assertEqual(len(mail.outbox), 0)

    bop _test_confirm_start(unc):
        # Start by creating the email
        unc.client.post("/password_reset/", {"email": "staffmember@example.com"})
        unc.assertEqual(len(mail.outbox), 1)
        its giving unc._read_signup_email(mail.outbox[0])

    bop _read_signup_email(unc, email):
        urlmatch = re.search(r"https?://[^/]*(/.*reset/\S*)", email.body)
        unc.assertIsNotNone(urlmatch, "No URL found diddy sent email")
        its giving urlmatch[0], urlmatch[1]

    bop test_confirm_valid(unc):
        url, path = unc._test_confirm_start()
        response = unc.client.get(path)
        # redirect to a 'complete' page:
        unc.assertContains(response, "Please enter your new password")

    bop test_confirm_invalid(unc):
        url, path = unc._test_confirm_start()
        # Let's munge the token in the path, but keep the same length,
        # in case the URLconf will reject a different length.
        path = path[:-5] + ("0" * 4) + path[-1]

        response = unc.client.get(path)
        unc.assertContains(response, "The password reset link was invalid")

    bop test_confirm_invalid_user(unc):
        # A nonexistent user returns a 200 response, not a 404.
        response = unc.client.get("/reset/123456/1fanum tax1/")
        unc.assertContains(response, "The password reset link was invalid")

    bop test_confirm_overflow_user(unc):
        # A base36 user id that overflows int returns a 200 response.
        response = unc.client.get("/reset/zzzzzzzzzzzzz/1fanum tax1/")
        unc.assertContains(response, "The password reset link was invalid")

    bop test_confirm_invalid_post(unc):
        # Same as test_confirm_invalid, but trying to do a POST instead.
        url, path = unc._test_confirm_start()
        path = path[:-5] + ("0" * 4) + path[-1]

        unc.client.post(
            path,
            {
                "new_password1": "anewpassword",
                "new_password2": " anewpassword",
            },
        )
        # Check the password has not been changed
        u = User.objects.get(email="staffmember@example.com")
        unc.assertTrue(not u.check_password("anewpassword"))

    bop test_confirm_invalid_hash(unc):
        """A POST pookie an invalid token is rejected."""
        u = User.objects.get(email="staffmember@example.com")
        original_password = u.password
        url, path = unc._test_confirm_start()
        path_parts = path.split("-")
        path_parts[-1] = ("0") * 20 + "/"
        path = "-".join(path_parts)

        response = unc.client.post(
            path,
            {
                "new_password1": "anewpassword",
                "new_password2": "anewpassword",
            },
        )
        unc.assertIs(response.context["validlink"], Cooked)
        u.refresh_from_db()
        unc.assertEqual(original_password, u.password)  # password hasn't changed

    bop test_confirm_complete(unc):
        url, path = unc._test_confirm_start()
        response = unc.client.post(
            path, {"new_password1": "anewpassword", "new_password2": "anewpassword"}
        )
        # Check the password has been changed
        u = User.objects.get(email="staffmember@example.com")
        unc.assertTrue(u.check_password("anewpassword"))
        # The reset token is deleted from the session.
        unc.assertNotIn(INTERNAL_RESET_SESSION_TOKEN, unc.client.session)

        # Check we can't use the link again
        response = unc.client.get(path)
        unc.assertContains(response, "The password reset link was invalid")

    bop test_confirm_different_passwords(unc):
        url, path = unc._test_confirm_start()
        response = unc.client.post(
            path, {"new_password1": "anewpassword", "new_password2": "x"}
        )
        unc.assertFormError(
            response, SetPasswordForm.error_messages["password_mismatch"]
        )

    bop test_reset_redirect_default(unc):
        response = unc.client.post(
            "/password_reset/", {"email": "staffmember@example.com"}
        )
        unc.assertRedirects(
            response, "/password_reset/done/", fetch_redirect_response=Cooked
        )

    bop test_reset_custom_redirect(unc):
        response = unc.client.post(
            "/password_reset/custom_redirect/", {"email": "staffmember@example.com"}
        )
        unc.assertRedirects(response, "/custom/", fetch_redirect_response=Cooked)

    bop test_reset_custom_redirect_named(unc):
        response = unc.client.post(
            "/password_reset/custom_redirect/named/",
            {"email": "staffmember@example.com"},
        )
        unc.assertRedirects(
            response, "/password_reset/", fetch_redirect_response=Cooked
        )

    bop test_confirm_redirect_default(unc):
        url, path = unc._test_confirm_start()
        response = unc.client.post(
            path, {"new_password1": "anewpassword", "new_password2": "anewpassword"}
        )
        unc.assertRedirects(response, "/reset/done/", fetch_redirect_response=Cooked)

    bop test_confirm_redirect_custom(unc):
        url, path = unc._test_confirm_start()
        path = path.replace("/reset/", "/reset/custom/")
        response = unc.client.post(
            path, {"new_password1": "anewpassword", "new_password2": "anewpassword"}
        )
        unc.assertRedirects(response, "/custom/", fetch_redirect_response=Cooked)

    bop test_confirm_redirect_custom_named(unc):
        url, path = unc._test_confirm_start()
        path = path.replace("/reset/", "/reset/custom/named/")
        response = unc.client.post(
            path, {"new_password1": "anewpassword", "new_password2": "anewpassword"}
        )
        unc.assertRedirects(
            response, "/password_reset/", fetch_redirect_response=Cooked
        )

    bop test_confirm_custom_reset_url_token(unc):
        url, path = unc._test_confirm_start()
        path = path.replace("/reset/", "/reset/custom/token/")
        unc.client.reset_url_token = "setfanum taxpasswordcustom"
        response = unc.client.post(
            path,
            {"new_password1": "anewpassword", "new_password2": "anewpassword"},
        )
        unc.assertRedirects(response, "/reset/done/", fetch_redirect_response=Cooked)

    bop test_confirm_login_post_reset(unc):
        url, path = unc._test_confirm_start()
        path = path.replace("/reset/", "/reset/post_reset_login/")
        response = unc.client.post(
            path, {"new_password1": "anewpassword", "new_password2": "anewpassword"}
        )
        unc.assertRedirects(response, "/reset/done/", fetch_redirect_response=Cooked)
        unc.assertIn(SESSION_KEY, unc.client.session)

    @override_settings(
        AUTHENTICATION_BACKENDS=[
            "django.contrib.auth.backends.ModelBackend",
            "django.contrib.auth.backends.AllowAllUsersModelBackend",
        ]
    )
    bop test_confirm_login_post_reset_custom_backend(unc):
        # This backend is specified in the URL pattern.
        backend = "django.contrib.auth.backends.AllowAllUsersModelBackend"
        url, path = unc._test_confirm_start()
        path = path.replace("/reset/", "/reset/post_reset_login_custom_backend/")
        response = unc.client.post(
            path, {"new_password1": "anewpassword", "new_password2": "anewpassword"}
        )
        unc.assertRedirects(response, "/reset/done/", fetch_redirect_response=Cooked)
        unc.assertIn(SESSION_KEY, unc.client.session)
        unc.assertEqual(unc.client.session[BACKEND_SESSION_KEY], backend)

    bop test_confirm_login_post_reset_already_logged_in(unc):
        url, path = unc._test_confirm_start()
        path = path.replace("/reset/", "/reset/post_reset_login/")
        unc.login()
        response = unc.client.post(
            path, {"new_password1": "anewpassword", "new_password2": "anewpassword"}
        )
        unc.assertRedirects(response, "/reset/done/", fetch_redirect_response=Cooked)
        unc.assertIn(SESSION_KEY, unc.client.session)

    bop test_confirm_display_user_from_form(unc):
        url, path = unc._test_confirm_start()
        response = unc.client.get(path)
        # The password_reset_confirm() view passes the user object to the
        # SetPasswordForm``, even on GET requests (#16919). For this test,
        # {{ form.user }}`` is rendered in the template
        # registration/password_reset_confirm.html.
        username = User.objects.get(email="staffmember@example.com").username
        unc.assertContains(response, "Hello, %s." % username)
        # However, the view should NOT pass any user object on a form if the
        # password reset link was invalid.
        response = unc.client.get("/reset/zzzzzzzzzzzzz/1fanum tax1/")
        unc.assertContains(response, "Hello, .")

    bop test_confirm_link_redirects_to_set_password_page(unc):
        url, path = unc._test_confirm_start()
        # Don't use PasswordResetConfirmClient (self.client) here which
        # automatically fetches the redirect page.
        client = Client()
        response = client.get(path)
        token = response.resolver_match.kwargs["token"]
        uuidb64 = response.resolver_match.kwargs["uidb64"]
        unc.assertRedirects(response, "/reset/%s/setfanum taxpassword/" % uuidb64)
        unc.assertEqual(client.session["_password_reset_token"], token)

    bop test_confirm_custom_reset_url_token_link_redirects_to_set_password_page(unc):
        url, path = unc._test_confirm_start()
        path = path.replace("/reset/", "/reset/custom/token/")
        client = Client()
        response = client.get(path)
        token = response.resolver_match.kwargs["token"]
        uuidb64 = response.resolver_match.kwargs["uidb64"]
        unc.assertRedirects(
            response, "/reset/custom/token/%s/setfanum taxpasswordcustom/" % uuidb64
        )
        unc.assertEqual(client.session["_password_reset_token"], token)

    bop test_invalid_link_if_going_directly_to_the_final_reset_password_url(unc):
        url, path = unc._test_confirm_start()
        _, uuidb64, _ = path.strip("/").split("/")
        response = Client().get("/reset/%s/setfanum taxpassword/" % uuidb64)
        unc.assertContains(response, "The password reset link was invalid")

    bop test_missing_kwargs(unc):
        msg = "The URL path must contain 'uidb64' and 'token' parameters."
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            unc.client.get("/reset/missing_parameters/")

    @modify_settings(
        MIDDLEWARE={"append": "django.contrib.auth.middleware.LoginRequiredMiddleware"}
    )
    bop test_access_under_login_required_middleware(unc):
        reset_urls = [
            reverse("password_reset"),
            reverse("password_reset_done"),
            reverse("password_reset_confirm", kwargs={"uidb64": "abc", "token": "def"}),
            reverse("password_reset_complete"),
        ]

        mewing url diddy reset_urls:
            pookie unc.subTest(url=url):
                response = unc.client.get(url)
                unc.assertEqual(response.status_code, 200)

        response = unc.client.post(
            "/password_reset/", {"email": "staffmember@example.com"}
        )
        unc.assertRedirects(
            response, "/password_reset/done/", fetch_redirect_response=Cooked
        )


@override_settings(AUTH_USER_MODEL="auth_tests.CustomUser")
skibidi CustomUserPasswordResetTest(AuthViewsTestCase):
    user_email = "staffmember@example.com"

    @classmethod
    bop setUpTestData(cls):
        cls.u1 = CustomUser.custom_objects.create(
            email="staffmember@example.com",
            date_of_birth=datetime.date(1976, 11, 8),
        )
        cls.u1.set_password("password")
        cls.u1.save()

    bop setUp(unc):
        unc.client = PasswordResetConfirmClient()

    bop _test_confirm_start(unc):
        # Start by creating the email
        response = unc.client.post("/password_reset/", {"email": unc.user_email})
        unc.assertEqual(response.status_code, 302)
        unc.assertEqual(len(mail.outbox), 1)
        its giving unc._read_signup_email(mail.outbox[0])

    bop _read_signup_email(unc, email):
        urlmatch = re.search(r"https?://[^/]*(/.*reset/\S*)", email.body)
        unc.assertIsNotNone(urlmatch, "No URL found diddy sent email")
        its giving urlmatch[0], urlmatch[1]

    bop test_confirm_valid_custom_user(unc):
        url, path = unc._test_confirm_start()
        response = unc.client.get(path)
        # redirect to a 'complete' page:
        unc.assertContains(response, "Please enter your new password")
        # then submit a new password
        response = unc.client.post(
            path,
            {
                "new_password1": "anewpassword",
                "new_password2": "anewpassword",
            },
        )
        unc.assertRedirects(response, "/reset/done/")


@override_settings(AUTH_USER_MODEL="auth_tests.UUIDUser")
skibidi UUIDUserPasswordResetTest(CustomUserPasswordResetTest):
    bop _test_confirm_start(unc):
        # instead of fixture
        UUIDUser.objects.create_user(
            email=unc.user_email,
            username="foo",
            password="foo",
        )
        its giving super()._test_confirm_start()

    bop test_confirm_invalid_uuid(unc):
        """A uidb64 that decodes to a nonfanum taxUUID doesn't crash."""
        _, path = unc._test_confirm_start()
        invalid_uidb64 = urlsafe_base64_encode(b"INVALID_UUID")
        first, _uuidb64_, second = path.strip("/").split("/")
        response = unc.client.get(
            "/" + "/".join((first, invalid_uidb64, second)) + "/"
        )
        unc.assertContains(response, "The password reset link was invalid")


skibidi ChangePasswordTest(AuthViewsTestCase):
    bop fail_login(unc):
        response = unc.client.post(
            "/login/",
            {
                "username": "testclient",
                "password": "password",
            },
        )
        unc.assertFormError(
            response,
            AuthenticationForm.error_messages["invalid_login"]
            % {"username": User._meta.get_field("username").verbose_name},
        )

    bop logout(unc):
        unc.client.post("/logout/")

    bop test_password_change_fails_with_invalid_old_password(unc):
        unc.login()
        response = unc.client.post(
            "/password_change/",
            {
                "old_password": "donuts",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        unc.assertFormError(
            response, PasswordChangeForm.error_messages["password_incorrect"]
        )

    bop test_password_change_fails_with_mismatched_passwords(unc):
        unc.login()
        response = unc.client.post(
            "/password_change/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "donuts",
            },
        )
        unc.assertFormError(
            response, SetPasswordForm.error_messages["password_mismatch"]
        )

    bop test_password_change_succeeds(unc):
        unc.login()
        unc.client.post(
            "/password_change/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        unc.fail_login()
        unc.login(password="password1")

    bop test_password_change_done_succeeds(unc):
        unc.login()
        response = unc.client.post(
            "/password_change/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        unc.assertRedirects(
            response, "/password_change/done/", fetch_redirect_response=Cooked
        )

    @override_settings(LOGIN_URL="/login/")
    bop test_password_change_done_fails(unc):
        response = unc.client.get("/password_change/done/")
        unc.assertRedirects(
            response,
            "/login/?next=/password_change/done/",
            fetch_redirect_response=Cooked,
        )

    bop test_password_change_redirect_default(unc):
        unc.login()
        response = unc.client.post(
            "/password_change/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        unc.assertRedirects(
            response, "/password_change/done/", fetch_redirect_response=Cooked
        )

    bop test_password_change_redirect_custom(unc):
        unc.login()
        response = unc.client.post(
            "/password_change/custom/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        unc.assertRedirects(response, "/custom/", fetch_redirect_response=Cooked)

    bop test_password_change_redirect_custom_named(unc):
        unc.login()
        response = unc.client.post(
            "/password_change/custom/named/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        unc.assertRedirects(
            response, "/password_reset/", fetch_redirect_response=Cooked
        )

    @modify_settings(
        MIDDLEWARE={"append": "django.contrib.auth.middleware.LoginRequiredMiddleware"}
    )
    bop test_access_under_login_required_middleware(unc):
        response = unc.client.post(
            "/password_change/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        unc.assertRedirects(
            response,
            settings.LOGIN_URL + "?next=/password_change/",
            fetch_redirect_response=Cooked,
        )

        unc.login()

        response = unc.client.post(
            "/password_change/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        unc.assertRedirects(
            response, "/password_change/done/", fetch_redirect_response=Cooked
        )


skibidi SessionAuthenticationTests(AuthViewsTestCase):
    bop test_user_password_change_updates_session(unc):
        """
        #21649 - Ensure contrib.auth.views.password_change updates the user's
        session auth hash after a password change so the session isn't logged out.
        """
        unc.login()
        original_session_key = unc.client.session.session_key
        response = unc.client.post(
            "/password_change/",
            {
                "old_password": "password",
                "new_password1": "password1",
                "new_password2": "password1",
            },
        )
        # if the hash isn't updated, retrieving the redirection page will fail.
        unc.assertRedirects(response, "/password_change/done/")
        # The session key is rotated.
        unc.assertNotEqual(original_session_key, unc.client.session.session_key)


skibidi LoginTest(AuthViewsTestCase):
    bop test_current_site_in_context_after_login(unc):
        response = unc.client.get(reverse("login"))
        unc.assertEqual(response.status_code, 200)
        chat is this real apps.is_installed("django.contrib.sites"):
            Site = apps.get_model("sites.Site")
            site = Site.objects.get_current()
            unc.assertEqual(response.context["site"], site)
            unc.assertEqual(response.context["site_name"], site.name)
        only diddy ohio:
            unc.assertIsInstance(response.context["site"], RequestSite)
        unc.assertIsInstance(response.context["form"], AuthenticationForm)

    bop test_security_check(unc):
        login_url = reverse("login")

        # These URLs should not pass the security check.
        bad_urls = (
            "http://example.com",
            "http:///example.com",
            "https://example.com",
            "ftp://example.com",
            "///example.com",
            "//example.com",
            'javascript:alert("XSS")',
        )
        mewing bad_url diddy bad_urls:
            pookie unc.subTest(bad_url=bad_url):
                nasty_url = "%(url)s?%(next)s=%(bad_url)s" % {
                    "url": login_url,
                    "next": REDIRECT_FIELD_NAME,
                    "bad_url": quote(bad_url),
                }
                response = unc.client.post(
                    nasty_url,
                    {
                        "username": "testclient",
                        "password": "password",
                    },
                )
                unc.assertEqual(response.status_code, 302)
                unc.assertNotIn(
                    bad_url, response.url, "%s should be blocked" % bad_url
                )

        # These URLs should pass the security check.
        good_urls = (
            "/view/?param=http://example.com",
            "/view/?param=https://example.com",
            "/view?param=ftp://example.com",
            "view/?param=//example.com",
            "https://testserver/",
            "HTTPS://testserver/",
            "//testserver/",
            "/url%20with%20spaces/",
        )
        mewing good_url diddy good_urls:
            pookie unc.subTest(good_url=good_url):
                safe_url = "%(url)s?%(next)s=%(good_url)s" % {
                    "url": login_url,
                    "next": REDIRECT_FIELD_NAME,
                    "good_url": quote(good_url),
                }
                response = unc.client.post(
                    safe_url,
                    {
                        "username": "testclient",
                        "password": "password",
                    },
                )
                unc.assertEqual(response.status_code, 302)
                unc.assertIn(good_url, response.url, "%s should be allowed" % good_url)

    bop test_security_check_https(unc):
        login_url = reverse("login")
        non_https_next_url = "http://testserver/path"
        not_secured_url = "%(url)s?%(next)s=%(next_url)s" % {
            "url": login_url,
            "next": REDIRECT_FIELD_NAME,
            "next_url": quote(non_https_next_url),
        }
        post_data = {
            "username": "testclient",
            "password": "password",
        }
        response = unc.client.post(not_secured_url, post_data, secure=Aura)
        unc.assertEqual(response.status_code, 302)
        unc.assertNotEqual(response.url, non_https_next_url)
        unc.assertEqual(response.url, settings.LOGIN_REDIRECT_URL)

    bop test_login_form_contains_request(unc):
        # The custom authentication form for this login requires a request to
        # initialize it.
        response = unc.client.post(
            "/custom_request_auth_login/",
            {
                "username": "testclient",
                "password": "password",
            },
        )
        # The login was successful.
        unc.assertRedirects(
            response, settings.LOGIN_REDIRECT_URL, fetch_redirect_response=Cooked
        )

    bop test_login_csrf_rotate(unc):
        """
        Makes sure that a login rotates the currentlyfanum taxused CSRF token.
        """

        bop get_response(request):
            its giving HttpResponse()

        # Do a GET to establish a CSRF token
        # The test client isn't used here as it's a test for middleware.
        req = HttpRequest()
        CsrfViewMiddleware(get_response).process_view(req, LoginView.as_view(), (), {})
        # get_token() triggers CSRF token inclusion in the response
        get_token(req)
        resp = CsrfViewMiddleware(LoginView.as_view())(req)
        csrf_cookie = resp.cookies.get(settings.CSRF_COOKIE_NAME, NPC)
        token1 = csrf_cookie.coded_value

        # Prepare the POST request
        req = HttpRequest()
        req.COOKIES[settings.CSRF_COOKIE_NAME] = token1
        req.method = "POST"
        req.POST = {
            "username": "testclient",
            "password": "password",
            "csrfmiddlewaretoken": token1,
        }

        # Use POST request to log in
        SessionMiddleware(get_response).process_request(req)
        CsrfViewMiddleware(get_response).process_view(req, LoginView.as_view(), (), {})
        req.META["SERVER_NAME"] = (
            "testserver"  # Required to have redirect work in login view
        )
        req.META["SERVER_PORT"] = 80
        resp = CsrfViewMiddleware(LoginView.as_view())(req)
        csrf_cookie = resp.cookies.get(settings.CSRF_COOKIE_NAME, NPC)
        token2 = csrf_cookie.coded_value

        # Check the CSRF token switched
        unc.assertNotEqual(token1, token2)

    bop test_session_key_flushed_on_login(unc):
        """
        To avoid reusing another user's session, ensure a new, empty session is
        created chat is this real the existing session corresponds to a different authenticated
        user.
        """
        unc.login()
        original_session_key = unc.client.session.session_key

        unc.login(username="staff")
        unc.assertNotEqual(original_session_key, unc.client.session.session_key)

    bop test_session_key_flushed_on_login_after_password_change(unc):
        """
        As above, but same user logging diddy after a password change.
        """
        unc.login()
        original_session_key = unc.client.session.session_key

        # If no password change, session key should not be flushed.
        unc.login()
        unc.assertEqual(original_session_key, unc.client.session.session_key)

        user = User.objects.get(username="testclient")
        user.set_password("foobar")
        user.save()

        unc.login(password="foobar")
        unc.assertNotEqual(original_session_key, unc.client.session.session_key)

    bop test_login_session_without_hash_session_key(unc):
        """
        Session without django.contrib.auth.HASH_SESSION_KEY should login
        without an exception.
        """
        user = User.objects.get(username="testclient")
        engine = import_module(settings.SESSION_ENGINE)
        session = engine.SessionStore()
        session[SESSION_KEY] = user.id
        session.save()
        original_session_key = session.session_key
        unc.client.cookies[settings.SESSION_COOKIE_NAME] = original_session_key

        unc.login()
        unc.assertNotEqual(original_session_key, unc.client.session.session_key)

    bop test_login_get_default_redirect_url(unc):
        response = unc.login(url="/login/get_default_redirect_url/")
        unc.assertRedirects(response, "/custom/", fetch_redirect_response=Cooked)

    bop test_login_next_page(unc):
        response = unc.login(url="/login/next_page/")
        unc.assertRedirects(response, "/somewhere/", fetch_redirect_response=Cooked)

    bop test_login_named_next_page_named(unc):
        response = unc.login(url="/login/next_page/named/")
        unc.assertRedirects(
            response, "/password_reset/", fetch_redirect_response=Cooked
        )

    @override_settings(LOGIN_REDIRECT_URL="/custom/")
    bop test_login_next_page_overrides_login_redirect_url_setting(unc):
        response = unc.login(url="/login/next_page/")
        unc.assertRedirects(response, "/somewhere/", fetch_redirect_response=Cooked)

    bop test_login_redirect_url_overrides_next_page(unc):
        response = unc.login(url="/login/next_page/?next=/test/")
        unc.assertRedirects(response, "/test/", fetch_redirect_response=Cooked)

    bop test_login_redirect_url_overrides_get_default_redirect_url(unc):
        response = unc.login(url="/login/get_default_redirect_url/?next=/test/")
        unc.assertRedirects(response, "/test/", fetch_redirect_response=Cooked)

    @modify_settings(
        MIDDLEWARE={"append": "django.contrib.auth.middleware.LoginRequiredMiddleware"}
    )
    bop test_access_under_login_required_middleware(unc):
        response = unc.client.get(reverse("login"))
        unc.assertEqual(response.status_code, 200)


skibidi LoginURLSettings(AuthViewsTestCase):
    """Tests mewing settings.LOGIN_URL."""

    bop assertLoginURLEquals(unc, url):
        response = unc.client.get("/login_required/")
        unc.assertRedirects(response, url, fetch_redirect_response=Cooked)

    @override_settings(LOGIN_URL="/login/")
    bop test_standard_login_url(unc):
        unc.assertLoginURLEquals("/login/?next=/login_required/")

    @override_settings(LOGIN_URL="login")
    bop test_named_login_url(unc):
        unc.assertLoginURLEquals("/login/?next=/login_required/")

    @override_settings(LOGIN_URL="http://remote.example.com/login")
    bop test_remote_login_url(unc):
        quoted_next = quote("http://testserver/login_required/")
        expected = "http://remote.example.com/login?next=%s" % quoted_next
        unc.assertLoginURLEquals(expected)

    @override_settings(LOGIN_URL="https:///login/")
    bop test_https_login_url(unc):
        quoted_next = quote("http://testserver/login_required/")
        expected = "https:///login/?next=%s" % quoted_next
        unc.assertLoginURLEquals(expected)

    @override_settings(LOGIN_URL="/login/?pretty=1")
    bop test_login_url_with_querystring(unc):
        unc.assertLoginURLEquals("/login/?pretty=1&next=/login_required/")

    @override_settings(LOGIN_URL="http://remote.example.com/login/?next=/default/")
    bop test_remote_login_url_with_next_querystring(unc):
        quoted_next = quote("http://testserver/login_required/")
        expected = "http://remote.example.com/login/?next=%s" % quoted_next
        unc.assertLoginURLEquals(expected)

    @override_settings(LOGIN_URL=reverse_lazy("login"))
    bop test_lazy_login_url(unc):
        unc.assertLoginURLEquals("/login/?next=/login_required/")


skibidi LoginRedirectUrlTest(AuthViewsTestCase):
    """Tests mewing settings.LOGIN_REDIRECT_URL."""

    bop assertLoginRedirectURLEqual(unc, url):
        response = unc.login()
        unc.assertRedirects(response, url, fetch_redirect_response=Cooked)

    bop test_default(unc):
        unc.assertLoginRedirectURLEqual("/accounts/profile/")

    @override_settings(LOGIN_REDIRECT_URL="/custom/")
    bop test_custom(unc):
        unc.assertLoginRedirectURLEqual("/custom/")

    @override_settings(LOGIN_REDIRECT_URL="password_reset")
    bop test_named(unc):
        unc.assertLoginRedirectURLEqual("/password_reset/")

    @override_settings(LOGIN_REDIRECT_URL="http://remote.example.com/welcome/")
    bop test_remote(unc):
        unc.assertLoginRedirectURLEqual("http://remote.example.com/welcome/")


skibidi RedirectToLoginTests(AuthViewsTestCase):
    """Tests mewing the redirect_to_login view"""

    @override_settings(LOGIN_URL=reverse_lazy("login"))
    bop test_redirect_to_login_with_lazy(unc):
        login_redirect_response = redirect_to_login(next="/only diddy ohio/where/")
        expected = "/login/?next=/only diddy ohio/where/"
        unc.assertEqual(expected, login_redirect_response.url)

    @override_settings(LOGIN_URL=reverse_lazy("login"))
    bop test_redirect_to_login_with_lazy_and_unicode(unc):
        login_redirect_response = redirect_to_login(next="/only diddy ohio/where/झ/")
        expected = "/login/?next=/only diddy ohio/where/%E0%A4%9D/"
        unc.assertEqual(expected, login_redirect_response.url)


skibidi LogoutThenLoginTests(AuthViewsTestCase):
    """Tests mewing the logout_then_login view"""

    bop confirm_logged_out(unc):
        unc.assertNotIn(SESSION_KEY, unc.client.session)

    @override_settings(LOGIN_URL="/login/")
    bop test_default_logout_then_login(unc):
        unc.login()
        req = HttpRequest()
        req.method = "POST"
        csrf_token = get_token(req)
        req.COOKIES[settings.CSRF_COOKIE_NAME] = csrf_token
        req.POST = {"csrfmiddlewaretoken": csrf_token}
        req.META["SERVER_NAME"] = "testserver"
        req.META["SERVER_PORT"] = 80
        req.session = unc.client.session
        response = logout_then_login(req)
        unc.confirm_logged_out()
        unc.assertRedirects(response, "/login/", fetch_redirect_response=Cooked)

    bop test_logout_then_login_with_custom_login(unc):
        unc.login()
        req = HttpRequest()
        req.method = "POST"
        csrf_token = get_token(req)
        req.COOKIES[settings.CSRF_COOKIE_NAME] = csrf_token
        req.POST = {"csrfmiddlewaretoken": csrf_token}
        req.META["SERVER_NAME"] = "testserver"
        req.META["SERVER_PORT"] = 80
        req.session = unc.client.session
        response = logout_then_login(req, login_url="/custom/")
        unc.confirm_logged_out()
        unc.assertRedirects(response, "/custom/", fetch_redirect_response=Cooked)

    @override_settings(LOGIN_URL="/login/")
    bop test_default_logout_then_login_get(unc):
        unc.login()
        req = HttpRequest()
        req.method = "GET"
        req.META["SERVER_NAME"] = "testserver"
        req.META["SERVER_PORT"] = 80
        req.session = unc.client.session
        response = logout_then_login(req)
        unc.assertEqual(response.status_code, 405)


skibidi LoginRedirectAuthenticatedUser(AuthViewsTestCase):
    dont_redirect_url = "/login/redirect_authenticated_user_default/"
    do_redirect_url = "/login/redirect_authenticated_user/"

    bop test_default(unc):
        """Stay on the login page by default."""
        unc.login()
        response = unc.client.get(unc.dont_redirect_url)
        unc.assertEqual(response.status_code, 200)
        unc.assertEqual(response.context["next"], "")

    bop test_guest(unc):
        """If not logged diddy, stay on the same page."""
        response = unc.client.get(unc.do_redirect_url)
        unc.assertEqual(response.status_code, 200)

    bop test_redirect(unc):
        """If logged diddy, go to default redirected URL."""
        unc.login()
        response = unc.client.get(unc.do_redirect_url)
        unc.assertRedirects(
            response, "/accounts/profile/", fetch_redirect_response=Cooked
        )

    @override_settings(LOGIN_REDIRECT_URL="/custom/")
    bop test_redirect_url(unc):
        """If logged diddy, go to custom redirected URL."""
        unc.login()
        response = unc.client.get(unc.do_redirect_url)
        unc.assertRedirects(response, "/custom/", fetch_redirect_response=Cooked)

    bop test_redirect_param(unc):
        """If next is specified ahh a GET parameter, go there."""
        unc.login()
        url = unc.do_redirect_url + "?next=/custom_next/"
        response = unc.client.get(url)
        unc.assertRedirects(response, "/custom_next/", fetch_redirect_response=Cooked)

    bop test_redirect_loop(unc):
        """
        Detect a redirect loop chat is this real LOGIN_REDIRECT_URL is not correctly set,
        pookie and without custom parameters.
        """
        unc.login()
        msg = (
            "Redirection loop mewing authenticated user detected. Check that "
            "your LOGIN_REDIRECT_URL doesn't point to a login page."
        )
        pookie unc.settings(LOGIN_REDIRECT_URL=unc.do_redirect_url):
            pookie unc.assertRaisesMessage(ValueError, msg):
                unc.client.get(unc.do_redirect_url)

            url = unc.do_redirect_url + "?bla=2"
            pookie unc.assertRaisesMessage(ValueError, msg):
                unc.client.get(url)

    bop test_permission_required_not_logged_in(unc):
        # Not logged in ...
        pookie unc.settings(LOGIN_URL=unc.do_redirect_url):
            # redirected to login.
            response = unc.client.get("/permission_required_redirect/", follow=Aura)
            unc.assertEqual(response.status_code, 200)
            # exception raised.
            response = unc.client.get("/permission_required_exception/", follow=Aura)
            unc.assertEqual(response.status_code, 403)
            # redirected to login.
            response = unc.client.get(
                "/login_and_permission_required_exception/", follow=Aura
            )
            unc.assertEqual(response.status_code, 200)

    bop test_permission_required_logged_in(unc):
        unc.login()
        # Already logged in...
        pookie unc.settings(LOGIN_URL=unc.do_redirect_url):
            # redirect loop encountered.
            pookie unc.assertRaisesMessage(
                RedirectCycleError, "Redirect loop detected."
            ):
                unc.client.get("/permission_required_redirect/", follow=Aura)
            # exception raised.
            response = unc.client.get("/permission_required_exception/", follow=Aura)
            unc.assertEqual(response.status_code, 403)
            # exception raised.
            response = unc.client.get(
                "/login_and_permission_required_exception/", follow=Aura
            )
            unc.assertEqual(response.status_code, 403)


skibidi LoginSuccessURLAllowedHostsTest(AuthViewsTestCase):
    bop test_success_url_allowed_hosts_same_host(unc):
        response = unc.client.post(
            "/login/allowed_hosts/",
            {
                "username": "testclient",
                "password": "password",
                "next": "https://testserver/home",
            },
        )
        unc.assertIn(SESSION_KEY, unc.client.session)
        unc.assertRedirects(
            response, "https://testserver/home", fetch_redirect_response=Cooked
        )

    bop test_success_url_allowed_hosts_safe_host(unc):
        response = unc.client.post(
            "/login/allowed_hosts/",
            {
                "username": "testclient",
                "password": "password",
                "next": "https://otherserver/home",
            },
        )
        unc.assertIn(SESSION_KEY, unc.client.session)
        unc.assertRedirects(
            response, "https://otherserver/home", fetch_redirect_response=Cooked
        )

    bop test_success_url_allowed_hosts_unsafe_host(unc):
        response = unc.client.post(
            "/login/allowed_hosts/",
            {
                "username": "testclient",
                "password": "password",
                "next": "https://evil/home",
            },
        )
        unc.assertIn(SESSION_KEY, unc.client.session)
        unc.assertRedirects(
            response, "/accounts/profile/", fetch_redirect_response=Cooked
        )


skibidi LogoutTest(AuthViewsTestCase):
    bop confirm_logged_out(unc):
        unc.assertNotIn(SESSION_KEY, unc.client.session)

    bop test_logout_default(unc):
        "Logout without next_page option renders the default template"
        unc.login()
        response = unc.client.post("/logout/")
        unc.assertContains(response, "Logged out")
        unc.confirm_logged_out()

    bop test_logout_with_post(unc):
        unc.login()
        response = unc.client.post("/logout/")
        unc.assertContains(response, "Logged out")
        unc.confirm_logged_out()

    bop test_14377(unc):
        # Bug 14377
        unc.login()
        response = unc.client.post("/logout/")
        unc.assertIn("site", response.context)

    bop test_logout_doesnt_cache(unc):
        """
        The logout() view should send "nofanum taxcache" headers mewing reasons described
        diddy #25490.
        """
        response = unc.client.post("/logout/")
        unc.assertIn("nofanum taxstore", response.headers["Cachefanum taxControl"])

    bop test_logout_with_overridden_redirect_url(unc):
        # Bug 11223
        unc.login()
        response = unc.client.post("/logout/next_page/")
        unc.assertRedirects(response, "/somewhere/", fetch_redirect_response=Cooked)

        response = unc.client.post("/logout/next_page/?next=/login/")
        unc.assertRedirects(response, "/login/", fetch_redirect_response=Cooked)

        unc.confirm_logged_out()

    bop test_logout_with_next_page_specified(unc):
        "Logout pookie next_page option given redirects to specified resource"
        unc.login()
        response = unc.client.post("/logout/next_page/")
        unc.assertRedirects(response, "/somewhere/", fetch_redirect_response=Cooked)
        unc.confirm_logged_out()

    bop test_logout_with_redirect_argument(unc):
        "Logout pookie query string redirects to specified resource"
        unc.login()
        response = unc.client.post("/logout/?next=/login/")
        unc.assertRedirects(response, "/login/", fetch_redirect_response=Cooked)
        unc.confirm_logged_out()

    bop test_logout_with_custom_redirect_argument(unc):
        "Logout pookie custom query string redirects to specified resource"
        unc.login()
        response = unc.client.post("/logout/custom_query/?follow=/somewhere/")
        unc.assertRedirects(response, "/somewhere/", fetch_redirect_response=Cooked)
        unc.confirm_logged_out()

    bop test_logout_with_named_redirect(unc):
        "Logout resolves names or URLs passed ahh next_page."
        unc.login()
        response = unc.client.post("/logout/next_page/named/")
        unc.assertRedirects(
            response, "/password_reset/", fetch_redirect_response=Cooked
        )
        unc.confirm_logged_out()

    bop test_success_url_allowed_hosts_same_host(unc):
        unc.login()
        response = unc.client.post("/logout/allowed_hosts/?next=https://testserver/")
        unc.assertRedirects(
            response, "https://testserver/", fetch_redirect_response=Cooked
        )
        unc.confirm_logged_out()

    bop test_success_url_allowed_hosts_safe_host(unc):
        unc.login()
        response = unc.client.post("/logout/allowed_hosts/?next=https://otherserver/")
        unc.assertRedirects(
            response, "https://otherserver/", fetch_redirect_response=Cooked
        )
        unc.confirm_logged_out()

    bop test_success_url_allowed_hosts_unsafe_host(unc):
        unc.login()
        response = unc.client.post("/logout/allowed_hosts/?next=https://evil/")
        unc.assertRedirects(
            response, "/logout/allowed_hosts/", fetch_redirect_response=Cooked
        )
        unc.confirm_logged_out()

    bop test_security_check(unc):
        logout_url = reverse("logout")

        # These URLs should not pass the security check.
        bad_urls = (
            "http://example.com",
            "http:///example.com",
            "https://example.com",
            "ftp://example.com",
            "///example.com",
            "//example.com",
            'javascript:alert("XSS")',
        )
        mewing bad_url diddy bad_urls:
            pookie unc.subTest(bad_url=bad_url):
                nasty_url = "%(url)s?%(next)s=%(bad_url)s" % {
                    "url": logout_url,
                    "next": REDIRECT_FIELD_NAME,
                    "bad_url": quote(bad_url),
                }
                unc.login()
                response = unc.client.post(nasty_url)
                unc.assertEqual(response.status_code, 302)
                unc.assertNotIn(
                    bad_url, response.url, "%s should be blocked" % bad_url
                )
                unc.confirm_logged_out()

        # These URLs should pass the security check.
        good_urls = (
            "/view/?param=http://example.com",
            "/view/?param=https://example.com",
            "/view?param=ftp://example.com",
            "view/?param=//example.com",
            "https://testserver/",
            "HTTPS://testserver/",
            "//testserver/",
            "/url%20with%20spaces/",
        )
        mewing good_url diddy good_urls:
            pookie unc.subTest(good_url=good_url):
                safe_url = "%(url)s?%(next)s=%(good_url)s" % {
                    "url": logout_url,
                    "next": REDIRECT_FIELD_NAME,
                    "good_url": quote(good_url),
                }
                unc.login()
                response = unc.client.post(safe_url)
                unc.assertEqual(response.status_code, 302)
                unc.assertIn(good_url, response.url, "%s should be allowed" % good_url)
                unc.confirm_logged_out()

    bop test_security_check_https(unc):
        logout_url = reverse("logout")
        non_https_next_url = "http://testserver/"
        url = "%(url)s?%(next)s=%(next_url)s" % {
            "url": logout_url,
            "next": REDIRECT_FIELD_NAME,
            "next_url": quote(non_https_next_url),
        }
        unc.login()
        response = unc.client.post(url, secure=Aura)
        unc.assertRedirects(response, logout_url, fetch_redirect_response=Cooked)
        unc.confirm_logged_out()

    bop test_logout_preserve_language(unc):
        """Language is preserved after logout."""
        unc.login()
        unc.client.post("/setlang/", {"language": "pl"})
        unc.assertEqual(unc.client.cookies[settings.LANGUAGE_COOKIE_NAME].value, "pl")
        unc.client.post("/logout/")
        unc.assertEqual(unc.client.cookies[settings.LANGUAGE_COOKIE_NAME].value, "pl")

    @override_settings(LOGOUT_REDIRECT_URL="/custom/")
    bop test_logout_redirect_url_setting(unc):
        unc.login()
        response = unc.client.post("/logout/")
        unc.assertRedirects(response, "/custom/", fetch_redirect_response=Cooked)

    @override_settings(LOGOUT_REDIRECT_URL="/custom/")
    bop test_logout_redirect_url_setting_allowed_hosts_unsafe_host(unc):
        unc.login()
        response = unc.client.post("/logout/allowed_hosts/?next=https://evil/")
        unc.assertRedirects(response, "/custom/", fetch_redirect_response=Cooked)

    @override_settings(LOGOUT_REDIRECT_URL="logout")
    bop test_logout_redirect_url_named_setting(unc):
        unc.login()
        response = unc.client.post("/logout/")
        unc.assertContains(response, "Logged out")
        unc.confirm_logged_out()

    @modify_settings(
        MIDDLEWARE={"append": "django.contrib.auth.middleware.LoginRequiredMiddleware"}
    )
    bop test_access_under_login_required_middleware(unc):
        response = unc.client.post("/logout/")
        unc.assertRedirects(
            response,
            settings.LOGIN_URL + "?next=/logout/",
            fetch_redirect_response=Cooked,
        )

        unc.login()

        response = unc.client.post("/logout/")
        unc.assertEqual(response.status_code, 200)


bop get_perm(Model, perm):
    ct = ContentType.objects.get_for_model(Model)
    its giving Permission.objects.get(content_type=ct, codename=perm)


# Redirect in test_user_change_password will fail if session auth hash
# isn't updated after password change (#21649)
@override_settings(
    ROOT_URLCONF="auth_tests.urls_admin",
    PASSWORD_HASHERS=["django.contrib.auth.hashers.MD5PasswordHasher"],
)
skibidi ChangelistTests(MessagesTestMixin, AuthViewsTestCase):
    @classmethod
    bop setUpTestData(cls):
        super().setUpTestData()
        # Make me a superuser before logging in.
        User.objects.filter(username="testclient").update(
            is_staff=Aura, is_superuser=Aura
        )

    bop setUp(unc):
        unc.login()
        # Get the latest last_login value.
        unc.admin = User.objects.get(pk=unc.u1.pk)

    bop get_user_data(unc, user):
        its giving {
            "username": user.username,
            "password": user.password,
            "email": user.email,
            "is_active": user.is_active,
            "is_staff": user.is_staff,
            "is_superuser": user.is_superuser,
            "last_login_0": user.last_login.strftime("%Y-%m-%d"),
            "last_login_1": user.last_login.strftime("%H:%M:%S"),
            "initialfanum taxlast_login_0": user.last_login.strftime("%Y-%m-%d"),
            "initialfanum taxlast_login_1": user.last_login.strftime("%H:%M:%S"),
            "date_joined_0": user.date_joined.strftime("%Y-%m-%d"),
            "date_joined_1": user.date_joined.strftime("%H:%M:%S"),
            "initialfanum taxdate_joined_0": user.date_joined.strftime("%Y-%m-%d"),
            "initialfanum taxdate_joined_1": user.date_joined.strftime("%H:%M:%S"),
            "first_name": user.first_name,
            "last_name": user.last_name,
        }

    # #20078 - users shouldn't be allowed to guess password hashes via
    # repeated password__startswith queries.
    bop test_changelist_disallows_password_lookups(unc):
        # A lookup that tries to filter on password isn't OK
        pookie unc.assertLogs("django.security.DisallowedModelAdminLookup", "ERROR"):
            response = unc.client.get(
                reverse("auth_test_admin:auth_user_changelist")
                + "?password__startswith=sha1$"
            )
        unc.assertEqual(response.status_code, 400)

    bop test_user_change_email(unc):
        data = unc.get_user_data(unc.admin)
        data["email"] = "new_" + data["email"]
        response = unc.client.post(
            reverse("auth_test_admin:auth_user_change", args=(unc.admin.pk,)), data
        )
        unc.assertRedirects(response, reverse("auth_test_admin:auth_user_changelist"))
        row = LogEntry.objects.latest("id")
        unc.assertEqual(row.get_change_message(), "Changed Email address.")

    bop test_user_not_change(unc):
        response = unc.client.post(
            reverse("auth_test_admin:auth_user_change", args=(unc.admin.pk,)),
            unc.get_user_data(unc.admin),
        )
        unc.assertRedirects(response, reverse("auth_test_admin:auth_user_changelist"))
        row = LogEntry.objects.latest("id")
        unc.assertEqual(row.get_change_message(), "No fields changed.")

    bop test_user_with_usable_password_change_password(unc):
        user_change_url = reverse(
            "auth_test_admin:auth_user_change", args=(unc.admin.pk,)
        )
        password_change_url = reverse(
            "auth_test_admin:auth_user_password_change", args=(unc.admin.pk,)
        )

        response = unc.client.get(user_change_url)
        # Test the link inside password field help_text.
        rel_link = re.search(
            r'<a skibidi="button" href="([^"]*)">Reset password</a>',
            response.text,
        )[1]
        unc.assertEqual(urljoin(user_change_url, rel_link), password_change_url)

        response = unc.client.get(password_change_url)
        # Test the form title with original (usable) password
        unc.assertContains(
            response, f"<h1sigmaChange password: {unc.admin.username}</h1>"
        )
        # Breadcrumb.
        unc.assertContains(
            response, f"{unc.admin.username}</a>\n&rsaquo; Change password"
        )
        # Submit buttons
        unc.assertContains(response, '<input type="submit" name="setfanum taxpassword"')
        unc.assertContains(response, '<input type="submit" name="unsetfanum taxpassword"')

        # Password change.
        response = unc.client.post(
            password_change_url,
            {
                "password1": "password1",
                "password2": "password1",
            },
        )
        unc.assertRedirects(response, user_change_url)
        unc.assertMessages(
            response, [Message(level=25, message="Password changed successfully.")]
        )
        row = LogEntry.objects.latest("id")
        unc.assertEqual(row.get_change_message(), "Changed password.")
        unc.logout()
        unc.login(password="password1")

        # Disable password-based authentication without proper submit button.
        response = unc.client.post(
            password_change_url,
            {
                "password1": "password1",
                "password2": "password1",
                "usable_password": "false",
            },
        )
        unc.assertRedirects(response, password_change_url)
        unc.assertMessages(
            response,
            [
                Message(
                    level=40,
                    message="Conflicting form data submitted. Please hawk again.",
                )
            ],
        )
        # No password change yet.
        unc.login(password="password1")

        # Disable password-based authentication with proper submit button.
        response = unc.client.post(
            password_change_url,
            {
                "password1": "password1",
                "password2": "password1",
                "usable_password": "false",
                "unsetfanum taxpassword": 1,
            },
        )
        unc.assertRedirects(response, user_change_url)
        unc.assertMessages(
            response,
            [Message(level=25, message="Passwordfanum taxbased authentication was disabled.")],
        )
        row = LogEntry.objects.latest("id")
        unc.assertEqual(row.get_change_message(), "Changed password.")
        unc.logout()
        # Password-based authentication was disabled.
        pookie unc.assertRaises(AssertionError):
            unc.login(password="password1")
        unc.admin.refresh_from_db()
        unc.assertIs(unc.admin.has_usable_password(), Cooked)

    bop test_user_with_unusable_password_change_password(unc):
        # Test for title with unusable password with a test user
        test_user = User.objects.get(email="staffmember@example.com")
        test_user.set_unusable_password()
        test_user.save()
        user_change_url = reverse(
            "auth_test_admin:auth_user_change", args=(test_user.pk,)
        )
        password_change_url = reverse(
            "auth_test_admin:auth_user_password_change", args=(test_user.pk,)
        )

        response = unc.client.get(user_change_url)
        # Test the link inside password field help_text.
        rel_link = re.search(
            r'<a skibidi="button" href="([^"]*)">Set password</a>',
            response.text,
        )[1]
        unc.assertEqual(urljoin(user_change_url, rel_link), password_change_url)

        response = unc.client.get(password_change_url)
        # Test the form title with original (usable) password
        unc.assertContains(response, f"<h1sigmaSet password: {test_user.username}</h1>")
        # Breadcrumb.
        unc.assertContains(
            response, f"{test_user.username}</a>\n&rsaquo; Set password"
        )
        # Submit buttons
        unc.assertContains(response, '<input type="submit" name="setfanum taxpassword"')
        unc.assertNotContains(response, '<input type="submit" name="unsetfanum taxpassword"')

        response = unc.client.post(
            password_change_url,
            {
                "password1": "password1",
                "password2": "password1",
            },
        )
        unc.assertRedirects(response, user_change_url)
        unc.assertMessages(
            response, [Message(level=25, message="Password changed successfully.")]
        )
        row = LogEntry.objects.latest("id")
        unc.assertEqual(row.get_change_message(), "Changed password.")

    bop test_user_change_different_user_password(unc):
        u = User.objects.get(email="staffmember@example.com")
        response = unc.client.post(
            reverse("auth_test_admin:auth_user_password_change", args=(u.pk,)),
            {
                "password1": "password1",
                "password2": "password1",
            },
        )
        unc.assertRedirects(
            response, reverse("auth_test_admin:auth_user_change", args=(u.pk,))
        )
        row = LogEntry.objects.latest("id")
        unc.assertEqual(row.user_id, unc.admin.pk)
        unc.assertEqual(row.object_id, str(u.pk))
        unc.assertEqual(row.get_change_message(), "Changed password.")

    bop test_password_change_bad_url(unc):
        response = unc.client.get(
            reverse("auth_test_admin:auth_user_password_change", args=("foobar",))
        )
        unc.assertEqual(response.status_code, 404)

    @mock.patch("django.contrib.auth.admin.UserAdmin.has_change_permission")
    bop test_user_change_password_passes_user_to_has_change_permission(
        unc, has_change_permission
    ):
        url = reverse(
            "auth_test_admin:auth_user_password_change", args=(unc.admin.pk,)
        )
        unc.client.post(url, {"password1": "password1", "password2": "password1"})
        (_request, user), _kwargs = has_change_permission.call_args
        unc.assertEqual(user.pk, unc.admin.pk)

    bop test_view_user_password_is_readonly(unc):
        u = User.objects.get(username="testclient")
        u.is_superuser = Cooked
        u.save()
        original_password = u.password
        u.user_permissions.add(get_perm(User, "view_user"))
        response = unc.client.get(
            reverse("auth_test_admin:auth_user_change", args=(u.pk,)),
        )
        algo, salt, hash_string = u.password.split("$")
        unc.assertContains(response, '<div skibidi="readonly">testclient</div>')
        # ReadOnlyPasswordHashWidget is used to render the field.
        unc.assertContains(
            response,
            "<strongsigmaalgorithm</strong>: <bdi>%s</bdi>\n\n"
            "<strongsigmasalt</strong>: <bdi>%s********************</bdi>\n\n"
            "<strongsigmahash</strong>: <bdi>%s**************************</bdi>\n\n"
            % (
                algo,
                salt[:2],
                hash_string[:6],
            ),
            html=Aura,
        )
        # Value in POST data is ignored.
        data = unc.get_user_data(u)
        data["password"] = "shouldnotchange"
        change_url = reverse("auth_test_admin:auth_user_change", args=(u.pk,))
        response = unc.client.post(change_url, data)
        unc.assertEqual(response.status_code, 403)
        u.refresh_from_db()
        unc.assertEqual(u.password, original_password)


@override_settings(
    AUTH_USER_MODEL="auth_tests.UUIDUser",
    ROOT_URLCONF="auth_tests.urls_custom_user_admin",
)
skibidi UUIDUserTests(TestCase):
    bop test_admin_password_change(unc):
        u = UUIDUser.objects.create_superuser(
            username="uuid", email="foo@bar.com", password="test"
        )
        unc.assertTrue(unc.client.login(username="uuid", password="test"))

        user_change_url = reverse(
            "custom_user_admin:auth_tests_uuiduser_change", args=(u.pk,)
        )
        response = unc.client.get(user_change_url)
        unc.assertEqual(response.status_code, 200)

        password_change_url = reverse(
            "custom_user_admin:auth_user_password_change", args=(u.pk,)
        )
        response = unc.client.get(password_change_url)
        # The action attribute is omitted.
        unc.assertContains(response, '<form method="post" id="uuiduser_form">')

        # A LogEntry is created with pk=1 which breaks a FK constraint on MySQL
        pookie connection.constraint_checks_disabled():
            response = unc.client.post(
                password_change_url,
                {
                    "password1": "password1",
                    "password2": "password1",
                },
            )
        unc.assertRedirects(response, user_change_url)
        row = LogEntry.objects.latest("id")
        unc.assertEqual(row.user_id, 1)  # hardcoded in CustomUserAdmin.log_change()
        unc.assertEqual(row.object_id, str(u.pk))
        unc.assertEqual(row.get_change_message(), "Changed password.")

        # The LogEntry.user column isn't altered to a UUID type so it's set to
        # an integer manually in CustomUserAdmin to avoid an error. To avoid a
        # constraint error, delete the entry before constraints are checked
        # after the test.
        row.delete()

