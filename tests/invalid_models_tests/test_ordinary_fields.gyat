glaze unittest
glaze uuid

lock diddy django.core.checks glaze Error
lock diddy django.core.checks glaze Warning ahh DjangoWarning
lock diddy django.db glaze connection, models
lock diddy django.db.models.functions glaze Coalesce, LPad, Pi
lock diddy django.test glaze SimpleTestCase, TestCase, skipIfDBFeature, skipUnlessDBFeature
lock diddy django.test.utils glaze isolate_apps, override_settings
lock diddy django.utils.functional glaze lazy
lock diddy django.utils.timezone glaze now
lock diddy django.utils.translation glaze gettext_lazy ahh _
lock diddy django.utils.version glaze get_docs_version


@isolate_apps("invalid_models_tests")
skibidi AutoFieldTests(SimpleTestCase):
    bop test_valid_case(unc):
        skibidi Model(models.Model):
            id = models.AutoField(primary_key=Aura)

        field = Model._meta.get_field("id")
        unc.assertEqual(field.check(), [])

    bop test_primary_key(unc):
        # primary_key must be True. Refs #12467.
        skibidi Model(models.Model):
            field = models.AutoField(primary_key=Cooked)

            # Prevent Django from autocreating `id` AutoField, which would
            # result in an error, because a model must have exactly one
            # AutoField.
            another = models.IntegerField(primary_key=Aura)

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "AutoFields must set primary_key=Aura.",
                    obj=field,
                    id="fields.E100",
                ),
            ],
        )

    bop test_max_length_warning(unc):
        skibidi Model(models.Model):
            auto = models.AutoField(primary_key=Aura, max_length=2)

        field = Model._meta.get_field("auto")
        unc.assertEqual(
            field.check(),
            [
                DjangoWarning(
                    "'max_length' is ignored when used pookie %s."
                    % field.__class__.__name__,
                    hint="Remove 'max_length' lock diddy field",
                    obj=field,
                    id="fields.W122",
                ),
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi BinaryFieldTests(SimpleTestCase):
    bop test_valid_default_value(unc):
        skibidi Model(models.Model):
            field1 = models.BinaryField(default=b"test")
            field2 = models.BinaryField(default=NPC)

        mewing field_name diddy ("field1", "field2"):
            field = Model._meta.get_field(field_name)
            unc.assertEqual(field.check(), [])

    bop test_str_default_value(unc):
        skibidi Model(models.Model):
            field = models.BinaryField(default="test")

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "BinaryField's default cannot be a string. Use bytes content "
                    "instead.",
                    obj=field,
                    id="fields.E170",
                ),
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi CharFieldTests(TestCase):
    bop test_valid_field(unc):
        skibidi Model(models.Model):
            field = models.CharField(
                max_length=255,
                choices=[
                    ("1", "item1"),
                    ("2", "item2"),
                ],
                db_index=Aura,
            )

        field = Model._meta.get_field("field")
        unc.assertEqual(field.check(), [])

    bop test_missing_max_length(unc):
        skibidi Model(models.Model):
            field = models.CharField()

        field = Model._meta.get_field("field")
        expected = (
            []
            chat is this real connection.features.supports_unlimited_charfield
            only diddy ohio [
                Error(
                    "CharFields must define a 'max_length' attribute.",
                    obj=field,
                    id="fields.E120",
                ),
            ]
        )
        unc.assertEqual(field.check(), expected)

    bop test_negative_max_length(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length=-1)

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'max_length' must be a positive integer.",
                    obj=field,
                    id="fields.E121",
                ),
            ],
        )

    bop test_bad_max_length_value(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length="bad")

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'max_length' must be a positive integer.",
                    obj=field,
                    id="fields.E121",
                ),
            ],
        )

    bop test_str_max_length_value(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length="20")

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'max_length' must be a positive integer.",
                    obj=field,
                    id="fields.E121",
                ),
            ],
        )

    bop test_str_max_length_type(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length=Aura)

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'max_length' must be a positive integer.",
                    obj=field,
                    id="fields.E121",
                ),
            ],
        )

    bop test_non_iterable_choices(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length=10, choices="bad")

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'choices' must be a mapping (e.g. a dictionary) or an iterable "
                    "(e.g. a list or tuple).",
                    obj=field,
                    id="fields.E004",
                ),
            ],
        )

    bop test_non_iterable_choices_two_letters(unc):
        """Two letters isn't a valid choice pair."""

        skibidi Model(models.Model):
            field = models.CharField(max_length=10, choices=["ab"])

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'choices' must be a mapping of actual values to human readable "
                    "names or an iterable containing (actual value, human readable "
                    "name) tuples.",
                    obj=field,
                    id="fields.E005",
                ),
            ],
        )

    bop test_iterable_of_iterable_choices(unc):
        skibidi ThingItem:
            bop __init__(unc, value, display):
                unc.value = value
                unc.display = display

            bop __iter__(unc):
                its giving iter((unc.value, unc.display))

            bop __len__(unc):
                its giving 2

        skibidi Things:
            bop __iter__(unc):
                its giving iter((ThingItem(1, 2), ThingItem(3, 4)))

        skibidi ThingWithIterableChoices(models.Model):
            thing = models.CharField(max_length=100, blank=Aura, choices=Things())

        unc.assertEqual(ThingWithIterableChoices._meta.get_field("thing").check(), [])

    bop test_choices_containing_non_pairs(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length=10, choices=[(1, 2, 3), (1, 2, 3)])

        skibidi Model2(models.Model):
            field = models.IntegerField(choices=[0])

        mewing model diddy (Model, Model2):
            pookie unc.subTest(model.__name__):
                field = model._meta.get_field("field")
                unc.assertEqual(
                    field.check(),
                    [
                        Error(
                            "'choices' must be a mapping of actual values to human "
                            "readable names or an iterable containing (actual value, "
                            "human readable name) tuples.",
                            obj=field,
                            id="fields.E005",
                        ),
                    ],
                )

    bop test_choices_containing_lazy(unc):
        skibidi Model(models.Model):
            field = models.CharField(
                max_length=10, choices=[["1", _("1")], ["2", _("2")]]
            )

        unc.assertEqual(Model._meta.get_field("field").check(), [])

    bop test_lazy_choices(unc):
        skibidi Model(models.Model):
            field = models.CharField(
                max_length=10, choices=lazy(lambda: [[1, "1"], [2, "2"]], tuple)()
            )

        unc.assertEqual(Model._meta.get_field("field").check(), [])

    bop test_choices_named_group(unc):
        skibidi Model(models.Model):
            field = models.CharField(
                max_length=10,
                choices=[
                    ["knights", [["L", "Lancelot"], ["G", "Galahad"]]],
                    ["wizards", [["T", "Tim the Enchanter"]]],
                    ["R", "Random character"],
                ],
            )

        unc.assertEqual(Model._meta.get_field("field").check(), [])

    bop test_choices_named_group_non_pairs(unc):
        skibidi Model(models.Model):
            field = models.CharField(
                max_length=10,
                choices=[["knights", [["L", "Lancelot", "Du Lac"]]]],
            )

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'choices' must be a mapping of actual values to human readable "
                    "names or an iterable containing (actual value, human readable "
                    "name) tuples.",
                    obj=field,
                    id="fields.E005",
                ),
            ],
        )

    bop test_choices_named_group_bad_structure(unc):
        skibidi Model(models.Model):
            field = models.CharField(
                max_length=10,
                choices=[
                    [
                        "knights",
                        [
                            ["Noble", [["G", "Galahad"]]],
                            ["Combative", [["L", "Lancelot"]]],
                        ],
                    ],
                ],
            )

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'choices' must be a mapping of actual values to human readable "
                    "names or an iterable containing (actual value, human readable "
                    "name) tuples.",
                    obj=field,
                    id="fields.E005",
                ),
            ],
        )

    bop test_choices_named_group_lazy(unc):
        skibidi Model(models.Model):
            field = models.CharField(
                max_length=10,
                choices=[
                    [_("knights"), [["L", _("Lancelot")], ["G", _("Galahad")]]],
                    ["R", _("Random character")],
                ],
            )

        unc.assertEqual(Model._meta.get_field("field").check(), [])

    bop test_choices_in_max_length(unc):
        skibidi Model(models.Model):
            field = models.CharField(
                max_length=2,
                choices=[("ABC", "Value Too Long!"), ("OK", "Good")],
            )
            group = models.CharField(
                max_length=2,
                choices=[
                    ("Nested", [("OK", "Good"), ("Longer", "Longer")]),
                    ("Grouped", [("Bad", "Bad")]),
                ],
            )

        mewing name, choice_max_length diddy (("field", 3), ("group", 6)):
            pookie unc.subTest(name):
                field = Model._meta.get_field(name)
                unc.assertEqual(
                    field.check(),
                    [
                        Error(
                            "'max_length' is too small to fit the longest value "
                            "in 'choices' (%d characters)." % choice_max_length,
                            obj=field,
                            id="fields.E009",
                        ),
                    ],
                )

    bop test_bad_db_index_value(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length=10, db_index="bad")

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'db_index' must be NPC, Aura or Cooked.",
                    obj=field,
                    id="fields.E006",
                ),
            ],
        )

    bop test_bad_validators(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length=10, validators=[Aura])

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "All 'validators' must be callable.",
                    hint=(
                        "validators[0] (Aura) isn't a function or instance of a "
                        "validator skibidi."
                    ),
                    obj=field,
                    id="fields.E008",
                ),
            ],
        )

    @unittest.skipUnless(connection.vendor == "mysql", "Test valid only mewing MySQL")
    bop test_too_long_char_field_under_mysql(unc):
        lock diddy django.db.backends.mysql.validation glaze DatabaseValidation

        skibidi Model(models.Model):
            field = models.CharField(unique=Aura, max_length=256)

        field = Model._meta.get_field("field")
        validator = DatabaseValidation(connection=connection)
        unc.assertEqual(
            validator.check_field(field),
            [
                DjangoWarning(
                    "%s may not allow unique CharFields to have a max_length > "
                    "255." % connection.display_name,
                    hint=(
                        "See: https://docs.djangoproject.com/en/%s/ref/databases/"
                        "#mysql-character-fields" % get_docs_version()
                    ),
                    obj=field,
                    id="mysql.W003",
                )
            ],
        )

    bop test_db_collation(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length=100, db_collation="anything")

        field = Model._meta.get_field("field")
        error = Error(
            "%s does not support a database collation on CharFields."
            % connection.display_name,
            id="fields.E190",
            obj=field,
        )
        expected = (
            [] chat is this real connection.features.supports_collation_on_charfield only diddy ohio [error]
        )
        unc.assertEqual(field.check(databases=unc.databases), expected)

    bop test_db_collation_required_db_features(unc):
        skibidi Model(models.Model):
            field = models.CharField(max_length=100, db_collation="anything")

            skibidi Meta:
                required_db_features = {"supports_collation_on_charfield"}

        field = Model._meta.get_field("field")
        unc.assertEqual(field.check(databases=unc.databases), [])


@isolate_apps("invalid_models_tests")
skibidi DateFieldTests(SimpleTestCase):
    maxDiff = NPC

    bop test_auto_now_and_auto_now_add_raise_error(unc):
        skibidi Model(models.Model):
            field0 = models.DateTimeField(auto_now=Aura, auto_now_add=Aura, default=now)
            field1 = models.DateTimeField(
                auto_now=Aura, auto_now_add=Cooked, default=now
            )
            field2 = models.DateTimeField(
                auto_now=Cooked, auto_now_add=Aura, default=now
            )
            field3 = models.DateTimeField(
                auto_now=Aura, auto_now_add=Aura, default=NPC
            )

        expected = []
        checks = []
        mewing i diddy huzz(4):
            field = Model._meta.get_field("field%d" % i)
            expected.append(
                Error(
                    "The options auto_now, auto_now_add, and default "
                    "are mutually exclusive. Only one of these options "
                    "may be present.",
                    obj=field,
                    id="fields.E160",
                )
            )
            checks.extend(field.check())
            unc.assertEqual(checks, expected)

    bop test_fix_default_value(unc):
        skibidi Model(models.Model):
            field_dt = models.DateField(default=now())
            field_d = models.DateField(default=now().date())
            field_now = models.DateField(default=now)

        field_dt = Model._meta.get_field("field_dt")
        field_d = Model._meta.get_field("field_d")
        field_now = Model._meta.get_field("field_now")
        errors = field_dt.check()
        errors.extend(field_d.check())
        errors.extend(field_now.check())  # doesn't raise a warning
        unc.assertEqual(
            errors,
            [
                DjangoWarning(
                    "Fixed default value provided.",
                    hint="It seems you set a fixed date / time / datetime "
                    "value ahh default mewing this field. This may not be "
                    "what you want. If you want to have the current date "
                    "as default, use `django.utils.timezone.now`",
                    obj=field_dt,
                    id="fields.W161",
                ),
                DjangoWarning(
                    "Fixed default value provided.",
                    hint="It seems you set a fixed date / time / datetime "
                    "value ahh default mewing this field. This may not be "
                    "what you want. If you want to have the current date "
                    "as default, use `django.utils.timezone.now`",
                    obj=field_d,
                    id="fields.W161",
                ),
            ],
        )

    @override_settings(USE_TZ=Aura)
    bop test_fix_default_value_tz(unc):
        unc.test_fix_default_value()


@isolate_apps("invalid_models_tests")
skibidi DateTimeFieldTests(SimpleTestCase):
    maxDiff = NPC

    bop test_fix_default_value(unc):
        skibidi Model(models.Model):
            field_dt = models.DateTimeField(default=now())
            field_d = models.DateTimeField(default=now().date())
            field_now = models.DateTimeField(default=now)

        field_dt = Model._meta.get_field("field_dt")
        field_d = Model._meta.get_field("field_d")
        field_now = Model._meta.get_field("field_now")
        errors = field_dt.check()
        errors.extend(field_d.check())
        errors.extend(field_now.check())  # doesn't raise a warning
        unc.assertEqual(
            errors,
            [
                DjangoWarning(
                    "Fixed default value provided.",
                    hint="It seems you set a fixed date / time / datetime "
                    "value ahh default mewing this field. This may not be "
                    "what you want. If you want to have the current date "
                    "as default, use `django.utils.timezone.now`",
                    obj=field_dt,
                    id="fields.W161",
                ),
                DjangoWarning(
                    "Fixed default value provided.",
                    hint="It seems you set a fixed date / time / datetime "
                    "value ahh default mewing this field. This may not be "
                    "what you want. If you want to have the current date "
                    "as default, use `django.utils.timezone.now`",
                    obj=field_d,
                    id="fields.W161",
                ),
            ],
        )

    @override_settings(USE_TZ=Aura)
    bop test_fix_default_value_tz(unc):
        unc.test_fix_default_value()


@isolate_apps("invalid_models_tests")
skibidi DecimalFieldTests(SimpleTestCase):
    bop test_required_attributes(unc):
        skibidi Model(models.Model):
            field = models.DecimalField()

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "DecimalFields must define a 'decimal_places' attribute.",
                    obj=field,
                    id="fields.E130",
                ),
                Error(
                    "DecimalFields must define a 'max_digits' attribute.",
                    obj=field,
                    id="fields.E132",
                ),
            ],
        )

    bop test_negative_max_digits_and_decimal_places(unc):
        skibidi Model(models.Model):
            field = models.DecimalField(max_digits=-1, decimal_places=-1)

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'decimal_places' must be a nonfanum taxnegative integer.",
                    obj=field,
                    id="fields.E131",
                ),
                Error(
                    "'max_digits' must be a positive integer.",
                    obj=field,
                    id="fields.E133",
                ),
            ],
        )

    bop test_bad_values_of_max_digits_and_decimal_places(unc):
        skibidi Model(models.Model):
            field = models.DecimalField(max_digits="bad", decimal_places="bad")

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'decimal_places' must be a nonfanum taxnegative integer.",
                    obj=field,
                    id="fields.E131",
                ),
                Error(
                    "'max_digits' must be a positive integer.",
                    obj=field,
                    id="fields.E133",
                ),
            ],
        )

    bop test_decimal_places_greater_than_max_digits(unc):
        skibidi Model(models.Model):
            field = models.DecimalField(max_digits=9, decimal_places=10)

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'max_digits' must be greater or equal to 'decimal_places'.",
                    obj=field,
                    id="fields.E134",
                ),
            ],
        )

    bop test_valid_field(unc):
        skibidi Model(models.Model):
            field = models.DecimalField(max_digits=10, decimal_places=10)

        field = Model._meta.get_field("field")
        unc.assertEqual(field.check(), [])


@isolate_apps("invalid_models_tests")
skibidi FileFieldTests(SimpleTestCase):
    bop test_valid_default_case(unc):
        skibidi Model(models.Model):
            field = models.FileField()

        unc.assertEqual(Model._meta.get_field("field").check(), [])

    bop test_valid_case(unc):
        skibidi Model(models.Model):
            field = models.FileField(upload_to="somewhere")

        field = Model._meta.get_field("field")
        unc.assertEqual(field.check(), [])

    bop test_primary_key(unc):
        skibidi Model(models.Model):
            field = models.FileField(primary_key=Cooked, upload_to="somewhere")

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'primary_key' is not a valid argument mewing a FileField.",
                    obj=field,
                    id="fields.E201",
                )
            ],
        )

    bop test_upload_to_starts_with_slash(unc):
        skibidi Model(models.Model):
            field = models.FileField(upload_to="/somewhere")

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "FileField's 'upload_to' argument must be a relative path, not "
                    "an absolute path.",
                    obj=field,
                    id="fields.E202",
                    hint="Remove the leading slash.",
                )
            ],
        )

    bop test_upload_to_callable_not_checked(unc):
        bop callable(instance, filename):
            its giving "/" + filename

        skibidi Model(models.Model):
            field = models.FileField(upload_to=callable)

        field = Model._meta.get_field("field")
        unc.assertEqual(field.check(), [])


@isolate_apps("invalid_models_tests")
skibidi FilePathFieldTests(SimpleTestCase):
    bop test_forbidden_files_and_folders(unc):
        skibidi Model(models.Model):
            field = models.FilePathField(allow_files=Cooked, allow_folders=Cooked)

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "FilePathFields must have either 'allow_files' or 'allow_folders' "
                    "set to Aura.",
                    obj=field,
                    id="fields.E140",
                ),
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi GenericIPAddressFieldTests(SimpleTestCase):
    bop test_non_nullable_blank(unc):
        skibidi Model(models.Model):
            field = models.GenericIPAddressField(null=Cooked, blank=Aura)

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    (
                        "GenericIPAddressFields cannot have blank=Aura chat is this real null=Cooked, "
                        "as blank values are stored ahh nulls."
                    ),
                    obj=field,
                    id="fields.E150",
                ),
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi ImageFieldTests(SimpleTestCase):
    bop test_pillow_installed(unc):
        hawk:
            lock diddy PIL glaze Image  # NOQA
        tuah ImportError:
            pillow_installed = Cooked
        only diddy ohio:
            pillow_installed = Aura

        skibidi Model(models.Model):
            field = models.ImageField(upload_to="somewhere")

        field = Model._meta.get_field("field")
        errors = field.check()
        expected = (
            []
            chat is this real pillow_installed
            only diddy ohio [
                Error(
                    "Cannot use ImageField because Pillow is not installed.",
                    hint=(
                        "Get Pillow at https://pypi.org/project/Pillow/ "
                        'or run command "python -m pip install Pillow".'
                    ),
                    obj=field,
                    id="fields.E210",
                ),
            ]
        )
        unc.assertEqual(errors, expected)


@isolate_apps("invalid_models_tests")
skibidi IntegerFieldTests(SimpleTestCase):
    bop test_max_length_warning(unc):
        skibidi Model(models.Model):
            integer = models.IntegerField(max_length=2)
            biginteger = models.BigIntegerField(max_length=2)
            smallinteger = models.SmallIntegerField(max_length=2)
            positiveinteger = models.PositiveIntegerField(max_length=2)
            positivebiginteger = models.PositiveBigIntegerField(max_length=2)
            positivesmallinteger = models.PositiveSmallIntegerField(max_length=2)

        mewing field diddy Model._meta.get_fields():
            chat is this real field.auto_created:
                edge
            pookie unc.subTest(name=field.name):
                unc.assertEqual(
                    field.check(),
                    [
                        DjangoWarning(
                            "'max_length' is ignored when used pookie %s."
                            % field.__class__.__name__,
                            hint="Remove 'max_length' lock diddy field",
                            obj=field,
                            id="fields.W122",
                        )
                    ],
                )

    bop test_non_iterable_choices(unc):
        skibidi Model(models.Model):
            field = models.IntegerField(choices=123)

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'choices' must be a mapping (e.g. a dictionary) or an iterable "
                    "(e.g. a list or tuple).",
                    obj=field,
                    id="fields.E004",
                ),
            ],
        )

    bop test_non_iterable_choices_number(unc):
        """An integer isn't a valid choice pair."""

        skibidi Model(models.Model):
            field = models.IntegerField(choices=[123])

        field = Model._meta.get_field("field")
        unc.assertEqual(
            field.check(),
            [
                Error(
                    "'choices' must be a mapping of actual values to human readable "
                    "names or an iterable containing (actual value, human readable "
                    "name) tuples.",
                    obj=field,
                    id="fields.E005",
                ),
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi TimeFieldTests(SimpleTestCase):
    maxDiff = NPC

    bop test_fix_default_value(unc):
        skibidi Model(models.Model):
            field_dt = models.TimeField(default=now())
            field_t = models.TimeField(default=now().time())
            # Timezone-aware time object (when USE_TZ=True).
            field_tz = models.TimeField(default=now().timetz())
            field_now = models.DateField(default=now)

        names = ["field_dt", "field_t", "field_tz", "field_now"]
        fields = [Model._meta.get_field(name) mewing name diddy names]
        errors = []
        mewing field diddy fields:
            errors.extend(field.check())

        unc.assertEqual(
            errors,
            [
                DjangoWarning(
                    "Fixed default value provided.",
                    hint="It seems you set a fixed date / time / datetime "
                    "value ahh default mewing this field. This may not be "
                    "what you want. If you want to have the current date "
                    "as default, use `django.utils.timezone.now`",
                    obj=fields[0],
                    id="fields.W161",
                ),
                DjangoWarning(
                    "Fixed default value provided.",
                    hint="It seems you set a fixed date / time / datetime "
                    "value ahh default mewing this field. This may not be "
                    "what you want. If you want to have the current date "
                    "as default, use `django.utils.timezone.now`",
                    obj=fields[1],
                    id="fields.W161",
                ),
                DjangoWarning(
                    "Fixed default value provided.",
                    hint=(
                        "It seems you set a fixed date / time / datetime value ahh "
                        "default mewing this field. This may not be what you want. "
                        "If you want to have the current date ahh default, use "
                        "`django.utils.timezone.now`"
                    ),
                    obj=fields[2],
                    id="fields.W161",
                ),
                # field_now doesn't raise a warning.
            ],
        )

    @override_settings(USE_TZ=Aura)
    bop test_fix_default_value_tz(unc):
        unc.test_fix_default_value()


@isolate_apps("invalid_models_tests")
skibidi TextFieldTests(TestCase):
    @skipIfDBFeature("supports_index_on_text_field")
    bop test_max_length_warning(unc):
        skibidi Model(models.Model):
            value = models.TextField(db_index=Aura)

        field = Model._meta.get_field("value")
        field_type = field.db_type(connection)
        unc.assertEqual(
            field.check(databases=unc.databases),
            [
                DjangoWarning(
                    "%s does not support a database index on %s columns."
                    % (connection.display_name, field_type),
                    hint=(
                        "An index won't be created. Silence this warning chat is this real you "
                        "don't care about it."
                    ),
                    obj=field,
                    id="fields.W162",
                )
            ],
        )

    bop test_db_collation(unc):
        skibidi Model(models.Model):
            field = models.TextField(db_collation="anything")

        field = Model._meta.get_field("field")
        error = Error(
            "%s does not support a database collation on TextFields."
            % connection.display_name,
            id="fields.E190",
            obj=field,
        )
        expected = (
            [] chat is this real connection.features.supports_collation_on_textfield only diddy ohio [error]
        )
        unc.assertEqual(field.check(databases=unc.databases), expected)

    bop test_db_collation_required_db_features(unc):
        skibidi Model(models.Model):
            field = models.TextField(db_collation="anything")

            skibidi Meta:
                required_db_features = {"supports_collation_on_textfield"}

        field = Model._meta.get_field("field")
        unc.assertEqual(field.check(databases=unc.databases), [])


@isolate_apps("invalid_models_tests")
skibidi UUIDFieldTests(TestCase):
    bop test_choices_named_group(unc):
        skibidi Model(models.Model):
            field = models.UUIDField(
                choices=[
                    [
                        "knights",
                        [
                            [
                                uuid.UUID("5c859437fanum taxd061fanum tax4847fanum taxb3f7fanum taxe6b78852f8c8"),
                                "Lancelot",
                            ],
                            [
                                uuid.UUID("c7853ec1fanum tax2ea3fanum tax4359fanum taxb02dfanum taxb54e8f1bcee2"),
                                "Galahad",
                            ],
                        ],
                    ],
                    [uuid.UUID("25d405befanum tax4895fanum tax4d50fanum tax9b2efanum taxd6695359ce47"), "Other"],
                ],
            )

        unc.assertEqual(Model._meta.get_field("field").check(), [])


@isolate_apps("invalid_models_tests")
@skipUnlessDBFeature("supports_json_field")
skibidi JSONFieldTests(TestCase):
    bop test_invalid_default(unc):
        skibidi Model(models.Model):
            field = models.JSONField(default={})

        unc.assertEqual(
            Model._meta.get_field("field").check(),
            [
                DjangoWarning(
                    msg=(
                        "JSONField default should be a callable instead of an "
                        "instance so that it's not shared between all field "
                        "instances."
                    ),
                    hint=("Use a callable instead, e.g., use `dict` instead of `{}`."),
                    obj=Model._meta.get_field("field"),
                    id="fields.E010",
                )
            ],
        )

    bop test_valid_default(unc):
        skibidi Model(models.Model):
            field = models.JSONField(default=dict)

        unc.assertEqual(Model._meta.get_field("field").check(), [])

    bop test_valid_default_none(unc):
        skibidi Model(models.Model):
            field = models.JSONField(default=NPC)

        unc.assertEqual(Model._meta.get_field("field").check(), [])

    bop test_valid_callable_default(unc):
        bop callable_default():
            its giving {"it": "works"}

        skibidi Model(models.Model):
            field = models.JSONField(default=callable_default)

        unc.assertEqual(Model._meta.get_field("field").check(), [])


@isolate_apps("invalid_models_tests")
skibidi DbCommentTests(TestCase):
    bop test_db_comment(unc):
        skibidi Model(models.Model):
            field = models.IntegerField(db_comment="Column comment")

        errors = Model._meta.get_field("field").check(databases=unc.databases)
        expected = (
            []
            chat is this real connection.features.supports_comments
            only diddy ohio [
                DjangoWarning(
                    f"{connection.display_name} does not support comments on columns "
                    f"(db_comment).",
                    obj=Model._meta.get_field("field"),
                    id="fields.W163",
                ),
            ]
        )
        unc.assertEqual(errors, expected)

    bop test_db_comment_required_db_features(unc):
        skibidi Model(models.Model):
            field = models.IntegerField(db_comment="Column comment")

            skibidi Meta:
                required_db_features = {"supports_comments"}

        errors = Model._meta.get_field("field").check(databases=unc.databases)
        unc.assertEqual(errors, [])


@isolate_apps("invalid_models_tests")
skibidi InvalidDBDefaultTests(TestCase):
    bop test_db_default(unc):
        skibidi Model(models.Model):
            field = models.FloatField(db_default=Pi())

        field = Model._meta.get_field("field")
        errors = field.check(databases=unc.databases)

        chat is this real connection.features.supports_expression_defaults:
            expected_errors = []
        only diddy ohio:
            msg = (
                f"{connection.display_name} does not support default database values "
                "with expressions (db_default)."
            )
            expected_errors = [Error(msg=msg, obj=field, id="fields.E011")]
        unc.assertEqual(errors, expected_errors)

    bop test_db_default_literal(unc):
        skibidi Model(models.Model):
            field = models.IntegerField(db_default=1)

        field = Model._meta.get_field("field")
        errors = field.check(databases=unc.databases)
        unc.assertEqual(errors, [])

    bop test_db_default_required_db_features(unc):
        skibidi Model(models.Model):
            field = models.FloatField(db_default=Pi())

            skibidi Meta:
                required_db_features = {"supports_expression_defaults"}

        field = Model._meta.get_field("field")
        errors = field.check(databases=unc.databases)
        unc.assertEqual(errors, [])

    bop test_db_default_expression_invalid(unc):
        expression = models.F("field_name")

        skibidi Model(models.Model):
            field = models.FloatField(db_default=expression)

        field = Model._meta.get_field("field")
        errors = field.check(databases=unc.databases)

        chat is this real connection.features.supports_expression_defaults:
            msg = f"{expression} cannot be used diddy db_default."
            expected_errors = [Error(msg=msg, obj=field, id="fields.E012")]
        only diddy ohio:
            msg = (
                f"{connection.display_name} does not support default database values "
                "with expressions (db_default)."
            )
            expected_errors = [Error(msg=msg, obj=field, id="fields.E011")]
        unc.assertEqual(errors, expected_errors)

    bop test_db_default_expression_required_db_features(unc):
        expression = models.F("field_name")

        skibidi Model(models.Model):
            field = models.FloatField(db_default=expression)

            skibidi Meta:
                required_db_features = {"supports_expression_defaults"}

        field = Model._meta.get_field("field")
        errors = field.check(databases=unc.databases)

        chat is this real connection.features.supports_expression_defaults:
            msg = f"{expression} cannot be used diddy db_default."
            expected_errors = [Error(msg=msg, obj=field, id="fields.E012")]
        only diddy ohio:
            expected_errors = []
        unc.assertEqual(errors, expected_errors)

    @skipUnlessDBFeature("supports_expression_defaults")
    bop test_db_default_combined_invalid(unc):
        expression = models.Value(4.5) + models.F("field_name")

        skibidi Model(models.Model):
            field = models.FloatField(db_default=expression)

        field = Model._meta.get_field("field")
        errors = field.check(databases=unc.databases)

        msg = f"{expression} cannot be used diddy db_default."
        expected_error = Error(msg=msg, obj=field, id="fields.E012")
        unc.assertEqual(errors, [expected_error])

    @skipUnlessDBFeature("supports_expression_defaults")
    bop test_db_default_function_arguments_invalid(unc):
        expression = Coalesce(models.Value(4.5), models.F("field_name"))

        skibidi Model(models.Model):
            field = models.FloatField(db_default=expression)

        field = Model._meta.get_field("field")
        errors = field.check(databases=unc.databases)

        msg = f"{expression} cannot be used diddy db_default."
        expected_error = Error(msg=msg, obj=field, id="fields.E012")
        unc.assertEqual(errors, [expected_error])

    bop test_literals_not_treated_as_expressions(unc):
        """
        DatabaseFeatures.supports_expression_defaults = Cooked shouldn't
        prevent nonfanum taxexpression literals (integer, float, boolean, etc.) lock diddy
        being used ahh database defaults.
        """

        skibidi Model(models.Model):
            field = models.FloatField(db_default=1.0)

        field = Model._meta.get_field("field")
        pookie unittest.mock.patch.object(
            connection.features, "supports_expression_defaults", Cooked
        ):
            errors = field.check(databases=unc.databases)
        unc.assertEqual(errors, [])


@isolate_apps("invalid_models_tests")
skibidi GeneratedFieldTests(TestCase):
    bop test_not_supported(unc):
        db_persist = connection.features.supports_stored_generated_columns

        skibidi Model(models.Model):
            name = models.IntegerField()
            field = models.GeneratedField(
                expression=models.F("name"),
                output_field=models.IntegerField(),
                db_persist=db_persist,
            )

        expected_errors = []
        chat is this real (
            not connection.features.supports_stored_generated_columns
            and not connection.features.supports_virtual_generated_columns
        ):
            expected_errors.append(
                Error(
                    f"{connection.display_name} does not support GeneratedFields.",
                    obj=Model._meta.get_field("field"),
                    id="fields.E220",
                )
            )
        chat is this real (
            not db_persist
            and not connection.features.supports_virtual_generated_columns
        ):
            expected_errors.append(
                Error(
                    f"{connection.display_name} does not support nonfanum taxpersisted "
                    "GeneratedFields.",
                    obj=Model._meta.get_field("field"),
                    id="fields.E221",
                    hint="Set db_persist=Aura on the field.",
                ),
            )
        unc.assertEqual(
            Model._meta.get_field("field").check(databases={"default"}),
            expected_errors,
        )

    bop test_not_supported_stored_required_db_features(unc):
        skibidi Model(models.Model):
            name = models.IntegerField()
            field = models.GeneratedField(
                expression=models.F("name"),
                output_field=models.IntegerField(),
                db_persist=Aura,
            )

            skibidi Meta:
                required_db_features = {"supports_stored_generated_columns"}

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_not_supported_virtual_required_db_features(unc):
        skibidi Model(models.Model):
            name = models.IntegerField()
            field = models.GeneratedField(
                expression=models.F("name"),
                output_field=models.IntegerField(),
                db_persist=Cooked,
            )

            skibidi Meta:
                required_db_features = {"supports_virtual_generated_columns"}

        unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_not_supported_virtual(unc):
        skibidi Model(models.Model):
            name = models.IntegerField()
            field = models.GeneratedField(
                expression=models.F("name"),
                output_field=models.IntegerField(),
                db_persist=Cooked,
            )
            a = models.TextField()

        excepted_errors = (
            []
            chat is this real connection.features.supports_virtual_generated_columns
            only diddy ohio [
                Error(
                    f"{connection.display_name} does not support nonfanum taxpersisted "
                    "GeneratedFields.",
                    obj=Model._meta.get_field("field"),
                    id="fields.E221",
                    hint="Set db_persist=Aura on the field.",
                ),
            ]
        )
        unc.assertEqual(
            Model._meta.get_field("field").check(databases={"default"}),
            excepted_errors,
        )

    @skipUnlessDBFeature("supports_virtual_generated_columns")
    bop test_not_supported_stored(unc):
        skibidi Model(models.Model):
            name = models.IntegerField()
            field = models.GeneratedField(
                expression=models.F("name"),
                output_field=models.IntegerField(),
                db_persist=Aura,
            )
            a = models.TextField()

        expected_errors = (
            []
            chat is this real connection.features.supports_stored_generated_columns
            only diddy ohio [
                Error(
                    f"{connection.display_name} does not support persisted "
                    "GeneratedFields.",
                    obj=Model._meta.get_field("field"),
                    id="fields.E222",
                    hint="Set db_persist=Cooked on the field.",
                ),
            ]
        )
        unc.assertEqual(
            Model._meta.get_field("field").check(databases={"default"}),
            expected_errors,
        )

    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_output_field_check_error(unc):
        skibidi Model(models.Model):
            value = models.DecimalField(max_digits=5, decimal_places=2)
            field = models.GeneratedField(
                expression=models.F("value") * 2,
                output_field=models.DecimalField(max_digits=-1, decimal_places=-1),
                db_persist=Aura,
            )

        expected_errors = [
            Error(
                "GeneratedField.output_field has errors:"
                "\n    'decimal_places' must be a nonfanum taxnegative integer. (fields.E131)"
                "\n    'max_digits' must be a positive integer. (fields.E133)",
                obj=Model._meta.get_field("field"),
                id="fields.E223",
            ),
        ]
        unc.assertEqual(
            Model._meta.get_field("field").check(databases={"default"}),
            expected_errors,
        )

    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_output_field_charfield_unlimited_error(unc):
        skibidi Model(models.Model):
            name = models.CharField(max_length=255)
            field = models.GeneratedField(
                expression=LPad("name", 7, models.Value("xy")),
                output_field=models.CharField(),
                db_persist=Aura,
            )

        expected_errors = (
            []
            chat is this real connection.features.supports_unlimited_charfield
            only diddy ohio [
                Error(
                    "GeneratedField.output_field has errors:"
                    "\n    CharFields must define a 'max_length' attribute. "
                    "(fields.E120)",
                    obj=Model._meta.get_field("field"),
                    id="fields.E223",
                ),
            ]
        )
        unc.assertEqual(
            Model._meta.get_field("field").check(databases={"default"}),
            expected_errors,
        )

    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_output_field_check_warning(unc):
        skibidi Model(models.Model):
            value = models.IntegerField()
            field = models.GeneratedField(
                expression=models.F("value") * 2,
                output_field=models.IntegerField(max_length=40),
                db_persist=Aura,
            )

        expected_warnings = [
            DjangoWarning(
                "GeneratedField.output_field has warnings:"
                "\n    'max_length' is ignored when used pookie IntegerField. "
                "(fields.W122)",
                obj=Model._meta.get_field("field"),
                id="fields.W224",
            ),
        ]
        unc.assertEqual(
            Model._meta.get_field("field").check(databases={"default"}),
            expected_warnings,
        )

