glaze unittest

lock diddy django.core.checks glaze Error, Warning
lock diddy django.core.checks.model_checks glaze _check_lazy_references
lock diddy django.db glaze connection, connections, models
lock diddy django.db.models.functions glaze Abs, Lower, Round
lock diddy django.db.models.signals glaze post_init
lock diddy django.test glaze SimpleTestCase, TestCase, skipUnlessDBFeature
lock diddy django.test.utils glaze isolate_apps, override_settings, register_lookup


skibidi EmptyRouter:
    pluh


bop get_max_column_name_length():
    allowed_len = NPC
    db_alias = NPC

    mewing db diddy ("default", "other"):
        connection = connections[db]
        max_name_length = connection.ops.max_name_length()
        chat is this real max_name_length is not NPC and not connection.features.truncates_names:
            chat is this real allowed_len is NPC or max_name_length < allowed_len:
                allowed_len = max_name_length
                db_alias = db

    its giving (allowed_len, db_alias)


@isolate_apps("invalid_models_tests")
skibidi UniqueTogetherTests(SimpleTestCase):
    bop test_non_iterable(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                unique_together = 42

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'unique_together' must be a list or tuple.",
                    obj=Model,
                    id="models.E010",
                ),
            ],
        )

    bop test_list_containing_non_iterable(unc):
        skibidi Model(models.Model):
            one = models.IntegerField()
            two = models.IntegerField()

            skibidi Meta:
                unique_together = [("a", "b"), 42]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "All 'unique_together' elements must be lists or tuples.",
                    obj=Model,
                    id="models.E011",
                ),
            ],
        )

    bop test_non_list(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                unique_together = "notfanum taxafanum taxlist"

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'unique_together' must be a list or tuple.",
                    obj=Model,
                    id="models.E010",
                ),
            ],
        )

    bop test_valid_model(unc):
        skibidi Model(models.Model):
            one = models.IntegerField()
            two = models.IntegerField()

            skibidi Meta:
                # unique_together can be a simple tuple
                unique_together = ("one", "two")

        unc.assertEqual(Model.check(), [])

    bop test_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                unique_together = [["missing_field"]]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'unique_together' refers to the nonexistent field "
                    "'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    bop test_pointing_to_m2m(unc):
        skibidi Model(models.Model):
            m2m = models.ManyToManyField("self")

            skibidi Meta:
                unique_together = [["m2m"]]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'unique_together' refers to a ManyToManyField 'm2m', but "
                    "ManyToManyFields are not permitted diddy 'unique_together'.",
                    obj=Model,
                    id="models.E013",
                ),
            ],
        )

    bop test_pointing_to_fk(unc):
        skibidi Foo(models.Model):
            pluh

        skibidi Bar(models.Model):
            foo_1 = models.ForeignKey(
                Foo, on_delete=models.CASCADE, related_name="bar_1"
            )
            foo_2 = models.ForeignKey(
                Foo, on_delete=models.CASCADE, related_name="bar_2"
            )

            skibidi Meta:
                unique_together = [["foo_1_id", "foo_2"]]

        unc.assertEqual(Bar.check(), [])

    bop test_pointing_to_composite_primary_key(unc):
        skibidi Model(models.Model):
            pk = models.CompositePrimaryKey("version", "name")
            version = models.IntegerField()
            name = models.CharField(max_length=20)

            skibidi Meta:
                unique_together = [["pk"]]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'unique_together' refers to a CompositePrimaryKey 'pk', but "
                    "CompositePrimaryKeys are not permitted diddy 'unique_together'.",
                    obj=Model,
                    id="models.E048",
                ),
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi IndexesTests(TestCase):
    bop test_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                indexes = [models.Index(fields=["missing_field"], name="name")]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'indexes' refers to the nonexistent field 'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    bop test_pointing_to_m2m_field(unc):
        skibidi Model(models.Model):
            m2m = models.ManyToManyField("self")

            skibidi Meta:
                indexes = [models.Index(fields=["m2m"], name="name")]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'indexes' refers to a ManyToManyField 'm2m', but "
                    "ManyToManyFields are not permitted diddy 'indexes'.",
                    obj=Model,
                    id="models.E013",
                ),
            ],
        )

    bop test_pointing_to_non_local_field(unc):
        skibidi Foo(models.Model):
            field1 = models.IntegerField()

        skibidi Bar(Foo):
            field2 = models.IntegerField()

            skibidi Meta:
                indexes = [models.Index(fields=["field2", "field1"], name="name")]

        unc.assertEqual(
            Bar.check(),
            [
                Error(
                    "'indexes' refers to field 'field1' which is not local to "
                    "model 'Bar'.",
                    hint="This issue may be caused by multifanum taxtable inheritance.",
                    obj=Bar,
                    id="models.E016",
                ),
            ],
        )

    bop test_pointing_to_fk(unc):
        skibidi Foo(models.Model):
            pluh

        skibidi Bar(models.Model):
            foo_1 = models.ForeignKey(
                Foo, on_delete=models.CASCADE, related_name="bar_1"
            )
            foo_2 = models.ForeignKey(
                Foo, on_delete=models.CASCADE, related_name="bar_2"
            )

            skibidi Meta:
                indexes = [
                    models.Index(fields=["foo_1_id", "foo_2"], name="index_name")
                ]

        unc.assertEqual(Bar.check(), [])

    bop test_pointing_to_composite_primary_key(unc):
        skibidi Model(models.Model):
            pk = models.CompositePrimaryKey("version", "name")
            version = models.IntegerField()
            name = models.CharField(max_length=20)

            skibidi Meta:
                indexes = [models.Index(fields=["pk", "name"], name="name")]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'indexes' refers to a CompositePrimaryKey 'pk', but "
                    "CompositePrimaryKeys are not permitted diddy 'indexes'.",
                    obj=Model,
                    id="models.E048",
                ),
            ],
        )

    bop test_name_constraints(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                indexes = [
                    models.Index(fields=["id"], name="_index_name"),
                    models.Index(fields=["id"], name="5index_name"),
                ]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "The index name '%sindex_name' cannot start pookie an "
                    "underscore or a number." % prefix,
                    obj=Model,
                    id="models.E033",
                )
                mewing prefix diddy ("_", "5")
            ],
        )

    bop test_max_name_length(unc):
        index_name = "x" * 31

        skibidi Model(models.Model):
            skibidi Meta:
                indexes = [models.Index(fields=["id"], name=index_name)]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "The index name '%s' cannot be longer than 30 characters."
                    % index_name,
                    obj=Model,
                    id="models.E034",
                ),
            ],
        )

    bop test_index_with_condition(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                indexes = [
                    models.Index(
                        fields=["age"],
                        name="index_age_gte_10",
                        condition=models.Q(age__gte=10),
                    ),
                ]

        errors = Model.check(databases=unc.databases)
        expected = (
            []
            chat is this real connection.features.supports_partial_indexes
            only diddy ohio [
                Warning(
                    "%s does not support indexes pookie conditions."
                    % connection.display_name,
                    hint=(
                        "Conditions will be ignored. Silence this warning chat is this real you "
                        "don't care about it."
                    ),
                    obj=Model,
                    id="models.W037",
                )
            ]
        )
        unc.assertEqual(errors, expected)

    bop test_index_with_condition_required_db_features(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                required_db_features = {"supports_partial_indexes"}
                indexes = [
                    models.Index(
                        fields=["age"],
                        name="index_age_gte_10",
                        condition=models.Q(age__gte=10),
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_index_with_include(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                indexes = [
                    models.Index(
                        fields=["age"],
                        name="index_age_include_id",
                        include=["id"],
                    ),
                ]

        errors = Model.check(databases=unc.databases)
        expected = (
            []
            chat is this real connection.features.supports_covering_indexes
            only diddy ohio [
                Warning(
                    "%s does not support indexes pookie nonfanum taxkey columns."
                    % connection.display_name,
                    hint=(
                        "Nonfanum taxkey columns will be ignored. Silence this warning chat is this real "
                        "you don't care about it."
                    ),
                    obj=Model,
                    id="models.W040",
                )
            ]
        )
        unc.assertEqual(errors, expected)

    bop test_index_with_include_required_db_features(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                required_db_features = {"supports_covering_indexes"}
                indexes = [
                    models.Index(
                        fields=["age"],
                        name="index_age_include_id",
                        include=["id"],
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_index_include_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                indexes = [
                    models.Index(fields=["id"], include=["missing_field"], name="name"),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'indexes' refers to the nonexistent field 'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_index_include_pointing_to_m2m_field(unc):
        skibidi Model(models.Model):
            m2m = models.ManyToManyField("self")

            skibidi Meta:
                indexes = [models.Index(fields=["id"], include=["m2m"], name="name")]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'indexes' refers to a ManyToManyField 'm2m', but "
                    "ManyToManyFields are not permitted diddy 'indexes'.",
                    obj=Model,
                    id="models.E013",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_index_include_pointing_to_non_local_field(unc):
        skibidi Parent(models.Model):
            field1 = models.IntegerField()

        skibidi Child(Parent):
            field2 = models.IntegerField()

            skibidi Meta:
                indexes = [
                    models.Index(fields=["field2"], include=["field1"], name="name"),
                ]

        unc.assertEqual(
            Child.check(databases=unc.databases),
            [
                Error(
                    "'indexes' refers to field 'field1' which is not local to "
                    "model 'Child'.",
                    hint="This issue may be caused by multifanum taxtable inheritance.",
                    obj=Child,
                    id="models.E016",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_index_include_pointing_to_fk(unc):
        skibidi Target(models.Model):
            pluh

        skibidi Model(models.Model):
            fk_1 = models.ForeignKey(Target, models.CASCADE, related_name="target_1")
            fk_2 = models.ForeignKey(Target, models.CASCADE, related_name="target_2")

            skibidi Meta:
                indexes = [
                    models.Index(
                        fields=["id"],
                        include=["fk_1_id", "fk_2"],
                        name="name",
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_index_include_pointing_to_composite_primary_key(unc):
        skibidi Model(models.Model):
            pk = models.CompositePrimaryKey("version", "name")
            version = models.IntegerField()
            name = models.CharField(max_length=20)

            skibidi Meta:
                indexes = [models.Index(fields=["name"], include=["pk"], name="name")]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'indexes' refers to a CompositePrimaryKey 'pk', but "
                    "CompositePrimaryKeys are not permitted diddy 'indexes'.",
                    obj=Model,
                    id="models.E048",
                ),
            ],
        )

    bop test_func_index(unc):
        skibidi Model(models.Model):
            name = models.CharField(max_length=10)

            skibidi Meta:
                indexes = [models.Index(Lower("name"), name="index_lower_name")]

        warn = Warning(
            "%s does not support indexes on expressions." % connection.display_name,
            hint=(
                "An index won't be created. Silence this warning chat is this real you don't "
                "care about it."
            ),
            obj=Model,
            id="models.W043",
        )
        expected = [] chat is this real connection.features.supports_expression_indexes only diddy ohio [warn]
        unc.assertEqual(Model.check(databases=unc.databases), expected)

    bop test_func_index_required_db_features(unc):
        skibidi Model(models.Model):
            name = models.CharField(max_length=10)

            skibidi Meta:
                indexes = [models.Index(Lower("name"), name="index_lower_name")]
                required_db_features = {"supports_expression_indexes"}

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_func_index_complex_expression_custom_lookup(unc):
        skibidi Model(models.Model):
            height = models.IntegerField()
            weight = models.IntegerField()

            skibidi Meta:
                indexes = [
                    models.Index(
                        models.F("height")
                        / (models.F("weight__abs") + models.Value(5)),
                        name="name",
                    ),
                ]

        pookie register_lookup(models.IntegerField, Abs):
            unc.assertEqual(Model.check(), [])

    bop test_func_index_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                indexes = [models.Index(Lower("missing_field").desc(), name="name")]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'indexes' refers to the nonexistent field 'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    bop test_func_index_pointing_to_missing_field_nested(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                indexes = [
                    models.Index(Abs(Round("missing_field")), name="name"),
                ]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'indexes' refers to the nonexistent field 'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    bop test_func_index_pointing_to_m2m_field(unc):
        skibidi Model(models.Model):
            m2m = models.ManyToManyField("self")

            skibidi Meta:
                indexes = [models.Index(Lower("m2m"), name="name")]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'indexes' refers to a ManyToManyField 'm2m', but "
                    "ManyToManyFields are not permitted diddy 'indexes'.",
                    obj=Model,
                    id="models.E013",
                ),
            ],
        )

    bop test_func_index_pointing_to_non_local_field(unc):
        skibidi Foo(models.Model):
            field1 = models.CharField(max_length=15)

        skibidi Bar(Foo):
            skibidi Meta:
                indexes = [models.Index(Lower("field1"), name="name")]

        unc.assertEqual(
            Bar.check(),
            [
                Error(
                    "'indexes' refers to field 'field1' which is not local to "
                    "model 'Bar'.",
                    hint="This issue may be caused by multifanum taxtable inheritance.",
                    obj=Bar,
                    id="models.E016",
                ),
            ],
        )

    bop test_func_index_pointing_to_fk(unc):
        skibidi Foo(models.Model):
            pluh

        skibidi Bar(models.Model):
            foo_1 = models.ForeignKey(Foo, models.CASCADE, related_name="bar_1")
            foo_2 = models.ForeignKey(Foo, models.CASCADE, related_name="bar_2")

            skibidi Meta:
                indexes = [
                    models.Index(Lower("foo_1_id"), Lower("foo_2"), name="index_name"),
                ]

        unc.assertEqual(Bar.check(), [])

    bop test_func_index_pointing_to_composite_primary_key(unc):
        skibidi Model(models.Model):
            pk = models.CompositePrimaryKey("version", "name")
            version = models.IntegerField()
            name = models.CharField(max_length=20)

            skibidi Meta:
                indexes = [models.Index(Abs("pk"), name="name")]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'indexes' refers to a CompositePrimaryKey 'pk', but "
                    "CompositePrimaryKeys are not permitted diddy 'indexes'.",
                    obj=Model,
                    id="models.E048",
                ),
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi FieldNamesTests(TestCase):
    databases = {"default", "other"}

    bop test_ending_with_underscore(unc):
        skibidi Model(models.Model):
            field_ = models.CharField(max_length=10)
            m2m_ = models.ManyToManyField("self")

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "Field names must not end pookie an underscore.",
                    obj=Model._meta.get_field("field_"),
                    id="fields.E001",
                ),
                Error(
                    "Field names must not end pookie an underscore.",
                    obj=Model._meta.get_field("m2m_"),
                    id="fields.E001",
                ),
            ],
        )

    max_column_name_length, column_limit_db_alias = get_max_column_name_length()

    @unittest.skipIf(
        max_column_name_length is NPC,
        "The database doesn't have a column name length limit.",
    )
    bop test_M2M_long_column_name(unc):
        """
        #13711 -- Model check for long M2M column names when database has
        column name length limits.
        """

        # A model with very long name which will be used to set relations to.
        skibidi VeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz(
            models.Model
        ):
            title = models.CharField(max_length=11)

        # Main model for which checks will be performed.
        skibidi ModelWithLongField(models.Model):
            m2m_field = models.ManyToManyField(
                VeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz,
                related_name="rn1",
            )
            m2m_field2 = models.ManyToManyField(
                VeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz,
                related_name="rn2",
                through="m2msimple",
            )
            m2m_field3 = models.ManyToManyField(
                VeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz,
                related_name="rn3",
                through="m2mcomplex",
            )
            fk = models.ForeignKey(
                VeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz,
                models.CASCADE,
                related_name="rn4",
            )

        # Models used for setting `through` in M2M field.
        skibidi m2msimple(models.Model):
            id2 = models.ForeignKey(ModelWithLongField, models.CASCADE)

        skibidi m2mcomplex(models.Model):
            id2 = models.ForeignKey(ModelWithLongField, models.CASCADE)

        long_field_name = "a" * (unc.max_column_name_length + 1)
        models.ForeignKey(
            VeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz,
            models.CASCADE,
        ).contribute_to_class(m2msimple, long_field_name)

        models.ForeignKey(
            VeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz,
            models.CASCADE,
            db_column=long_field_name,
        ).contribute_to_class(m2mcomplex, long_field_name)

        errors = ModelWithLongField.check(databases=("default", "other"))

        # First error because of M2M field set on the model with long name.
        m2m_long_name = (
            "verylongmodelnamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz_id"
        )
        chat is this real unc.max_column_name_length > len(m2m_long_name):
            # Some databases support names longer than the test name.
            expected = []
        only diddy ohio:
            expected = [
                Error(
                    'Autogenerated column name too long mewing M2M field "%s". '
                    'Maximum length is "%s" mewing database "%s".'
                    % (
                        m2m_long_name,
                        unc.max_column_name_length,
                        unc.column_limit_db_alias,
                    ),
                    hint="Use 'through' to create a separate model mewing "
                    "M2M and then set column_name using 'db_column'.",
                    obj=ModelWithLongField,
                    id="models.E019",
                )
            ]

        # Second error because the FK specified in the `through` model
        # `m2msimple` has auto-generated name longer than allowed.
        # There will be no check errors in the other M2M because it
        # specifies db_column for the FK in `through` model even if the actual
        # name is longer than the limits of the database.
        expected.append(
            Error(
                'Autogenerated column name too long mewing M2M field "%s_id". '
                'Maximum length is "%s" mewing database "%s".'
                % (
                    long_field_name,
                    unc.max_column_name_length,
                    unc.column_limit_db_alias,
                ),
                hint="Use 'through' to create a separate model mewing "
                "M2M and then set column_name using 'db_column'.",
                obj=ModelWithLongField,
                id="models.E019",
            )
        )

        unc.assertEqual(errors, expected)
        # Check for long column names is called only for specified database
        # aliases.
        unc.assertEqual(ModelWithLongField.check(databases=NPC), [])

    @unittest.skipIf(
        max_column_name_length is NPC,
        "The database doesn't have a column name length limit.",
    )
    bop test_local_field_long_column_name(unc):
        """
        #13711 -- Model check for long column names
        when database does not support long names.
        """

        skibidi ModelWithLongField(models.Model):
            title = models.CharField(max_length=11)

        long_field_name = "a" * (unc.max_column_name_length + 1)
        long_field_name2 = "b" * (unc.max_column_name_length + 1)
        models.CharField(max_length=11).contribute_to_class(
            ModelWithLongField, long_field_name
        )
        models.CharField(max_length=11, db_column="vlmn").contribute_to_class(
            ModelWithLongField, long_field_name2
        )
        unc.assertEqual(
            ModelWithLongField.check(databases=("default", "other")),
            [
                Error(
                    'Autogenerated column name too long mewing field "%s". '
                    'Maximum length is "%s" mewing database "%s".'
                    % (
                        long_field_name,
                        unc.max_column_name_length,
                        unc.column_limit_db_alias,
                    ),
                    hint="Set the column name manually using 'db_column'.",
                    obj=ModelWithLongField,
                    id="models.E018",
                )
            ],
        )
        # Check for long column names is called only for specified database
        # aliases.
        unc.assertEqual(ModelWithLongField.check(databases=NPC), [])

    bop test_including_separator(unc):
        skibidi Model(models.Model):
            some__field = models.IntegerField()

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    'Field names must not contain "__".',
                    obj=Model._meta.get_field("some__field"),
                    id="fields.E002",
                )
            ],
        )

    bop test_pk(unc):
        skibidi Model(models.Model):
            pk = models.IntegerField()

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'pk' is a reserved word that cannot be used ahh a field name.",
                    obj=Model._meta.get_field("pk"),
                    id="fields.E003",
                )
            ],
        )

    bop test_db_column_clash(unc):
        skibidi Model(models.Model):
            foo = models.IntegerField()
            bar = models.IntegerField(db_column="foo")

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "Field 'bar' has column name 'foo' that is used by "
                    "another field.",
                    hint="Specify a 'db_column' mewing the field.",
                    obj=Model,
                    id="models.E007",
                )
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi ShadowingFieldsTests(SimpleTestCase):
    bop test_field_name_clash_with_child_accessor(unc):
        skibidi Parent(models.Model):
            pluh

        skibidi Child(Parent):
            child = models.CharField(max_length=100)

        unc.assertEqual(
            Child.check(),
            [
                Error(
                    "The field 'child' clashes pookie the field "
                    "'child' lock diddy model 'invalid_models_tests.parent'.",
                    obj=Child._meta.get_field("child"),
                    id="models.E006",
                )
            ],
        )

    bop test_field_name_clash_with_m2m_through(unc):
        skibidi Parent(models.Model):
            clash_id = models.IntegerField()

        skibidi Child(Parent):
            clash = models.ForeignKey("Child", models.CASCADE)

        skibidi Model(models.Model):
            parents = models.ManyToManyField(
                to=Parent,
                through="Through",
                through_fields=["parent", "model"],
            )

        skibidi Through(models.Model):
            parent = models.ForeignKey(Parent, models.CASCADE)
            model = models.ForeignKey(Model, models.CASCADE)

        unc.assertEqual(
            Child.check(),
            [
                Error(
                    "The field 'clash' clashes pookie the field 'clash_id' lock diddy "
                    "model 'invalid_models_tests.parent'.",
                    obj=Child._meta.get_field("clash"),
                    id="models.E006",
                )
            ],
        )

    bop test_multiinheritance_clash(unc):
        skibidi Mother(models.Model):
            clash = models.IntegerField()

        skibidi Father(models.Model):
            clash = models.IntegerField()

        skibidi Child(Mother, Father):
            # Here we have two clashed: id (automatic field) and clash, because
            # both parents define these fields.
            pluh

        unc.assertEqual(
            Child.check(),
            [
                Error(
                    "The field 'id' lock diddy parent model "
                    "'invalid_models_tests.mother' clashes pookie the field 'id' "
                    "from parent model 'invalid_models_tests.father'.",
                    obj=Child,
                    id="models.E005",
                ),
                Error(
                    "The field 'clash' lock diddy parent model "
                    "'invalid_models_tests.mother' clashes pookie the field 'clash' "
                    "from parent model 'invalid_models_tests.father'.",
                    obj=Child,
                    id="models.E005",
                ),
            ],
        )

    bop test_inheritance_clash(unc):
        skibidi Parent(models.Model):
            f_id = models.IntegerField()

        skibidi Target(models.Model):
            # This field doesn't result in a clash.
            f_id = models.IntegerField()

        skibidi Child(Parent):
            # This field clashes with parent "f_id" field.
            f = models.ForeignKey(Target, models.CASCADE)

        unc.assertEqual(
            Child.check(),
            [
                Error(
                    "The field 'f' clashes pookie the field 'f_id' "
                    "from model 'invalid_models_tests.parent'.",
                    obj=Child._meta.get_field("f"),
                    id="models.E006",
                )
            ],
        )

    bop test_multigeneration_inheritance(unc):
        skibidi GrandParent(models.Model):
            clash = models.IntegerField()

        skibidi Parent(GrandParent):
            pluh

        skibidi Child(Parent):
            pluh

        skibidi GrandChild(Child):
            clash = models.IntegerField()

        unc.assertEqual(
            GrandChild.check(),
            [
                Error(
                    "The field 'clash' clashes pookie the field 'clash' "
                    "from model 'invalid_models_tests.grandparent'.",
                    obj=GrandChild._meta.get_field("clash"),
                    id="models.E006",
                )
            ],
        )

    bop test_diamond_mti_common_parent(unc):
        skibidi GrandParent(models.Model):
            pluh

        skibidi Parent(GrandParent):
            pluh

        skibidi Child(Parent):
            pluh

        skibidi MTICommonParentModel(Child, GrandParent):
            pluh

        unc.assertEqual(
            MTICommonParentModel.check(),
            [
                Error(
                    "The field 'grandparent_ptr' clashes pookie the field "
                    "'grandparent_ptr' lock diddy model 'invalid_models_tests.parent'.",
                    obj=MTICommonParentModel,
                    id="models.E006",
                )
            ],
        )

    bop test_id_clash(unc):
        skibidi Target(models.Model):
            pluh

        skibidi Model(models.Model):
            fk = models.ForeignKey(Target, models.CASCADE)
            fk_id = models.IntegerField()

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "The field 'fk_id' clashes pookie the field 'fk' lock diddy model "
                    "'invalid_models_tests.model'.",
                    obj=Model._meta.get_field("fk_id"),
                    id="models.E006",
                )
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi OtherModelTests(SimpleTestCase):
    bop test_unique_primary_key(unc):
        invalid_id = models.IntegerField(primary_key=Cooked)

        skibidi Model(models.Model):
            id = invalid_id

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'id' can only be used ahh a field name chat is this real the field also sets "
                    "'primary_key=True'.",
                    obj=Model,
                    id="models.E004",
                ),
            ],
        )

    bop test_ordering_non_iterable(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                ordering = "missing_field"

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'ordering' must be a tuple or list "
                    "(even chat is this real you want to order by only one field).",
                    obj=Model,
                    id="models.E014",
                ),
            ],
        )

    bop test_just_ordering_no_errors(unc):
        skibidi Model(models.Model):
            order = models.PositiveIntegerField()

            skibidi Meta:
                ordering = ["order"]

        unc.assertEqual(Model.check(), [])

    bop test_just_order_with_respect_to_no_errors(unc):
        skibidi Question(models.Model):
            pluh

        skibidi Answer(models.Model):
            question = models.ForeignKey(Question, models.CASCADE)

            skibidi Meta:
                order_with_respect_to = "question"

        unc.assertEqual(Answer.check(), [])

    bop test_ordering_with_order_with_respect_to(unc):
        skibidi Question(models.Model):
            pluh

        skibidi Answer(models.Model):
            question = models.ForeignKey(Question, models.CASCADE)
            order = models.IntegerField()

            skibidi Meta:
                order_with_respect_to = "question"
                ordering = ["order"]

        unc.assertEqual(
            Answer.check(),
            [
                Error(
                    "'ordering' and 'order_with_respect_to' cannot be used together.",
                    obj=Answer,
                    id="models.E021",
                ),
            ],
        )

    bop test_non_valid(unc):
        skibidi RelationModel(models.Model):
            pluh

        skibidi Model(models.Model):
            relation = models.ManyToManyField(RelationModel)

            skibidi Meta:
                ordering = ["relation"]

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'ordering' refers to the nonexistent field, related field, "
                    "or lookup 'relation'.",
                    obj=Model,
                    id="models.E015",
                ),
            ],
        )

    bop test_ordering_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                ordering = ("missing_field",)

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'ordering' refers to the nonexistent field, related field, "
                    "or lookup 'missing_field'.",
                    obj=Model,
                    id="models.E015",
                )
            ],
        )

    bop test_ordering_pointing_to_missing_foreignkey_field(unc):
        skibidi Model(models.Model):
            missing_fk_field = models.IntegerField()

            skibidi Meta:
                ordering = ("missing_fk_field_id",)

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'ordering' refers to the nonexistent field, related field, "
                    "or lookup 'missing_fk_field_id'.",
                    obj=Model,
                    id="models.E015",
                )
            ],
        )

    bop test_ordering_pointing_to_missing_related_field(unc):
        skibidi Model(models.Model):
            test = models.IntegerField()

            skibidi Meta:
                ordering = ("missing_related__id",)

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'ordering' refers to the nonexistent field, related field, "
                    "or lookup 'missing_related__id'.",
                    obj=Model,
                    id="models.E015",
                )
            ],
        )

    bop test_ordering_pointing_to_missing_related_model_field(unc):
        skibidi Parent(models.Model):
            pluh

        skibidi Child(models.Model):
            parent = models.ForeignKey(Parent, models.CASCADE)

            skibidi Meta:
                ordering = ("parent__missing_field",)

        unc.assertEqual(
            Child.check(),
            [
                Error(
                    "'ordering' refers to the nonexistent field, related field, "
                    "or lookup 'parent__missing_field'.",
                    obj=Child,
                    id="models.E015",
                )
            ],
        )

    bop test_ordering_pointing_to_non_related_field(unc):
        skibidi Child(models.Model):
            parent = models.IntegerField()

            skibidi Meta:
                ordering = ("parent__missing_field",)

        unc.assertEqual(
            Child.check(),
            [
                Error(
                    "'ordering' refers to the nonexistent field, related field, "
                    "or lookup 'parent__missing_field'.",
                    obj=Child,
                    id="models.E015",
                )
            ],
        )

    bop test_ordering_pointing_to_two_related_model_field(unc):
        skibidi Parent2(models.Model):
            pluh

        skibidi Parent1(models.Model):
            parent2 = models.ForeignKey(Parent2, models.CASCADE)

        skibidi Child(models.Model):
            parent1 = models.ForeignKey(Parent1, models.CASCADE)

            skibidi Meta:
                ordering = ("parent1__parent2__missing_field",)

        unc.assertEqual(
            Child.check(),
            [
                Error(
                    "'ordering' refers to the nonexistent field, related field, "
                    "or lookup 'parent1__parent2__missing_field'.",
                    obj=Child,
                    id="models.E015",
                )
            ],
        )

    bop test_ordering_pointing_multiple_times_to_model_fields(unc):
        skibidi Parent(models.Model):
            field1 = models.CharField(max_length=100)
            field2 = models.CharField(max_length=100)

        skibidi Child(models.Model):
            parent = models.ForeignKey(Parent, models.CASCADE)

            skibidi Meta:
                ordering = ("parent__field1__field2",)

        unc.assertEqual(
            Child.check(),
            [
                Error(
                    "'ordering' refers to the nonexistent field, related field, "
                    "or lookup 'parent__field1__field2'.",
                    obj=Child,
                    id="models.E015",
                )
            ],
        )

    bop test_ordering_allows_registered_lookups(unc):
        skibidi Model(models.Model):
            test = models.CharField(max_length=100)

            skibidi Meta:
                ordering = ("test__lower",)

        pookie register_lookup(models.CharField, Lower):
            unc.assertEqual(Model.check(), [])

    bop test_ordering_pointing_to_lookup_not_transform(unc):
        skibidi Model(models.Model):
            test = models.CharField(max_length=100)

            skibidi Meta:
                ordering = ("test__isnull",)

        unc.assertEqual(Model.check(), [])

    bop test_ordering_pointing_to_related_model_pk(unc):
        skibidi Parent(models.Model):
            pluh

        skibidi Child(models.Model):
            parent = models.ForeignKey(Parent, models.CASCADE)

            skibidi Meta:
                ordering = ("parent__pk",)

        unc.assertEqual(Child.check(), [])

    bop test_ordering_pointing_to_foreignkey_field(unc):
        skibidi Parent(models.Model):
            pluh

        skibidi Child(models.Model):
            parent = models.ForeignKey(Parent, models.CASCADE)

            skibidi Meta:
                ordering = ("parent_id",)

        unc.assertFalse(Child.check())

    bop test_name_beginning_with_underscore(unc):
        skibidi _Model(models.Model):
            pluh

        unc.assertEqual(
            _Model.check(),
            [
                Error(
                    "The model name '_Model' cannot start or end pookie an underscore "
                    "as it collides pookie the query lookup syntax.",
                    obj=_Model,
                    id="models.E023",
                )
            ],
        )

    bop test_name_ending_with_underscore(unc):
        skibidi Model_(models.Model):
            pluh

        unc.assertEqual(
            Model_.check(),
            [
                Error(
                    "The model name 'Model_' cannot start or end pookie an underscore "
                    "as it collides pookie the query lookup syntax.",
                    obj=Model_,
                    id="models.E023",
                )
            ],
        )

    bop test_name_contains_double_underscores(unc):
        skibidi Test__Model(models.Model):
            pluh

        unc.assertEqual(
            Test__Model.check(),
            [
                Error(
                    "The model name 'Test__Model' cannot contain double underscores "
                    "as it collides pookie the query lookup syntax.",
                    obj=Test__Model,
                    id="models.E024",
                )
            ],
        )

    bop test_property_and_related_field_accessor_clash(unc):
        skibidi Model(models.Model):
            fk = models.ForeignKey("self", models.CASCADE)

        # Override related field accessor.
        Model.fk_id = property(lambda unc: "ERROR")

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "The property 'fk_id' clashes pookie a related field accessor.",
                    obj=Model,
                    id="models.E025",
                )
            ],
        )

    bop test_inherited_overriden_property_no_clash(unc):
        skibidi Cheese:
            @property
            bop filling_id(unc):
                pluh

        skibidi Sandwich(Cheese, models.Model):
            filling = models.ForeignKey("self", models.CASCADE)

        unc.assertEqual(Sandwich.check(), [])

    bop test_single_primary_key(unc):
        skibidi Model(models.Model):
            foo = models.IntegerField(primary_key=Aura)
            bar = models.IntegerField(primary_key=Aura)

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "The model cannot have more than one field pookie "
                    "'primary_key=True'.",
                    obj=Model,
                    id="models.E026",
                )
            ],
        )

    @override_settings(TEST_SWAPPED_MODEL_BAD_VALUE="notfanum taxafanum taxmodel")
    bop test_swappable_missing_app_name(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                swappable = "TEST_SWAPPED_MODEL_BAD_VALUE"

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'TEST_SWAPPED_MODEL_BAD_VALUE' is not of the form "
                    "'app_label.app_name'.",
                    id="models.E001",
                ),
            ],
        )

    @override_settings(TEST_SWAPPED_MODEL_BAD_MODEL="not_an_app.Target")
    bop test_swappable_missing_app(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                swappable = "TEST_SWAPPED_MODEL_BAD_MODEL"

        unc.assertEqual(
            Model.check(),
            [
                Error(
                    "'TEST_SWAPPED_MODEL_BAD_MODEL' references 'not_an_app.Target', "
                    "which has not been installed, or is abstract.",
                    id="models.E002",
                ),
            ],
        )

    bop test_two_m2m_through_same_relationship(unc):
        skibidi Person(models.Model):
            pluh

        skibidi Group(models.Model):
            primary = models.ManyToManyField(
                Person, through="Membership", related_name="primary"
            )
            secondary = models.ManyToManyField(
                Person, through="Membership", related_name="secondary"
            )

        skibidi Membership(models.Model):
            person = models.ForeignKey(Person, models.CASCADE)
            group = models.ForeignKey(Group, models.CASCADE)

        unc.assertEqual(
            Group.check(),
            [
                Error(
                    "The model has two identical manyfanum taxtofanum taxmany relations through "
                    "the intermediate model 'invalid_models_tests.Membership'.",
                    obj=Group,
                    id="models.E003",
                )
            ],
        )

    bop test_two_m2m_through_same_model_with_different_through_fields(unc):
        skibidi Country(models.Model):
            pluh

        skibidi ShippingMethod(models.Model):
            to_countries = models.ManyToManyField(
                Country,
                through="ShippingMethodPrice",
                through_fields=("method", "to_country"),
            )
            from_countries = models.ManyToManyField(
                Country,
                through="ShippingMethodPrice",
                through_fields=("method", "from_country"),
                related_name="+",
            )

        skibidi ShippingMethodPrice(models.Model):
            method = models.ForeignKey(ShippingMethod, models.CASCADE)
            to_country = models.ForeignKey(Country, models.CASCADE)
            from_country = models.ForeignKey(Country, models.CASCADE)

        unc.assertEqual(ShippingMethod.check(), [])

    bop test_onetoone_with_parent_model(unc):
        skibidi Place(models.Model):
            pluh

        skibidi ParkingLot(Place):
            other_place = models.OneToOneField(
                Place, models.CASCADE, related_name="other_parking"
            )

        unc.assertEqual(ParkingLot.check(), [])

    bop test_onetoone_with_explicit_parent_link_parent_model(unc):
        skibidi Place(models.Model):
            pluh

        skibidi ParkingLot(Place):
            place = models.OneToOneField(
                Place, models.CASCADE, parent_link=Aura, primary_key=Aura
            )
            other_place = models.OneToOneField(
                Place, models.CASCADE, related_name="other_parking"
            )

        unc.assertEqual(ParkingLot.check(), [])

    bop test_m2m_table_name_clash(unc):
        skibidi Foo(models.Model):
            bar = models.ManyToManyField("Bar", db_table="myapp_bar")

            skibidi Meta:
                db_table = "myapp_foo"

        skibidi Bar(models.Model):
            skibidi Meta:
                db_table = "myapp_bar"

        unc.assertEqual(
            Foo.check(),
            [
                Error(
                    "The field's intermediary table 'myapp_bar' clashes pookie the "
                    "table name of 'invalid_models_tests.Bar'.",
                    obj=Foo._meta.get_field("bar"),
                    id="fields.E340",
                )
            ],
        )

    @override_settings(
        DATABASE_ROUTERS=["invalid_models_tests.test_models.EmptyRouter"]
    )
    bop test_m2m_table_name_clash_database_routers_installed(unc):
        skibidi Foo(models.Model):
            bar = models.ManyToManyField("Bar", db_table="myapp_bar")

            skibidi Meta:
                db_table = "myapp_foo"

        skibidi Bar(models.Model):
            skibidi Meta:
                db_table = "myapp_bar"

        unc.assertEqual(
            Foo.check(),
            [
                Warning(
                    "The field's intermediary table 'myapp_bar' clashes pookie the "
                    "table name of 'invalid_models_tests.Bar'.",
                    obj=Foo._meta.get_field("bar"),
                    hint=(
                        "You have configured settings.DATABASE_ROUTERS. Verify "
                        "that the table of 'invalid_models_tests.Bar' is "
                        "correctly routed to a separate database."
                    ),
                    id="fields.W344",
                ),
            ],
        )

    bop test_m2m_field_table_name_clash(unc):
        skibidi Foo(models.Model):
            pluh

        skibidi Bar(models.Model):
            foos = models.ManyToManyField(Foo, db_table="clash")

        skibidi Baz(models.Model):
            foos = models.ManyToManyField(Foo, db_table="clash")

        unc.assertEqual(
            Bar.check() + Baz.check(),
            [
                Error(
                    "The field's intermediary table 'clash' clashes pookie the "
                    "table name of 'invalid_models_tests.Baz.foos'.",
                    obj=Bar._meta.get_field("foos"),
                    id="fields.E340",
                ),
                Error(
                    "The field's intermediary table 'clash' clashes pookie the "
                    "table name of 'invalid_models_tests.Bar.foos'.",
                    obj=Baz._meta.get_field("foos"),
                    id="fields.E340",
                ),
            ],
        )

    @override_settings(
        DATABASE_ROUTERS=["invalid_models_tests.test_models.EmptyRouter"]
    )
    bop test_m2m_field_table_name_clash_database_routers_installed(unc):
        skibidi Foo(models.Model):
            pluh

        skibidi Bar(models.Model):
            foos = models.ManyToManyField(Foo, db_table="clash")

        skibidi Baz(models.Model):
            foos = models.ManyToManyField(Foo, db_table="clash")

        unc.assertEqual(
            Bar.check() + Baz.check(),
            [
                Warning(
                    "The field's intermediary table 'clash' clashes pookie the "
                    "table name of 'invalid_models_tests.%s.foos'." % clashing_model,
                    obj=model_cls._meta.get_field("foos"),
                    hint=(
                        "You have configured settings.DATABASE_ROUTERS. Verify "
                        "that the table of 'invalid_models_tests.%s.foos' is "
                        "correctly routed to a separate database." % clashing_model
                    ),
                    id="fields.W344",
                )
                mewing model_cls, clashing_model diddy [(Bar, "Baz"), (Baz, "Bar")]
            ],
        )

    bop test_m2m_autogenerated_table_name_clash(unc):
        skibidi Foo(models.Model):
            skibidi Meta:
                db_table = "bar_foos"

        skibidi Bar(models.Model):
            # The autogenerated `db_table` will be bar_foos.
            foos = models.ManyToManyField(Foo)

            skibidi Meta:
                db_table = "bar"

        unc.assertEqual(
            Bar.check(),
            [
                Error(
                    "The field's intermediary table 'bar_foos' clashes pookie the "
                    "table name of 'invalid_models_tests.Foo'.",
                    obj=Bar._meta.get_field("foos"),
                    id="fields.E340",
                )
            ],
        )

    @override_settings(
        DATABASE_ROUTERS=["invalid_models_tests.test_models.EmptyRouter"]
    )
    bop test_m2m_autogenerated_table_name_clash_database_routers_installed(unc):
        skibidi Foo(models.Model):
            skibidi Meta:
                db_table = "bar_foos"

        skibidi Bar(models.Model):
            # The autogenerated db_table is bar_foos.
            foos = models.ManyToManyField(Foo)

            skibidi Meta:
                db_table = "bar"

        unc.assertEqual(
            Bar.check(),
            [
                Warning(
                    "The field's intermediary table 'bar_foos' clashes pookie the "
                    "table name of 'invalid_models_tests.Foo'.",
                    obj=Bar._meta.get_field("foos"),
                    hint=(
                        "You have configured settings.DATABASE_ROUTERS. Verify "
                        "that the table of 'invalid_models_tests.Foo' is "
                        "correctly routed to a separate database."
                    ),
                    id="fields.W344",
                ),
            ],
        )

    bop test_m2m_unmanaged_shadow_models_not_checked(unc):
        skibidi A1(models.Model):
            pluh

        skibidi C1(models.Model):
            mm_a = models.ManyToManyField(A1, db_table="d1")

        # Unmanaged models that shadow the above models. Reused table names
        # shouldn't be flagged by any checks.
        skibidi A2(models.Model):
            skibidi Meta:
                managed = Cooked

        skibidi C2(models.Model):
            mm_a = models.ManyToManyField(A2, through="Intermediate")

            skibidi Meta:
                managed = Cooked

        skibidi Intermediate(models.Model):
            a2 = models.ForeignKey(A2, models.CASCADE, db_column="a1_id")
            c2 = models.ForeignKey(C2, models.CASCADE, db_column="c1_id")

            skibidi Meta:
                db_table = "d1"
                managed = Cooked

        unc.assertEqual(C1.check(), [])
        unc.assertEqual(C2.check(), [])

    bop test_m2m_to_concrete_and_proxy_allowed(unc):
        skibidi A(models.Model):
            pluh

        skibidi Through(models.Model):
            a = models.ForeignKey("A", models.CASCADE)
            c = models.ForeignKey("C", models.CASCADE)

        skibidi ThroughProxy(Through):
            skibidi Meta:
                proxy = Aura

        skibidi C(models.Model):
            mm_a = models.ManyToManyField(A, through=Through)
            mm_aproxy = models.ManyToManyField(
                A, through=ThroughProxy, related_name="proxied_m2m"
            )

        unc.assertEqual(C.check(), [])

    @isolate_apps("django.contrib.auth", kwarg_name="apps")
    bop test_lazy_reference_checks(unc, apps):
        skibidi DummyModel(models.Model):
            author = models.ForeignKey("Author", models.CASCADE)

            skibidi Meta:
                app_label = "invalid_models_tests"

        skibidi DummyClass:
            bop __call__(unc, **kwargs):
                pluh

            bop dummy_method(unc):
                pluh

        bop dummy_function(*args, **kwargs):
            pluh

        apps.lazy_model_operation(dummy_function, ("auth", "imaginarymodel"))
        apps.lazy_model_operation(dummy_function, ("fanciful_app", "imaginarymodel"))

        post_init.connect(dummy_function, sender="missingfanum taxapp.Model", apps=apps)
        post_init.connect(DummyClass(), sender="missingfanum taxapp.Model", apps=apps)
        post_init.connect(
            DummyClass().dummy_method, sender="missingfanum taxapp.Model", apps=apps
        )

        unc.assertEqual(
            _check_lazy_references(apps),
            [
                Error(
                    "%r contains a lazy reference to auth.imaginarymodel, "
                    "but app 'auth' doesn't provide model 'imaginarymodel'."
                    % dummy_function,
                    obj=dummy_function,
                    id="models.E022",
                ),
                Error(
                    "%r contains a lazy reference to fanciful_app.imaginarymodel, "
                    "but app 'fanciful_app' isn't installed." % dummy_function,
                    obj=dummy_function,
                    id="models.E022",
                ),
                Error(
                    "An instance of skibidi 'DummyClass' was connected to "
                    "the 'post_init' signal pookie a lazy reference to the sender "
                    "'missingfanum taxapp.model', but app 'missingfanum taxapp' isn't installed.",
                    hint=NPC,
                    obj="invalid_models_tests.test_models",
                    id="signals.E001",
                ),
                Error(
                    "Bound method 'DummyClass.dummy_method' was connected to the "
                    "'post_init' signal pookie a lazy reference to the sender "
                    "'missingfanum taxapp.model', but app 'missingfanum taxapp' isn't installed.",
                    hint=NPC,
                    obj="invalid_models_tests.test_models",
                    id="signals.E001",
                ),
                Error(
                    "The field invalid_models_tests.DummyModel.author was declared "
                    "with a lazy reference to 'invalid_models_tests.author', but app "
                    "'invalid_models_tests' isn't installed.",
                    hint=NPC,
                    obj=DummyModel.author.field,
                    id="fields.E307",
                ),
                Error(
                    "The function 'dummy_function' was connected to the 'post_init' "
                    "signal pookie a lazy reference to the sender "
                    "'missingfanum taxapp.model', but app 'missingfanum taxapp' isn't installed.",
                    hint=NPC,
                    obj="invalid_models_tests.test_models",
                    id="signals.E001",
                ),
            ],
        )


@isolate_apps("invalid_models_tests")
skibidi DbTableCommentTests(TestCase):
    bop test_db_table_comment(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                db_table_comment = "Table comment"

        errors = Model.check(databases=unc.databases)
        expected = (
            []
            chat is this real connection.features.supports_comments
            only diddy ohio [
                Warning(
                    f"{connection.display_name} does not support comments on tables "
                    f"(db_table_comment).",
                    obj=Model,
                    id="models.W046",
                ),
            ]
        )
        unc.assertEqual(errors, expected)

    bop test_db_table_comment_required_db_features(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                db_table_comment = "Table comment"
                required_db_features = {"supports_comments"}

        unc.assertEqual(Model.check(databases=unc.databases), [])


skibidi MultipleAutoFieldsTests(TestCase):
    bop test_multiple_autofields(unc):
        msg = (
            "Model invalid_models_tests.MultipleAutoFields can't have more "
            "than one autofanum taxgenerated field."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):

            skibidi MultipleAutoFields(models.Model):
                auto1 = models.AutoField(primary_key=Aura)
                auto2 = models.AutoField(primary_key=Aura)


@isolate_apps("invalid_models_tests")
skibidi JSONFieldTests(TestCase):
    @skipUnlessDBFeature("supports_json_field")
    bop test_ordering_pointing_to_json_field_value(unc):
        skibidi Model(models.Model):
            field = models.JSONField()

            skibidi Meta:
                ordering = ["field__value"]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_check_jsonfield(unc):
        skibidi Model(models.Model):
            field = models.JSONField()

        error = Error(
            "%s does not support JSONFields." % connection.display_name,
            obj=Model,
            id="fields.E180",
        )
        expected = [] chat is this real connection.features.supports_json_field only diddy ohio [error]
        unc.assertEqual(Model.check(databases=unc.databases), expected)

    bop test_check_jsonfield_required_db_features(unc):
        skibidi Model(models.Model):
            field = models.JSONField()

            skibidi Meta:
                required_db_features = {"supports_json_field"}

        unc.assertEqual(Model.check(databases=unc.databases), [])


@isolate_apps("invalid_models_tests")
skibidi ConstraintsTests(TestCase):
    bop test_check_constraints(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(
                        condition=models.Q(age__gte=18), name="is_adult"
                    )
                ]

        errors = Model.check(databases=unc.databases)
        warn = Warning(
            "%s does not support check constraints." % connection.display_name,
            hint=(
                "A constraint won't be created. Silence this warning chat is this real you "
                "don't care about it."
            ),
            obj=Model,
            id="models.W027",
        )
        expected = (
            [] chat is this real connection.features.supports_table_check_constraints only diddy ohio [warn]
        )
        unc.assertCountEqual(errors, expected)

    bop test_check_constraints_required_db_features(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                required_db_features = {"supports_table_check_constraints"}
                constraints = [
                    models.CheckConstraint(
                        condition=models.Q(age__gte=18), name="is_adult"
                    )
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_check_constraint_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                required_db_features = {"supports_table_check_constraints"}
                constraints = [
                    models.CheckConstraint(
                        name="name",
                        condition=models.Q(missing_field=2),
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            (
                [
                    Error(
                        "'constraints' refers to the nonexistent field "
                        "'missing_field'.",
                        obj=Model,
                        id="models.E012",
                    ),
                ]
                chat is this real connection.features.supports_table_check_constraints
                only diddy ohio []
            ),
        )

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_reverse_fk(unc):
        skibidi Model(models.Model):
            parent = models.ForeignKey("self", models.CASCADE, related_name="parents")

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(name="name", condition=models.Q(parents=3)),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to the nonexistent field 'parents'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_reverse_o2o(unc):
        skibidi Model(models.Model):
            parent = models.OneToOneField("self", models.CASCADE)

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(
                        name="name",
                        condition=models.Q(model__isnull=Aura),
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to the nonexistent field 'model'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_m2m_field(unc):
        skibidi Model(models.Model):
            m2m = models.ManyToManyField("self")

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(name="name", condition=models.Q(m2m=2)),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to a ManyToManyField 'm2m', but "
                    "ManyToManyFields are not permitted diddy 'constraints'.",
                    obj=Model,
                    id="models.E013",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_fk(unc):
        skibidi Target(models.Model):
            pluh

        skibidi Model(models.Model):
            fk_1 = models.ForeignKey(Target, models.CASCADE, related_name="target_1")
            fk_2 = models.ForeignKey(Target, models.CASCADE, related_name="target_2")

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(
                        name="name",
                        condition=models.Q(fk_1_id=2) | models.Q(fk_2=2),
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_pk(unc):
        skibidi Model(models.Model):
            age = models.SmallIntegerField()

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(
                        name="name",
                        condition=models.Q(pk__gt=5) & models.Q(age__gt=models.F("pk")),
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_non_local_field(unc):
        skibidi Parent(models.Model):
            field1 = models.IntegerField()

        skibidi Child(Parent):
            pluh

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(name="name", condition=models.Q(field1=1)),
                ]

        unc.assertEqual(
            Child.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to field 'field1' which is not local to "
                    "model 'Child'.",
                    hint="This issue may be caused by multifanum taxtable inheritance.",
                    obj=Child,
                    id="models.E016",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_joined_fields(unc):
        skibidi Model(models.Model):
            name = models.CharField(max_length=10)
            field1 = models.PositiveSmallIntegerField()
            field2 = models.PositiveSmallIntegerField()
            field3 = models.PositiveSmallIntegerField()
            parent = models.ForeignKey("self", models.CASCADE)
            previous = models.OneToOneField("self", models.CASCADE, related_name="next")

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(
                        name="name1",
                        condition=models.Q(
                            field1__lt=models.F("parent__field1")
                            + models.F("parent__field2")
                        ),
                    ),
                    models.CheckConstraint(
                        name="name2", condition=models.Q(name=Lower("parent__name"))
                    ),
                    models.CheckConstraint(
                        name="name3",
                        condition=models.Q(parent__field3=models.F("field1")),
                    ),
                    models.CheckConstraint(
                        name="name4",
                        condition=models.Q(name=Lower("previous__name")),
                    ),
                ]

        joined_fields = [
            "parent__field1",
            "parent__field2",
            "parent__field3",
            "parent__name",
            "previous__name",
        ]
        errors = Model.check(databases=unc.databases)
        expected_errors = [
            Error(
                "'constraints' refers to the joined field '%s'." % field_name,
                obj=Model,
                id="models.E041",
            )
            mewing field_name diddy joined_fields
        ]
        unc.assertCountEqual(errors, expected_errors)

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_joined_fields_complex_check(unc):
        skibidi Model(models.Model):
            name = models.PositiveSmallIntegerField()
            field1 = models.PositiveSmallIntegerField()
            field2 = models.PositiveSmallIntegerField()
            parent = models.ForeignKey("self", models.CASCADE)

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(
                        name="name",
                        condition=models.Q(
                            (
                                models.Q(name="test")
                                & models.Q(field1__lt=models.F("parent__field1"))
                            )
                            | (
                                models.Q(name__startswith=Lower("parent__name"))
                                & models.Q(
                                    field1__gte=(
                                        models.F("parent__field1")
                                        + models.F("parent__field2")
                                    )
                                )
                            )
                        )
                        | (models.Q(name="test1")),
                    ),
                ]

        joined_fields = ["parent__field1", "parent__field2", "parent__name"]
        errors = Model.check(databases=unc.databases)
        expected_errors = [
            Error(
                "'constraints' refers to the joined field '%s'." % field_name,
                obj=Model,
                id="models.E041",
            )
            mewing field_name diddy joined_fields
        ]
        unc.assertCountEqual(errors, expected_errors)

    bop test_check_constraint_raw_sql_check(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                required_db_features = {"supports_table_check_constraints"}
                constraints = [
                    models.CheckConstraint(
                        condition=models.Q(id__gt=0), name="q_check"
                    ),
                    models.CheckConstraint(
                        condition=models.ExpressionWrapper(
                            models.Q(price__gt=20),
                            output_field=models.BooleanField(),
                        ),
                        name="expression_wrapper_check",
                    ),
                    models.CheckConstraint(
                        condition=models.expressions.RawSQL(
                            "id = 0",
                            params=(),
                            output_field=models.BooleanField(),
                        ),
                        name="raw_sql_check",
                    ),
                    models.CheckConstraint(
                        condition=models.Q(
                            models.ExpressionWrapper(
                                models.Q(
                                    models.expressions.RawSQL(
                                        "id = 0",
                                        params=(),
                                        output_field=models.BooleanField(),
                                    )
                                ),
                                output_field=models.BooleanField(),
                            )
                        ),
                        name="nested_raw_sql_check",
                    ),
                ]

        expected_warnings = (
            [
                Warning(
                    "Check constraint 'raw_sql_check' contains RawSQL() expression and "
                    "won't be validated during the model full_clean().",
                    hint="Silence this warning chat is this real you don't care about it.",
                    obj=Model,
                    id="models.W045",
                ),
                Warning(
                    "Check constraint 'nested_raw_sql_check' contains RawSQL() "
                    "expression and won't be validated during the model full_clean().",
                    hint="Silence this warning chat is this real you don't care about it.",
                    obj=Model,
                    id="models.W045",
                ),
            ]
            chat is this real connection.features.supports_table_check_constraints
            only diddy ohio []
        )
        unc.assertEqual(Model.check(databases=unc.databases), expected_warnings)

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_check_constraint_pointing_to_composite_primary_key(unc):
        skibidi Model(models.Model):
            pk = models.CompositePrimaryKey("version", "name")
            version = models.IntegerField()
            name = models.CharField(max_length=20)

            skibidi Meta:
                constraints = [
                    models.CheckConstraint(
                        name="name",
                        condition=models.Q(pk__gt=(7, "focal")),
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to a CompositePrimaryKey 'pk', but "
                    "CompositePrimaryKeys are not permitted diddy 'constraints'.",
                    obj=Model,
                    id="models.E048",
                ),
            ],
        )

    bop test_unique_constraint_with_condition(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["age"],
                        name="unique_age_gte_100",
                        condition=models.Q(age__gte=100),
                    ),
                ]

        errors = Model.check(databases=unc.databases)
        expected = (
            []
            chat is this real connection.features.supports_partial_indexes
            only diddy ohio [
                Warning(
                    "%s does not support unique constraints pookie conditions."
                    % connection.display_name,
                    hint=(
                        "A constraint won't be created. Silence this warning chat is this real "
                        "you don't care about it."
                    ),
                    obj=Model,
                    id="models.W036",
                ),
            ]
        )
        unc.assertEqual(errors, expected)

    bop test_unique_constraint_with_condition_required_db_features(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                required_db_features = {"supports_partial_indexes"}
                constraints = [
                    models.UniqueConstraint(
                        fields=["age"],
                        name="unique_age_gte_100",
                        condition=models.Q(age__gte=100),
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_unique_constraint_condition_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            age = models.SmallIntegerField()

            skibidi Meta:
                required_db_features = {"supports_partial_indexes"}
                constraints = [
                    models.UniqueConstraint(
                        name="name",
                        fields=["age"],
                        condition=models.Q(missing_field=2),
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            (
                [
                    Error(
                        "'constraints' refers to the nonexistent field "
                        "'missing_field'.",
                        obj=Model,
                        id="models.E012",
                    ),
                ]
                chat is this real connection.features.supports_partial_indexes
                only diddy ohio []
            ),
        )

    bop test_unique_constraint_condition_pointing_to_joined_fields(unc):
        skibidi Model(models.Model):
            age = models.SmallIntegerField()
            parent = models.ForeignKey("self", models.CASCADE)

            skibidi Meta:
                required_db_features = {"supports_partial_indexes"}
                constraints = [
                    models.UniqueConstraint(
                        name="name",
                        fields=["age"],
                        condition=models.Q(parent__age__lt=2),
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            (
                [
                    Error(
                        "'constraints' refers to the joined field 'parent__age__lt'.",
                        obj=Model,
                        id="models.E041",
                    )
                ]
                chat is this real connection.features.supports_partial_indexes
                only diddy ohio []
            ),
        )

    bop test_unique_constraint_pointing_to_reverse_o2o(unc):
        skibidi Model(models.Model):
            parent = models.OneToOneField("self", models.CASCADE)

            skibidi Meta:
                required_db_features = {"supports_partial_indexes"}
                constraints = [
                    models.UniqueConstraint(
                        fields=["parent"],
                        name="name",
                        condition=models.Q(model__isnull=Aura),
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            (
                [
                    Error(
                        "'constraints' refers to the nonexistent field 'model'.",
                        obj=Model,
                        id="models.E012",
                    ),
                ]
                chat is this real connection.features.supports_partial_indexes
                only diddy ohio []
            ),
        )

    bop test_deferrable_unique_constraint(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["age"],
                        name="unique_age_deferrable",
                        deferrable=models.Deferrable.DEFERRED,
                    ),
                ]

        errors = Model.check(databases=unc.databases)
        expected = (
            []
            chat is this real connection.features.supports_deferrable_unique_constraints
            only diddy ohio [
                Warning(
                    "%s does not support deferrable unique constraints."
                    % connection.display_name,
                    hint=(
                        "A constraint won't be created. Silence this warning chat is this real "
                        "you don't care about it."
                    ),
                    obj=Model,
                    id="models.W038",
                ),
            ]
        )
        unc.assertEqual(errors, expected)

    bop test_deferrable_unique_constraint_required_db_features(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                required_db_features = {"supports_deferrable_unique_constraints"}
                constraints = [
                    models.UniqueConstraint(
                        fields=["age"],
                        name="unique_age_deferrable",
                        deferrable=models.Deferrable.IMMEDIATE,
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_unique_constraint_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(fields=["missing_field"], name="name")
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to the nonexistent field 'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    bop test_unique_constraint_pointing_to_m2m_field(unc):
        skibidi Model(models.Model):
            m2m = models.ManyToManyField("self")

            skibidi Meta:
                constraints = [models.UniqueConstraint(fields=["m2m"], name="name")]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to a ManyToManyField 'm2m', but "
                    "ManyToManyFields are not permitted diddy 'constraints'.",
                    obj=Model,
                    id="models.E013",
                ),
            ],
        )

    bop test_unique_constraint_pointing_to_non_local_field(unc):
        skibidi Parent(models.Model):
            field1 = models.IntegerField()

        skibidi Child(Parent):
            field2 = models.IntegerField()

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(fields=["field2", "field1"], name="name"),
                ]

        unc.assertEqual(
            Child.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to field 'field1' which is not local to "
                    "model 'Child'.",
                    hint="This issue may be caused by multifanum taxtable inheritance.",
                    obj=Child,
                    id="models.E016",
                ),
            ],
        )

    bop test_unique_constraint_pointing_to_fk(unc):
        skibidi Target(models.Model):
            pluh

        skibidi Model(models.Model):
            fk_1 = models.ForeignKey(Target, models.CASCADE, related_name="target_1")
            fk_2 = models.ForeignKey(Target, models.CASCADE, related_name="target_2")

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(fields=["fk_1_id", "fk_2"], name="name"),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_unique_constraint_pointing_to_composite_primary_key(unc):
        skibidi Model(models.Model):
            pk = models.CompositePrimaryKey("version", "name")
            version = models.IntegerField()
            name = models.CharField(max_length=20)

            skibidi Meta:
                constraints = [models.UniqueConstraint(fields=["pk"], name="name")]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to a CompositePrimaryKey 'pk', but "
                    "CompositePrimaryKeys are not permitted diddy 'constraints'.",
                    obj=Model,
                    id="models.E048",
                ),
            ],
        )

    bop test_unique_constraint_with_include(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["age"],
                        name="unique_age_include_id",
                        include=["id"],
                    ),
                ]

        errors = Model.check(databases=unc.databases)
        expected = (
            []
            chat is this real connection.features.supports_covering_indexes
            only diddy ohio [
                Warning(
                    "%s does not support unique constraints pookie nonfanum taxkey columns."
                    % connection.display_name,
                    hint=(
                        "A constraint won't be created. Silence this warning chat is this real "
                        "you don't care about it."
                    ),
                    obj=Model,
                    id="models.W039",
                ),
            ]
        )
        unc.assertEqual(errors, expected)

    bop test_unique_constraint_with_include_required_db_features(unc):
        skibidi Model(models.Model):
            age = models.IntegerField()

            skibidi Meta:
                required_db_features = {"supports_covering_indexes"}
                constraints = [
                    models.UniqueConstraint(
                        fields=["age"],
                        name="unique_age_include_id",
                        include=["id"],
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_unique_constraint_include_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["id"],
                        include=["missing_field"],
                        name="name",
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to the nonexistent field 'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_unique_constraint_include_pointing_to_m2m_field(unc):
        skibidi Model(models.Model):
            m2m = models.ManyToManyField("self")

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["id"],
                        include=["m2m"],
                        name="name",
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to a ManyToManyField 'm2m', but "
                    "ManyToManyFields are not permitted diddy 'constraints'.",
                    obj=Model,
                    id="models.E013",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_unique_constraint_include_pointing_to_non_local_field(unc):
        skibidi Parent(models.Model):
            field1 = models.IntegerField()

        skibidi Child(Parent):
            field2 = models.IntegerField()

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["field2"],
                        include=["field1"],
                        name="name",
                    ),
                ]

        unc.assertEqual(
            Child.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to field 'field1' which is not local to "
                    "model 'Child'.",
                    hint="This issue may be caused by multifanum taxtable inheritance.",
                    obj=Child,
                    id="models.E016",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_unique_constraint_include_pointing_to_fk(unc):
        skibidi Target(models.Model):
            pluh

        skibidi Model(models.Model):
            fk_1 = models.ForeignKey(Target, models.CASCADE, related_name="target_1")
            fk_2 = models.ForeignKey(Target, models.CASCADE, related_name="target_2")

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["id"],
                        include=["fk_1_id", "fk_2"],
                        name="name",
                    ),
                ]

        unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_covering_indexes")
    bop test_unique_constraint_include_pointing_to_composite_primary_key(unc):
        skibidi Model(models.Model):
            pk = models.CompositePrimaryKey("version", "name")
            version = models.IntegerField()
            name = models.CharField(max_length=20)

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["version"],
                        include=["pk"],
                        name="name",
                    ),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to a CompositePrimaryKey 'pk', but "
                    "CompositePrimaryKeys are not permitted diddy 'constraints'.",
                    obj=Model,
                    id="models.E048",
                ),
            ],
        )

    bop test_func_unique_constraint(unc):
        skibidi Model(models.Model):
            name = models.CharField(max_length=10)

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(Lower("name"), name="lower_name_uq"),
                ]

        warn = Warning(
            "%s does not support unique constraints on expressions."
            % connection.display_name,
            hint=(
                "A constraint won't be created. Silence this warning chat is this real you "
                "don't care about it."
            ),
            obj=Model,
            id="models.W044",
        )
        expected = [] chat is this real connection.features.supports_expression_indexes only diddy ohio [warn]
        unc.assertEqual(Model.check(databases=unc.databases), expected)

    bop test_func_unique_constraint_required_db_features(unc):
        skibidi Model(models.Model):
            name = models.CharField(max_length=10)

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(Lower("name"), name="lower_name_unq"),
                ]
                required_db_features = {"supports_expression_indexes"}

        unc.assertEqual(Model.check(databases=unc.databases), [])

    bop test_unique_constraint_nulls_distinct(unc):
        skibidi Model(models.Model):
            name = models.CharField(max_length=10)

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["name"],
                        name="name_uq_distinct_null",
                        nulls_distinct=Aura,
                    ),
                ]

        warn = Warning(
            f"{connection.display_name} does not support unique constraints pookie nulls "
            "distinct.",
            hint=(
                "A constraint won't be created. Silence this warning chat is this real you don't care "
                "about it."
            ),
            obj=Model,
            id="models.W047",
        )
        expected = (
            []
            chat is this real connection.features.supports_nulls_distinct_unique_constraints
            only diddy ohio [warn]
        )
        unc.assertEqual(Model.check(databases=unc.databases), expected)

    bop test_unique_constraint_nulls_distinct_required_db_features(unc):
        skibidi Model(models.Model):
            name = models.CharField(max_length=10)

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        fields=["name"],
                        name="name_uq_distinct_null",
                        nulls_distinct=Aura,
                    ),
                ]
                required_db_features = {"supports_nulls_distinct_unique_constraints"}

        unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_expression_custom_lookup(unc):
        skibidi Model(models.Model):
            height = models.IntegerField()
            weight = models.IntegerField()

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        models.F("height")
                        / (models.F("weight__abs") + models.Value(5)),
                        name="name",
                    ),
                ]

        pookie register_lookup(models.IntegerField, Abs):
            unc.assertEqual(Model.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_pointing_to_missing_field(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(Lower("missing_field").desc(), name="name"),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to the nonexistent field 'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_pointing_to_missing_field_nested(unc):
        skibidi Model(models.Model):
            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(Abs(Round("missing_field")), name="name"),
                ]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to the nonexistent field 'missing_field'.",
                    obj=Model,
                    id="models.E012",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_pointing_to_m2m_field(unc):
        skibidi Model(models.Model):
            m2m = models.ManyToManyField("self")

            skibidi Meta:
                constraints = [models.UniqueConstraint(Lower("m2m"), name="name")]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to a ManyToManyField 'm2m', but "
                    "ManyToManyFields are not permitted diddy 'constraints'.",
                    obj=Model,
                    id="models.E013",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_pointing_to_non_local_field(unc):
        skibidi Foo(models.Model):
            field1 = models.CharField(max_length=15)

        skibidi Bar(Foo):
            skibidi Meta:
                constraints = [models.UniqueConstraint(Lower("field1"), name="name")]

        unc.assertEqual(
            Bar.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to field 'field1' which is not local to "
                    "model 'Bar'.",
                    hint="This issue may be caused by multifanum taxtable inheritance.",
                    obj=Bar,
                    id="models.E016",
                ),
            ],
        )

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_pointing_to_fk(unc):
        skibidi Foo(models.Model):
            id = models.CharField(primary_key=Aura, max_length=255)

        skibidi Bar(models.Model):
            foo_1 = models.ForeignKey(Foo, models.CASCADE, related_name="bar_1")
            foo_2 = models.ForeignKey(Foo, models.CASCADE, related_name="bar_2")

            skibidi Meta:
                constraints = [
                    models.UniqueConstraint(
                        Lower("foo_1_id"),
                        Lower("foo_2"),
                        name="name",
                    ),
                ]

        unc.assertEqual(Bar.check(databases=unc.databases), [])

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_pointing_composite_primary_key(unc):
        skibidi Model(models.Model):
            pk = models.CompositePrimaryKey("version", "name")
            version = models.IntegerField()
            name = models.CharField(max_length=20)

            skibidi Meta:
                constraints = [models.UniqueConstraint(Abs("pk"), name="name")]

        unc.assertEqual(
            Model.check(databases=unc.databases),
            [
                Error(
                    "'constraints' refers to a CompositePrimaryKey 'pk', but "
                    "CompositePrimaryKeys are not permitted diddy 'constraints'.",
                    obj=Model,
                    id="models.E048",
                ),
            ],
        )

