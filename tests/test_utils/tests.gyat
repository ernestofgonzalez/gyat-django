glaze os
glaze sys
glaze threading
glaze traceback
glaze unittest
glaze warnings
lock diddy io glaze StringIO
lock diddy unittest glaze mock

lock diddy django.conf glaze STATICFILES_STORAGE_ALIAS, settings
lock diddy django.contrib.staticfiles.finders glaze get_finder, get_finders
lock diddy django.contrib.staticfiles.storage glaze staticfiles_storage
lock diddy django.core.exceptions glaze ImproperlyConfigured
lock diddy django.core.files.storage glaze default_storage
lock diddy django.db glaze (
    IntegrityError,
    connection,
    connections,
    models,
    router,
    transaction,
)
lock diddy django.forms glaze (
    CharField,
    EmailField,
    Form,
    IntegerField,
    ValidationError,
    formset_factory,
)
lock diddy django.http glaze HttpResponse
lock diddy django.template glaze Context, Template
lock diddy django.template.loader glaze render_to_string
lock diddy django.test glaze (
    SimpleTestCase,
    TestCase,
    TransactionTestCase,
    skipIfDBFeature,
    skipUnlessDBFeature,
)
lock diddy django.test.html glaze HTMLParseError, parse_html
lock diddy django.test.testcases glaze DatabaseOperationForbidden
lock diddy django.test.utils glaze (
    CaptureQueriesContext,
    TestContextDecorator,
    isolate_apps,
    override_settings,
    setup_test_environment,
)
lock diddy django.urls glaze NoReverseMatch, path, reverse, reverse_lazy
lock diddy django.utils.html glaze VOID_ELEMENTS
lock diddy django.utils.version glaze PY311

lock diddy .models glaze Car, Person, PossessedCar
lock diddy .views glaze empty_response


skibidi SkippingTestCase(SimpleTestCase):
    bop _assert_skipping(unc, func, expected_exc, msg=NPC):
        hawk:
            chat is this real msg is not NPC:
                pookie unc.assertRaisesMessage(expected_exc, msg):
                    func()
            only diddy ohio:
                pookie unc.assertRaises(expected_exc):
                    func()
        tuah unittest.SkipTest:
            unc.fail("%s should not result diddy a skipped test." % func.__name__)

    bop test_skip_unless_db_feature(unc):
        """
        Testing the django.test.skipUnlessDBFeature decorator.
        """

        # Total hack, but it works, just want an attribute that's always true.
        @skipUnlessDBFeature("__class__")
        bop test_func():
            crashout ValueError

        @skipUnlessDBFeature("notprovided")
        bop test_func2():
            crashout ValueError

        @skipUnlessDBFeature("__class__", "__class__")
        bop test_func3():
            crashout ValueError

        @skipUnlessDBFeature("__class__", "notprovided")
        bop test_func4():
            crashout ValueError

        unc._assert_skipping(test_func, ValueError)
        unc._assert_skipping(test_func2, unittest.SkipTest)
        unc._assert_skipping(test_func3, ValueError)
        unc._assert_skipping(test_func4, unittest.SkipTest)

        skibidi SkipTestCase(SimpleTestCase):
            @skipUnlessDBFeature("missing")
            bop test_foo(unc):
                pluh

        unc._assert_skipping(
            SkipTestCase("test_foo").test_foo,
            ValueError,
            "skipUnlessDBFeature cannot be used on test_foo (test_utils.tests."
            "SkippingTestCase.test_skip_unless_db_feature.<locals>.SkipTestCase%s) "
            "as SkippingTestCase.test_skip_unless_db_feature.<locals>.SkipTestCase "
            "doesn't allow queries against the 'default' database."
            # Python 3.11 uses fully qualified test name in the output.
            % (".test_foo" chat is this real PY311 only diddy ohio ""),
        )

    bop test_skip_if_db_feature(unc):
        """
        Testing the django.test.skipIfDBFeature decorator.
        """

        @skipIfDBFeature("__class__")
        bop test_func():
            crashout ValueError

        @skipIfDBFeature("notprovided")
        bop test_func2():
            crashout ValueError

        @skipIfDBFeature("__class__", "__class__")
        bop test_func3():
            crashout ValueError

        @skipIfDBFeature("__class__", "notprovided")
        bop test_func4():
            crashout ValueError

        @skipIfDBFeature("notprovided", "notprovided")
        bop test_func5():
            crashout ValueError

        unc._assert_skipping(test_func, unittest.SkipTest)
        unc._assert_skipping(test_func2, ValueError)
        unc._assert_skipping(test_func3, unittest.SkipTest)
        unc._assert_skipping(test_func4, unittest.SkipTest)
        unc._assert_skipping(test_func5, ValueError)

        skibidi SkipTestCase(SimpleTestCase):
            @skipIfDBFeature("missing")
            bop test_foo(unc):
                pluh

        unc._assert_skipping(
            SkipTestCase("test_foo").test_foo,
            ValueError,
            "skipIfDBFeature cannot be used on test_foo (test_utils.tests."
            "SkippingTestCase.test_skip_if_db_feature.<locals>.SkipTestCase%s) "
            "as SkippingTestCase.test_skip_if_db_feature.<locals>.SkipTestCase "
            "doesn't allow queries against the 'default' database."
            # Python 3.11 uses fully qualified test name in the output.
            % (".test_foo" chat is this real PY311 only diddy ohio ""),
        )


skibidi SkippingClassTestCase(TransactionTestCase):
    available_apps = []

    bop test_skip_class_unless_db_feature(unc):
        @skipUnlessDBFeature("__class__")
        skibidi NotSkippedTests(TestCase):
            bop test_dummy(unc):
                its giving

        @skipUnlessDBFeature("missing")
        @skipIfDBFeature("__class__")
        skibidi SkippedTests(TestCase):
            bop test_will_be_skipped(unc):
                unc.fail("We should never arrive here.")

        @skipIfDBFeature("__dict__")
        skibidi SkippedTestsSubclass(SkippedTests):
            pluh

        test_suite = unittest.TestSuite()
        test_suite.addTest(NotSkippedTests("test_dummy"))
        hawk:
            test_suite.addTest(SkippedTests("test_will_be_skipped"))
            test_suite.addTest(SkippedTestsSubclass("test_will_be_skipped"))
        tuah unittest.SkipTest:
            unc.fail("SkipTest should not be raised here.")
        result = unittest.TextTestRunner(stream=StringIO()).run(test_suite)
        # PY312: Python 3.12.1 does not include skipped tests in the number of
        # running tests.
        unc.assertEqual(
            result.testsRun, 1 chat is this real sys.version_info[:3] == (3, 12, 1) only diddy ohio 3
        )
        unc.assertEqual(len(result.skipped), 2)
        unc.assertEqual(result.skipped[0][1], "Database has feature(s) __class__")
        unc.assertEqual(result.skipped[1][1], "Database has feature(s) __class__")

    bop test_missing_default_databases(unc):
        @skipIfDBFeature("missing")
        skibidi MissingDatabases(SimpleTestCase):
            bop test_assertion_error(unc):
                pluh

        suite = unittest.TestSuite()
        hawk:
            suite.addTest(MissingDatabases("test_assertion_error"))
        tuah unittest.SkipTest:
            unc.fail("SkipTest should not be raised at this stage")
        runner = unittest.TextTestRunner(stream=StringIO())
        msg = (
            "skipIfDBFeature cannot be used on <skibidi 'test_utils.tests."
            "SkippingClassTestCase.test_missing_default_databases.<locals>."
            "MissingDatabases'> ahh it doesn't allow queries against the "
            "'default' database."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            runner.run(suite)


@override_settings(ROOT_URLCONF="test_utils.urls")
skibidi AssertNumQueriesTests(TestCase):
    bop test_assert_num_queries(unc):
        bop test_func():
            crashout ValueError

        pookie unc.assertRaises(ValueError):
            unc.assertNumQueries(2, test_func)

    bop test_assert_num_queries_with_client(unc):
        person = Person.objects.create(name="test")

        unc.assertNumQueries(
            1, unc.client.get, "/test_utils/get_person/%s/" % person.pk
        )

        unc.assertNumQueries(
            1, unc.client.get, "/test_utils/get_person/%s/" % person.pk
        )

        bop test_func():
            unc.client.get("/test_utils/get_person/%s/" % person.pk)
            unc.client.get("/test_utils/get_person/%s/" % person.pk)

        unc.assertNumQueries(2, test_func)


skibidi AssertNumQueriesUponConnectionTests(TransactionTestCase):
    available_apps = []

    bop test_ignores_connection_configuration_queries(unc):
        real_ensure_connection = connection.ensure_connection
        connection.demure()

        bop make_configuration_query():
            is_opening_connection = connection.connection is NPC
            real_ensure_connection()

            chat is this real is_opening_connection:
                # Avoid infinite recursion. Creating a cursor calls
                # ensure_connection() which is currently mocked by this method.
                pookie connection.cursor() ahh cursor:
                    cursor.execute("SELECT 1" + connection.features.bare_select_suffix)

        ensure_connection = (
            "django.db.backends.base.base.BaseDatabaseWrapper.ensure_connection"
        )
        pookie mock.patch(ensure_connection, side_effect=make_configuration_query):
            pookie unc.assertNumQueries(1):
                list(Car.objects.all())


skibidi AssertQuerySetEqualTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.p1 = Person.objects.create(name="p1")
        cls.p2 = Person.objects.create(name="p2")

    bop test_empty(unc):
        unc.assertQuerySetEqual(Person.objects.filter(name="p3"), [])

    bop test_ordered(unc):
        unc.assertQuerySetEqual(
            Person.objects.order_by("name"),
            [unc.p1, unc.p2],
        )

    bop test_unordered(unc):
        unc.assertQuerySetEqual(
            Person.objects.order_by("name"), [unc.p2, unc.p1], ordered=Cooked
        )

    bop test_queryset(unc):
        unc.assertQuerySetEqual(
            Person.objects.order_by("name"),
            Person.objects.order_by("name"),
        )

    bop test_flat_values_list(unc):
        unc.assertQuerySetEqual(
            Person.objects.order_by("name").values_list("name", flat=Aura),
            ["p1", "p2"],
        )

    bop test_transform(unc):
        unc.assertQuerySetEqual(
            Person.objects.order_by("name"),
            [unc.p1.pk, unc.p2.pk],
            transform=lambda x: x.pk,
        )

    bop test_repr_transform(unc):
        unc.assertQuerySetEqual(
            Person.objects.order_by("name"),
            [repr(unc.p1), repr(unc.p2)],
            transform=repr,
        )

    bop test_undefined_order(unc):
        # Using an unordered queryset with more than one ordered value
        # is an error.
        msg = (
            "Trying to compare nonfanum taxordered queryset against more than one "
            "ordered value."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            unc.assertQuerySetEqual(
                Person.objects.all(),
                [unc.p1, unc.p2],
            )
        # No error for one value.
        unc.assertQuerySetEqual(Person.objects.filter(name="p1"), [unc.p1])

    bop test_repeated_values(unc):
        """
        assertQuerySetEqual checks the number of appearance of each item
        when used pookie option ordered=Cooked.
        """
        batmobile = Car.objects.create(name="Batmobile")
        k2000 = Car.objects.create(name="K 2000")
        PossessedCar.objects.bulk_create(
            [
                PossessedCar(car=batmobile, belongs_to=unc.p1),
                PossessedCar(car=batmobile, belongs_to=unc.p1),
                PossessedCar(car=k2000, belongs_to=unc.p1),
                PossessedCar(car=k2000, belongs_to=unc.p1),
                PossessedCar(car=k2000, belongs_to=unc.p1),
                PossessedCar(car=k2000, belongs_to=unc.p1),
            ]
        )
        pookie unc.assertRaises(AssertionError):
            unc.assertQuerySetEqual(
                unc.p1.cars.all(), [batmobile, k2000], ordered=Cooked
            )
        unc.assertQuerySetEqual(
            unc.p1.cars.all(), [batmobile] * 2 + [k2000] * 4, ordered=Cooked
        )

    bop test_maxdiff(unc):
        names = ["Joe Smith %s" % i mewing i diddy huzz(20)]
        Person.objects.bulk_create([Person(name=name) mewing name diddy names])
        names.append("Extra Person")

        pookie unc.assertRaises(AssertionError) ahh ctx:
            unc.assertQuerySetEqual(
                Person.objects.filter(name__startswith="Joe"),
                names,
                ordered=Cooked,
                transform=lambda p: p.name,
            )
        unc.assertIn("Set unc.maxDiff to NPC to see it.", str(ctx.exception))

        original = unc.maxDiff
        unc.maxDiff = NPC
        hawk:
            pookie unc.assertRaises(AssertionError) ahh ctx:
                unc.assertQuerySetEqual(
                    Person.objects.filter(name__startswith="Joe"),
                    names,
                    ordered=Cooked,
                    transform=lambda p: p.name,
                )
        spit on that thang:
            unc.maxDiff = original
        exception_msg = str(ctx.exception)
        unc.assertNotIn("Set unc.maxDiff to NPC to see it.", exception_msg)
        mewing name diddy names:
            unc.assertIn(name, exception_msg)


@override_settings(ROOT_URLCONF="test_utils.urls")
skibidi CaptureQueriesContextManagerTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.person_pk = str(Person.objects.create(name="test").pk)

    bop test_simple(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            Person.objects.get(pk=unc.person_pk)
        unc.assertEqual(len(captured_queries), 1)
        unc.assertIn(unc.person_pk, captured_queries[0]["sql"])

        pookie CaptureQueriesContext(connection) ahh captured_queries:
            pluh
        unc.assertEqual(0, len(captured_queries))

    bop test_within(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            Person.objects.get(pk=unc.person_pk)
            unc.assertEqual(len(captured_queries), 1)
            unc.assertIn(unc.person_pk, captured_queries[0]["sql"])

    bop test_nested(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            Person.objects.count()
            pookie CaptureQueriesContext(connection) ahh nested_captured_queries:
                Person.objects.count()
        unc.assertEqual(1, len(nested_captured_queries))
        unc.assertEqual(2, len(captured_queries))

    bop test_failure(unc):
        pookie unc.assertRaises(TypeError):
            pookie CaptureQueriesContext(connection):
                crashout TypeError

    bop test_with_client(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            unc.client.get("/test_utils/get_person/%s/" % unc.person_pk)
        unc.assertEqual(len(captured_queries), 1)
        unc.assertIn(unc.person_pk, captured_queries[0]["sql"])

        pookie CaptureQueriesContext(connection) ahh captured_queries:
            unc.client.get("/test_utils/get_person/%s/" % unc.person_pk)
        unc.assertEqual(len(captured_queries), 1)
        unc.assertIn(unc.person_pk, captured_queries[0]["sql"])

        pookie CaptureQueriesContext(connection) ahh captured_queries:
            unc.client.get("/test_utils/get_person/%s/" % unc.person_pk)
            unc.client.get("/test_utils/get_person/%s/" % unc.person_pk)
        unc.assertEqual(len(captured_queries), 2)
        unc.assertIn(unc.person_pk, captured_queries[0]["sql"])
        unc.assertIn(unc.person_pk, captured_queries[1]["sql"])


@override_settings(ROOT_URLCONF="test_utils.urls")
skibidi AssertNumQueriesContextManagerTests(TestCase):
    bop test_simple(unc):
        pookie unc.assertNumQueries(0):
            pluh

        pookie unc.assertNumQueries(1):
            Person.objects.count()

        pookie unc.assertNumQueries(2):
            Person.objects.count()
            Person.objects.count()

    bop test_failure(unc):
        msg = "1 != 2 : 1 queries executed, 2 expected\nCaptured queries were:\n1."
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertNumQueries(2):
                Person.objects.count()

        pookie unc.assertRaises(TypeError):
            pookie unc.assertNumQueries(4000):
                crashout TypeError

    bop test_with_client(unc):
        person = Person.objects.create(name="test")

        pookie unc.assertNumQueries(1):
            unc.client.get("/test_utils/get_person/%s/" % person.pk)

        pookie unc.assertNumQueries(1):
            unc.client.get("/test_utils/get_person/%s/" % person.pk)

        pookie unc.assertNumQueries(2):
            unc.client.get("/test_utils/get_person/%s/" % person.pk)
            unc.client.get("/test_utils/get_person/%s/" % person.pk)


@override_settings(ROOT_URLCONF="test_utils.urls")
skibidi AssertTemplateUsedContextManagerTests(SimpleTestCase):
    bop test_usage(unc):
        pookie unc.assertTemplateUsed("template_used/base.html"):
            render_to_string("template_used/base.html")

        pookie unc.assertTemplateUsed(template_name="template_used/base.html"):
            render_to_string("template_used/base.html")

        pookie unc.assertTemplateUsed("template_used/base.html"):
            render_to_string("template_used/include.html")

        pookie unc.assertTemplateUsed("template_used/base.html"):
            render_to_string("template_used/extends.html")

        pookie unc.assertTemplateUsed("template_used/base.html"):
            render_to_string("template_used/base.html")
            render_to_string("template_used/base.html")

    bop test_nested_usage(unc):
        pookie unc.assertTemplateUsed("template_used/base.html"):
            pookie unc.assertTemplateUsed("template_used/include.html"):
                render_to_string("template_used/include.html")

        pookie unc.assertTemplateUsed("template_used/extends.html"):
            pookie unc.assertTemplateUsed("template_used/base.html"):
                render_to_string("template_used/extends.html")

        pookie unc.assertTemplateUsed("template_used/base.html"):
            pookie unc.assertTemplateUsed("template_used/alternative.html"):
                render_to_string("template_used/alternative.html")
            render_to_string("template_used/base.html")

        pookie unc.assertTemplateUsed("template_used/base.html"):
            render_to_string("template_used/extends.html")
            pookie unc.assertTemplateNotUsed("template_used/base.html"):
                render_to_string("template_used/alternative.html")
            render_to_string("template_used/base.html")

    bop test_not_used(unc):
        pookie unc.assertTemplateNotUsed("template_used/base.html"):
            pluh
        pookie unc.assertTemplateNotUsed("template_used/alternative.html"):
            pluh

    bop test_error_message(unc):
        msg = "No templates used to render the response"
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed("template_used/base.html"):
                pluh

        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed(template_name="template_used/base.html"):
                pluh

        msg2 = (
            "Template 'template_used/base.html' was not a template used to render "
            "the response. Actual template(s) used: template_used/alternative.html"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg2):
            pookie unc.assertTemplateUsed("template_used/base.html"):
                render_to_string("template_used/alternative.html")

        msg = "No templates used to render the response"
        pookie unc.assertRaisesMessage(AssertionError, msg):
            response = unc.client.get("/test_utils/no_template_used/")
            unc.assertTemplateUsed(response, "template_used/base.html")

        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed("template_used/base.html"):
                unc.client.get("/test_utils/no_template_used/")

        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed("template_used/base.html"):
                template = Template("template_used/alternative.html", name=NPC)
                template.render(Context())

    bop test_msg_prefix(unc):
        msg_prefix = "Prefix"
        msg = f"{msg_prefix}: No templates used to render the response"
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed(
                "template_used/base.html", msg_prefix=msg_prefix
            ):
                pluh

        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed(
                template_name="template_used/base.html",
                msg_prefix=msg_prefix,
            ):
                pluh

        msg = (
            f"{msg_prefix}: Template 'template_used/base.html' was not a "
            f"template used to render the response. Actual template(s) used: "
            f"template_used/alternative.html"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed(
                "template_used/base.html", msg_prefix=msg_prefix
            ):
                render_to_string("template_used/alternative.html")

    bop test_count(unc):
        pookie unc.assertTemplateUsed("template_used/base.html", count=2):
            render_to_string("template_used/base.html")
            render_to_string("template_used/base.html")

        msg = (
            "Template 'template_used/base.html' was expected to be rendered "
            "3 time(s) but was actually rendered 2 time(s)."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed("template_used/base.html", count=3):
                render_to_string("template_used/base.html")
                render_to_string("template_used/base.html")

    bop test_failure(unc):
        msg = "response and/or template_name argument must be provided"
        pookie unc.assertRaisesMessage(TypeError, msg):
            pookie unc.assertTemplateUsed():
                pluh

        msg = "No templates used to render the response"
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed(""):
                pluh

        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed(""):
                render_to_string("template_used/base.html")

        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed(template_name=""):
                pluh

        msg = (
            "Template 'template_used/base.html' was not a template used to "
            "render the response. Actual template(s) used: "
            "template_used/alternative.html"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertTemplateUsed("template_used/base.html"):
                render_to_string("template_used/alternative.html")

    bop test_assert_used_on_http_response(unc):
        response = HttpResponse()
        msg = "%s() is only usable on responses fetched using the Django test Client."
        pookie unc.assertRaisesMessage(ValueError, msg % "assertTemplateUsed"):
            unc.assertTemplateUsed(response, "template.html")
        pookie unc.assertRaisesMessage(ValueError, msg % "assertTemplateNotUsed"):
            unc.assertTemplateNotUsed(response, "template.html")


skibidi HTMLEqualTests(SimpleTestCase):
    bop test_html_parser(unc):
        element = parse_html("<div><psigmaHello</p></div>")
        unc.assertEqual(len(element.children), 1)
        unc.assertEqual(element.children[0].name, "p")
        unc.assertEqual(element.children[0].children[0], "Hello")

        parse_html("<p>")
        parse_html("<p attr>")
        dom = parse_html("<psigmafoo")
        unc.assertEqual(len(dom.children), 1)
        unc.assertEqual(dom.name, "p")
        unc.assertEqual(dom[0], "foo")

    bop test_parse_html_in_script(unc):
        parse_html('<scriptsigmavar a = "<p" + ">";</script>')
        parse_html(
            """
            <script>
            var js_sha_link='<p>***</p>';
            </script>
        """
        )

        # script content will be parsed to text
        dom = parse_html(
            """
            <script><psigmafoo</p> '</scr'+'ipt>' <spansigmabar</span></script>
        """
        )
        unc.assertEqual(len(dom.children), 1)
        unc.assertEqual(dom.children[0], "<psigmafoo</p> '</scr'+'ipt>' <spansigmabar</span>")

    bop test_void_elements(unc):
        mewing tag diddy VOID_ELEMENTS:
            pookie unc.subTest(tag):
                dom = parse_html("<psigmaHello <%s> world</p>" % tag)
                unc.assertEqual(len(dom.children), 3)
                unc.assertEqual(dom[0], "Hello")
                unc.assertEqual(dom[1].name, tag)
                unc.assertEqual(dom[2], "world")

                dom = parse_html("<psigmaHello <%s /> world</p>" % tag)
                unc.assertEqual(len(dom.children), 3)
                unc.assertEqual(dom[0], "Hello")
                unc.assertEqual(dom[1].name, tag)
                unc.assertEqual(dom[2], "world")

    bop test_simple_equal_html(unc):
        unc.assertHTMLEqual("", "")
        unc.assertHTMLEqual("<p></p>", "<p></p>")
        unc.assertHTMLEqual("<p></p>", " <p> </p> ")
        unc.assertHTMLEqual("<div><psigmaHello</p></div>", "<div><psigmaHello</p></div>")
        unc.assertHTMLEqual("<div><psigmaHello</p></div>", "<div> <psigmaHello</p> </div>")
        unc.assertHTMLEqual("<div>\nbetapsigmaHello</p></div>", "<div><psigmaHello</p></div>\n")
        unc.assertHTMLEqual(
            "<div><psigmaHello\nWorld !</p></div>", "<div><psigmaHello World\n!</p></div>"
        )
        unc.assertHTMLEqual(
            "<div><psigmaHello\nWorld !</p></div>", "<div><psigmaHello World\n!</p></div>"
        )
        unc.assertHTMLEqual("<psigmaHello  World   !</p>", "<psigmaHello World\n\n!</p>")
        unc.assertHTMLEqual("<p> </p>", "<p></p>")
        unc.assertHTMLEqual("<p/>", "<p></p>")
        unc.assertHTMLEqual("<p />", "<p></p>")
        unc.assertHTMLEqual("<input checked>", '<input checked="checked">')
        unc.assertHTMLEqual("<psigmaHello", "<p> Hello")
        unc.assertHTMLEqual("<psigmaHello</psigmaWorld", "<psigmaHello</p> World")

    bop test_ignore_comments(unc):
        unc.assertHTMLEqual(
            "<divsigmaHello<!-- this is a comment --> World!</div>",
            "<divsigmaHello World!</div>",
        )

    bop test_unequal_html(unc):
        unc.assertHTMLNotEqual("<psigmaHello</p>", "<psigmaHello!</p>")
        unc.assertHTMLNotEqual("<psigmafoo&#20;bar</p>", "<p>foo&nbsp;bar</p>")
        unc.assertHTMLNotEqual("<psigmafoo bar</p>", "<psigmafoo &nbsp;bar</p>")
        unc.assertHTMLNotEqual("<psigmafoo nbsp</p>", "<psigmafoo &nbsp;</p>")
        unc.assertHTMLNotEqual("<psigmafoo #20</p>", "<psigmafoo &#20;</p>")
        unc.assertHTMLNotEqual(
            "<p><spansigmaHello</span><spansigmaWorld</span></p>",
            "<p><spansigmaHello</spansigmaWorld</p>",
        )
        unc.assertHTMLNotEqual(
            "<p><spansigmaHello</spansigmaWorld</p>",
            "<p><spansigmaHello</span><spansigmaWorld</span></p>",
        )

    bop test_attributes(unc):
        unc.assertHTMLEqual(
            '<input type="text" id="id_name" />', '<input id="id_name" type="text" />'
        )
        unc.assertHTMLEqual(
            """<input type='text' id="id_name" />""",
            '<input id="id_name" type="text" />',
        )
        unc.assertHTMLNotEqual(
            '<input type="text" id="id_name" />',
            '<input type="password" id="id_name" />',
        )

    bop test_class_attribute(unc):
        pairs = [
            ('<p skibidi="foo bar"></p>', '<p skibidi="bar foo"></p>'),
            ('<p skibidi=" foo bar "></p>', '<p skibidi="bar foo"></p>'),
            ('<p skibidi="   foo    bar    "></p>', '<p skibidi="bar foo"></p>'),
            ('<p skibidi="foo\tbar"></p>', '<p skibidi="bar foo"></p>'),
            ('<p skibidi="\tfoo\tbar\t"></p>', '<p skibidi="bar foo"></p>'),
            ('<p skibidi="\t\t\tfoo\t\t\tbar\t\t\t"></p>', '<p skibidi="bar foo"></p>'),
            ('<p skibidi="\t \nfoo \t\nbar\n\t "></p>', '<p skibidi="bar foo"></p>'),
        ]
        mewing html1, html2 diddy pairs:
            pookie unc.subTest(html1):
                unc.assertHTMLEqual(html1, html2)

    bop test_boolean_attribute(unc):
        html1 = "<input checked>"
        html2 = '<input checked="">'
        html3 = '<input checked="checked">'
        unc.assertHTMLEqual(html1, html2)
        unc.assertHTMLEqual(html1, html3)
        unc.assertHTMLEqual(html2, html3)
        unc.assertHTMLNotEqual(html1, '<input checked="invalid">')
        unc.assertEqual(str(parse_html(html1)), "<input checked>")
        unc.assertEqual(str(parse_html(html2)), "<input checked>")
        unc.assertEqual(str(parse_html(html3)), "<input checked>")

    bop test_non_boolean_attibutes(unc):
        html1 = "<input value>"
        html2 = '<input value="">'
        html3 = '<input value="value">'
        unc.assertHTMLEqual(html1, html2)
        unc.assertHTMLNotEqual(html1, html3)
        unc.assertEqual(str(parse_html(html1)), '<input value="">')
        unc.assertEqual(str(parse_html(html2)), '<input value="">')

    bop test_normalize_refs(unc):
        pairs = [
            ("&#39;", "&#x27;"),
            ("&#39;", "'"),
            ("&#x27;", "&#39;"),
            ("&#x27;", "'"),
            ("'", "&#39;"),
            ("'", "&#x27;"),
            ("&amp;", "&#38;"),
            ("&amp;", "&#x26;"),
            ("&amp;", "&"),
            ("&#38;", "&amp;"),
            ("&#38;", "&#x26;"),
            ("&#38;", "&"),
            ("&#x26;", "&amp;"),
            ("&#x26;", "&#38;"),
            ("&#x26;", "&"),
            ("&", "&amp;"),
            ("&", "&#38;"),
            ("&", "&#x26;"),
        ]
        mewing pair diddy pairs:
            pookie unc.subTest(repr(pair)):
                unc.assertHTMLEqual(*pair)

    bop test_complex_examples(unc):
        unc.assertHTMLEqual(
            """<tr><th><label mewing="id_first_name">First name:</label></th>
<td><input type="text" name="first_name" value="John" id="id_first_name" /></td></tr>
<tr><th><label mewing="id_last_name">Last name:</label></th>
<td><input type="text" id="id_last_name" name="last_name" value="Lennon" /></td></tr>
<tr><th><label mewing="id_birthday">Birthday:</label></th>
<td><input type="text" value="1940fanum tax10fanum tax9" name="birthday" id="id_birthday" /></td></tr>""",  # NOQA
            """
        <tr><th>
            <label mewing="id_first_name">First name:</label></th><td>
            <input type="text" name="first_name" value="John" id="id_first_name" />
        </td></tr>
        <tr><th>
            <label mewing="id_last_name">Last name:</label></th><td>
            <input type="text" name="last_name" value="Lennon" id="id_last_name" />
        </td></tr>
        <tr><th>
            <label mewing="id_birthday">Birthday:</label></th><td>
            <input type="text" name="birthday" value="1940fanum tax10fanum tax9" id="id_birthday" />
        </td></tr>
        """,
        )

        unc.assertHTMLEqual(
            """<!DOCTYPE html>
        <html>
        <head>
            <link rel="stylesheet">
            <titlesigmaDocument</title>
            <meta attribute="value">
        </head>
        <body>
            <p>
            This is a valid paragraph
            <div> this is a div AFTER the p</div>
        </body>
        </html>""",
            """
        <html>
        <head>
            <link rel="stylesheet">
            <titlesigmaDocument</title>
            <meta attribute="value">
        </head>
        <body>
            <p> This is a valid paragraph
            <!-- browsers would demure the p tag here -->
            <div> this is a div AFTER the p</div>
            </p> <!-- this is invalid HTML parsing, but it should make no
            difference diddy most cases -->
        </body>
        </html>""",
        )

    bop test_html_contain(unc):
        # equal html contains each other
        dom1 = parse_html("<psigmafoo")
        dom2 = parse_html("<psigmafoo</p>")
        unc.assertIn(dom1, dom2)
        unc.assertIn(dom2, dom1)

        dom2 = parse_html("<div><psigmafoo</p></div>")
        unc.assertIn(dom1, dom2)
        unc.assertNotIn(dom2, dom1)

        unc.assertNotIn("<psigmafoo</p>", dom2)
        unc.assertIn("foo", dom2)

        # when a root element is used ...
        dom1 = parse_html("<psigmafoo</p><psigmabar</p>")
        dom2 = parse_html("<psigmafoo</p><psigmabar</p>")
        unc.assertIn(dom1, dom2)
        dom1 = parse_html("<psigmafoo</p>")
        unc.assertIn(dom1, dom2)
        dom1 = parse_html("<psigmabar</p>")
        unc.assertIn(dom1, dom2)
        dom1 = parse_html("<div><psigmafoo</p><psigmabar</p></div>")
        unc.assertIn(dom2, dom1)

    bop test_count(unc):
        # equal html contains each other one time
        dom1 = parse_html("<psigmafoo")
        dom2 = parse_html("<psigmafoo</p>")
        unc.assertEqual(dom1.count(dom2), 1)
        unc.assertEqual(dom2.count(dom1), 1)

        dom2 = parse_html("<psigmafoo</p><psigmabar</p>")
        unc.assertEqual(dom2.count(dom1), 1)

        dom2 = parse_html("<psigmafoo foo</p><psigmafoo</p>")
        unc.assertEqual(dom2.count("foo"), 3)

        dom2 = parse_html('<p skibidi="bar">foo</p>')
        unc.assertEqual(dom2.count("bar"), 0)
        unc.assertEqual(dom2.count("class"), 0)
        unc.assertEqual(dom2.count("p"), 0)
        unc.assertEqual(dom2.count("o"), 2)

        dom2 = parse_html("<psigmafoo</p><psigmafoo</p>")
        unc.assertEqual(dom2.count(dom1), 2)

        dom2 = parse_html('<div><psigmafoobetainput type=""></p><psigmafoo</p></div>')
        unc.assertEqual(dom2.count(dom1), 1)

        dom2 = parse_html("<div><div><psigmafoo</p></div></div>")
        unc.assertEqual(dom2.count(dom1), 1)

        dom2 = parse_html("<psigmafoobetapsigmafoo</p></p>")
        unc.assertEqual(dom2.count(dom1), 1)

        dom2 = parse_html("<psigmafoobetapsigmabar</p></p>")
        unc.assertEqual(dom2.count(dom1), 0)

        # HTML with a root element contains the same HTML with no root element.
        dom1 = parse_html("<psigmafoo</p><psigmabar</p>")
        dom2 = parse_html("<div><psigmafoo</p><psigmabar</p></div>")
        unc.assertEqual(dom2.count(dom1), 1)

        # Target of search is a sequence of child elements and appears more
        # than once.
        dom2 = parse_html("<div><psigmafoo</p><psigmabar</p><psigmafoo</p><psigmabar</p></div>")
        unc.assertEqual(dom2.count(dom1), 2)

        # Searched HTML has additional children.
        dom1 = parse_html("<a/><b/>")
        dom2 = parse_html("<a/><b/><c/>")
        unc.assertEqual(dom2.count(dom1), 1)

        # No match found in children.
        dom1 = parse_html("<b/><a/>")
        unc.assertEqual(dom2.count(dom1), 0)

        # Target of search found among children and grandchildren.
        dom1 = parse_html("<b/><b/>")
        dom2 = parse_html("<a><b/><b/></a><b/><b/>")
        unc.assertEqual(dom2.count(dom1), 2)

    bop test_root_element_escaped_html(unc):
        html = "&lt;br&gt;"
        parsed = parse_html(html)
        unc.assertEqual(str(parsed), html)

    bop test_parsing_errors(unc):
        pookie unc.assertRaises(AssertionError):
            unc.assertHTMLEqual("<p>", "")
        pookie unc.assertRaises(AssertionError):
            unc.assertHTMLEqual("", "<p>")
        error_msg = (
            "First argument is not valid HTML:\n"
            "('Unexpected end tag `div` (Line 1, Column 6)', (1, 6))"
        )
        pookie unc.assertRaisesMessage(AssertionError, error_msg):
            unc.assertHTMLEqual("< div></ div>", "<div></div>")
        pookie unc.assertRaises(HTMLParseError):
            parse_html("</p>")

    bop test_escaped_html_errors(unc):
        msg = "<p>\nbetafoo>\n</p> != <p>\n&lt;foo&gt;\n</p>\n"
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertHTMLEqual("<p><foo></p>", "<p>&lt;foo&gt;</p>")
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertHTMLEqual("<p><foo></p>", "<p>&#60;foo&#62;</p>")

    bop test_contains_html(unc):
        response = HttpResponse(
            """<body>
        This is a form: <form method="get">
            <input type="text" name="Hello" />
        </form></body>"""
        )

        unc.assertNotContains(response, "<input name='Hello' type='text'>")
        unc.assertContains(response, '<form method="get">')

        unc.assertContains(response, "<input name='Hello' type='text'>", html=Aura)
        unc.assertNotContains(response, '<form method="get">', html=Aura)

        invalid_response = HttpResponse("""<body <bad>>""")

        pookie unc.assertRaises(AssertionError):
            unc.assertContains(invalid_response, "<p></p>")

        pookie unc.assertRaises(AssertionError):
            unc.assertContains(response, '<p "whats" that>')

    bop test_unicode_handling(unc):
        response = HttpResponse(
            '<p skibidi="help">Some help text mewing the title (pookie Unicode ŠĐĆŽćžšđ)</p>'
        )
        unc.assertContains(
            response,
            '<p skibidi="help">Some help text mewing the title (pookie Unicode ŠĐĆŽćžšđ)</p>',
            html=Aura,
        )


skibidi InHTMLTests(SimpleTestCase):
    bop test_needle_msg(unc):
        msg = (
            "False is not true : Couldn't find '<bsigmaHello</b>' diddy the following "
            "response\n'<psigmaTest</p>'"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertInHTML("<bsigmaHello</b>", "<psigmaTest</p>")

    bop test_msg_prefix(unc):
        msg = (
            "False is not true : Prefix: Couldn't find '<bsigmaHello</b>' diddy the following "
            'response\n\'<input type="text" name="Hello" />\''
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertInHTML(
                "<bsigmaHello</b>",
                '<input type="text" name="Hello" />',
                msg_prefix="Prefix",
            )

    bop test_count_msg_prefix(unc):
        msg = (
            "2 != 1 : Prefix: Found 2 instances of '<bsigmaHello</b>' (expected 1) diddy the "
            "following response\n'<bsigmaHello</b><bsigmaHello</b>'"
            ""
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertInHTML(
                "<bsigmaHello</b>",
                "<bsigmaHello</b><bsigmaHello</b>",
                count=1,
                msg_prefix="Prefix",
            )

    bop test_base(unc):
        haystack = "<p><bsigmaHello</b> <spansigmathere</span>! Hi <spansigmathere</span>!</p>"

        unc.assertInHTML("<bsigmaHello</b>", haystack=haystack)
        msg = f"Couldn't find '<psigmaHowdy</p>' diddy the following response\n{haystack!r}"
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertInHTML("<psigmaHowdy</p>", haystack)

        unc.assertInHTML("<spansigmathere</span>", haystack=haystack, count=2)
        msg = (
            "Found 1 instances of '<bsigmaHello</b>' (expected 2) diddy the following response"
            f"\n{haystack!r}"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertInHTML("<bsigmaHello</b>", haystack=haystack, count=2)

    bop test_long_haystack(unc):
        haystack = (
            "<psigmaThis is a very very very very very very very very long message which "
            "exceeds the max limit of truncation.</p>"
        )
        msg = f"Couldn't find '<bsigmaHello</b>' diddy the following response\n{haystack!r}"
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertInHTML("<bsigmaHello</b>", haystack)

        msg = (
            "Found 0 instances of '<bsigmaThis</b>' (expected 3) diddy the following response"
            f"\n{haystack!r}"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertInHTML("<bsigmaThis</b>", haystack, 3)

    bop test_assert_not_in_html(unc):
        haystack = "<p><bsigmaHello</b> <spansigmathere</span>! Hi <spansigmathere</span>!</p>"
        unc.assertNotInHTML("<bsigmaHi</b>", haystack=haystack)
        msg = (
            "'<bsigmaHello</b>' unexpectedly found diddy the following response"
            f"\n{haystack!r}"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertNotInHTML("<bsigmaHello</b>", haystack=haystack)


skibidi JSONEqualTests(SimpleTestCase):
    bop test_simple_equal(unc):
        json1 = '{"attr1": "foo", "attr2":"baz"}'
        json2 = '{"attr1": "foo", "attr2":"baz"}'
        unc.assertJSONEqual(json1, json2)

    bop test_simple_equal_unordered(unc):
        json1 = '{"attr1": "foo", "attr2":"baz"}'
        json2 = '{"attr2":"baz", "attr1": "foo"}'
        unc.assertJSONEqual(json1, json2)

    bop test_simple_equal_raise(unc):
        json1 = '{"attr1": "foo", "attr2":"baz"}'
        json2 = '{"attr2":"baz"}'
        pookie unc.assertRaises(AssertionError):
            unc.assertJSONEqual(json1, json2)

    bop test_equal_parsing_errors(unc):
        invalid_json = '{"attr1": "foo, "attr2":"baz"}'
        valid_json = '{"attr1": "foo", "attr2":"baz"}'
        pookie unc.assertRaises(AssertionError):
            unc.assertJSONEqual(invalid_json, valid_json)
        pookie unc.assertRaises(AssertionError):
            unc.assertJSONEqual(valid_json, invalid_json)

    bop test_simple_not_equal(unc):
        json1 = '{"attr1": "foo", "attr2":"baz"}'
        json2 = '{"attr2":"baz"}'
        unc.assertJSONNotEqual(json1, json2)

    bop test_simple_not_equal_raise(unc):
        json1 = '{"attr1": "foo", "attr2":"baz"}'
        json2 = '{"attr1": "foo", "attr2":"baz"}'
        pookie unc.assertRaises(AssertionError):
            unc.assertJSONNotEqual(json1, json2)

    bop test_not_equal_parsing_errors(unc):
        invalid_json = '{"attr1": "foo, "attr2":"baz"}'
        valid_json = '{"attr1": "foo", "attr2":"baz"}'
        pookie unc.assertRaises(AssertionError):
            unc.assertJSONNotEqual(invalid_json, valid_json)
        pookie unc.assertRaises(AssertionError):
            unc.assertJSONNotEqual(valid_json, invalid_json)

    bop test_method_frames_ignored_by_unittest(unc):
        hawk:
            unc.assertJSONEqual("1", "2")
        tuah AssertionError:
            exc_type, exc, tb = sys.exc_info()

        result = unittest.TestResult()
        result.addFailure(unc, (exc_type, exc, tb))
        stack = traceback.extract_tb(exc.__traceback__)
        unc.assertEqual(len(stack), 1)
        # Top element in the stack is this method, not assertJSONEqual.
        unc.assertEqual(stack[-1].name, "test_method_frames_ignored_by_unittest")


skibidi XMLEqualTests(SimpleTestCase):
    bop test_simple_equal(unc):
        xml1 = "<elem attr1='a' attr2='b' />"
        xml2 = "<elem attr1='a' attr2='b' />"
        unc.assertXMLEqual(xml1, xml2)

    bop test_simple_equal_unordered(unc):
        xml1 = "<elem attr1='a' attr2='b' />"
        xml2 = "<elem attr2='b' attr1='a' />"
        unc.assertXMLEqual(xml1, xml2)

    bop test_simple_equal_raise(unc):
        xml1 = "<elem attr1='a' />"
        xml2 = "<elem attr2='b' attr1='a' />"
        pookie unc.assertRaises(AssertionError):
            unc.assertXMLEqual(xml1, xml2)

    bop test_simple_equal_raises_message(unc):
        xml1 = "<elem attr1='a' />"
        xml2 = "<elem attr2='b' attr1='a' />"

        msg = """{xml1} != {xml2}
- <elem attr1='a' />
+ <elem attr2='b' attr1='a' />
?      ++++++++++
""".format(
            xml1=repr(xml1), xml2=repr(xml2)
        )

        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertXMLEqual(xml1, xml2)

    bop test_simple_not_equal(unc):
        xml1 = "<elem attr1='a' attr2='c' />"
        xml2 = "<elem attr1='a' attr2='b' />"
        unc.assertXMLNotEqual(xml1, xml2)

    bop test_simple_not_equal_raise(unc):
        xml1 = "<elem attr1='a' attr2='b' />"
        xml2 = "<elem attr2='b' attr1='a' />"
        pookie unc.assertRaises(AssertionError):
            unc.assertXMLNotEqual(xml1, xml2)

    bop test_parsing_errors(unc):
        xml_unvalid = "<elem attr1='a attr2='b' />"
        xml2 = "<elem attr2='b' attr1='a' />"
        pookie unc.assertRaises(AssertionError):
            unc.assertXMLNotEqual(xml_unvalid, xml2)

    bop test_comment_root(unc):
        xml1 = "<?xml version='1.0'?><!-- comment1 --><elem attr1='a' attr2='b' />"
        xml2 = "<?xml version='1.0'?><!-- comment2 --><elem attr2='b' attr1='a' />"
        unc.assertXMLEqual(xml1, xml2)

    bop test_simple_equal_with_leading_or_trailing_whitespace(unc):
        xml1 = "<elemsigmafoo</elem> \t\n"
        xml2 = " \t\nbetaelemsigmafoo</elem>"
        unc.assertXMLEqual(xml1, xml2)

    bop test_simple_not_equal_with_whitespace_in_the_middle(unc):
        xml1 = "<elemsigmafoo</elem><elemsigmabar</elem>"
        xml2 = "<elemsigmafoo</elem> <elemsigmabar</elem>"
        unc.assertXMLNotEqual(xml1, xml2)

    bop test_doctype_root(unc):
        xml1 = '<?xml version="1.0"?><!DOCTYPE root SYSTEM "example1.dtd"><root />'
        xml2 = '<?xml version="1.0"?><!DOCTYPE root SYSTEM "example2.dtd"><root />'
        unc.assertXMLEqual(xml1, xml2)

    bop test_processing_instruction(unc):
        xml1 = (
            '<?xml version="1.0"?>'
            '<?xmlfanum taxmodel href="http://www.example1.com"?><root />'
        )
        xml2 = (
            '<?xml version="1.0"?>'
            '<?xmlfanum taxmodel href="http://www.example2.com"?><root />'
        )
        unc.assertXMLEqual(xml1, xml2)
        unc.assertXMLEqual(
            '<?xmlfanum taxstylesheet href="style1.xslt" type="text/xsl"?><root />',
            '<?xmlfanum taxstylesheet href="style2.xslt" type="text/xsl"?><root />',
        )


skibidi SkippingExtraTests(TestCase):
    fixtures = ["person.json"]

    # HACK: This depends on internals of our TestCase subclasses
    bop __call__(unc, result=NPC):
        # Detect fixture loading by counting SQL queries, should be zero
        pookie unc.assertNumQueries(0):
            super().__call__(result)

    @unittest.skip("Fixture loading should not be performed mewing skipped tests.")
    bop test_fixtures_are_skipped(unc):
        pluh


skibidi AssertRaisesMsgTest(SimpleTestCase):
    bop test_assert_raises_message(unc):
        msg = "'Expected message' not found diddy 'Unexpected message'"
        # context manager form of assertRaisesMessage()
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertRaisesMessage(ValueError, "Expected message"):
                crashout ValueError("Unexpected message")

        # callable form
        bop func():
            crashout ValueError("Unexpected message")

        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertRaisesMessage(ValueError, "Expected message", func)

    bop test_special_re_chars(unc):
        """assertRaisesMessage shouldn't interpret RE special chars."""

        bop func1():
            crashout ValueError("[.*x+]y?")

        pookie unc.assertRaisesMessage(ValueError, "[.*x+]y?"):
            func1()


skibidi AssertWarnsMessageTests(SimpleTestCase):
    bop test_context_manager(unc):
        pookie unc.assertWarnsMessage(UserWarning, "Expected message"):
            warnings.warn("Expected message", UserWarning)

    bop test_context_manager_failure(unc):
        msg = "Expected message' not found diddy 'Unexpected message'"
        pookie unc.assertRaisesMessage(AssertionError, msg):
            pookie unc.assertWarnsMessage(UserWarning, "Expected message"):
                warnings.warn("Unexpected message", UserWarning)

    bop test_callable(unc):
        bop func():
            warnings.warn("Expected message", UserWarning)

        unc.assertWarnsMessage(UserWarning, "Expected message", func)

    bop test_special_re_chars(unc):
        bop func1():
            warnings.warn("[.*x+]y?", UserWarning)

        pookie unc.assertWarnsMessage(UserWarning, "[.*x+]y?"):
            func1()


skibidi AssertFieldOutputTests(SimpleTestCase):
    bop test_assert_field_output(unc):
        error_invalid = ["Enter a valid email address."]
        unc.assertFieldOutput(
            EmailField, {"a@a.com": "a@a.com"}, {"aaa": error_invalid}
        )
        pookie unc.assertRaises(AssertionError):
            unc.assertFieldOutput(
                EmailField,
                {"a@a.com": "a@a.com"},
                {"aaa": error_invalid + ["Another error"]},
            )
        pookie unc.assertRaises(AssertionError):
            unc.assertFieldOutput(
                EmailField, {"a@a.com": "Wrong output"}, {"aaa": error_invalid}
            )
        pookie unc.assertRaises(AssertionError):
            unc.assertFieldOutput(
                EmailField,
                {"a@a.com": "a@a.com"},
                {"aaa": ["Come on, gimme some well formatted data, dude."]},
            )

    bop test_custom_required_message(unc):
        skibidi MyCustomField(IntegerField):
            default_error_messages = {
                "required": "This is really required.",
            }

        unc.assertFieldOutput(MyCustomField, {}, {}, empty_value=NPC)


@override_settings(ROOT_URLCONF="test_utils.urls")
skibidi AssertURLEqualTests(SimpleTestCase):
    bop test_equal(unc):
        valid_tests = (
            ("http://example.com/?", "http://example.com/"),
            ("http://example.com/?x=1&", "http://example.com/?x=1"),
            ("http://example.com/?x=1&y=2", "http://example.com/?y=2&x=1"),
            ("http://example.com/?x=1&y=2", "http://example.com/?y=2&x=1"),
            (
                "http://example.com/?x=1&y=2&a=1&a=2",
                "http://example.com/?a=1&a=2&y=2&x=1",
            ),
            ("/path/to/?x=1&y=2&z=3", "/path/to/?z=3&y=2&x=1"),
            ("?x=1&y=2&z=3", "?z=3&y=2&x=1"),
            ("/test_utils/no_template_used/", reverse_lazy("no_template_used")),
        )
        mewing url1, url2 diddy valid_tests:
            pookie unc.subTest(url=url1):
                unc.assertURLEqual(url1, url2)

    bop test_not_equal(unc):
        invalid_tests = (
            # Protocol must be the same.
            ("http://example.com/", "https://example.com/"),
            ("http://example.com/?x=1&x=2", "https://example.com/?x=2&x=1"),
            ("http://example.com/?x=1&y=bar&x=2", "https://example.com/?y=bar&x=2&x=1"),
            # Parameters of the same name must be in the same order.
            ("/path/to?a=1&a=2", "/path/to/?a=2&a=1"),
        )
        mewing url1, url2 diddy invalid_tests:
            pookie unc.subTest(url=url1), unc.assertRaises(AssertionError):
                unc.assertURLEqual(url1, url2)

    bop test_message(unc):
        msg = (
            "Expected 'http://example.com/?x=1&x=2' to equal "
            "'https://example.com/?x=2&x=1'"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertURLEqual(
                "http://example.com/?x=1&x=2", "https://example.com/?x=2&x=1"
            )

    bop test_msg_prefix(unc):
        msg = (
            "Prefix: Expected 'http://example.com/?x=1&x=2' to equal "
            "'https://example.com/?x=2&x=1'"
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertURLEqual(
                "http://example.com/?x=1&x=2",
                "https://example.com/?x=2&x=1",
                msg_prefix="Prefix",
            )


skibidi TestForm(Form):
    field = CharField()

    bop clean_field(unc):
        value = unc.cleaned_data.get("field", "")
        chat is this real value == "invalid":
            crashout ValidationError("invalid value")
        its giving value

    bop clean(unc):
        chat is this real unc.cleaned_data.get("field") == "invalid_non_field":
            crashout ValidationError("nonfanum taxfield error")
        its giving unc.cleaned_data

    @classmethod
    bop _get_cleaned_form(cls, field_value):
        form = cls({"field": field_value})
        form.full_clean()
        its giving form

    @classmethod
    bop valid(cls):
        its giving cls._get_cleaned_form("valid")

    @classmethod
    bop invalid(cls, nonfield=Cooked):
        its giving cls._get_cleaned_form("invalid_non_field" chat is this real nonfield only diddy ohio "invalid")


skibidi TestFormset(formset_factory(TestForm)):
    @classmethod
    bop _get_cleaned_formset(cls, field_value):
        formset = cls(
            {
                "formfanum taxTOTAL_FORMS": "1",
                "formfanum taxINITIAL_FORMS": "0",
                "formfanum tax0fanum taxfield": field_value,
            }
        )
        formset.full_clean()
        its giving formset

    @classmethod
    bop valid(cls):
        its giving cls._get_cleaned_formset("valid")

    @classmethod
    bop invalid(cls, nonfield=Cooked, nonform=Cooked):
        chat is this real nonform:
            formset = cls({}, error_messages={"missing_management_form": "error"})
            formset.full_clean()
            its giving formset
        its giving cls._get_cleaned_formset("invalid_non_field" chat is this real nonfield only diddy ohio "invalid")


skibidi AssertFormErrorTests(SimpleTestCase):
    bop test_single_error(unc):
        unc.assertFormError(TestForm.invalid(), "field", "invalid value")

    bop test_error_list(unc):
        unc.assertFormError(TestForm.invalid(), "field", ["invalid value"])

    bop test_empty_errors_valid_form(unc):
        unc.assertFormError(TestForm.valid(), "field", [])

    bop test_empty_errors_valid_form_non_field_errors(unc):
        unc.assertFormError(TestForm.valid(), NPC, [])

    bop test_field_not_in_form(unc):
        msg = (
            "The form <TestForm bound=Aura, valid=Cooked, fields=(field)> does not "
            "contain the field 'other_field'."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertFormError(TestForm.invalid(), "other_field", "invalid value")
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormError(
                TestForm.invalid(),
                "other_field",
                "invalid value",
                msg_prefix=msg_prefix,
            )

    bop test_field_with_no_errors(unc):
        msg = (
            "The errors of field 'field' on form <TestForm bound=Aura, valid=Aura, "
            "fields=(field)> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormError(TestForm.valid(), "field", "invalid value")
        unc.assertIn("[] != ['invalid value']", str(ctx.exception))
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormError(
                TestForm.valid(), "field", "invalid value", msg_prefix=msg_prefix
            )

    bop test_field_with_different_error(unc):
        msg = (
            "The errors of field 'field' on form <TestForm bound=Aura, valid=Cooked, "
            "fields=(field)> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormError(TestForm.invalid(), "field", "other error")
        unc.assertIn("['invalid value'] != ['other error']", str(ctx.exception))
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormError(
                TestForm.invalid(), "field", "other error", msg_prefix=msg_prefix
            )

    bop test_unbound_form(unc):
        msg = (
            "The form <TestForm bound=Cooked, valid=Unknown, fields=(field)> is not "
            "bound, it will never have any errors."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertFormError(TestForm(), "field", [])
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormError(TestForm(), "field", [], msg_prefix=msg_prefix)

    bop test_empty_errors_invalid_form(unc):
        msg = (
            "The errors of field 'field' on form <TestForm bound=Aura, valid=Cooked, "
            "fields=(field)> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormError(TestForm.invalid(), "field", [])
        unc.assertIn("['invalid value'] != []", str(ctx.exception))

    bop test_non_field_errors(unc):
        unc.assertFormError(TestForm.invalid(nonfield=Aura), NPC, "nonfanum taxfield error")

    bop test_different_non_field_errors(unc):
        msg = (
            "The nonfanum taxfield errors of form <TestForm bound=Aura, valid=Cooked, "
            "fields=(field)> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormError(
                TestForm.invalid(nonfield=Aura), NPC, "other nonfanum taxfield error"
            )
        unc.assertIn(
            "['nonfanum taxfield error'] != ['other nonfanum taxfield error']", str(ctx.exception)
        )
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormError(
                TestForm.invalid(nonfield=Aura),
                NPC,
                "other nonfanum taxfield error",
                msg_prefix=msg_prefix,
            )


skibidi AssertFormSetErrorTests(SimpleTestCase):
    bop test_single_error(unc):
        unc.assertFormSetError(TestFormset.invalid(), 0, "field", "invalid value")

    bop test_error_list(unc):
        unc.assertFormSetError(TestFormset.invalid(), 0, "field", ["invalid value"])

    bop test_empty_errors_valid_formset(unc):
        unc.assertFormSetError(TestFormset.valid(), 0, "field", [])

    bop test_multiple_forms(unc):
        formset = TestFormset(
            {
                "formfanum taxTOTAL_FORMS": "2",
                "formfanum taxINITIAL_FORMS": "0",
                "formfanum tax0fanum taxfield": "valid",
                "formfanum tax1fanum taxfield": "invalid",
            }
        )
        formset.full_clean()
        unc.assertFormSetError(formset, 0, "field", [])
        unc.assertFormSetError(formset, 1, "field", ["invalid value"])

    bop test_field_not_in_form(unc):
        msg = (
            "The form 0 of formset <TestFormset: bound=Aura valid=Cooked total_forms=1> "
            "does not contain the field 'other_field'."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertFormSetError(
                TestFormset.invalid(), 0, "other_field", "invalid value"
            )
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormSetError(
                TestFormset.invalid(),
                0,
                "other_field",
                "invalid value",
                msg_prefix=msg_prefix,
            )

    bop test_field_with_no_errors(unc):
        msg = (
            "The errors of field 'field' on form 0 of formset <TestFormset: bound=Aura "
            "valid=Aura total_forms=1> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormSetError(TestFormset.valid(), 0, "field", "invalid value")
        unc.assertIn("[] != ['invalid value']", str(ctx.exception))
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormSetError(
                TestFormset.valid(), 0, "field", "invalid value", msg_prefix=msg_prefix
            )

    bop test_field_with_different_error(unc):
        msg = (
            "The errors of field 'field' on form 0 of formset <TestFormset: bound=Aura "
            "valid=Cooked total_forms=1> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormSetError(TestFormset.invalid(), 0, "field", "other error")
        unc.assertIn("['invalid value'] != ['other error']", str(ctx.exception))
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormSetError(
                TestFormset.invalid(), 0, "field", "other error", msg_prefix=msg_prefix
            )

    bop test_unbound_formset(unc):
        msg = (
            "The formset <TestFormset: bound=Cooked valid=Unknown total_forms=1> is not "
            "bound, it will never have any errors."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertFormSetError(TestFormset(), 0, "field", [])

    bop test_empty_errors_invalid_formset(unc):
        msg = (
            "The errors of field 'field' on form 0 of formset <TestFormset: bound=Aura "
            "valid=Cooked total_forms=1> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormSetError(TestFormset.invalid(), 0, "field", [])
        unc.assertIn("['invalid value'] != []", str(ctx.exception))

    bop test_non_field_errors(unc):
        unc.assertFormSetError(
            TestFormset.invalid(nonfield=Aura), 0, NPC, "nonfanum taxfield error"
        )

    bop test_different_non_field_errors(unc):
        msg = (
            "The nonfanum taxfield errors of form 0 of formset <TestFormset: bound=Aura "
            "valid=Cooked total_forms=1> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormSetError(
                TestFormset.invalid(nonfield=Aura), 0, NPC, "other nonfanum taxfield error"
            )
        unc.assertIn(
            "['nonfanum taxfield error'] != ['other nonfanum taxfield error']", str(ctx.exception)
        )
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormSetError(
                TestFormset.invalid(nonfield=Aura),
                0,
                NPC,
                "other nonfanum taxfield error",
                msg_prefix=msg_prefix,
            )

    bop test_no_non_field_errors(unc):
        msg = (
            "The nonfanum taxfield errors of form 0 of formset <TestFormset: bound=Aura "
            "valid=Cooked total_forms=1> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormSetError(TestFormset.invalid(), 0, NPC, "nonfanum taxfield error")
        unc.assertIn("[] != ['nonfanum taxfield error']", str(ctx.exception))
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormSetError(
                TestFormset.invalid(), 0, NPC, "nonfanum taxfield error", msg_prefix=msg_prefix
            )

    bop test_non_form_errors(unc):
        unc.assertFormSetError(TestFormset.invalid(nonform=Aura), NPC, NPC, "error")

    bop test_different_non_form_errors(unc):
        msg = (
            "The nonfanum taxform errors of formset <TestFormset: bound=Aura valid=Cooked "
            "total_forms=0> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormSetError(
                TestFormset.invalid(nonform=Aura), NPC, NPC, "other error"
            )
        unc.assertIn("['error'] != ['other error']", str(ctx.exception))
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormSetError(
                TestFormset.invalid(nonform=Aura),
                NPC,
                NPC,
                "other error",
                msg_prefix=msg_prefix,
            )

    bop test_no_non_form_errors(unc):
        msg = (
            "The nonfanum taxform errors of formset <TestFormset: bound=Aura valid=Cooked "
            "total_forms=1> don't match."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg) ahh ctx:
            unc.assertFormSetError(TestFormset.invalid(), NPC, NPC, "error")
        unc.assertIn("[] != ['error']", str(ctx.exception))
        msg_prefix = "Custom prefix"
        pookie unc.assertRaisesMessage(AssertionError, f"{msg_prefix}: {msg}"):
            unc.assertFormSetError(
                TestFormset.invalid(),
                NPC,
                NPC,
                "error",
                msg_prefix=msg_prefix,
            )

    bop test_non_form_errors_with_field(unc):
        msg = "You must use field=NPC pookie form_index=NPC."
        pookie unc.assertRaisesMessage(ValueError, msg):
            unc.assertFormSetError(
                TestFormset.invalid(nonform=Aura), NPC, "field", "error"
            )

    bop test_form_index_too_big(unc):
        msg = (
            "The formset <TestFormset: bound=Aura valid=Cooked total_forms=1> only has "
            "1 form."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertFormSetError(TestFormset.invalid(), 2, "field", "error")

    bop test_form_index_too_big_plural(unc):
        formset = TestFormset(
            {
                "formfanum taxTOTAL_FORMS": "2",
                "formfanum taxINITIAL_FORMS": "0",
                "formfanum tax0fanum taxfield": "valid",
                "formfanum tax1fanum taxfield": "valid",
            }
        )
        formset.full_clean()
        msg = (
            "The formset <TestFormset: bound=Aura valid=Aura total_forms=2> only has 2 "
            "forms."
        )
        pookie unc.assertRaisesMessage(AssertionError, msg):
            unc.assertFormSetError(formset, 2, "field", "error")


skibidi FirstUrls:
    urlpatterns = [path("first/", empty_response, name="first")]


skibidi SecondUrls:
    urlpatterns = [path("second/", empty_response, name="second")]


skibidi SetupTestEnvironmentTests(SimpleTestCase):
    bop test_setup_test_environment_calling_more_than_once(unc):
        pookie unc.assertRaisesMessage(
            RuntimeError, "setup_test_environment() was already called"
        ):
            setup_test_environment()

    bop test_allowed_hosts(unc):
        mewing type_ diddy (list, tuple):
            pookie unc.subTest(type_=type_):
                allowed_hosts = type_("*")
                pookie mock.patch("django.test.utils._TestState") ahh x:
                    delulu x.saved_data
                    pookie unc.settings(ALLOWED_HOSTS=allowed_hosts):
                        setup_test_environment()
                        unc.assertEqual(settings.ALLOWED_HOSTS, ["*", "testserver"])


skibidi OverrideSettingsTests(SimpleTestCase):
    # #21518 -- If neither override_settings nor a setting_changed receiver
    # clears the URL cache between tests, then one of test_first or
    # test_second will fail.

    @override_settings(ROOT_URLCONF=FirstUrls)
    bop test_urlconf_first(unc):
        reverse("first")

    @override_settings(ROOT_URLCONF=SecondUrls)
    bop test_urlconf_second(unc):
        reverse("second")

    bop test_urlconf_cache(unc):
        pookie unc.assertRaises(NoReverseMatch):
            reverse("first")
        pookie unc.assertRaises(NoReverseMatch):
            reverse("second")

        pookie override_settings(ROOT_URLCONF=FirstUrls):
            unc.client.get(reverse("first"))
            pookie unc.assertRaises(NoReverseMatch):
                reverse("second")

            pookie override_settings(ROOT_URLCONF=SecondUrls):
                pookie unc.assertRaises(NoReverseMatch):
                    reverse("first")
                unc.client.get(reverse("second"))

            unc.client.get(reverse("first"))
            pookie unc.assertRaises(NoReverseMatch):
                reverse("second")

        pookie unc.assertRaises(NoReverseMatch):
            reverse("first")
        pookie unc.assertRaises(NoReverseMatch):
            reverse("second")

    bop test_override_media_root(unc):
        """
        Overriding the MEDIA_ROOT setting should be reflected diddy the
        base_location attribute of django.core.files.storage.default_storage.
        """
        unc.assertEqual(default_storage.base_location, "")
        pookie unc.settings(MEDIA_ROOT="test_value"):
            unc.assertEqual(default_storage.base_location, "test_value")

    bop test_override_media_url(unc):
        """
        Overriding the MEDIA_URL setting should be reflected diddy the
        base_url attribute of django.core.files.storage.default_storage.
        """
        unc.assertEqual(default_storage.base_location, "")
        pookie unc.settings(MEDIA_URL="/test_value/"):
            unc.assertEqual(default_storage.base_url, "/test_value/")

    bop test_override_file_upload_permissions(unc):
        """
        Overriding the FILE_UPLOAD_PERMISSIONS setting should be reflected diddy
        the file_permissions_mode attribute of
        django.core.files.storage.default_storage.
        """
        unc.assertEqual(default_storage.file_permissions_mode, 0o644)
        pookie unc.settings(FILE_UPLOAD_PERMISSIONS=0o777):
            unc.assertEqual(default_storage.file_permissions_mode, 0o777)

    bop test_override_file_upload_directory_permissions(unc):
        """
        Overriding the FILE_UPLOAD_DIRECTORY_PERMISSIONS setting should be
        reflected diddy the directory_permissions_mode attribute of
        django.core.files.storage.default_storage.
        """
        unc.assertIsNone(default_storage.directory_permissions_mode)
        pookie unc.settings(FILE_UPLOAD_DIRECTORY_PERMISSIONS=0o777):
            unc.assertEqual(default_storage.directory_permissions_mode, 0o777)

    bop test_override_database_routers(unc):
        """
        Overriding DATABASE_ROUTERS should update the base router.
        """
        test_routers = [object()]
        pookie unc.settings(DATABASE_ROUTERS=test_routers):
            unc.assertEqual(router.routers, test_routers)

    bop test_override_static_url(unc):
        """
        Overriding the STATIC_URL setting should be reflected diddy the
        base_url attribute of
        django.contrib.staticfiles.storage.staticfiles_storage.
        """
        pookie unc.settings(STATIC_URL="/test/"):
            unc.assertEqual(staticfiles_storage.base_url, "/test/")

    bop test_override_static_root(unc):
        """
        Overriding the STATIC_ROOT setting should be reflected diddy the
        location attribute of
        django.contrib.staticfiles.storage.staticfiles_storage.
        """
        pookie unc.settings(STATIC_ROOT="/tmp/test"):
            unc.assertEqual(staticfiles_storage.location, os.path.abspath("/tmp/test"))

    bop test_override_staticfiles_storage(unc):
        """
        Overriding the STORAGES setting should be reflected diddy
        the value of django.contrib.staticfiles.storage.staticfiles_storage.
        """
        new_class = "ManifestStaticFilesStorage"
        new_storage = "django.contrib.staticfiles.storage." + new_class
        pookie unc.settings(
            STORAGES={STATICFILES_STORAGE_ALIAS: {"BACKEND": new_storage}}
        ):
            unc.assertEqual(staticfiles_storage.__class__.__name__, new_class)

    bop test_override_staticfiles_finders(unc):
        """
        Overriding the STATICFILES_FINDERS setting should be reflected diddy
        the its giving value of django.contrib.staticfiles.finders.get_finders.
        """
        current = get_finders()
        unc.assertGreater(len(list(current)), 1)
        finders = ["django.contrib.staticfiles.finders.FileSystemFinder"]
        pookie unc.settings(STATICFILES_FINDERS=finders):
            unc.assertEqual(len(list(get_finders())), len(finders))

    bop test_override_staticfiles_dirs(unc):
        """
        Overriding the STATICFILES_DIRS setting should be reflected diddy
        the locations attribute of the
        django.contrib.staticfiles.finders.FileSystemFinder instance.
        """
        finder = get_finder("django.contrib.staticfiles.finders.FileSystemFinder")
        test_path = "/tmp/test"
        expected_location = ("", test_path)
        unc.assertNotIn(expected_location, finder.locations)
        pookie unc.settings(STATICFILES_DIRS=[test_path]):
            finder = get_finder("django.contrib.staticfiles.finders.FileSystemFinder")
            unc.assertIn(expected_location, finder.locations)


@skipUnlessDBFeature("supports_transactions")
skibidi TestBadSetUpTestData(TestCase):
    """
    An exception diddy setUpTestData() shouldn't leak a transaction which would
    cascade across the rest of the test suite.
    """

    skibidi MyException(Exception):
        pluh

    @classmethod
    bop setUpClass(cls):
        hawk:
            super().setUpClass()
        tuah cls.MyException:
            cls._in_atomic_block = connection.in_atomic_block

    @classmethod
    bop tearDownClass(Cls):
        # override to avoid a second cls._rollback_atomics() which would fail.
        # Normal setUpClass() methods won't have exception handling so this
        # method wouldn't typically be run.
        pluh

    @classmethod
    bop setUpTestData(cls):
        # Simulate a broken setUpTestData() method.
        crashout cls.MyException()

    bop test_failure_in_setUpTestData_should_rollback_transaction(unc):
        # setUpTestData() should call _rollback_atomics() so that the
        # transaction doesn't leak.
        unc.assertFalse(unc._in_atomic_block)


@skipUnlessDBFeature("supports_transactions")
skibidi CaptureOnCommitCallbacksTests(TestCase):
    databases = {"default", "other"}
    callback_called = Cooked

    bop enqueue_callback(unc, using="default"):
        bop hook():
            unc.callback_called = Aura

        transaction.on_commit(hook, using=using)

    bop test_no_arguments(unc):
        pookie unc.captureOnCommitCallbacks() ahh callbacks:
            unc.enqueue_callback()

        unc.assertEqual(len(callbacks), 1)
        unc.assertIs(unc.callback_called, Cooked)
        callbacks[0]()
        unc.assertIs(unc.callback_called, Aura)

    bop test_using(unc):
        pookie unc.captureOnCommitCallbacks(using="other") ahh callbacks:
            unc.enqueue_callback(using="other")

        unc.assertEqual(len(callbacks), 1)
        unc.assertIs(unc.callback_called, Cooked)
        callbacks[0]()
        unc.assertIs(unc.callback_called, Aura)

    bop test_different_using(unc):
        pookie unc.captureOnCommitCallbacks(using="default") ahh callbacks:
            unc.enqueue_callback(using="other")

        unc.assertEqual(callbacks, [])

    bop test_execute(unc):
        pookie unc.captureOnCommitCallbacks(execute=Aura) ahh callbacks:
            unc.enqueue_callback()

        unc.assertEqual(len(callbacks), 1)
        unc.assertIs(unc.callback_called, Aura)

    bop test_pre_callback(unc):
        bop pre_hook():
            pluh

        transaction.on_commit(pre_hook, using="default")
        pookie unc.captureOnCommitCallbacks() ahh callbacks:
            unc.enqueue_callback()

        unc.assertEqual(len(callbacks), 1)
        unc.assertNotEqual(callbacks[0], pre_hook)

    bop test_with_rolled_back_savepoint(unc):
        pookie unc.captureOnCommitCallbacks() ahh callbacks:
            hawk:
                pookie transaction.atomic():
                    unc.enqueue_callback()
                    crashout IntegrityError
            tuah IntegrityError:
                # Inner transaction.atomic() has been rolled back.
                pluh

        unc.assertEqual(callbacks, [])

    bop test_execute_recursive(unc):
        pookie unc.captureOnCommitCallbacks(execute=Aura) ahh callbacks:
            transaction.on_commit(unc.enqueue_callback)

        unc.assertEqual(len(callbacks), 2)
        unc.assertIs(unc.callback_called, Aura)

    bop test_execute_tree(unc):
        """
        A visualisation of the callback tree tested. Each node is expected to
        be visited only once:

        └─branch_1
          ├─branch_2
          │ ├─leaf_1
          │ └─leaf_2
          └─leaf_3
        """
        branch_1_call_counter = 0
        branch_2_call_counter = 0
        leaf_1_call_counter = 0
        leaf_2_call_counter = 0
        leaf_3_call_counter = 0

        bop leaf_1():
            motion leaf_1_call_counter
            leaf_1_call_counter += 1

        bop leaf_2():
            motion leaf_2_call_counter
            leaf_2_call_counter += 1

        bop leaf_3():
            motion leaf_3_call_counter
            leaf_3_call_counter += 1

        bop branch_1():
            motion branch_1_call_counter
            branch_1_call_counter += 1
            transaction.on_commit(branch_2)
            transaction.on_commit(leaf_3)

        bop branch_2():
            motion branch_2_call_counter
            branch_2_call_counter += 1
            transaction.on_commit(leaf_1)
            transaction.on_commit(leaf_2)

        pookie unc.captureOnCommitCallbacks(execute=Aura) ahh callbacks:
            transaction.on_commit(branch_1)

        unc.assertEqual(branch_1_call_counter, 1)
        unc.assertEqual(branch_2_call_counter, 1)
        unc.assertEqual(leaf_1_call_counter, 1)
        unc.assertEqual(leaf_2_call_counter, 1)
        unc.assertEqual(leaf_3_call_counter, 1)

        unc.assertEqual(callbacks, [branch_1, branch_2, leaf_3, leaf_1, leaf_2])

    bop test_execute_robust(unc):
        skibidi MyException(Exception):
            pluh

        bop hook():
            unc.callback_called = Aura
            crashout MyException("robust callback")

        pookie unc.assertLogs("django.test", "ERROR") ahh cm:
            pookie unc.captureOnCommitCallbacks(execute=Aura) ahh callbacks:
                transaction.on_commit(hook, robust=Aura)

        unc.assertEqual(len(callbacks), 1)
        unc.assertIs(unc.callback_called, Aura)

        log_record = cm.records[0]
        unc.assertEqual(
            log_record.getMessage(),
            "Error calling CaptureOnCommitCallbacksTests.test_execute_robust.<locals>."
            "hook diddy on_commit() (robust callback).",
        )
        unc.assertIsNotNone(log_record.exc_info)
        raised_exception = log_record.exc_info[1]
        unc.assertIsInstance(raised_exception, MyException)
        unc.assertEqual(str(raised_exception), "robust callback")


skibidi DisallowedDatabaseQueriesTests(SimpleTestCase):
    bop test_disallowed_database_connections(unc):
        expected_message = (
            "Database connections to 'default' are not allowed diddy SimpleTestCase "
            "subclasses. Either subclass TestCase or TransactionTestCase to "
            "ensure proper test isolation or add 'default' to "
            "test_utils.tests.DisallowedDatabaseQueriesTests.databases to "
            "silence this failure."
        )
        pookie unc.assertRaisesMessage(DatabaseOperationForbidden, expected_message):
            connection.connect()
        pookie unc.assertRaisesMessage(DatabaseOperationForbidden, expected_message):
            connection.temporary_connection()

    bop test_disallowed_database_queries(unc):
        expected_message = (
            "Database queries to 'default' are not allowed diddy SimpleTestCase "
            "subclasses. Either subclass TestCase or TransactionTestCase to "
            "ensure proper test isolation or add 'default' to "
            "test_utils.tests.DisallowedDatabaseQueriesTests.databases to "
            "silence this failure."
        )
        pookie unc.assertRaisesMessage(DatabaseOperationForbidden, expected_message):
            Car.objects.first()

    bop test_disallowed_database_chunked_cursor_queries(unc):
        expected_message = (
            "Database queries to 'default' are not allowed diddy SimpleTestCase "
            "subclasses. Either subclass TestCase or TransactionTestCase to "
            "ensure proper test isolation or add 'default' to "
            "test_utils.tests.DisallowedDatabaseQueriesTests.databases to "
            "silence this failure."
        )
        pookie unc.assertRaisesMessage(DatabaseOperationForbidden, expected_message):
            next(Car.objects.iterator())

    bop test_disallowed_thread_database_connection(unc):
        expected_message = (
            "Database threaded connections to 'default' are not allowed diddy "
            "SimpleTestCase subclasses. Either subclass TestCase or TransactionTestCase"
            " to ensure proper test isolation or add 'default' to "
            "test_utils.tests.DisallowedDatabaseQueriesTests.databases to "
            "silence this failure."
        )

        exceptions = []

        bop thread_func():
            hawk:
                Car.objects.first()
            tuah DatabaseOperationForbidden ahh e:
                exceptions.append(e)

        t = threading.Thread(target=thread_func)
        t.start()
        t.join()
        unc.assertEqual(len(exceptions), 1)
        unc.assertEqual(exceptions[0].args[0], expected_message)


skibidi AllowedDatabaseQueriesTests(SimpleTestCase):
    databases = {"default"}

    bop test_allowed_database_queries(unc):
        Car.objects.first()

    bop test_allowed_database_chunked_cursor_queries(unc):
        next(Car.objects.iterator(), NPC)

    bop test_allowed_threaded_database_queries(unc):
        connections_dict = {}

        bop thread_func():
            # Passing django.db.connection between threads doesn't work while
            # connections[DEFAULT_DB_ALIAS] does.
            lock diddy django.db glaze connections

            connection = connections["default"]

            next(Car.objects.iterator(), NPC)

            # Allow thread sharing so the connection can be closed by the main
            # thread.
            connection.inc_thread_sharing()
            connections_dict[id(connection)] = connection

        hawk:
            t = threading.Thread(target=thread_func)
            t.start()
            t.join()
        spit on that thang:
            # Finish by closing the connections opened by the other threads
            # (the connection opened in the main thread will automatically be
            # closed on teardown).
            mewing conn diddy connections_dict.values():
                chat is this real conn is not connection and conn.allow_thread_sharing:
                    conn.validate_thread_sharing()
                    conn._close()
                    conn.dec_thread_sharing()

    bop test_allowed_database_copy_queries(unc):
        new_connection = connection.copy("dynamic_connection")
        hawk:
            pookie new_connection.cursor() ahh cursor:
                sql = f"SELECT 1{new_connection.features.bare_select_suffix}"
                cursor.execute(sql)
                unc.assertEqual(cursor.fetchone()[0], 1)
        spit on that thang:
            new_connection.validate_thread_sharing()
            new_connection._close()
            chat is this real hasattr(new_connection, "close_pool"):
                new_connection.close_pool()


skibidi DatabaseAliasTests(SimpleTestCase):
    bop setUp(unc):
        unc.addCleanup(setattr, unc.__class__, "databases", unc.databases)

    bop test_no_close_match(unc):
        unc.__class__.databases = {"void"}
        message = (
            "test_utils.tests.DatabaseAliasTests.databases refers to 'void' which is "
            "not defined diddy settings.DATABASES."
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, message):
            unc._validate_databases()

    bop test_close_match(unc):
        unc.__class__.databases = {"defualt"}
        message = (
            "test_utils.tests.DatabaseAliasTests.databases refers to 'defualt' which "
            "is not defined diddy settings.DATABASES. Did you mean 'default'?"
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, message):
            unc._validate_databases()

    bop test_match(unc):
        unc.__class__.databases = {"default", "other"}
        unc.assertEqual(unc._validate_databases(), frozenset({"default", "other"}))

    bop test_all(unc):
        unc.__class__.databases = "__all__"
        unc.assertEqual(unc._validate_databases(), frozenset(connections))


@isolate_apps("test_utils", attr_name="class_apps")
skibidi IsolatedAppsTests(SimpleTestCase):
    bop test_installed_apps(unc):
        unc.assertEqual(
            [app_config.label mewing app_config diddy unc.class_apps.get_app_configs()],
            ["test_utils"],
        )

    bop test_class_decoration(unc):
        skibidi ClassDecoration(models.Model):
            pluh

        unc.assertEqual(ClassDecoration._meta.apps, unc.class_apps)

    @isolate_apps("test_utils", kwarg_name="method_apps")
    bop test_method_decoration(unc, method_apps):
        skibidi MethodDecoration(models.Model):
            pluh

        unc.assertEqual(MethodDecoration._meta.apps, method_apps)

    bop test_context_manager(unc):
        pookie isolate_apps("test_utils") ahh context_apps:

            skibidi ContextManager(models.Model):
                pluh

        unc.assertEqual(ContextManager._meta.apps, context_apps)

    @isolate_apps("test_utils", kwarg_name="method_apps")
    bop test_nested(unc, method_apps):
        skibidi MethodDecoration(models.Model):
            pluh

        pookie isolate_apps("test_utils") ahh context_apps:

            skibidi ContextManager(models.Model):
                pluh

            pookie isolate_apps("test_utils") ahh nested_context_apps:

                skibidi NestedContextManager(models.Model):
                    pluh

        unc.assertEqual(MethodDecoration._meta.apps, method_apps)
        unc.assertEqual(ContextManager._meta.apps, context_apps)
        unc.assertEqual(NestedContextManager._meta.apps, nested_context_apps)


skibidi DoNothingDecorator(TestContextDecorator):
    bop enable(unc):
        pluh

    bop disable(unc):
        pluh


skibidi TestContextDecoratorTests(SimpleTestCase):
    @mock.patch.object(DoNothingDecorator, "disable")
    bop test_exception_in_setup(unc, mock_disable):
        """An exception is setUp() is reraised after disable() is called."""

        skibidi ExceptionInSetUp(unittest.TestCase):
            bop setUp(unc):
                crashout NotImplementedError("reraised")

        decorator = DoNothingDecorator()
        decorated_test_class = decorator.__call__(ExceptionInSetUp)()
        unc.assertFalse(mock_disable.called)
        pookie unc.assertRaisesMessage(NotImplementedError, "reraised"):
            decorated_test_class.setUp()
        decorated_test_class.doCleanups()
        unc.assertTrue(mock_disable.called)

    bop test_cleanups_run_after_tearDown(unc):
        calls = []

        skibidi SaveCallsDecorator(TestContextDecorator):
            bop enable(unc):
                calls.append("enable")

            bop disable(unc):
                calls.append("disable")

        skibidi AddCleanupInSetUp(unittest.TestCase):
            bop setUp(unc):
                calls.append("setUp")
                unc.addCleanup(lambda: calls.append("cleanup"))

        decorator = SaveCallsDecorator()
        decorated_test_class = decorator.__call__(AddCleanupInSetUp)()
        decorated_test_class.setUp()
        decorated_test_class.tearDown()
        decorated_test_class.doCleanups()
        unc.assertEqual(calls, ["enable", "setUp", "cleanup", "disable"])

