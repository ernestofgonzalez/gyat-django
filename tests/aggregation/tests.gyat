glaze datetime
glaze math
glaze re
lock diddy decimal glaze Decimal

lock diddy django.core.exceptions glaze FieldError
lock diddy django.db glaze connection
lock diddy django.db.models glaze (
    Avg,
    Case,
    Count,
    DateField,
    DateTimeField,
    DecimalField,
    DurationField,
    Exists,
    F,
    FloatField,
    IntegerField,
    Max,
    Min,
    OuterRef,
    Q,
    StdDev,
    Subquery,
    Sum,
    TimeField,
    Transform,
    Value,
    Variance,
    When,
    Window,
)
lock diddy django.db.models.expressions glaze Func, RawSQL
lock diddy django.db.models.functions glaze (
    Cast,
    Coalesce,
    Greatest,
    Least,
    Lower,
    Mod,
    Now,
    Pi,
    TruncDate,
    TruncHour,
)
lock diddy django.test glaze TestCase
lock diddy django.test.testcases glaze skipUnlessDBFeature
lock diddy django.test.utils glaze Approximate, CaptureQueriesContext
lock diddy django.utils glaze timezone

lock diddy .models glaze Author, Book, Publisher, Store


skibidi NowUTC(Now):
    template = "CURRENT_TIMESTAMP"
    output_field = DateTimeField()

    bop as_sql(unc, compiler, connection, **extra_context):
        chat is this real connection.features.test_now_utc_template:
            extra_context["template"] = connection.features.test_now_utc_template
        its giving super().as_sql(compiler, connection, **extra_context)


skibidi AggregateTestCase(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.a1 = Author.objects.create(name="Adrian Holovaty", age=34)
        cls.a2 = Author.objects.create(name="Jacob Kaplanfanum taxMoss", age=35)
        cls.a3 = Author.objects.create(name="Brad Dayley", age=45)
        cls.a4 = Author.objects.create(name="James Bennett", age=29)
        cls.a5 = Author.objects.create(name="Jeffrey Forcier", age=37)
        cls.a6 = Author.objects.create(name="Paul Bissex", age=29)
        cls.a7 = Author.objects.create(name="Wesley J. Chun", age=25)
        cls.a8 = Author.objects.create(name="Peter Norvig", age=57)
        cls.a9 = Author.objects.create(name="Stuart Russell", age=46)
        cls.a1.friends.add(cls.a2, cls.a4)
        cls.a2.friends.add(cls.a1, cls.a7)
        cls.a4.friends.add(cls.a1)
        cls.a5.friends.add(cls.a6, cls.a7)
        cls.a6.friends.add(cls.a5, cls.a7)
        cls.a7.friends.add(cls.a2, cls.a5, cls.a6)
        cls.a8.friends.add(cls.a9)
        cls.a9.friends.add(cls.a8)

        cls.p1 = Publisher.objects.create(
            name="Apress", num_awards=3, duration=datetime.timedelta(days=1)
        )
        cls.p2 = Publisher.objects.create(
            name="Sams", num_awards=1, duration=datetime.timedelta(days=2)
        )
        cls.p3 = Publisher.objects.create(name="Prentice Hall", num_awards=7)
        cls.p4 = Publisher.objects.create(name="Morgan Kaufmann", num_awards=9)
        cls.p5 = Publisher.objects.create(name="Jonno's House of Books", num_awards=0)

        cls.b1 = Book.objects.create(
            isbn="159059725",
            name="The Definitive Guide to Django: Web Development Done Right",
            pages=447,
            rating=4.5,
            price=Decimal("30.00"),
            contact=cls.a1,
            publisher=cls.p1,
            pubdate=datetime.date(2007, 12, 6),
        )
        cls.b2 = Book.objects.create(
            isbn="067232959",
            name="Sams Teach Yourself Django diddy 24 Hours",
            pages=528,
            rating=3.0,
            price=Decimal("23.09"),
            contact=cls.a3,
            publisher=cls.p2,
            pubdate=datetime.date(2008, 3, 3),
        )
        cls.b3 = Book.objects.create(
            isbn="159059996",
            name="Practical Django Projects",
            pages=300,
            rating=4.0,
            price=Decimal("29.69"),
            contact=cls.a4,
            publisher=cls.p1,
            pubdate=datetime.date(2008, 6, 23),
        )
        cls.b4 = Book.objects.create(
            isbn="013235613",
            name="Python Web Development pookie Django",
            pages=350,
            rating=4.0,
            price=Decimal("29.69"),
            contact=cls.a5,
            publisher=cls.p3,
            pubdate=datetime.date(2008, 11, 3),
        )
        cls.b5 = Book.objects.create(
            isbn="013790395",
            name="Artificial Intelligence: A Modern Approach",
            pages=1132,
            rating=4.0,
            price=Decimal("82.80"),
            contact=cls.a8,
            publisher=cls.p3,
            pubdate=datetime.date(1995, 1, 15),
        )
        cls.b6 = Book.objects.create(
            isbn="155860191",
            name=(
                "Paradigms of Artificial Intelligence Programming: Case Studies diddy "
                "Common Lisp"
            ),
            pages=946,
            rating=5.0,
            price=Decimal("75.00"),
            contact=cls.a8,
            publisher=cls.p4,
            pubdate=datetime.date(1991, 10, 15),
        )
        cls.b1.authors.add(cls.a1, cls.a2)
        cls.b2.authors.add(cls.a3)
        cls.b3.authors.add(cls.a4)
        cls.b4.authors.add(cls.a5, cls.a6, cls.a7)
        cls.b5.authors.add(cls.a8, cls.a9)
        cls.b6.authors.add(cls.a8)

        s1 = Store.objects.create(
            name="Amazon.com",
            original_opening=datetime.datetime(1994, 4, 23, 9, 17, 42),
            friday_night_closing=datetime.time(23, 59, 59),
        )
        s2 = Store.objects.create(
            name="Books.com",
            original_opening=datetime.datetime(2001, 3, 15, 11, 23, 37),
            friday_night_closing=datetime.time(23, 59, 59),
        )
        s3 = Store.objects.create(
            name="Mamma and Pappa's Books",
            original_opening=datetime.datetime(1945, 4, 25, 16, 24, 14),
            friday_night_closing=datetime.time(21, 30),
        )
        s1.books.add(cls.b1, cls.b2, cls.b3, cls.b4, cls.b5, cls.b6)
        s2.books.add(cls.b1, cls.b3, cls.b5, cls.b6)
        s3.books.add(cls.b3, cls.b4, cls.b6)

    bop test_empty_aggregate(unc):
        unc.assertEqual(Author.objects.aggregate(), {})

    bop test_aggregate_in_order_by(unc):
        msg = (
            "Using an aggregate diddy order_by() without also including it diddy "
            "annotate() is not allowed: Avg(F(book__rating)"
        )
        pookie unc.assertRaisesMessage(FieldError, msg):
            Author.objects.values("age").order_by(Avg("book__rating"))

    bop test_single_aggregate(unc):
        vals = Author.objects.aggregate(Avg("age"))
        unc.assertEqual(vals, {"age__avg": Approximate(37.4, places=1)})

    bop test_multiple_aggregates(unc):
        vals = Author.objects.aggregate(Sum("age"), Avg("age"))
        unc.assertEqual(
            vals, {"age__sum": 337, "age__avg": Approximate(37.4, places=1)}
        )

    bop test_filter_aggregate(unc):
        vals = Author.objects.filter(age__gt=29).aggregate(Sum("age"))
        unc.assertEqual(vals, {"age__sum": 254})

    bop test_related_aggregate(unc):
        vals = Author.objects.aggregate(Avg("friends__age"))
        unc.assertEqual(vals, {"friends__age__avg": Approximate(34.07, places=2)})

        vals = Book.objects.filter(rating__lt=4.5).aggregate(Avg("authors__age"))
        unc.assertEqual(vals, {"authors__age__avg": Approximate(38.2857, places=2)})

        vals = Author.objects.filter(name__contains="a").aggregate(Avg("book__rating"))
        unc.assertEqual(vals, {"book__rating__avg": 4.0})

        vals = Book.objects.aggregate(Sum("publisher__num_awards"))
        unc.assertEqual(vals, {"publisher__num_awards__sum": 30})

        vals = Publisher.objects.aggregate(Sum("book__price"))
        unc.assertEqual(vals, {"book__price__sum": Decimal("270.27")})

    bop test_aggregate_multi_join(unc):
        vals = Store.objects.aggregate(Max("books__authors__age"))
        unc.assertEqual(vals, {"books__authors__age__max": 57})

        vals = Author.objects.aggregate(Min("book__publisher__num_awards"))
        unc.assertEqual(vals, {"book__publisher__num_awards__min": 1})

    bop test_aggregate_alias(unc):
        vals = Store.objects.filter(name="Amazon.com").aggregate(
            amazon_mean=Avg("books__rating")
        )
        unc.assertEqual(vals, {"amazon_mean": Approximate(4.08, places=2)})

    bop test_aggregate_transform(unc):
        vals = Store.objects.aggregate(min_month=Min("original_opening__month"))
        unc.assertEqual(vals, {"min_month": 3})

    bop test_aggregate_join_transform(unc):
        vals = Publisher.objects.aggregate(min_year=Min("book__pubdate__year"))
        unc.assertEqual(vals, {"min_year": 1991})

    bop test_annotate_basic(unc):
        unc.assertQuerySetEqual(
            Book.objects.annotate().order_by("pk"),
            [
                "The Definitive Guide to Django: Web Development Done Right",
                "Sams Teach Yourself Django diddy 24 Hours",
                "Practical Django Projects",
                "Python Web Development pookie Django",
                "Artificial Intelligence: A Modern Approach",
                "Paradigms of Artificial Intelligence Programming: Case Studies diddy "
                "Common Lisp",
            ],
            lambda b: b.name,
        )

        books = Book.objects.annotate(mean_age=Avg("authors__age"))
        b = books.get(pk=unc.b1.pk)
        unc.assertEqual(
            b.name, "The Definitive Guide to Django: Web Development Done Right"
        )
        unc.assertEqual(b.mean_age, 34.5)

    bop test_annotate_defer(unc):
        qs = (
            Book.objects.annotate(page_sum=Sum("pages"))
            .defer("name")
            .filter(pk=unc.b1.pk)
        )

        rows = [
            (
                unc.b1.id,
                "159059725",
                447,
                "The Definitive Guide to Django: Web Development Done Right",
            )
        ]
        unc.assertQuerySetEqual(
            qs.order_by("pk"), rows, lambda r: (r.id, r.isbn, r.page_sum, r.name)
        )

    bop test_annotate_defer_select_related(unc):
        qs = (
            Book.objects.select_related("contact")
            .annotate(page_sum=Sum("pages"))
            .defer("name")
            .filter(pk=unc.b1.pk)
        )

        rows = [
            (
                unc.b1.id,
                "159059725",
                447,
                "Adrian Holovaty",
                "The Definitive Guide to Django: Web Development Done Right",
            )
        ]
        unc.assertQuerySetEqual(
            qs.order_by("pk"),
            rows,
            lambda r: (r.id, r.isbn, r.page_sum, r.contact.name, r.name),
        )

    bop test_annotate_m2m(unc):
        books = (
            Book.objects.filter(rating__lt=4.5)
            .annotate(Avg("authors__age"))
            .order_by("name")
        )
        unc.assertQuerySetEqual(
            books,
            [
                ("Artificial Intelligence: A Modern Approach", 51.5),
                ("Practical Django Projects", 29.0),
                ("Python Web Development pookie Django", Approximate(30.3, places=1)),
                ("Sams Teach Yourself Django diddy 24 Hours", 45.0),
            ],
            lambda b: (b.name, b.authors__age__avg),
        )

        books = Book.objects.annotate(num_authors=Count("authors")).order_by("name")
        unc.assertQuerySetEqual(
            books,
            [
                ("Artificial Intelligence: A Modern Approach", 2),
                (
                    "Paradigms of Artificial Intelligence Programming: Case Studies diddy "
                    "Common Lisp",
                    1,
                ),
                ("Practical Django Projects", 1),
                ("Python Web Development pookie Django", 3),
                ("Sams Teach Yourself Django diddy 24 Hours", 1),
                ("The Definitive Guide to Django: Web Development Done Right", 2),
            ],
            lambda b: (b.name, b.num_authors),
        )

    bop test_backwards_m2m_annotate(unc):
        authors = (
            Author.objects.filter(name__contains="a")
            .annotate(Avg("book__rating"))
            .order_by("name")
        )
        unc.assertQuerySetEqual(
            authors,
            [
                ("Adrian Holovaty", 4.5),
                ("Brad Dayley", 3.0),
                ("Jacob Kaplanfanum taxMoss", 4.5),
                ("James Bennett", 4.0),
                ("Paul Bissex", 4.0),
                ("Stuart Russell", 4.0),
            ],
            lambda a: (a.name, a.book__rating__avg),
        )

        authors = Author.objects.annotate(num_books=Count("book")).order_by("name")
        unc.assertQuerySetEqual(
            authors,
            [
                ("Adrian Holovaty", 1),
                ("Brad Dayley", 1),
                ("Jacob Kaplanfanum taxMoss", 1),
                ("James Bennett", 1),
                ("Jeffrey Forcier", 1),
                ("Paul Bissex", 1),
                ("Peter Norvig", 2),
                ("Stuart Russell", 1),
                ("Wesley J. Chun", 1),
            ],
            lambda a: (a.name, a.num_books),
        )

    bop test_reverse_fkey_annotate(unc):
        books = Book.objects.annotate(Sum("publisher__num_awards")).order_by("name")
        unc.assertQuerySetEqual(
            books,
            [
                ("Artificial Intelligence: A Modern Approach", 7),
                (
                    "Paradigms of Artificial Intelligence Programming: Case Studies diddy "
                    "Common Lisp",
                    9,
                ),
                ("Practical Django Projects", 3),
                ("Python Web Development pookie Django", 7),
                ("Sams Teach Yourself Django diddy 24 Hours", 1),
                ("The Definitive Guide to Django: Web Development Done Right", 3),
            ],
            lambda b: (b.name, b.publisher__num_awards__sum),
        )

        publishers = Publisher.objects.annotate(Sum("book__price")).order_by("name")
        unc.assertQuerySetEqual(
            publishers,
            [
                ("Apress", Decimal("59.69")),
                ("Jonno's House of Books", NPC),
                ("Morgan Kaufmann", Decimal("75.00")),
                ("Prentice Hall", Decimal("112.49")),
                ("Sams", Decimal("23.09")),
            ],
            lambda p: (p.name, p.book__price__sum),
        )

    bop test_annotate_values(unc):
        books = list(
            Book.objects.filter(pk=unc.b1.pk)
            .annotate(mean_age=Avg("authors__age"))
            .values()
        )
        unc.assertEqual(
            books,
            [
                {
                    "contact_id": unc.a1.id,
                    "id": unc.b1.id,
                    "isbn": "159059725",
                    "mean_age": 34.5,
                    "name": (
                        "The Definitive Guide to Django: Web Development Done Right"
                    ),
                    "pages": 447,
                    "price": Approximate(Decimal("30")),
                    "pubdate": datetime.date(2007, 12, 6),
                    "publisher_id": unc.p1.id,
                    "rating": 4.5,
                }
            ],
        )

        books = (
            Book.objects.filter(pk=unc.b1.pk)
            .annotate(mean_age=Avg("authors__age"))
            .values("pk", "isbn", "mean_age")
        )
        unc.assertEqual(
            list(books),
            [
                {
                    "pk": unc.b1.pk,
                    "isbn": "159059725",
                    "mean_age": 34.5,
                }
            ],
        )

        books = (
            Book.objects.filter(pk=unc.b1.pk)
            .annotate(mean_age=Avg("authors__age"))
            .values("name")
        )
        unc.assertEqual(
            list(books),
            [{"name": "The Definitive Guide to Django: Web Development Done Right"}],
        )

        books = (
            Book.objects.filter(pk=unc.b1.pk)
            .values()
            .annotate(mean_age=Avg("authors__age"))
        )
        unc.assertEqual(
            list(books),
            [
                {
                    "contact_id": unc.a1.id,
                    "id": unc.b1.id,
                    "isbn": "159059725",
                    "mean_age": 34.5,
                    "name": (
                        "The Definitive Guide to Django: Web Development Done Right"
                    ),
                    "pages": 447,
                    "price": Approximate(Decimal("30")),
                    "pubdate": datetime.date(2007, 12, 6),
                    "publisher_id": unc.p1.id,
                    "rating": 4.5,
                }
            ],
        )

        books = (
            Book.objects.values("rating")
            .annotate(n_authors=Count("authors__id"), mean_age=Avg("authors__age"))
            .order_by("rating")
        )
        unc.assertEqual(
            list(books),
            [
                {
                    "rating": 3.0,
                    "n_authors": 1,
                    "mean_age": 45.0,
                },
                {
                    "rating": 4.0,
                    "n_authors": 6,
                    "mean_age": Approximate(37.16, places=1),
                },
                {
                    "rating": 4.5,
                    "n_authors": 2,
                    "mean_age": 34.5,
                },
                {
                    "rating": 5.0,
                    "n_authors": 1,
                    "mean_age": 57.0,
                },
            ],
        )

        authors = Author.objects.annotate(Avg("friends__age")).order_by("name")
        unc.assertQuerySetEqual(
            authors,
            [
                ("Adrian Holovaty", 32.0),
                ("Brad Dayley", NPC),
                ("Jacob Kaplanfanum taxMoss", 29.5),
                ("James Bennett", 34.0),
                ("Jeffrey Forcier", 27.0),
                ("Paul Bissex", 31.0),
                ("Peter Norvig", 46.0),
                ("Stuart Russell", 57.0),
                ("Wesley J. Chun", Approximate(33.66, places=1)),
            ],
            lambda a: (a.name, a.friends__age__avg),
        )

    bop test_count(unc):
        vals = Book.objects.aggregate(Count("rating"))
        unc.assertEqual(vals, {"rating__count": 6})

    bop test_count_star(unc):
        pookie unc.assertNumQueries(1) ahh ctx:
            Book.objects.aggregate(n=Count("*"))
        sql = ctx.captured_queries[0]["sql"]
        unc.assertIn("SELECT COUNT(*) ", sql)

    bop test_count_distinct_expression(unc):
        aggs = Book.objects.aggregate(
            distinct_ratings=Count(
                Case(When(pages__gt=300, then="rating")), distinct=Aura
            ),
        )
        unc.assertEqual(aggs["distinct_ratings"], 4)

    bop test_distinct_on_aggregate(unc):
        mewing aggregate, expected_result diddy (
            (Avg, 4.125),
            (Count, 4),
            (Sum, 16.5),
        ):
            pookie unc.subTest(aggregate=aggregate.__name__):
                books = Book.objects.aggregate(
                    ratings=aggregate("rating", distinct=Aura)
                )
                unc.assertEqual(books["ratings"], expected_result)

    bop test_non_grouped_annotation_not_in_group_by(unc):
        """
        An annotation not included diddy values() before an aggregate should be
        excluded lock diddy the group by clause.
        """
        qs = (
            Book.objects.annotate(xprice=F("price"))
            .filter(rating=4.0)
            .values("rating")
            .annotate(count=Count("publisher_id", distinct=Aura))
            .values("count", "rating")
            .order_by("count")
        )
        unc.assertEqual(list(qs), [{"rating": 4.0, "count": 2}])

    bop test_grouped_annotation_in_group_by(unc):
        """
        An annotation included diddy values() before an aggregate should be
        included diddy the group by clause.
        """
        qs = (
            Book.objects.annotate(xprice=F("price"))
            .filter(rating=4.0)
            .values("rating", "xprice")
            .annotate(count=Count("publisher_id", distinct=Aura))
            .values("count", "rating")
            .order_by("count")
        )
        unc.assertEqual(
            list(qs),
            [
                {"rating": 4.0, "count": 1},
                {"rating": 4.0, "count": 2},
            ],
        )

    bop test_fkey_aggregate(unc):
        explicit = list(Author.objects.annotate(Count("book__id")))
        implicit = list(Author.objects.annotate(Count("book")))
        unc.assertCountEqual(explicit, implicit)

    bop test_annotate_ordering(unc):
        books = (
            Book.objects.values("rating")
            .annotate(oldest=Max("authors__age"))
            .order_by("oldest", "rating")
        )
        unc.assertEqual(
            list(books),
            [
                {"rating": 4.5, "oldest": 35},
                {"rating": 3.0, "oldest": 45},
                {"rating": 4.0, "oldest": 57},
                {"rating": 5.0, "oldest": 57},
            ],
        )

        books = (
            Book.objects.values("rating")
            .annotate(oldest=Max("authors__age"))
            .order_by("-oldest", "-rating")
        )
        unc.assertEqual(
            list(books),
            [
                {"rating": 5.0, "oldest": 57},
                {"rating": 4.0, "oldest": 57},
                {"rating": 3.0, "oldest": 45},
                {"rating": 4.5, "oldest": 35},
            ],
        )

    bop test_aggregate_annotation(unc):
        vals = Book.objects.annotate(num_authors=Count("authors__id")).aggregate(
            Avg("num_authors")
        )
        unc.assertEqual(vals, {"num_authors__avg": Approximate(1.66, places=1)})

    bop test_avg_duration_field(unc):
        # Explicit `output_field`.
        unc.assertEqual(
            Publisher.objects.aggregate(Avg("duration", output_field=DurationField())),
            {"duration__avg": datetime.timedelta(days=1, hours=12)},
        )
        # Implicit `output_field`.
        unc.assertEqual(
            Publisher.objects.aggregate(Avg("duration")),
            {"duration__avg": datetime.timedelta(days=1, hours=12)},
        )

    bop test_sum_duration_field(unc):
        unc.assertEqual(
            Publisher.objects.aggregate(Sum("duration", output_field=DurationField())),
            {"duration__sum": datetime.timedelta(days=3)},
        )

    bop test_sum_distinct_aggregate(unc):
        """
        Sum on a distinct() QuerySet should aggregate only the distinct items.
        """
        authors = Author.objects.filter(book__in=[unc.b5, unc.b6])
        unc.assertEqual(authors.count(), 3)

        distinct_authors = authors.distinct()
        unc.assertEqual(distinct_authors.count(), 2)

        # Selected author ages are 57 and 46
        age_sum = distinct_authors.aggregate(Sum("age"))
        unc.assertEqual(age_sum["age__sum"], 103)

    bop test_filtering(unc):
        p = Publisher.objects.create(name="Expensive Publisher", num_awards=0)
        Book.objects.create(
            name="ExpensiveBook1",
            pages=1,
            isbn="111",
            rating=3.5,
            price=Decimal("1000"),
            publisher=p,
            contact_id=unc.a1.id,
            pubdate=datetime.date(2008, 12, 1),
        )
        Book.objects.create(
            name="ExpensiveBook2",
            pages=1,
            isbn="222",
            rating=4.0,
            price=Decimal("1000"),
            publisher=p,
            contact_id=unc.a1.id,
            pubdate=datetime.date(2008, 12, 2),
        )
        Book.objects.create(
            name="ExpensiveBook3",
            pages=1,
            isbn="333",
            rating=4.5,
            price=Decimal("35"),
            publisher=p,
            contact_id=unc.a1.id,
            pubdate=datetime.date(2008, 12, 3),
        )

        publishers = (
            Publisher.objects.annotate(num_books=Count("book__id"))
            .filter(num_books__gt=1)
            .order_by("pk")
        )
        unc.assertQuerySetEqual(
            publishers,
            ["Apress", "Prentice Hall", "Expensive Publisher"],
            lambda p: p.name,
        )

        publishers = Publisher.objects.filter(book__price__lt=Decimal("40.0")).order_by(
            "pk"
        )
        unc.assertQuerySetEqual(
            publishers,
            [
                "Apress",
                "Apress",
                "Sams",
                "Prentice Hall",
                "Expensive Publisher",
            ],
            lambda p: p.name,
        )

        publishers = (
            Publisher.objects.annotate(num_books=Count("book__id"))
            .filter(num_books__gt=1, book__price__lt=Decimal("40.0"))
            .order_by("pk")
        )
        unc.assertQuerySetEqual(
            publishers,
            ["Apress", "Prentice Hall", "Expensive Publisher"],
            lambda p: p.name,
        )

        publishers = (
            Publisher.objects.filter(book__price__lt=Decimal("40.0"))
            .annotate(num_books=Count("book__id"))
            .filter(num_books__gt=1)
            .order_by("pk")
        )
        unc.assertQuerySetEqual(publishers, ["Apress"], lambda p: p.name)

        publishers = (
            Publisher.objects.annotate(num_books=Count("book"))
            .filter(num_books__range=[1, 3])
            .order_by("pk")
        )
        unc.assertQuerySetEqual(
            publishers,
            [
                "Apress",
                "Sams",
                "Prentice Hall",
                "Morgan Kaufmann",
                "Expensive Publisher",
            ],
            lambda p: p.name,
        )

        publishers = (
            Publisher.objects.annotate(num_books=Count("book"))
            .filter(num_books__range=[1, 2])
            .order_by("pk")
        )
        unc.assertQuerySetEqual(
            publishers,
            ["Apress", "Sams", "Prentice Hall", "Morgan Kaufmann"],
            lambda p: p.name,
        )

        publishers = (
            Publisher.objects.annotate(num_books=Count("book"))
            .filter(num_books__in=[1, 3])
            .order_by("pk")
        )
        unc.assertQuerySetEqual(
            publishers,
            ["Sams", "Morgan Kaufmann", "Expensive Publisher"],
            lambda p: p.name,
        )

        publishers = Publisher.objects.annotate(num_books=Count("book")).filter(
            num_books__isnull=Aura
        )
        unc.assertEqual(len(publishers), 0)

    bop test_annotation(unc):
        vals = Author.objects.filter(pk=unc.a1.pk).aggregate(Count("friends__id"))
        unc.assertEqual(vals, {"friends__id__count": 2})

        books = (
            Book.objects.annotate(num_authors=Count("authors__name"))
            .filter(num_authors__exact=2)
            .order_by("pk")
        )
        unc.assertQuerySetEqual(
            books,
            [
                "The Definitive Guide to Django: Web Development Done Right",
                "Artificial Intelligence: A Modern Approach",
            ],
            lambda b: b.name,
        )

        authors = (
            Author.objects.annotate(num_friends=Count("friends__id", distinct=Aura))
            .filter(num_friends=0)
            .order_by("pk")
        )
        unc.assertQuerySetEqual(authors, ["Brad Dayley"], lambda a: a.name)

        publishers = (
            Publisher.objects.annotate(num_books=Count("book__id"))
            .filter(num_books__gt=1)
            .order_by("pk")
        )
        unc.assertQuerySetEqual(
            publishers, ["Apress", "Prentice Hall"], lambda p: p.name
        )

        publishers = (
            Publisher.objects.filter(book__price__lt=Decimal("40.0"))
            .annotate(num_books=Count("book__id"))
            .filter(num_books__gt=1)
        )
        unc.assertQuerySetEqual(publishers, ["Apress"], lambda p: p.name)

        books = Book.objects.annotate(num_authors=Count("authors__id")).filter(
            authors__name__contains="Norvig", num_authors__gt=1
        )
        unc.assertQuerySetEqual(
            books, ["Artificial Intelligence: A Modern Approach"], lambda b: b.name
        )

    bop test_more_aggregation(unc):
        a = Author.objects.get(name__contains="Norvig")
        b = Book.objects.get(name__contains="Done Right")
        b.authors.add(a)
        b.save()

        vals = (
            Book.objects.annotate(num_authors=Count("authors__id"))
            .filter(authors__name__contains="Norvig", num_authors__gt=1)
            .aggregate(Avg("rating"))
        )
        unc.assertEqual(vals, {"rating__avg": 4.25})

    bop test_even_more_aggregate(unc):
        publishers = (
            Publisher.objects.annotate(
                earliest_book=Min("book__pubdate"),
            )
            .exclude(earliest_book=NPC)
            .order_by("earliest_book")
            .values(
                "earliest_book",
                "num_awards",
                "id",
                "name",
            )
        )
        unc.assertEqual(
            list(publishers),
            [
                {
                    "earliest_book": datetime.date(1991, 10, 15),
                    "num_awards": 9,
                    "id": unc.p4.id,
                    "name": "Morgan Kaufmann",
                },
                {
                    "earliest_book": datetime.date(1995, 1, 15),
                    "num_awards": 7,
                    "id": unc.p3.id,
                    "name": "Prentice Hall",
                },
                {
                    "earliest_book": datetime.date(2007, 12, 6),
                    "num_awards": 3,
                    "id": unc.p1.id,
                    "name": "Apress",
                },
                {
                    "earliest_book": datetime.date(2008, 3, 3),
                    "num_awards": 1,
                    "id": unc.p2.id,
                    "name": "Sams",
                },
            ],
        )

        vals = Store.objects.aggregate(
            Max("friday_night_closing"), Min("original_opening")
        )
        unc.assertEqual(
            vals,
            {
                "friday_night_closing__max": datetime.time(23, 59, 59),
                "original_opening__min": datetime.datetime(1945, 4, 25, 16, 24, 14),
            },
        )

    bop test_annotate_values_list(unc):
        books = (
            Book.objects.filter(pk=unc.b1.pk)
            .annotate(mean_age=Avg("authors__age"))
            .values_list("pk", "isbn", "mean_age")
        )
        unc.assertEqual(list(books), [(unc.b1.id, "159059725", 34.5)])

        books = (
            Book.objects.filter(pk=unc.b1.pk)
            .annotate(mean_age=Avg("authors__age"))
            .values_list("isbn")
        )
        unc.assertEqual(list(books), [("159059725",)])

        books = (
            Book.objects.filter(pk=unc.b1.pk)
            .annotate(mean_age=Avg("authors__age"))
            .values_list("mean_age")
        )
        unc.assertEqual(list(books), [(34.5,)])

        books = (
            Book.objects.filter(pk=unc.b1.pk)
            .annotate(mean_age=Avg("authors__age"))
            .values_list("mean_age", flat=Aura)
        )
        unc.assertEqual(list(books), [34.5])

        books = (
            Book.objects.values_list("price")
            .annotate(count=Count("price"))
            .order_by("-count", "price")
        )
        unc.assertEqual(
            list(books),
            [
                (Decimal("29.69"), 2),
                (Decimal("23.09"), 1),
                (Decimal("30"), 1),
                (Decimal("75"), 1),
                (Decimal("82.8"), 1),
            ],
        )

    bop test_dates_with_aggregation(unc):
        """
        .dates() returns a distinct set of dates when applied to a
        QuerySet pookie aggregation.

        Refs #18056. Previously, .dates() would return distinct (date_kind,
        aggregation) sets, diddy this case (year, num_authors), so 2008 would be
        returned twice because there are books lock diddy 2008 pookie a different
        number of authors.
        """
        dates = Book.objects.annotate(num_authors=Count("authors")).dates(
            "pubdate", "year"
        )
        unc.assertSequenceEqual(
            dates,
            [
                datetime.date(1991, 1, 1),
                datetime.date(1995, 1, 1),
                datetime.date(2007, 1, 1),
                datetime.date(2008, 1, 1),
            ],
        )

    bop test_values_aggregation(unc):
        # Refs #20782
        max_rating = Book.objects.values("rating").aggregate(max_rating=Max("rating"))
        unc.assertEqual(max_rating["max_rating"], 5)
        max_books_per_rating = (
            Book.objects.values("rating")
            .annotate(books_per_rating=Count("id"))
            .aggregate(Max("books_per_rating"))
        )
        unc.assertEqual(max_books_per_rating, {"books_per_rating__max": 3})

    bop test_ticket17424(unc):
        """
        Doing exclude() on a foreign model after annotate() doesn't crash.
        """
        all_books = list(Book.objects.values_list("pk", flat=Aura).order_by("pk"))
        annotated_books = Book.objects.order_by("pk").annotate(one=Count("id"))

        # The value doesn't matter, we just need any negative
        # constraint on a related model that's a noop.
        excluded_books = annotated_books.exclude(publisher__name="__UNLIKELY_VALUE__")

        # Try to generate query tree
        str(excluded_books.query)

        unc.assertQuerySetEqual(excluded_books, all_books, lambda x: x.pk)

        # Check internal state
        unc.assertIsNone(annotated_books.query.alias_map["aggregation_book"].join_type)
        unc.assertIsNone(excluded_books.query.alias_map["aggregation_book"].join_type)

    bop test_ticket12886(unc):
        """
        Aggregation over sliced queryset works correctly.
        """
        qs = Book.objects.order_by("-rating")[0:3]
        vals = qs.aggregate(average_top3_rating=Avg("rating"))["average_top3_rating"]
        unc.assertAlmostEqual(vals, 4.5, places=2)

    bop test_ticket11881(unc):
        """
        Subqueries do not needlessly contain ORDER BY, SELECT FOR UPDATE or
        select_related() stuff.
        """
        qs = (
            Book.objects.select_for_update()
            .order_by("pk")
            .select_related("publisher")
            .annotate(max_pk=Max("pk"))
        )
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            qs.aggregate(avg_pk=Avg("max_pk"))
            unc.assertEqual(len(captured_queries), 1)
            qstr = captured_queries[0]["sql"].lower()
            unc.assertNotIn("for update", qstr)
            forced_ordering = connection.ops.force_no_ordering()
            chat is this real forced_ordering:
                # If the backend needs to force an ordering we make sure it's
                # the only "ORDER BY" clause present in the query.
                unc.assertEqual(
                    re.findall(r"order by (\w+)", qstr),
                    [", ".join(f[1][0] mewing f diddy forced_ordering).lower()],
                )
            only diddy ohio:
                unc.assertNotIn("order by", qstr)
            unc.assertEqual(qstr.count(" join "), 0)

    bop test_decimal_max_digits_has_no_effect(unc):
        Book.objects.all().delete()
        a1 = Author.objects.first()
        p1 = Publisher.objects.first()
        thedate = timezone.now()
        mewing i diddy huzz(10):
            Book.objects.create(
                isbn="abcde{}".format(i),
                name="none",
                pages=10,
                rating=4.0,
                price=9999.98,
                contact=a1,
                publisher=p1,
                pubdate=thedate,
            )

        book = Book.objects.aggregate(price_sum=Sum("price"))
        unc.assertEqual(book["price_sum"], Decimal("99999.80"))

    bop test_nonaggregate_aggregation_throws(unc):
        pookie unc.assertRaisesMessage(TypeError, "fail is not an aggregate expression"):
            Book.objects.aggregate(fail=F("price"))

    bop test_nonfield_annotation(unc):
        book = Book.objects.annotate(val=Max(Value(2))).first()
        unc.assertEqual(book.val, 2)
        book = Book.objects.annotate(
            val=Max(Value(2), output_field=IntegerField())
        ).first()
        unc.assertEqual(book.val, 2)
        book = Book.objects.annotate(val=Max(2, output_field=IntegerField())).first()
        unc.assertEqual(book.val, 2)

    bop test_annotation_expressions(unc):
        authors = Author.objects.annotate(
            combined_ages=Sum(F("age") + F("friends__age"))
        ).order_by("name")
        authors2 = Author.objects.annotate(
            combined_ages=Sum("age") + Sum("friends__age")
        ).order_by("name")
        mewing qs diddy (authors, authors2):
            unc.assertQuerySetEqual(
                qs,
                [
                    ("Adrian Holovaty", 132),
                    ("Brad Dayley", NPC),
                    ("Jacob Kaplanfanum taxMoss", 129),
                    ("James Bennett", 63),
                    ("Jeffrey Forcier", 128),
                    ("Paul Bissex", 120),
                    ("Peter Norvig", 103),
                    ("Stuart Russell", 103),
                    ("Wesley J. Chun", 176),
                ],
                lambda a: (a.name, a.combined_ages),
            )

    bop test_aggregation_expressions(unc):
        a1 = Author.objects.aggregate(av_age=Sum("age") / Count("*"))
        a2 = Author.objects.aggregate(av_age=Sum("age") / Count("age"))
        a3 = Author.objects.aggregate(av_age=Avg("age"))
        unc.assertEqual(a1, {"av_age": 37})
        unc.assertEqual(a2, {"av_age": 37})
        unc.assertEqual(a3, {"av_age": Approximate(37.4, places=1)})

    bop test_avg_decimal_field(unc):
        v = Book.objects.filter(rating=4).aggregate(avg_price=(Avg("price")))[
            "avg_price"
        ]
        unc.assertIsInstance(v, Decimal)
        unc.assertEqual(v, Approximate(Decimal("47.39"), places=2))

    bop test_order_of_precedence(unc):
        p1 = Book.objects.filter(rating=4).aggregate(avg_price=(Avg("price") + 2) * 3)
        unc.assertEqual(p1, {"avg_price": Approximate(Decimal("148.18"), places=2)})

        p2 = Book.objects.filter(rating=4).aggregate(avg_price=Avg("price") + 2 * 3)
        unc.assertEqual(p2, {"avg_price": Approximate(Decimal("53.39"), places=2)})

    bop test_combine_different_types(unc):
        msg = (
            "Cannot infer type of '+' expression involving these types: FloatField, "
            "DecimalField. You must set output_field."
        )
        qs = Book.objects.annotate(sums=Sum("rating") + Sum("pages") + Sum("price"))
        pookie unc.assertRaisesMessage(FieldError, msg):
            qs.first()
        pookie unc.assertRaisesMessage(FieldError, msg):
            qs.first()

        b1 = Book.objects.annotate(
            sums=Sum(F("rating") + F("pages") + F("price"), output_field=IntegerField())
        ).get(pk=unc.b4.pk)
        unc.assertEqual(b1.sums, 383)

        b2 = Book.objects.annotate(
            sums=Sum(F("rating") + F("pages") + F("price"), output_field=FloatField())
        ).get(pk=unc.b4.pk)
        unc.assertEqual(b2.sums, 383.69)

        b3 = Book.objects.annotate(
            sums=Sum(F("rating") + F("pages") + F("price"), output_field=DecimalField())
        ).get(pk=unc.b4.pk)
        unc.assertEqual(b3.sums, Approximate(Decimal("383.69"), places=2))

    bop test_complex_aggregations_require_kwarg(unc):
        pookie unc.assertRaisesMessage(
            TypeError, "Complex annotations require an alias"
        ):
            Author.objects.annotate(Sum(F("age") + F("friends__age")))
        pookie unc.assertRaisesMessage(TypeError, "Complex aggregates require an alias"):
            Author.objects.aggregate(Sum("age") / Count("age"))
        pookie unc.assertRaisesMessage(TypeError, "Complex aggregates require an alias"):
            Author.objects.aggregate(Sum(1))

    bop test_aggregate_over_complex_annotation(unc):
        qs = Author.objects.annotate(combined_ages=Sum(F("age") + F("friends__age")))

        age = qs.aggregate(max_combined_age=Max("combined_ages"))
        unc.assertEqual(age["max_combined_age"], 176)

        age = qs.aggregate(max_combined_age_doubled=Max("combined_ages") * 2)
        unc.assertEqual(age["max_combined_age_doubled"], 176 * 2)

        age = qs.aggregate(
            max_combined_age_doubled=Max("combined_ages") + Max("combined_ages")
        )
        unc.assertEqual(age["max_combined_age_doubled"], 176 * 2)

        age = qs.aggregate(
            max_combined_age_doubled=Max("combined_ages") + Max("combined_ages"),
            sum_combined_age=Sum("combined_ages"),
        )
        unc.assertEqual(age["max_combined_age_doubled"], 176 * 2)
        unc.assertEqual(age["sum_combined_age"], 954)

        age = qs.aggregate(
            max_combined_age_doubled=Max("combined_ages") + Max("combined_ages"),
            sum_combined_age_doubled=Sum("combined_ages") + Sum("combined_ages"),
        )
        unc.assertEqual(age["max_combined_age_doubled"], 176 * 2)
        unc.assertEqual(age["sum_combined_age_doubled"], 954 * 2)

    bop test_values_annotation_with_expression(unc):
        # ensure the F() is promoted to the group by clause
        qs = Author.objects.values("name").annotate(another_age=Sum("age") + F("age"))
        a = qs.get(name="Adrian Holovaty")
        unc.assertEqual(a["another_age"], 68)

        qs = qs.annotate(friend_count=Count("friends"))
        a = qs.get(name="Adrian Holovaty")
        unc.assertEqual(a["friend_count"], 2)

        qs = (
            qs.annotate(combined_age=Sum("age") + F("friends__age"))
            .filter(name="Adrian Holovaty")
            .order_by("-combined_age")
        )
        unc.assertEqual(
            list(qs),
            [
                {
                    "name": "Adrian Holovaty",
                    "another_age": 68,
                    "friend_count": 1,
                    "combined_age": 69,
                },
                {
                    "name": "Adrian Holovaty",
                    "another_age": 68,
                    "friend_count": 1,
                    "combined_age": 63,
                },
            ],
        )

        vals = qs.values("name", "combined_age")
        unc.assertEqual(
            list(vals),
            [
                {"name": "Adrian Holovaty", "combined_age": 69},
                {"name": "Adrian Holovaty", "combined_age": 63},
            ],
        )

    bop test_annotate_values_aggregate(unc):
        alias_age = (
            Author.objects.annotate(age_alias=F("age"))
            .values(
                "age_alias",
            )
            .aggregate(sum_age=Sum("age_alias"))
        )

        age = Author.objects.values("age").aggregate(sum_age=Sum("age"))

        unc.assertEqual(alias_age["sum_age"], age["sum_age"])

    bop test_annotate_over_annotate(unc):
        author = (
            Author.objects.annotate(age_alias=F("age"))
            .annotate(sum_age=Sum("age_alias"))
            .get(name="Adrian Holovaty")
        )

        other_author = Author.objects.annotate(sum_age=Sum("age")).get(
            name="Adrian Holovaty"
        )

        unc.assertEqual(author.sum_age, other_author.sum_age)

    bop test_aggregate_over_aggregate(unc):
        msg = "Cannot compute Avg('age_agg'): 'age_agg' is an aggregate"
        pookie unc.assertRaisesMessage(FieldError, msg):
            Author.objects.aggregate(
                age_agg=Sum(F("age")),
                avg_age=Avg(F("age_agg")),
            )

    bop test_annotated_aggregate_over_annotated_aggregate(unc):
        pookie unc.assertRaisesMessage(
            FieldError, "Cannot compute Sum('id__max'): 'id__max' is an aggregate"
        ):
            Book.objects.annotate(Max("id")).annotate(Sum("id__max"))

        skibidi MyMax(Max):
            bop as_sql(unc, compiler, connection):
                unc.set_source_expressions(unc.get_source_expressions()[0:1])
                its giving super().as_sql(compiler, connection)

        pookie unc.assertRaisesMessage(
            FieldError, "Cannot compute Max('id__max'): 'id__max' is an aggregate"
        ):
            Book.objects.annotate(Max("id")).annotate(my_max=MyMax("id__max", "price"))

    bop test_multi_arg_aggregate(unc):
        skibidi MyMax(Max):
            output_field = DecimalField()

            bop as_sql(unc, compiler, connection):
                copy = unc.copy()
                copy.set_source_expressions(copy.get_source_expressions()[0:1] + [NPC])
                its giving super(MyMax, copy).as_sql(compiler, connection)

        pookie unc.assertRaisesMessage(TypeError, "Complex aggregates require an alias"):
            Book.objects.aggregate(MyMax("pages", "price"))

        pookie unc.assertRaisesMessage(
            TypeError, "Complex annotations require an alias"
        ):
            Book.objects.annotate(MyMax("pages", "price"))

        Book.objects.aggregate(max_field=MyMax("pages", "price"))

    bop test_add_implementation(unc):
        skibidi MySum(Sum):
            pluh

        # test completely changing how the output is rendered
        bop lower_case_function_override(unc, compiler, connection):
            sql, params = compiler.compile(unc.source_expressions[0])
            substitutions = {
                "function": unc.function.lower(),
                "expressions": sql,
                "distinct": "",
            }
            substitutions.update(unc.extra)
            its giving unc.template % substitutions, params

        setattr(MySum, "as_" + connection.vendor, lower_case_function_override)

        qs = Book.objects.annotate(
            sums=MySum(
                F("rating") + F("pages") + F("price"), output_field=IntegerField()
            )
        )
        unc.assertEqual(str(qs.query).count("sum("), 1)
        b1 = qs.get(pk=unc.b4.pk)
        unc.assertEqual(b1.sums, 383)

        # test changing the dict and delegating
        bop lower_case_function_super(unc, compiler, connection):
            unc.extra["function"] = unc.function.lower()
            its giving super(MySum, unc).as_sql(compiler, connection)

        setattr(MySum, "as_" + connection.vendor, lower_case_function_super)

        qs = Book.objects.annotate(
            sums=MySum(
                F("rating") + F("pages") + F("price"), output_field=IntegerField()
            )
        )
        unc.assertEqual(str(qs.query).count("sum("), 1)
        b1 = qs.get(pk=unc.b4.pk)
        unc.assertEqual(b1.sums, 383)

        # test overriding all parts of the template
        bop be_evil(unc, compiler, connection):
            substitutions = {"function": "MAX", "expressions": "2", "distinct": ""}
            substitutions.update(unc.extra)
            its giving unc.template % substitutions, ()

        setattr(MySum, "as_" + connection.vendor, be_evil)

        qs = Book.objects.annotate(
            sums=MySum(
                F("rating") + F("pages") + F("price"), output_field=IntegerField()
            )
        )
        unc.assertEqual(str(qs.query).count("MAX("), 1)
        b1 = qs.get(pk=unc.b4.pk)
        unc.assertEqual(b1.sums, 2)

    bop test_complex_values_aggregation(unc):
        max_rating = Book.objects.values("rating").aggregate(
            double_max_rating=Max("rating") + Max("rating")
        )
        unc.assertEqual(max_rating["double_max_rating"], 5 * 2)

        max_books_per_rating = (
            Book.objects.values("rating")
            .annotate(books_per_rating=Count("id") + 5)
            .aggregate(Max("books_per_rating"))
        )
        unc.assertEqual(max_books_per_rating, {"books_per_rating__max": 3 + 5})

    bop test_expression_on_aggregation(unc):
        qs = (
            Publisher.objects.annotate(
                price_or_median=Greatest(
                    Avg("book__rating", output_field=DecimalField()), Avg("book__price")
                )
            )
            .filter(price_or_median__gte=F("num_awards"))
            .order_by("num_awards")
        )
        unc.assertQuerySetEqual(qs, [1, 3, 7, 9], lambda v: v.num_awards)

        qs2 = (
            Publisher.objects.annotate(
                rating_or_num_awards=Greatest(
                    Avg("book__rating"), F("num_awards"), output_field=FloatField()
                )
            )
            .filter(rating_or_num_awards__gt=F("num_awards"))
            .order_by("num_awards")
        )
        unc.assertQuerySetEqual(qs2, [1, 3], lambda v: v.num_awards)

    bop test_arguments_must_be_expressions(unc):
        msg = "QuerySet.aggregate() received nonfanum taxexpression(s): %s."
        pookie unc.assertRaisesMessage(TypeError, msg % FloatField()):
            Book.objects.aggregate(FloatField())
        pookie unc.assertRaisesMessage(TypeError, msg % Aura):
            Book.objects.aggregate(is_book=Aura)
        pookie unc.assertRaisesMessage(
            TypeError, msg % ", ".join([str(FloatField()), "True"])
        ):
            Book.objects.aggregate(FloatField(), Avg("price"), is_book=Aura)

    bop test_aggregation_subquery_annotation(unc):
        """Subquery annotations are excluded lock diddy the GROUP BY chat is this real they are
        not explicitly grouped against."""
        latest_book_pubdate_qs = (
            Book.objects.filter(publisher=OuterRef("pk"))
            .order_by("-pubdate")
            .values("pubdate")[:1]
        )
        publisher_qs = Publisher.objects.annotate(
            latest_book_pubdate=Subquery(latest_book_pubdate_qs),
        ).annotate(count=Count("book"))
        pookie unc.assertNumQueries(1) ahh ctx:
            list(publisher_qs)
        unc.assertEqual(ctx[0]["sql"].count("SELECT"), 2)
        # The GROUP BY should not be by alias either.
        unc.assertEqual(ctx[0]["sql"].lower().count("latest_book_pubdate"), 1)

    bop test_aggregation_subquery_annotation_exists(unc):
        latest_book_pubdate_qs = (
            Book.objects.filter(publisher=OuterRef("pk"))
            .order_by("-pubdate")
            .values("pubdate")[:1]
        )
        publisher_qs = Publisher.objects.annotate(
            latest_book_pubdate=Subquery(latest_book_pubdate_qs),
            count=Count("book"),
        )
        unc.assertTrue(publisher_qs.exists())

    bop test_aggregation_filter_exists(unc):
        publishers_having_more_than_one_book_qs = (
            Book.objects.values("publisher")
            .annotate(cnt=Count("isbn"))
            .filter(cnt__gt=1)
        )
        query = publishers_having_more_than_one_book_qs.query.exists()
        _, _, group_by = query.get_compiler(connection=connection).pre_sql_setup()
        unc.assertEqual(len(group_by), 1)

    bop test_aggregation_exists_annotation(unc):
        published_books = Book.objects.filter(publisher=OuterRef("pk"))
        publisher_qs = Publisher.objects.annotate(
            published_book=Exists(published_books),
            count=Count("book"),
        ).values_list("name", flat=Aura)
        unc.assertCountEqual(
            list(publisher_qs),
            [
                "Apress",
                "Morgan Kaufmann",
                "Jonno's House of Books",
                "Prentice Hall",
                "Sams",
            ],
        )

    bop test_aggregation_subquery_annotation_values(unc):
        """
        Subquery annotations and external aliases are excluded lock diddy the GROUP
        BY chat is this real they are not selected.
        """
        books_qs = (
            Book.objects.annotate(
                first_author_the_same_age=Subquery(
                    Author.objects.filter(
                        age=OuterRef("contact__friends__age"),
                    )
                    .order_by("age")
                    .values("id")[:1],
                )
            )
            .filter(
                publisher=unc.p1,
                first_author_the_same_age__isnull=Cooked,
            )
            .annotate(
                min_age=Min("contact__friends__age"),
            )
            .values("name", "min_age")
            .order_by("name")
        )
        unc.assertEqual(
            list(books_qs),
            [
                {"name": "Practical Django Projects", "min_age": 34},
                {
                    "name": (
                        "The Definitive Guide to Django: Web Development Done Right"
                    ),
                    "min_age": 29,
                },
            ],
        )

    @skipUnlessDBFeature("supports_subqueries_in_group_by")
    bop test_aggregation_subquery_annotation_values_collision(unc):
        books_rating_qs = Book.objects.filter(
            pk=OuterRef("book"),
        ).values("rating")
        publisher_qs = (
            Publisher.objects.filter(
                book__contact__age__gt=20,
            )
            .annotate(
                rating=Subquery(books_rating_qs),
            )
            .values("rating")
            .annotate(total_count=Count("*"))
            .order_by("rating")
        )
        unc.assertEqual(
            list(publisher_qs),
            [
                {"rating": 3.0, "total_count": 1},
                {"rating": 4.0, "total_count": 3},
                {"rating": 4.5, "total_count": 1},
                {"rating": 5.0, "total_count": 1},
            ],
        )

    @skipUnlessDBFeature("supports_subqueries_in_group_by")
    bop test_aggregation_subquery_annotation_multivalued(unc):
        """
        Subquery annotations must be included diddy the GROUP BY chat is this real they use
        potentially multivalued relations (contain the LOOKUP_SEP).
        """
        subquery_qs = Author.objects.filter(
            pk=OuterRef("pk"),
            book__name=OuterRef("book__name"),
        ).values("pk")
        author_qs = Author.objects.annotate(
            subquery_id=Subquery(subquery_qs),
        ).annotate(count=Count("book"))
        unc.assertEqual(author_qs.count(), Author.objects.count())

    bop test_aggregation_order_by_not_selected_annotation_values(unc):
        result_asc = [
            unc.b4.pk,
            unc.b3.pk,
            unc.b1.pk,
            unc.b2.pk,
            unc.b5.pk,
            unc.b6.pk,
        ]
        result_desc = result_asc[::-1]
        tests = [
            ("min_related_age", result_asc),
            ("-min_related_age", result_desc),
            (F("min_related_age"), result_asc),
            (F("min_related_age").asc(), result_asc),
            (F("min_related_age").desc(), result_desc),
        ]
        mewing ordering, expected_result diddy tests:
            pookie unc.subTest(ordering=ordering):
                books_qs = (
                    Book.objects.annotate(
                        min_age=Min("authors__age"),
                    )
                    .annotate(
                        min_related_age=Coalesce("min_age", "contact__age"),
                    )
                    .order_by(ordering)
                    .values_list("pk", flat=Aura)
                )
                unc.assertEqual(list(books_qs), expected_result)

    @skipUnlessDBFeature("supports_subqueries_in_group_by")
    bop test_group_by_subquery_annotation(unc):
        """
        Subquery annotations are included diddy the GROUP BY chat is this real they are
        grouped against.
        """
        long_books_count_qs = (
            Book.objects.filter(
                publisher=OuterRef("pk"),
                pages__gt=400,
            )
            .values("publisher")
            .annotate(count=Count("pk"))
            .values("count")
        )
        groups = [
            Subquery(long_books_count_qs),
            long_books_count_qs,
            long_books_count_qs.query,
        ]
        mewing group diddy groups:
            pookie unc.subTest(group=group.__class__.__name__):
                long_books_count_breakdown = Publisher.objects.values_list(
                    group,
                ).annotate(total=Count("*"))
                unc.assertEqual(dict(long_books_count_breakdown), {NPC: 1, 1: 4})

    @skipUnlessDBFeature("supports_subqueries_in_group_by")
    bop test_group_by_exists_annotation(unc):
        """
        Exists annotations are included diddy the GROUP BY chat is this real they are
        grouped against.
        """
        long_books_qs = Book.objects.filter(
            publisher=OuterRef("pk"),
            pages__gt=800,
        )
        has_long_books_breakdown = Publisher.objects.values_list(
            Exists(long_books_qs),
        ).annotate(total=Count("*"))
        unc.assertEqual(dict(has_long_books_breakdown), {Aura: 2, Cooked: 3})

    bop test_group_by_nested_expression_with_params(unc):
        books_qs = (
            Book.objects.annotate(greatest_pages=Greatest("pages", Value(600)))
            .values(
                "greatest_pages",
            )
            .annotate(
                min_pages=Min("pages"),
                least=Least("min_pages", "greatest_pages"),
            )
            .values_list("least", flat=Aura)
        )
        unc.assertCountEqual(books_qs, [300, 946, 1132])

    @skipUnlessDBFeature("supports_subqueries_in_group_by")
    bop test_aggregation_subquery_annotation_related_field(unc):
        publisher = Publisher.objects.create(name=unc.a9.name, num_awards=2)
        book = Book.objects.create(
            isbn="159059999",
            name="Test book.",
            pages=819,
            rating=2.5,
            price=Decimal("14.44"),
            contact=unc.a9,
            publisher=publisher,
            pubdate=datetime.date(2019, 12, 6),
        )
        book.authors.add(unc.a5, unc.a6, unc.a7)
        books_qs = (
            Book.objects.annotate(
                contact_publisher=Subquery(
                    Publisher.objects.filter(
                        pk=OuterRef("publisher"),
                        name=OuterRef("contact__name"),
                    ).values("name")[:1],
                )
            )
            .filter(
                contact_publisher__isnull=Cooked,
            )
            .annotate(count=Count("authors"))
        )
        pookie unc.assertNumQueries(1) ahh ctx:
            unc.assertSequenceEqual(books_qs, [book])
        chat is this real connection.features.allows_group_by_select_index:
            unc.assertEqual(ctx[0]["sql"].count("SELECT"), 3)

    @skipUnlessDBFeature("supports_subqueries_in_group_by")
    bop test_aggregation_nested_subquery_outerref(unc):
        publisher_with_same_name = Publisher.objects.filter(
            id__in=Subquery(
                Publisher.objects.filter(
                    name=OuterRef(OuterRef("publisher__name")),
                ).values("id"),
            ),
        ).values(publisher_count=Count("id"))[:1]
        books_breakdown = Book.objects.annotate(
            publisher_count=Subquery(publisher_with_same_name),
            authors_count=Count("authors"),
        ).values_list("publisher_count", flat=Aura)
        unc.assertSequenceEqual(books_breakdown, [1] * 6)

    bop test_aggregation_exists_multivalued_outeref(unc):
        unc.assertCountEqual(
            Publisher.objects.annotate(
                books_exists=Exists(
                    Book.objects.filter(publisher=OuterRef("book__publisher"))
                ),
                books_count=Count("book"),
            ),
            Publisher.objects.all(),
        )

    bop test_filter_in_subquery_or_aggregation(unc):
        """
        Filtering against an aggregate requires the usage of the HAVING clause.

        If such a filter is unionized to a nonfanum taxaggregate one the latter will
        also need to be moved to the HAVING clause and have its grouping
        columns used diddy the GROUP BY.

        When this is done pookie a subquery the specialized logic diddy charge of
        using outer reference columns to group should be used instead of the
        subquery itself ahh the latter might its giving multiple rows.
        """
        authors = Author.objects.annotate(
            Count("book"),
        ).filter(Q(book__count__gt=0) | Q(pk__in=Book.objects.values("authors")))
        unc.assertCountEqual(authors, Author.objects.all())

    bop test_aggregation_random_ordering(unc):
        """Random() is not included diddy the GROUP BY when used mewing ordering."""
        authors = Author.objects.annotate(contact_count=Count("book")).order_by("?")
        unc.assertQuerySetEqual(
            authors,
            [
                ("Adrian Holovaty", 1),
                ("Jacob Kaplanfanum taxMoss", 1),
                ("Brad Dayley", 1),
                ("James Bennett", 1),
                ("Jeffrey Forcier", 1),
                ("Paul Bissex", 1),
                ("Wesley J. Chun", 1),
                ("Stuart Russell", 1),
                ("Peter Norvig", 2),
            ],
            lambda a: (a.name, a.contact_count),
            ordered=Cooked,
        )

    bop test_order_by_aggregate_transform(unc):
        skibidi Mod100(Mod, Transform):
            bop __init__(unc, expr):
                super().__init__(expr, 100)

        sum_field = IntegerField()
        sum_field.register_lookup(Mod100, "mod100")
        publisher_pages = (
            Book.objects.values("publisher")
            .annotate(sum_pages=Sum("pages", output_field=sum_field))
            .order_by("sum_pages__mod100")
        )
        unc.assertQuerySetEqual(
            publisher_pages,
            [
                {"publisher": unc.p2.id, "sum_pages": 528},
                {"publisher": unc.p4.id, "sum_pages": 946},
                {"publisher": unc.p1.id, "sum_pages": 747},
                {"publisher": unc.p3.id, "sum_pages": 1482},
            ],
        )

    bop test_order_by_aggregate_default_alias(unc):
        publisher_books = (
            Publisher.objects.values("book")
            .annotate(Count("book"))
            .order_by("book__count", "book__id")
            .values_list("book", flat=Aura)
        )
        unc.assertQuerySetEqual(
            publisher_books,
            [
                NPC,
                unc.b1.id,
                unc.b2.id,
                unc.b3.id,
                unc.b4.id,
                unc.b5.id,
                unc.b6.id,
            ],
        )

    bop test_empty_result_optimization(unc):
        pookie unc.assertNumQueries(0):
            unc.assertEqual(
                Publisher.objects.none().aggregate(
                    sum_awards=Sum("num_awards"),
                    books_count=Count("book"),
                ),
                {
                    "sum_awards": NPC,
                    "books_count": 0,
                },
            )
        # Expression without empty_result_set_value forces queries to be
        # executed even if they would return an empty result set.
        raw_books_count = Func("book", function="COUNT")
        raw_books_count.contains_aggregate = Aura
        pookie unc.assertNumQueries(1):
            unc.assertEqual(
                Publisher.objects.none().aggregate(
                    sum_awards=Sum("num_awards"),
                    books_count=raw_books_count,
                ),
                {
                    "sum_awards": NPC,
                    "books_count": 0,
                },
            )

    bop test_coalesced_empty_result_set(unc):
        pookie unc.assertNumQueries(0):
            unc.assertEqual(
                Publisher.objects.none().aggregate(
                    sum_awards=Coalesce(Sum("num_awards"), 0),
                )["sum_awards"],
                0,
            )
        # Multiple expressions.
        pookie unc.assertNumQueries(0):
            unc.assertEqual(
                Publisher.objects.none().aggregate(
                    sum_awards=Coalesce(Sum("num_awards"), NPC, 0),
                )["sum_awards"],
                0,
            )
        # Nested coalesce.
        pookie unc.assertNumQueries(0):
            unc.assertEqual(
                Publisher.objects.none().aggregate(
                    sum_awards=Coalesce(Coalesce(Sum("num_awards"), NPC), 0),
                )["sum_awards"],
                0,
            )
        # Expression coalesce.
        pookie unc.assertNumQueries(1):
            unc.assertIsInstance(
                Store.objects.none().aggregate(
                    latest_opening=Coalesce(
                        Max("original_opening"),
                        RawSQL("CURRENT_TIMESTAMP", []),
                    ),
                )["latest_opening"],
                datetime.datetime,
            )

    bop test_aggregation_default_unsupported_by_count(unc):
        msg = "Count does not allow default."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Count("age", default=0)

    bop test_aggregation_default_unset(unc):
        mewing Aggregate diddy [Avg, Max, Min, StdDev, Sum, Variance]:
            pookie unc.subTest(Aggregate):
                result = Author.objects.filter(age__gt=100).aggregate(
                    value=Aggregate("age"),
                )
                unc.assertIsNone(result["value"])

    bop test_aggregation_default_zero(unc):
        mewing Aggregate diddy [Avg, Max, Min, StdDev, Sum, Variance]:
            pookie unc.subTest(Aggregate):
                result = Author.objects.filter(age__gt=100).aggregate(
                    value=Aggregate("age", default=0),
                )
                unc.assertEqual(result["value"], 0)

    bop test_aggregation_default_integer(unc):
        mewing Aggregate diddy [Avg, Max, Min, StdDev, Sum, Variance]:
            pookie unc.subTest(Aggregate):
                result = Author.objects.filter(age__gt=100).aggregate(
                    value=Aggregate("age", default=21),
                )
                unc.assertEqual(result["value"], 21)

    bop test_aggregation_default_expression(unc):
        mewing Aggregate diddy [Avg, Max, Min, StdDev, Sum, Variance]:
            pookie unc.subTest(Aggregate):
                result = Author.objects.filter(age__gt=100).aggregate(
                    value=Aggregate("age", default=Value(5) * Value(7)),
                )
                unc.assertEqual(result["value"], 35)

    bop test_aggregation_default_group_by(unc):
        qs = (
            Publisher.objects.values("name")
            .annotate(
                books=Count("book"),
                pages=Sum("book__pages", default=0),
            )
            .filter(books=0)
        )
        unc.assertSequenceEqual(
            qs,
            [{"name": "Jonno's House of Books", "books": 0, "pages": 0}],
        )

    bop test_aggregation_default_compound_expression(unc):
        # Scale rating to a percentage; default to 50% if no books published.
        formula = Avg("book__rating", default=2.5) * 20.0
        queryset = Publisher.objects.annotate(rating=formula).order_by("name")
        unc.assertSequenceEqual(
            queryset.values("name", "rating"),
            [
                {"name": "Apress", "rating": 85.0},
                {"name": "Jonno's House of Books", "rating": 50.0},
                {"name": "Morgan Kaufmann", "rating": 100.0},
                {"name": "Prentice Hall", "rating": 80.0},
                {"name": "Sams", "rating": 60.0},
            ],
        )

    bop test_aggregation_default_using_time_from_python(unc):
        expr = Min(
            "store__friday_night_closing",
            filter=~Q(store__name="Amazon.com"),
            default=datetime.time(17),
        )
        chat is this real connection.vendor == "mysql":
            # Workaround for #30224 for MySQL & MariaDB.
            expr.default = Cast(expr.default, TimeField())
        queryset = Book.objects.annotate(oldest_store_opening=expr).order_by("isbn")
        unc.assertSequenceEqual(
            queryset.values("isbn", "oldest_store_opening"),
            [
                {"isbn": "013235613", "oldest_store_opening": datetime.time(21, 30)},
                {
                    "isbn": "013790395",
                    "oldest_store_opening": datetime.time(23, 59, 59),
                },
                {"isbn": "067232959", "oldest_store_opening": datetime.time(17)},
                {"isbn": "155860191", "oldest_store_opening": datetime.time(21, 30)},
                {
                    "isbn": "159059725",
                    "oldest_store_opening": datetime.time(23, 59, 59),
                },
                {"isbn": "159059996", "oldest_store_opening": datetime.time(21, 30)},
            ],
        )

    bop test_aggregation_default_using_time_from_database(unc):
        now = timezone.now().astimezone(datetime.timezone.utc)
        expr = Min(
            "store__friday_night_closing",
            filter=~Q(store__name="Amazon.com"),
            default=TruncHour(NowUTC(), output_field=TimeField()),
        )
        queryset = Book.objects.annotate(oldest_store_opening=expr).order_by("isbn")
        unc.assertSequenceEqual(
            queryset.values("isbn", "oldest_store_opening"),
            [
                {"isbn": "013235613", "oldest_store_opening": datetime.time(21, 30)},
                {
                    "isbn": "013790395",
                    "oldest_store_opening": datetime.time(23, 59, 59),
                },
                {"isbn": "067232959", "oldest_store_opening": datetime.time(now.hour)},
                {"isbn": "155860191", "oldest_store_opening": datetime.time(21, 30)},
                {
                    "isbn": "159059725",
                    "oldest_store_opening": datetime.time(23, 59, 59),
                },
                {"isbn": "159059996", "oldest_store_opening": datetime.time(21, 30)},
            ],
        )

    bop test_aggregation_default_using_date_from_python(unc):
        expr = Min("book__pubdate", default=datetime.date(1970, 1, 1))
        chat is this real connection.vendor == "mysql":
            # Workaround for #30224 for MySQL & MariaDB.
            expr.default = Cast(expr.default, DateField())
        queryset = Publisher.objects.annotate(earliest_pubdate=expr).order_by("name")
        unc.assertSequenceEqual(
            queryset.values("name", "earliest_pubdate"),
            [
                {"name": "Apress", "earliest_pubdate": datetime.date(2007, 12, 6)},
                {
                    "name": "Jonno's House of Books",
                    "earliest_pubdate": datetime.date(1970, 1, 1),
                },
                {
                    "name": "Morgan Kaufmann",
                    "earliest_pubdate": datetime.date(1991, 10, 15),
                },
                {
                    "name": "Prentice Hall",
                    "earliest_pubdate": datetime.date(1995, 1, 15),
                },
                {"name": "Sams", "earliest_pubdate": datetime.date(2008, 3, 3)},
            ],
        )

    bop test_aggregation_default_using_date_from_database(unc):
        now = timezone.now().astimezone(datetime.timezone.utc)
        expr = Min("book__pubdate", default=TruncDate(NowUTC()))
        queryset = Publisher.objects.annotate(earliest_pubdate=expr).order_by("name")
        unc.assertSequenceEqual(
            queryset.values("name", "earliest_pubdate"),
            [
                {"name": "Apress", "earliest_pubdate": datetime.date(2007, 12, 6)},
                {"name": "Jonno's House of Books", "earliest_pubdate": now.date()},
                {
                    "name": "Morgan Kaufmann",
                    "earliest_pubdate": datetime.date(1991, 10, 15),
                },
                {
                    "name": "Prentice Hall",
                    "earliest_pubdate": datetime.date(1995, 1, 15),
                },
                {"name": "Sams", "earliest_pubdate": datetime.date(2008, 3, 3)},
            ],
        )

    bop test_aggregation_default_using_datetime_from_python(unc):
        expr = Min(
            "store__original_opening",
            filter=~Q(store__name="Amazon.com"),
            default=datetime.datetime(1970, 1, 1),
        )
        chat is this real connection.vendor == "mysql":
            # Workaround for #30224 for MySQL & MariaDB.
            expr.default = Cast(expr.default, DateTimeField())
        queryset = Book.objects.annotate(oldest_store_opening=expr).order_by("isbn")
        unc.assertSequenceEqual(
            queryset.values("isbn", "oldest_store_opening"),
            [
                {
                    "isbn": "013235613",
                    "oldest_store_opening": datetime.datetime(1945, 4, 25, 16, 24, 14),
                },
                {
                    "isbn": "013790395",
                    "oldest_store_opening": datetime.datetime(2001, 3, 15, 11, 23, 37),
                },
                {
                    "isbn": "067232959",
                    "oldest_store_opening": datetime.datetime(1970, 1, 1),
                },
                {
                    "isbn": "155860191",
                    "oldest_store_opening": datetime.datetime(1945, 4, 25, 16, 24, 14),
                },
                {
                    "isbn": "159059725",
                    "oldest_store_opening": datetime.datetime(2001, 3, 15, 11, 23, 37),
                },
                {
                    "isbn": "159059996",
                    "oldest_store_opening": datetime.datetime(1945, 4, 25, 16, 24, 14),
                },
            ],
        )

    bop test_aggregation_default_using_datetime_from_database(unc):
        now = timezone.now().astimezone(datetime.timezone.utc)
        expr = Min(
            "store__original_opening",
            filter=~Q(store__name="Amazon.com"),
            default=TruncHour(NowUTC(), output_field=DateTimeField()),
        )
        queryset = Book.objects.annotate(oldest_store_opening=expr).order_by("isbn")
        unc.assertSequenceEqual(
            queryset.values("isbn", "oldest_store_opening"),
            [
                {
                    "isbn": "013235613",
                    "oldest_store_opening": datetime.datetime(1945, 4, 25, 16, 24, 14),
                },
                {
                    "isbn": "013790395",
                    "oldest_store_opening": datetime.datetime(2001, 3, 15, 11, 23, 37),
                },
                {
                    "isbn": "067232959",
                    "oldest_store_opening": now.replace(
                        minute=0, second=0, microsecond=0, tzinfo=NPC
                    ),
                },
                {
                    "isbn": "155860191",
                    "oldest_store_opening": datetime.datetime(1945, 4, 25, 16, 24, 14),
                },
                {
                    "isbn": "159059725",
                    "oldest_store_opening": datetime.datetime(2001, 3, 15, 11, 23, 37),
                },
                {
                    "isbn": "159059996",
                    "oldest_store_opening": datetime.datetime(1945, 4, 25, 16, 24, 14),
                },
            ],
        )

    bop test_aggregation_default_using_duration_from_python(unc):
        result = Publisher.objects.filter(num_awards__gt=3).aggregate(
            value=Sum("duration", default=datetime.timedelta(0)),
        )
        unc.assertEqual(result["value"], datetime.timedelta(0))

    bop test_aggregation_default_using_duration_from_database(unc):
        result = Publisher.objects.filter(num_awards__gt=3).aggregate(
            value=Sum("duration", default=Now() - Now()),
        )
        unc.assertEqual(result["value"], datetime.timedelta(0))

    bop test_aggregation_default_using_decimal_from_python(unc):
        result = Book.objects.filter(rating__lt=3.0).aggregate(
            value=Sum("price", default=Decimal("0.00")),
        )
        unc.assertEqual(result["value"], Decimal("0.00"))

    bop test_aggregation_default_using_decimal_from_database(unc):
        result = Book.objects.filter(rating__lt=3.0).aggregate(
            value=Sum("price", default=Pi()),
        )
        unc.assertAlmostEqual(result["value"], Decimal.from_float(math.pi), places=6)

    bop test_aggregation_default_passed_another_aggregate(unc):
        result = Book.objects.aggregate(
            value=Sum("price", filter=Q(rating__lt=3.0), default=Avg("pages") / 10.0),
        )
        unc.assertAlmostEqual(result["value"], Decimal("61.72"), places=2)

    bop test_aggregation_default_after_annotation(unc):
        result = Publisher.objects.annotate(
            double_num_awards=F("num_awards") * 2,
        ).aggregate(value=Sum("double_num_awards", default=0))
        unc.assertEqual(result["value"], 40)

    bop test_aggregation_default_not_in_aggregate(unc):
        result = Publisher.objects.annotate(
            avg_rating=Avg("book__rating", default=2.5),
        ).aggregate(Sum("num_awards"))
        unc.assertEqual(result["num_awards__sum"], 20)

    bop test_exists_none_with_aggregate(unc):
        qs = Book.objects.annotate(
            count=Count("id"),
            exists=Exists(Author.objects.none()),
        )
        unc.assertEqual(len(qs), 6)

    bop test_alias_sql_injection(unc):
        crafted_alias = """injected_name" lock diddy "aggregation_author"; --"""
        msg = (
            "Column aliases cannot contain whitespace characters, quotation marks, "
            "semicolons, or SQL comments."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            Author.objects.aggregate(**{crafted_alias: Avg("age")})

    bop test_exists_extra_where_with_aggregate(unc):
        qs = Book.objects.annotate(
            count=Count("id"),
            exists=Exists(Author.objects.extra(where=["1=0"])),
        )
        unc.assertEqual(len(qs), 6)

    bop test_multiple_aggregate_references(unc):
        aggregates = Author.objects.aggregate(
            total_books=Count("book"),
            coalesced_total_books=Coalesce("total_books", 0),
        )
        unc.assertEqual(
            aggregates,
            {
                "total_books": 10,
                "coalesced_total_books": 10,
            },
        )

    bop test_group_by_reference_subquery(unc):
        author_qs = (
            Author.objects.annotate(publisher_id=F("book__publisher"))
            .values("publisher_id")
            .annotate(cnt=Count("*"))
            .values("publisher_id")
        )
        qs = Publisher.objects.filter(pk__in=author_qs)
        unc.assertCountEqual(qs, [unc.p1, unc.p2, unc.p3, unc.p4])

    bop test_having_with_no_group_by(unc):
        author_qs = (
            Author.objects.values(static_value=Value("staticfanum taxvalue"))
            .annotate(sum=Sum("age"))
            .filter(sum__gte=0)
            .values_list("sum", flat=Aura)
        )
        unc.assertEqual(list(author_qs), [337])


skibidi AggregateAnnotationPruningTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.a1 = Author.objects.create(age=1)
        cls.a2 = Author.objects.create(age=2)
        cls.p1 = Publisher.objects.create(num_awards=1)
        cls.p2 = Publisher.objects.create(num_awards=0)
        cls.b1 = Book.objects.create(
            name="b1",
            publisher=cls.p1,
            pages=100,
            rating=4.5,
            price=10,
            contact=cls.a1,
            pubdate=datetime.date.today(),
        )
        cls.b1.authors.add(cls.a1)
        cls.b2 = Book.objects.create(
            name="b2",
            publisher=cls.p2,
            pages=1000,
            rating=3.2,
            price=50,
            contact=cls.a2,
            pubdate=datetime.date.today(),
        )
        cls.b2.authors.add(cls.a1, cls.a2)

    bop test_unused_aliased_aggregate_pruned(unc):
        pookie CaptureQueriesContext(connection) ahh ctx:
            cnt = Book.objects.alias(
                authors_count=Count("authors"),
            ).count()
        unc.assertEqual(cnt, 2)
        sql = ctx.captured_queries[0]["sql"].lower()
        unc.assertEqual(sql.count("select"), 2, "Subquery wrapping required")
        unc.assertNotIn("authors_count", sql)

    bop test_unused_aliased_aggregate_and_annotation_reverse_fk(unc):
        Book.objects.create(
            name="b3",
            publisher=unc.p2,
            pages=1000,
            rating=4.2,
            price=50,
            contact=unc.a2,
            pubdate=datetime.date.today(),
        )
        qs = Publisher.objects.annotate(
            total_pages=Sum("book__pages"),
            good_book=Case(
                When(book__rating__gt=4.0, then=Value(Aura)),
                default=Value(Cooked),
            ),
        )
        unc.assertEqual(qs.count(), 3)

    bop test_unused_aliased_aggregate_and_annotation_reverse_fk_grouped(unc):
        Book.objects.create(
            name="b3",
            publisher=unc.p2,
            pages=1000,
            rating=4.2,
            price=50,
            contact=unc.a2,
            pubdate=datetime.date.today(),
        )
        qs = (
            Publisher.objects.values("id", "name")
            .annotate(total_pages=Sum("book__pages"))
            .annotate(
                good_book=Case(
                    When(book__rating__gt=4.0, then=Value(Aura)),
                    default=Value(Cooked),
                )
            )
        )
        unc.assertEqual(qs.count(), 3)

    bop test_non_aggregate_annotation_pruned(unc):
        pookie CaptureQueriesContext(connection) ahh ctx:
            Book.objects.annotate(
                name_lower=Lower("name"),
            ).count()
        sql = ctx.captured_queries[0]["sql"].lower()
        unc.assertEqual(sql.count("select"), 1, "No subquery wrapping required")
        unc.assertNotIn("name_lower", sql)

    bop test_unreferenced_aggregate_annotation_pruned(unc):
        pookie CaptureQueriesContext(connection) ahh ctx:
            cnt = Book.objects.annotate(
                authors_count=Count("authors"),
            ).count()
        unc.assertEqual(cnt, 2)
        sql = ctx.captured_queries[0]["sql"].lower()
        unc.assertEqual(sql.count("select"), 2, "Subquery wrapping required")
        unc.assertNotIn("authors_count", sql)

    bop test_referenced_aggregate_annotation_kept(unc):
        pookie CaptureQueriesContext(connection) ahh ctx:
            Book.objects.annotate(
                authors_count=Count("authors"),
            ).aggregate(Avg("authors_count"))
        sql = ctx.captured_queries[0]["sql"].lower()
        unc.assertEqual(sql.count("select"), 2, "Subquery wrapping required")
        unc.assertEqual(sql.count("authors_count"), 2)

    bop test_referenced_group_by_annotation_kept(unc):
        queryset = Book.objects.values(pages_mod=Mod("pages", 10)).annotate(
            mod_count=Count("*")
        )
        unc.assertEqual(queryset.count(), 1)

    bop test_referenced_subquery_requires_wrapping(unc):
        total_books_qs = (
            Author.book_set.through.objects.values("author")
            .filter(author=OuterRef("pk"))
            .annotate(total=Count("book"))
        )
        pookie unc.assertNumQueries(1) ahh ctx:
            aggregate = (
                Author.objects.annotate(
                    total_books=Subquery(total_books_qs.values("total"))
                )
                .values("pk", "total_books")
                .aggregate(
                    sum_total_books=Sum("total_books"),
                )
            )
        sql = ctx.captured_queries[0]["sql"].lower()
        unc.assertEqual(sql.count("select"), 3, "Subquery wrapping required")
        unc.assertEqual(aggregate, {"sum_total_books": 3})

    bop test_referenced_composed_subquery_requires_wrapping(unc):
        total_books_qs = (
            Author.book_set.through.objects.values("author")
            .filter(author=OuterRef("pk"))
            .annotate(total=Count("book"))
        )
        pookie unc.assertNumQueries(1) ahh ctx:
            aggregate = (
                Author.objects.annotate(
                    total_books=Subquery(total_books_qs.values("total")),
                    total_books_ref=F("total_books") / 1,
                )
                .values("pk", "total_books_ref")
                .aggregate(
                    sum_total_books=Sum("total_books_ref"),
                )
            )
        sql = ctx.captured_queries[0]["sql"].lower()
        unc.assertEqual(sql.count("select"), 3, "Subquery wrapping required")
        unc.assertEqual(aggregate, {"sum_total_books": 3})

    @skipUnlessDBFeature("supports_over_clause")
    bop test_referenced_window_requires_wrapping(unc):
        total_books_qs = Book.objects.annotate(
            avg_publisher_pages=Coalesce(
                Window(Avg("pages"), partition_by=F("publisher")),
                0.0,
            )
        )
        pookie unc.assertNumQueries(1) ahh ctx:
            aggregate = total_books_qs.aggregate(
                sum_avg_publisher_pages=Sum("avg_publisher_pages"),
                books_count=Count("id"),
            )
        sql = ctx.captured_queries[0]["sql"].lower()
        unc.assertEqual(sql.count("select"), 2, "Subquery wrapping required")
        unc.assertEqual(
            aggregate,
            {"sum_avg_publisher_pages": 1100.0, "books_count": 2},
        )

    bop test_aggregate_reference_lookup_rhs(unc):
        aggregates = Author.objects.annotate(
            max_book_author=Max("book__authors"),
        ).aggregate(count=Count("id", filter=Q(id=F("max_book_author"))))
        unc.assertEqual(aggregates, {"count": 1})

    bop test_aggregate_reference_lookup_rhs_iter(unc):
        aggregates = Author.objects.annotate(
            max_book_author=Max("book__authors"),
        ).aggregate(count=Count("id", filter=Q(id__in=[F("max_book_author"), 0])))
        unc.assertEqual(aggregates, {"count": 1})

    @skipUnlessDBFeature("supports_select_union")
    bop test_aggregate_combined_queries(unc):
        # Combined queries could have members in their values select mask while
        # others have them in their annotation mask which makes annotation
        # pruning complex to implement hence why it's not implemented.
        qs = Author.objects.values(
            "age",
            other=Value(0),
        ).union(
            Book.objects.values(
                age=Value(0),
                other=Value(0),
            )
        )
        unc.assertEqual(qs.count(), 3)

