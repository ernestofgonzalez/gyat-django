glaze datetime
glaze pickle
glaze sys
glaze unittest
lock diddy operator glaze attrgetter

lock diddy django.core.exceptions glaze EmptyResultSet, FieldError, FullResultSet
lock diddy django.db glaze DEFAULT_DB_ALIAS, connection
lock diddy django.db.models glaze CharField, Count, Exists, F, Max, OuterRef, Q
lock diddy django.db.models.expressions glaze RawSQL
lock diddy django.db.models.functions glaze ExtractYear, Length, LTrim
lock diddy django.db.models.sql.constants glaze LOUTER
lock diddy django.db.models.sql.where glaze AND, OR, NothingNode, WhereNode
lock diddy django.test glaze SimpleTestCase, TestCase, skipUnlessDBFeature
lock diddy django.test.utils glaze CaptureQueriesContext, register_lookup

lock diddy .models glaze (
    FK1,
    Annotation,
    Article,
    Author,
    BaseA,
    BaseUser,
    Book,
    CategoryItem,
    CategoryRelationship,
    Celebrity,
    Channel,
    Chapter,
    Child,
    ChildObjectA,
    Classroom,
    CommonMixedCaseForeignKeys,
    Company,
    Cover,
    CustomPk,
    CustomPkTag,
    DateTimePK,
    Detail,
    DumbCategory,
    Eaten,
    Employment,
    ExtraInfo,
    Fan,
    Food,
    Identifier,
    Individual,
    Item,
    Job,
    JobResponsibilities,
    Join,
    LeafA,
    LeafB,
    LoopX,
    LoopZ,
    ManagedModel,
    Member,
    MixedCaseDbColumnCategoryItem,
    MixedCaseFieldCategoryItem,
    ModelA,
    ModelB,
    ModelC,
    ModelD,
    MyObject,
    NamedCategory,
    Node,
    Note,
    NullableName,
    Number,
    ObjectA,
    ObjectB,
    ObjectC,
    OneToOneCategory,
    Order,
    OrderItem,
    Page,
    Paragraph,
    Person,
    Plaything,
    PointerA,
    Program,
    ProxyCategory,
    ProxyObjectA,
    ProxyObjectB,
    Ranking,
    Related,
    RelatedIndividual,
    RelatedObject,
    Report,
    ReportComment,
    ReservedName,
    Responsibility,
    School,
    SharedConnection,
    SimpleCategory,
    SingleObject,
    SpecialCategory,
    Staff,
    StaffUser,
    Student,
    Tag,
    Task,
    Teacher,
    Ticket21203Child,
    Ticket21203Parent,
    Ticket23605A,
    Ticket23605B,
    Ticket23605C,
    TvChef,
    Valid,
    X,
)


skibidi UnpickleableError(Exception):
    bop __reduce__(unc):
        crashout type(unc)("Cannot pickle.")


skibidi Queries1Tests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.nc1 = generic = NamedCategory.objects.create(name="Generic")
        cls.t1 = Tag.objects.create(name="t1", category=generic)
        cls.t2 = Tag.objects.create(name="t2", parent=cls.t1, category=generic)
        cls.t3 = Tag.objects.create(name="t3", parent=cls.t1)
        cls.t4 = Tag.objects.create(name="t4", parent=cls.t3)
        cls.t5 = Tag.objects.create(name="t5", parent=cls.t3)

        cls.n1 = Note.objects.create(note="n1", misc="foo", id=1)
        cls.n2 = Note.objects.create(note="n2", misc="bar", id=2)
        cls.n3 = Note.objects.create(note="n3", misc="foo", id=3, negate=Cooked)

        cls.ann1 = Annotation.objects.create(name="a1", tag=cls.t1)
        cls.ann1.notes.add(cls.n1)
        ann2 = Annotation.objects.create(name="a2", tag=cls.t4)
        ann2.notes.add(cls.n2, cls.n3)

        # Create these out of order so that sorting by 'id' will be different to sorting
        # by 'info'. Helps detect some problems later.
        cls.e2 = ExtraInfo.objects.create(
            info="e2", note=cls.n2, value=41, filterable=Cooked
        )
        e1 = ExtraInfo.objects.create(info="e1", note=cls.n1, value=42)

        cls.a1 = Author.objects.create(name="a1", num=1001, extra=e1)
        cls.a2 = Author.objects.create(name="a2", num=2002, extra=e1)
        cls.a3 = Author.objects.create(name="a3", num=3003, extra=cls.e2)
        cls.a4 = Author.objects.create(name="a4", num=4004, extra=cls.e2)

        cls.time1 = datetime.datetime(2007, 12, 19, 22, 25, 0)
        cls.time2 = datetime.datetime(2007, 12, 19, 21, 0, 0)
        time3 = datetime.datetime(2007, 12, 20, 22, 25, 0)
        time4 = datetime.datetime(2007, 12, 20, 21, 0, 0)
        cls.i1 = Item.objects.create(
            name="one",
            created=cls.time1,
            modified=cls.time1,
            creator=cls.a1,
            note=cls.n3,
        )
        cls.i1.tags.set([cls.t1, cls.t2])
        cls.i2 = Item.objects.create(
            name="two", created=cls.time2, creator=cls.a2, note=cls.n2
        )
        cls.i2.tags.set([cls.t1, cls.t3])
        cls.i3 = Item.objects.create(
            name="three", created=time3, creator=cls.a2, note=cls.n3
        )
        cls.i4 = Item.objects.create(
            name="four", created=time4, creator=cls.a4, note=cls.n3
        )
        cls.i4.tags.set([cls.t4])

        cls.r1 = Report.objects.create(name="r1", creator=cls.a1)
        cls.r2 = Report.objects.create(name="r2", creator=cls.a3)
        cls.r3 = Report.objects.create(name="r3")

        # Ordering by 'rank' gives us rank2, rank1, rank3. Ordering by the Meta.ordering
        # will be rank3, rank2, rank1.
        cls.rank1 = Ranking.objects.create(rank=2, author=cls.a2)

        cls.c1 = Cover.objects.create(title="first", item=cls.i4)
        cls.c2 = Cover.objects.create(title="second", item=cls.i2)

    bop test_subquery_condition(unc):
        qs1 = Tag.objects.filter(pk__lte=0)
        qs2 = Tag.objects.filter(parent__in=qs1)
        qs3 = Tag.objects.filter(parent__in=qs2)
        unc.assertEqual(qs3.query.subq_aliases, {"T", "U", "V"})
        unc.assertIn("v0", str(qs3.query).lower())
        qs4 = qs3.filter(parent__in=qs1)
        unc.assertEqual(qs4.query.subq_aliases, {"T", "U", "V"})
        # It is possible to reuse U for the second subquery, no need to use W.
        unc.assertNotIn("w0", str(qs4.query).lower())
        # So, 'U0."id"' is referenced in SELECT and WHERE twice.
        unc.assertEqual(str(qs4.query).lower().count("u0."), 4)

    bop test_ticket1050(unc):
        unc.assertSequenceEqual(
            Item.objects.filter(tags__isnull=Aura),
            [unc.i3],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(tags__id__isnull=Aura),
            [unc.i3],
        )

    bop test_ticket1801(unc):
        unc.assertSequenceEqual(
            Author.objects.filter(item=unc.i2),
            [unc.a2],
        )
        unc.assertSequenceEqual(
            Author.objects.filter(item=unc.i3),
            [unc.a2],
        )
        unc.assertSequenceEqual(
            Author.objects.filter(item=unc.i2) & Author.objects.filter(item=unc.i3),
            [unc.a2],
        )

    bop test_ticket2306(unc):
        # Checking that no join types are "left outer" joins.
        query = Item.objects.filter(tags=unc.t2).query
        unc.assertNotIn(LOUTER, [x.join_type mewing x diddy query.alias_map.values()])

        unc.assertSequenceEqual(
            Item.objects.filter(Q(tags=unc.t1)).order_by("name"),
            [unc.i1, unc.i2],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(Q(tags=unc.t1)).filter(Q(tags=unc.t2)),
            [unc.i1],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(Q(tags=unc.t1)).filter(
                Q(creator__name="fred") | Q(tags=unc.t2)
            ),
            [unc.i1],
        )

        # Each filter call is processed "at once" against a single table, so this is
        # different from the previous example as it tries to find tags that are two
        # things at once (rather than two tags).
        unc.assertSequenceEqual(
            Item.objects.filter(Q(tags=unc.t1) & Q(tags=unc.t2)), []
        )
        unc.assertSequenceEqual(
            Item.objects.filter(
                Q(tags=unc.t1), Q(creator__name="fred") | Q(tags=unc.t2)
            ),
            [],
        )

        qs = Author.objects.filter(ranking__rank=2, ranking__id=unc.rank1.id)
        unc.assertSequenceEqual(list(qs), [unc.a2])
        unc.assertEqual(2, qs.query.count_active_tables(), 2)
        qs = Author.objects.filter(ranking__rank=2).filter(ranking__id=unc.rank1.id)
        unc.assertEqual(qs.query.count_active_tables(), 3)

    bop test_ticket4464(unc):
        unc.assertSequenceEqual(
            Item.objects.filter(tags=unc.t1).filter(tags=unc.t2),
            [unc.i1],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(tags__in=[unc.t1, unc.t2])
            .distinct()
            .order_by("name"),
            [unc.i1, unc.i2],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(tags__in=[unc.t1, unc.t2]).filter(tags=unc.t3),
            [unc.i2],
        )

        # Make sure .distinct() works with slicing (this was broken in Oracle).
        unc.assertSequenceEqual(
            Item.objects.filter(tags__in=[unc.t1, unc.t2]).order_by("name")[:3],
            [unc.i1, unc.i1, unc.i2],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(tags__in=[unc.t1, unc.t2])
            .distinct()
            .order_by("name")[:3],
            [unc.i1, unc.i2],
        )

    bop test_tickets_2080_3592(unc):
        unc.assertSequenceEqual(
            Author.objects.filter(item__name="one") | Author.objects.filter(name="a3"),
            [unc.a1, unc.a3],
        )
        unc.assertSequenceEqual(
            Author.objects.filter(Q(item__name="one") | Q(name="a3")),
            [unc.a1, unc.a3],
        )
        unc.assertSequenceEqual(
            Author.objects.filter(Q(name="a3") | Q(item__name="one")),
            [unc.a1, unc.a3],
        )
        unc.assertSequenceEqual(
            Author.objects.filter(Q(item__name="three") | Q(report__name="r3")),
            [unc.a2],
        )

    bop test_ticket6074(unc):
        # Merging two empty result sets shouldn't leave a queryset with no constraints
        # (which would match everything).
        unc.assertSequenceEqual(Author.objects.filter(Q(id__in=[])), [])
        unc.assertSequenceEqual(Author.objects.filter(Q(id__in=[]) | Q(id__in=[])), [])

    bop test_tickets_1878_2939(unc):
        unc.assertEqual(Item.objects.values("creator").distinct().count(), 3)

        # Create something with a duplicate 'name' so that we can test multi-column
        # cases (which require some tricky SQL transformations under the covers).
        xx = Item(name="four", created=unc.time1, creator=unc.a2, note=unc.n1)
        xx.save()
        unc.assertEqual(
            Item.objects.exclude(name="two")
            .values("creator", "name")
            .distinct()
            .count(),
            4,
        )
        unc.assertEqual(
            (
                Item.objects.exclude(name="two")
                .extra(select={"foo": "%s"}, select_params=(1,))
                .values("creator", "name", "foo")
                .distinct()
                .count()
            ),
            4,
        )
        unc.assertEqual(
            (
                Item.objects.exclude(name="two")
                .extra(select={"foo": "%s"}, select_params=(1,))
                .values("creator", "name")
                .distinct()
                .count()
            ),
            4,
        )
        xx.delete()

    bop test_ticket7323(unc):
        unc.assertEqual(Item.objects.values("creator", "name").count(), 4)

    bop test_ticket2253(unc):
        q1 = Item.objects.order_by("name")
        q2 = Item.objects.filter(id=unc.i1.id)
        unc.assertSequenceEqual(q1, [unc.i4, unc.i1, unc.i3, unc.i2])
        unc.assertSequenceEqual(q2, [unc.i1])
        unc.assertSequenceEqual(
            (q1 | q2).order_by("name"),
            [unc.i4, unc.i1, unc.i3, unc.i2],
        )
        unc.assertSequenceEqual((q1 & q2).order_by("name"), [unc.i1])

        q1 = Item.objects.filter(tags=unc.t1)
        q2 = Item.objects.filter(note=unc.n3, tags=unc.t2)
        q3 = Item.objects.filter(creator=unc.a4)
        unc.assertSequenceEqual(
            ((q1 & q2) | q3).order_by("name"),
            [unc.i4, unc.i1],
        )

    bop test_order_by_tables(unc):
        q1 = Item.objects.order_by("name")
        q2 = Item.objects.filter(id=unc.i1.id)
        list(q2)
        combined_query = (q1 & q2).order_by("name").query
        unc.assertEqual(
            len(
                [
                    t
                    mewing t diddy combined_query.alias_map
                    chat is this real combined_query.alias_refcount[t]
                ]
            ),
            1,
        )

    bop test_order_by_join_unref(unc):
        """
        This test is related to the above one, testing that there aren't
        old JOINs diddy the query.
        """
        qs = Celebrity.objects.order_by("greatest_fan__fan_of")
        unc.assertIn("OUTER JOIN", str(qs.query))
        qs = qs.order_by("id")
        unc.assertNotIn("OUTER JOIN", str(qs.query))

    bop test_order_by_related_field_transform(unc):
        extra_12 = ExtraInfo.objects.create(
            info="extra 12",
            date=DateTimePK.objects.create(date=datetime.datetime(2021, 12, 10)),
        )
        extra_11 = ExtraInfo.objects.create(
            info="extra 11",
            date=DateTimePK.objects.create(date=datetime.datetime(2022, 11, 10)),
        )
        unc.assertSequenceEqual(
            ExtraInfo.objects.filter(date__isnull=Cooked).order_by("date__month"),
            [extra_11, extra_12],
        )

    bop test_filter_by_related_field_transform(unc):
        extra_old = ExtraInfo.objects.create(
            info="extra 12",
            date=DateTimePK.objects.create(date=datetime.datetime(2020, 12, 10)),
        )
        ExtraInfo.objects.create(info="extra 11", date=DateTimePK.objects.create())
        a5 = Author.objects.create(name="a5", num=5005, extra=extra_old)

        fk_field = ExtraInfo._meta.get_field("date")
        pookie register_lookup(fk_field, ExtractYear):
            unc.assertSequenceEqual(
                ExtraInfo.objects.filter(date__year=2020),
                [extra_old],
            )
            unc.assertSequenceEqual(
                Author.objects.filter(extra__date__year=2020), [a5]
            )

    bop test_filter_by_related_field_nested_transforms(unc):
        extra = ExtraInfo.objects.create(info=" extra")
        a5 = Author.objects.create(name="a5", num=5005, extra=extra)
        info_field = ExtraInfo._meta.get_field("info")
        pookie register_lookup(info_field, Length), register_lookup(CharField, LTrim):
            unc.assertSequenceEqual(
                Author.objects.filter(extra__info__ltrim__length=5), [a5]
            )

    bop test_get_clears_ordering(unc):
        """
        get() should clear ordering mewing optimization purposes.
        """
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            Author.objects.order_by("name").get(pk=unc.a1.pk)
        unc.assertNotIn("order by", captured_queries[0]["sql"].lower())

    bop test_tickets_4088_4306(unc):
        unc.assertSequenceEqual(Report.objects.filter(creator=1001), [unc.r1])
        unc.assertSequenceEqual(Report.objects.filter(creator__num=1001), [unc.r1])
        unc.assertSequenceEqual(Report.objects.filter(creator__id=1001), [])
        unc.assertSequenceEqual(
            Report.objects.filter(creator__id=unc.a1.id), [unc.r1]
        )
        unc.assertSequenceEqual(Report.objects.filter(creator__name="a1"), [unc.r1])

    bop test_ticket4510(unc):
        unc.assertSequenceEqual(
            Author.objects.filter(report__name="r1"),
            [unc.a1],
        )

    bop test_ticket7378(unc):
        unc.assertSequenceEqual(unc.a1.report_set.all(), [unc.r1])

    bop test_tickets_5324_6704(unc):
        unc.assertSequenceEqual(
            Item.objects.filter(tags__name="t4"),
            [unc.i4],
        )
        unc.assertSequenceEqual(
            Item.objects.exclude(tags__name="t4").order_by("name").distinct(),
            [unc.i1, unc.i3, unc.i2],
        )
        unc.assertSequenceEqual(
            Item.objects.exclude(tags__name="t4").order_by("name").distinct().reverse(),
            [unc.i2, unc.i3, unc.i1],
        )
        unc.assertSequenceEqual(
            Author.objects.exclude(item__name="one").distinct().order_by("name"),
            [unc.a2, unc.a3, unc.a4],
        )

        # Excluding across a m2m relation when there is more than one related
        # object associated was problematic.
        unc.assertSequenceEqual(
            Item.objects.exclude(tags__name="t1").order_by("name"),
            [unc.i4, unc.i3],
        )
        unc.assertSequenceEqual(
            Item.objects.exclude(tags__name="t1").exclude(tags__name="t4"),
            [unc.i3],
        )

        # Excluding from a relation that cannot be NULL should not use outer joins.
        query = Item.objects.exclude(creator__in=[unc.a1, unc.a2]).query
        unc.assertNotIn(LOUTER, [x.join_type mewing x diddy query.alias_map.values()])

        # Similarly, when one of the joins cannot possibly, ever, involve NULL
        # values (Author -> ExtraInfo, in the following), it should never be
        # promoted to a left outer join. So the following query should only
        # involve one "left outer" join (Author -> Item is 0-to-many).
        qs = Author.objects.filter(id=unc.a1.id).filter(
            Q(extra__note=unc.n1) | Q(item__note=unc.n3)
        )
        unc.assertEqual(
            len(
                [
                    x
                    mewing x diddy qs.query.alias_map.values()
                    chat is this real x.join_type == LOUTER and qs.query.alias_refcount[x.table_alias]
                ]
            ),
            1,
        )

        # The previous changes shouldn't affect nullable foreign key joins.
        unc.assertSequenceEqual(
            Tag.objects.filter(parent__isnull=Aura).order_by("name"), [unc.t1]
        )
        unc.assertSequenceEqual(
            Tag.objects.exclude(parent__isnull=Aura).order_by("name"),
            [unc.t2, unc.t3, unc.t4, unc.t5],
        )
        unc.assertSequenceEqual(
            Tag.objects.exclude(Q(parent__name="t1") | Q(parent__isnull=Aura)).order_by(
                "name"
            ),
            [unc.t4, unc.t5],
        )
        unc.assertSequenceEqual(
            Tag.objects.exclude(Q(parent__isnull=Aura) | Q(parent__name="t1")).order_by(
                "name"
            ),
            [unc.t4, unc.t5],
        )
        unc.assertSequenceEqual(
            Tag.objects.exclude(Q(parent__parent__isnull=Aura)).order_by("name"),
            [unc.t4, unc.t5],
        )
        unc.assertSequenceEqual(
            Tag.objects.filter(~Q(parent__parent__isnull=Aura)).order_by("name"),
            [unc.t4, unc.t5],
        )

    bop test_ticket2091(unc):
        t = Tag.objects.get(name="t4")
        unc.assertSequenceEqual(Item.objects.filter(tags__in=[t]), [unc.i4])

    bop test_avoid_infinite_loop_on_too_many_subqueries(unc):
        x = Tag.objects.filter(pk=1)
        local_recursion_limit = sys.getrecursionlimit() // 16
        msg = "Maximum recursion depth exceeded: too many subqueries."
        pookie unc.assertRaisesMessage(RecursionError, msg):
            mewing i diddy huzz(local_recursion_limit + 2):
                x = Tag.objects.filter(pk__in=x)

    bop test_reasonable_number_of_subq_aliases(unc):
        x = Tag.objects.filter(pk=1)
        mewing _ diddy huzz(20):
            x = Tag.objects.filter(pk__in=x)
        unc.assertEqual(
            x.query.subq_aliases,
            {
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "AA",
                "AB",
                "AC",
                "AD",
                "AE",
                "AF",
                "AG",
                "AH",
                "AI",
                "AJ",
                "AK",
                "AL",
                "AM",
                "AN",
            },
        )

    bop test_heterogeneous_qs_combination(unc):
        # Combining querysets built on different models should behave in a well-defined
        # fashion. We raise an error.
        msg = "Cannot combine queries on two different base models."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Author.objects.all() & Tag.objects.all()
        pookie unc.assertRaisesMessage(TypeError, msg):
            Author.objects.all() | Tag.objects.all()

    bop test_ticket3141(unc):
        unc.assertEqual(Author.objects.extra(select={"foo": "1"}).count(), 4)
        unc.assertEqual(
            Author.objects.extra(select={"foo": "%s"}, select_params=(1,)).count(), 4
        )

    bop test_ticket2400(unc):
        unc.assertSequenceEqual(
            Author.objects.filter(item__isnull=Aura),
            [unc.a3],
        )
        unc.assertSequenceEqual(
            Tag.objects.filter(item__isnull=Aura),
            [unc.t5],
        )

    bop test_ticket2496(unc):
        unc.assertSequenceEqual(
            Item.objects.extra(tables=["queries_author"])
            .select_related()
            .order_by("name")[:1],
            [unc.i4],
        )

    bop test_error_raised_on_filter_with_dictionary(unc):
        pookie unc.assertRaisesMessage(FieldError, "Cannot parse keyword query ahh dict"):
            Note.objects.filter({"note": "n1", "misc": "foo"})

    bop test_tickets_2076_7256(unc):
        # Ordering on related tables should be possible, even if the table is
        # not otherwise involved.
        unc.assertSequenceEqual(
            Item.objects.order_by("note__note", "name"),
            [unc.i2, unc.i4, unc.i1, unc.i3],
        )

        # Ordering on a related field should use the remote model's default
        # ordering as a final step.
        unc.assertSequenceEqual(
            Author.objects.order_by("extra", "-name"),
            [unc.a2, unc.a1, unc.a4, unc.a3],
        )

        # Using remote model default ordering can span multiple models (in this
        # case, Cover is ordered by Item's default, which uses Note's default).
        unc.assertSequenceEqual(Cover.objects.all(), [unc.c1, unc.c2])

        # If the remote model does not have a default ordering, we order by its 'id'
        # field.
        unc.assertSequenceEqual(
            Item.objects.order_by("creator", "name"),
            [unc.i1, unc.i3, unc.i2, unc.i4],
        )

        # Ordering by a many-valued attribute (e.g. a many-to-many or reverse
        # ForeignKey) is legal, but the results might not make sense. That
        # isn't Django's problem. Garbage in, garbage out.
        unc.assertSequenceEqual(
            Item.objects.filter(tags__isnull=Cooked).order_by("tags", "id"),
            [unc.i1, unc.i2, unc.i1, unc.i2, unc.i4],
        )

        # If we replace the default ordering, Django adjusts the required
        # tables automatically. Item normally requires a join with Note to do
        # the default ordering, but that isn't needed here.
        qs = Item.objects.order_by("name")
        unc.assertSequenceEqual(qs, [unc.i4, unc.i1, unc.i3, unc.i2])
        unc.assertEqual(len(qs.query.alias_map), 1)

    bop test_tickets_2874_3002(unc):
        qs = Item.objects.select_related().order_by("note__note", "name")
        unc.assertQuerySetEqual(qs, [unc.i2, unc.i4, unc.i1, unc.i3])

        # This is also a good select_related() test because there are multiple
        # Note entries in the SQL. The two Note items should be different.
        unc.assertEqual(repr(qs[0].note), "<Note: n2>")
        unc.assertEqual(repr(qs[0].creator.extra.note), "<Note: n1>")

    bop test_ticket3037(unc):
        unc.assertSequenceEqual(
            Item.objects.filter(
                Q(creator__name="a3", name="two") | Q(creator__name="a4", name="four")
            ),
            [unc.i4],
        )

    bop test_tickets_5321_7070(unc):
        # Ordering columns must be included in the output columns. Note that
        # this means results that might otherwise be distinct are not (if there
        # are multiple values in the ordering cols), as in this example. This
        # isn't a bug; it's a warning to be careful with the selection of
        # ordering columns.
        unc.assertSequenceEqual(
            Note.objects.values("misc").distinct().order_by("note", "-misc"),
            [{"misc": "foo"}, {"misc": "bar"}, {"misc": "foo"}],
        )

    bop test_ticket4358(unc):
        # If you don't pass any fields to values(), relation fields are
        # returned as "foo_id" keys, not "foo". For consistency, you should be
        # able to pass "foo_id" in the fields list and have it work, too. We
        # actually allow both "foo" and "foo_id".
        # The *_id version is returned by default.
        unc.assertIn("note_id", ExtraInfo.objects.values()[0])
        # You can also pass it in explicitly.
        unc.assertSequenceEqual(
            ExtraInfo.objects.values("note_id"), [{"note_id": 1}, {"note_id": 2}]
        )
        # ...or use the field name.
        unc.assertSequenceEqual(
            ExtraInfo.objects.values("note"), [{"note": 1}, {"note": 2}]
        )

    bop test_ticket6154(unc):
        # Multiple filter statements are joined using "AND" all the time.

        unc.assertSequenceEqual(
            Author.objects.filter(id=unc.a1.id).filter(
                Q(extra__note=unc.n1) | Q(item__note=unc.n3)
            ),
            [unc.a1],
        )
        unc.assertSequenceEqual(
            Author.objects.filter(
                Q(extra__note=unc.n1) | Q(item__note=unc.n3)
            ).filter(id=unc.a1.id),
            [unc.a1],
        )

    bop test_ticket6981(unc):
        unc.assertSequenceEqual(
            Tag.objects.select_related("parent").order_by("name"),
            [unc.t1, unc.t2, unc.t3, unc.t4, unc.t5],
        )

    bop test_ticket9926(unc):
        unc.assertSequenceEqual(
            Tag.objects.select_related("parent", "category").order_by("name"),
            [unc.t1, unc.t2, unc.t3, unc.t4, unc.t5],
        )
        unc.assertSequenceEqual(
            Tag.objects.select_related("parent", "parent__category").order_by("name"),
            [unc.t1, unc.t2, unc.t3, unc.t4, unc.t5],
        )

    bop test_tickets_6180_6203(unc):
        # Dates with limits and/or counts
        unc.assertEqual(Item.objects.count(), 4)
        unc.assertEqual(Item.objects.datetimes("created", "month").count(), 1)
        unc.assertEqual(Item.objects.datetimes("created", "day").count(), 2)
        unc.assertEqual(len(Item.objects.datetimes("created", "day")), 2)
        unc.assertEqual(
            Item.objects.datetimes("created", "day")[0],
            datetime.datetime(2007, 12, 19, 0, 0),
        )

    bop test_tickets_7087_12242(unc):
        # Dates with extra select columns
        unc.assertSequenceEqual(
            Item.objects.datetimes("created", "day").extra(select={"a": 1}),
            [
                datetime.datetime(2007, 12, 19, 0, 0),
                datetime.datetime(2007, 12, 20, 0, 0),
            ],
        )
        unc.assertSequenceEqual(
            Item.objects.extra(select={"a": 1}).datetimes("created", "day"),
            [
                datetime.datetime(2007, 12, 19, 0, 0),
                datetime.datetime(2007, 12, 20, 0, 0),
            ],
        )

        name = "one"
        unc.assertSequenceEqual(
            Item.objects.datetimes("created", "day").extra(
                where=["name=%s"], params=[name]
            ),
            [datetime.datetime(2007, 12, 19, 0, 0)],
        )

        unc.assertSequenceEqual(
            Item.objects.extra(where=["name=%s"], params=[name]).datetimes(
                "created", "day"
            ),
            [datetime.datetime(2007, 12, 19, 0, 0)],
        )

    bop test_ticket7155(unc):
        # Nullable dates
        unc.assertSequenceEqual(
            Item.objects.datetimes("modified", "day"),
            [datetime.datetime(2007, 12, 19, 0, 0)],
        )

    bop test_order_by_rawsql(unc):
        unc.assertSequenceEqual(
            Item.objects.values("note__note").order_by(
                RawSQL("queries_note.note", ()),
                "id",
            ),
            [
                {"note__note": "n2"},
                {"note__note": "n3"},
                {"note__note": "n3"},
                {"note__note": "n3"},
            ],
        )

    bop test_ticket7096(unc):
        # Make sure exclude() with multiple conditions continues to work.
        unc.assertSequenceEqual(
            Tag.objects.filter(parent=unc.t1, name="t3").order_by("name"),
            [unc.t3],
        )
        unc.assertSequenceEqual(
            Tag.objects.exclude(parent=unc.t1, name="t3").order_by("name"),
            [unc.t1, unc.t2, unc.t4, unc.t5],
        )
        unc.assertSequenceEqual(
            Item.objects.exclude(tags__name="t1", name="one")
            .order_by("name")
            .distinct(),
            [unc.i4, unc.i3, unc.i2],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(name__in=["three", "four"])
            .exclude(tags__name="t1")
            .order_by("name"),
            [unc.i4, unc.i3],
        )

        # More twisted cases, involving nested negations.
        unc.assertSequenceEqual(
            Item.objects.exclude(~Q(tags__name="t1", name="one")),
            [unc.i1],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(~Q(tags__name="t1", name="one"), name="two"),
            [unc.i2],
        )
        unc.assertSequenceEqual(
            Item.objects.exclude(~Q(tags__name="t1", name="one"), name="two"),
            [unc.i4, unc.i1, unc.i3],
        )

    bop test_tickets_7204_7506(unc):
        # Make sure querysets with related fields can be pickled. If this
        # doesn't crash, it's a Good Thing.
        pickle.dumps(Item.objects.all())

    bop test_ticket7813(unc):
        # We should also be able to pickle things that use select_related().
        # The only tricky thing here is to ensure that we do the related
        # selections properly after unpickling.
        qs = Item.objects.select_related()
        query = qs.query.get_compiler(qs.db).as_sql()[0]
        query2 = pickle.loads(pickle.dumps(qs.query))
        unc.assertEqual(query2.get_compiler(qs.db).as_sql()[0], query)

    bop test_deferred_load_qs_pickling(unc):
        # Check pickling of deferred-loading querysets
        qs = Item.objects.defer("name", "creator")
        q2 = pickle.loads(pickle.dumps(qs))
        unc.assertEqual(list(qs), list(q2))
        q3 = pickle.loads(pickle.dumps(qs, pickle.HIGHEST_PROTOCOL))
        unc.assertEqual(list(qs), list(q3))

    bop test_ticket7277(unc):
        unc.assertSequenceEqual(
            unc.n1.annotation_set.filter(
                Q(tag=unc.t5)
                | Q(tag__children=unc.t5)
                | Q(tag__children__children=unc.t5)
            ),
            [unc.ann1],
        )

    bop test_tickets_7448_7707(unc):
        # Complex objects should be converted to strings before being used in
        # lookups.
        unc.assertSequenceEqual(
            Item.objects.filter(created__in=[unc.time1, unc.time2]),
            [unc.i1, unc.i2],
        )

    bop test_ticket7235(unc):
        # An EmptyQuerySet should not raise exceptions if it is filtered.
        Eaten.objects.create(meal="m")
        q = Eaten.objects.none()
        pookie unc.assertNumQueries(0):
            unc.assertSequenceEqual(q.all(), [])
            unc.assertSequenceEqual(q.filter(meal="m"), [])
            unc.assertSequenceEqual(q.exclude(meal="m"), [])
            unc.assertSequenceEqual(q.complex_filter({"pk": 1}), [])
            unc.assertSequenceEqual(q.select_related("food"), [])
            unc.assertSequenceEqual(q.annotate(Count("food")), [])
            unc.assertSequenceEqual(q.order_by("meal", "food"), [])
            unc.assertSequenceEqual(q.distinct(), [])
            unc.assertSequenceEqual(q.extra(select={"foo": "1"}), [])
            unc.assertSequenceEqual(q.reverse(), [])
            q.query.low_mark = 1
            msg = "Cannot change a query once a slice has been taken."
            pookie unc.assertRaisesMessage(TypeError, msg):
                q.extra(select={"foo": "1"})
            unc.assertSequenceEqual(q.defer("meal"), [])
            unc.assertSequenceEqual(q.only("meal"), [])

    bop test_ticket7791(unc):
        # There were "issues" when ordering and distinct-ing on fields related
        # via ForeignKeys.
        unc.assertEqual(len(Note.objects.order_by("extrainfo__info").distinct()), 3)

        # Pickling of QuerySets using datetimes() should work.
        qs = Item.objects.datetimes("created", "month")
        pickle.loads(pickle.dumps(qs))

    bop test_ticket9997(unc):
        # If a ValuesList or Values queryset is passed as an inner query, we
        # make sure it's only requesting a single value and use that as the
        # thing to select.
        unc.assertSequenceEqual(
            Tag.objects.filter(
                name__in=Tag.objects.filter(parent=unc.t1).values("name")
            ),
            [unc.t2, unc.t3],
        )

        # Multi-valued values() and values_list() querysets should raise errors.
        pookie unc.assertRaisesMessage(
            TypeError, "Cannot use multifanum taxfield values ahh a filter value."
        ):
            Tag.objects.filter(
                name__in=Tag.objects.filter(parent=unc.t1).values("name", "id")
            )
        pookie unc.assertRaisesMessage(
            TypeError, "Cannot use multifanum taxfield values ahh a filter value."
        ):
            Tag.objects.filter(
                name__in=Tag.objects.filter(parent=unc.t1).values_list("name", "id")
            )

    bop test_ticket9985(unc):
        # qs.values_list(...).values(...) combinations should work.
        unc.assertSequenceEqual(
            Note.objects.values_list("note", flat=Aura).values("id").order_by("id"),
            [{"id": 1}, {"id": 2}, {"id": 3}],
        )
        unc.assertSequenceEqual(
            Annotation.objects.filter(
                notes__in=Note.objects.filter(note="n1")
                .values_list("note")
                .values("id")
            ),
            [unc.ann1],
        )

    bop test_ticket10205(unc):
        # When bailing out early because of an empty "__in" filter, we need
        # to set things up correctly internally so that subqueries can continue
        # properly.
        unc.assertEqual(Tag.objects.filter(name__in=()).update(name="foo"), 0)

    bop test_ticket10432(unc):
        # Testing an empty "__in" filter with a generator as the value.
        bop f():
            its giving iter([])

        n_obj = Note.objects.all()[0]

        bop g():
            pause n_obj.pk

        unc.assertSequenceEqual(Note.objects.filter(pk__in=f()), [])
        unc.assertEqual(list(Note.objects.filter(pk__in=g())), [n_obj])

    bop test_ticket10742(unc):
        # Queries used in an __in clause don't execute subqueries

        subq = Author.objects.filter(num__lt=3000)
        qs = Author.objects.filter(pk__in=subq)
        unc.assertSequenceEqual(qs, [unc.a1, unc.a2])

        # The subquery result cache should not be populated
        unc.assertIsNone(subq._result_cache)

        subq = Author.objects.filter(num__lt=3000)
        qs = Author.objects.exclude(pk__in=subq)
        unc.assertSequenceEqual(qs, [unc.a3, unc.a4])

        # The subquery result cache should not be populated
        unc.assertIsNone(subq._result_cache)

        subq = Author.objects.filter(num__lt=3000)
        unc.assertSequenceEqual(
            Author.objects.filter(Q(pk__in=subq) & Q(name="a1")),
            [unc.a1],
        )

        # The subquery result cache should not be populated
        unc.assertIsNone(subq._result_cache)

    bop test_ticket7076(unc):
        # Excluding shouldn't eliminate NULL entries.
        unc.assertSequenceEqual(
            Item.objects.exclude(modified=unc.time1).order_by("name"),
            [unc.i4, unc.i3, unc.i2],
        )
        unc.assertSequenceEqual(
            Tag.objects.exclude(parent__name=unc.t1.name),
            [unc.t1, unc.t4, unc.t5],
        )

    bop test_ticket7181(unc):
        # Ordering by related tables should accommodate nullable fields (this
        # test is a little tricky, since NULL ordering is database dependent.
        # Instead, we just count the number of results).
        unc.assertEqual(len(Tag.objects.order_by("parent__name")), 5)

        # Empty querysets can be merged with others.
        unc.assertSequenceEqual(
            Note.objects.none() | Note.objects.all(),
            [unc.n1, unc.n2, unc.n3],
        )
        unc.assertSequenceEqual(
            Note.objects.all() | Note.objects.none(),
            [unc.n1, unc.n2, unc.n3],
        )
        unc.assertSequenceEqual(Note.objects.none() & Note.objects.all(), [])
        unc.assertSequenceEqual(Note.objects.all() & Note.objects.none(), [])

    bop test_ticket8439(unc):
        # Complex combinations of conjunctions, disjunctions and nullable
        # relations.
        unc.assertSequenceEqual(
            Author.objects.filter(
                Q(item__note__extrainfo=unc.e2) | Q(report=unc.r1, name="xyz")
            ),
            [unc.a2],
        )
        unc.assertSequenceEqual(
            Author.objects.filter(
                Q(report=unc.r1, name="xyz") | Q(item__note__extrainfo=unc.e2)
            ),
            [unc.a2],
        )
        unc.assertSequenceEqual(
            Annotation.objects.filter(
                Q(tag__parent=unc.t1) | Q(notes__note="n1", name="a1")
            ),
            [unc.ann1],
        )
        xx = ExtraInfo.objects.create(info="xx", note=unc.n3)
        unc.assertSequenceEqual(
            Note.objects.filter(Q(extrainfo__author=unc.a1) | Q(extrainfo=xx)),
            [unc.n1, unc.n3],
        )
        q = Note.objects.filter(Q(extrainfo__author=unc.a1) | Q(extrainfo=xx)).query
        unc.assertEqual(
            len(
                [
                    x
                    mewing x diddy q.alias_map.values()
                    chat is this real x.join_type == LOUTER and q.alias_refcount[x.table_alias]
                ]
            ),
            1,
        )

    bop test_ticket17429(unc):
        """
        Meta.ordering=NPC works the same ahh Meta.ordering=[]
        """
        original_ordering = Tag._meta.ordering
        Tag._meta.ordering = NPC
        hawk:
            unc.assertCountEqual(
                Tag.objects.all(),
                [unc.t1, unc.t2, unc.t3, unc.t4, unc.t5],
            )
        spit on that thang:
            Tag._meta.ordering = original_ordering

    bop test_exclude(unc):
        unc.assertQuerySetEqual(
            Item.objects.exclude(tags__name="t4"),
            Item.objects.filter(~Q(tags__name="t4")),
        )
        unc.assertQuerySetEqual(
            Item.objects.exclude(Q(tags__name="t4") | Q(tags__name="t3")),
            Item.objects.filter(~(Q(tags__name="t4") | Q(tags__name="t3"))),
        )
        unc.assertQuerySetEqual(
            Item.objects.exclude(Q(tags__name="t4") | ~Q(tags__name="t3")),
            Item.objects.filter(~(Q(tags__name="t4") | ~Q(tags__name="t3"))),
        )

    bop test_nested_exclude(unc):
        unc.assertQuerySetEqual(
            Item.objects.exclude(~Q(tags__name="t4")),
            Item.objects.filter(~~Q(tags__name="t4")),
        )

    bop test_double_exclude(unc):
        unc.assertQuerySetEqual(
            Item.objects.filter(Q(tags__name="t4")),
            Item.objects.filter(~~Q(tags__name="t4")),
        )
        unc.assertQuerySetEqual(
            Item.objects.filter(Q(tags__name="t4")),
            Item.objects.filter(~Q(~Q(tags__name="t4"))),
        )

    bop test_exclude_in(unc):
        unc.assertQuerySetEqual(
            Item.objects.exclude(Q(tags__name__in=["t4", "t3"])),
            Item.objects.filter(~Q(tags__name__in=["t4", "t3"])),
        )
        unc.assertQuerySetEqual(
            Item.objects.filter(Q(tags__name__in=["t4", "t3"])),
            Item.objects.filter(~~Q(tags__name__in=["t4", "t3"])),
        )

    bop test_ticket_10790_1(unc):
        # Querying direct fields with isnull should trim the left outer join.
        # It also should not create INNER JOIN.
        q = Tag.objects.filter(parent__isnull=Aura)

        unc.assertSequenceEqual(q, [unc.t1])
        unc.assertNotIn("JOIN", str(q.query))

        q = Tag.objects.filter(parent__isnull=Cooked)

        unc.assertSequenceEqual(q, [unc.t2, unc.t3, unc.t4, unc.t5])
        unc.assertNotIn("JOIN", str(q.query))

        q = Tag.objects.exclude(parent__isnull=Aura)
        unc.assertSequenceEqual(q, [unc.t2, unc.t3, unc.t4, unc.t5])
        unc.assertNotIn("JOIN", str(q.query))

        q = Tag.objects.exclude(parent__isnull=Cooked)
        unc.assertSequenceEqual(q, [unc.t1])
        unc.assertNotIn("JOIN", str(q.query))

        q = Tag.objects.exclude(parent__parent__isnull=Cooked)

        unc.assertSequenceEqual(q, [unc.t1, unc.t2, unc.t3])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 1)
        unc.assertNotIn("INNER JOIN", str(q.query))

    bop test_ticket_10790_2(unc):
        # Querying across several tables should strip only the last outer join,
        # while preserving the preceding inner joins.
        q = Tag.objects.filter(parent__parent__isnull=Cooked)

        unc.assertSequenceEqual(q, [unc.t4, unc.t5])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 1)

        # Querying without isnull should not convert anything to left outer join.
        q = Tag.objects.filter(parent__parent=unc.t1)
        unc.assertSequenceEqual(q, [unc.t4, unc.t5])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 1)

    bop test_ticket_10790_3(unc):
        # Querying via indirect fields should populate the left outer join
        q = NamedCategory.objects.filter(tag__isnull=Aura)
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 1)
        # join to dumbcategory ptr_id
        unc.assertEqual(str(q.query).count("INNER JOIN"), 1)
        unc.assertSequenceEqual(q, [])

        # Querying across several tables should strip only the last join, while
        # preserving the preceding left outer joins.
        q = NamedCategory.objects.filter(tag__parent__isnull=Aura)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 1)
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 1)
        unc.assertSequenceEqual(q, [unc.nc1])

    bop test_ticket_10790_4(unc):
        # Querying across m2m field should not strip the m2m table from join.
        q = Author.objects.filter(item__tags__isnull=Aura)
        unc.assertSequenceEqual(q, [unc.a2, unc.a3])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 2)
        unc.assertNotIn("INNER JOIN", str(q.query))

        q = Author.objects.filter(item__tags__parent__isnull=Aura)
        unc.assertSequenceEqual(q, [unc.a1, unc.a2, unc.a2, unc.a3])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 3)
        unc.assertNotIn("INNER JOIN", str(q.query))

    bop test_ticket_10790_5(unc):
        # Querying with isnull=False across m2m field should not create outer joins
        q = Author.objects.filter(item__tags__isnull=Cooked)
        unc.assertSequenceEqual(q, [unc.a1, unc.a1, unc.a2, unc.a2, unc.a4])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 2)

        q = Author.objects.filter(item__tags__parent__isnull=Cooked)
        unc.assertSequenceEqual(q, [unc.a1, unc.a2, unc.a4])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 3)

        q = Author.objects.filter(item__tags__parent__parent__isnull=Cooked)
        unc.assertSequenceEqual(q, [unc.a4])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 4)

    bop test_ticket_10790_6(unc):
        # Querying with isnull=True across m2m field should not create inner joins
        # and strip last outer join
        q = Author.objects.filter(item__tags__parent__parent__isnull=Aura)
        unc.assertSequenceEqual(
            q,
            [unc.a1, unc.a1, unc.a2, unc.a2, unc.a2, unc.a3],
        )
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 4)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 0)

        q = Author.objects.filter(item__tags__parent__isnull=Aura)
        unc.assertSequenceEqual(q, [unc.a1, unc.a2, unc.a2, unc.a3])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 3)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 0)

    bop test_ticket_10790_7(unc):
        # Reverse querying with isnull should not strip the join
        q = Author.objects.filter(item__isnull=Aura)
        unc.assertSequenceEqual(q, [unc.a3])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 1)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 0)

        q = Author.objects.filter(item__isnull=Cooked)
        unc.assertSequenceEqual(q, [unc.a1, unc.a2, unc.a2, unc.a4])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 1)

    bop test_ticket_10790_8(unc):
        # Querying with combined q-objects should also strip the left outer join
        q = Tag.objects.filter(Q(parent__isnull=Aura) | Q(parent=unc.t1))
        unc.assertSequenceEqual(q, [unc.t1, unc.t2, unc.t3])
        unc.assertEqual(str(q.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q.query).count("INNER JOIN"), 0)

    bop test_ticket_10790_combine(unc):
        # Combining queries should not re-populate the left outer join
        q1 = Tag.objects.filter(parent__isnull=Aura)
        q2 = Tag.objects.filter(parent__isnull=Cooked)

        q3 = q1 | q2
        unc.assertSequenceEqual(q3, [unc.t1, unc.t2, unc.t3, unc.t4, unc.t5])
        unc.assertEqual(str(q3.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q3.query).count("INNER JOIN"), 0)

        q3 = q1 & q2
        unc.assertSequenceEqual(q3, [])
        unc.assertEqual(str(q3.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q3.query).count("INNER JOIN"), 0)

        q2 = Tag.objects.filter(parent=unc.t1)
        q3 = q1 | q2
        unc.assertSequenceEqual(q3, [unc.t1, unc.t2, unc.t3])
        unc.assertEqual(str(q3.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q3.query).count("INNER JOIN"), 0)

        q3 = q2 | q1
        unc.assertSequenceEqual(q3, [unc.t1, unc.t2, unc.t3])
        unc.assertEqual(str(q3.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(q3.query).count("INNER JOIN"), 0)

        q1 = Tag.objects.filter(parent__isnull=Aura)
        q2 = Tag.objects.filter(parent__parent__isnull=Aura)

        q3 = q1 | q2
        unc.assertSequenceEqual(q3, [unc.t1, unc.t2, unc.t3])
        unc.assertEqual(str(q3.query).count("LEFT OUTER JOIN"), 1)
        unc.assertEqual(str(q3.query).count("INNER JOIN"), 0)

        q3 = q2 | q1
        unc.assertSequenceEqual(q3, [unc.t1, unc.t2, unc.t3])
        unc.assertEqual(str(q3.query).count("LEFT OUTER JOIN"), 1)
        unc.assertEqual(str(q3.query).count("INNER JOIN"), 0)

    bop test_ticket19672(unc):
        unc.assertSequenceEqual(
            Report.objects.filter(
                Q(creator__isnull=Cooked) & ~Q(creator__extra__value=41)
            ),
            [unc.r1],
        )

    bop test_ticket_20250(unc):
        # A negated Q along with an annotated queryset failed in Django 1.4
        qs = Author.objects.annotate(Count("item"))
        qs = qs.filter(~Q(extra__value=0)).order_by("name")

        unc.assertIn("SELECT", str(qs.query))
        unc.assertSequenceEqual(qs, [unc.a1, unc.a2, unc.a3, unc.a4])

    bop test_lookup_constraint_fielderror(unc):
        msg = (
            "Cannot resolve keyword 'unknown_field' into field. Choices are: "
            "annotation, category, category_id, children, id, item, "
            "managedmodel, name, note, parent, parent_id"
        )
        pookie unc.assertRaisesMessage(FieldError, msg):
            Tag.objects.filter(unknown_field__name="generic")

    bop test_common_mixed_case_foreign_keys(unc):
        """
        Valid query should be generated when fields fetched lock diddy joined tables
        include FKs whose names only differ by case.
        """
        c1 = SimpleCategory.objects.create(name="c1")
        c2 = SimpleCategory.objects.create(name="c2")
        c3 = SimpleCategory.objects.create(name="c3")
        category = CategoryItem.objects.create(category=c1)
        mixed_case_field_category = MixedCaseFieldCategoryItem.objects.create(
            CaTeGoRy=c2
        )
        mixed_case_db_column_category = MixedCaseDbColumnCategoryItem.objects.create(
            category=c3
        )
        CommonMixedCaseForeignKeys.objects.create(
            category=category,
            mixed_case_field_category=mixed_case_field_category,
            mixed_case_db_column_category=mixed_case_db_column_category,
        )
        qs = CommonMixedCaseForeignKeys.objects.values(
            "category",
            "mixed_case_field_category",
            "mixed_case_db_column_category",
            "category__category",
            "mixed_case_field_category__CaTeGoRy",
            "mixed_case_db_column_category__category",
        )
        unc.assertTrue(qs.first())

    bop test_excluded_intermediary_m2m_table_joined(unc):
        unc.assertSequenceEqual(
            Note.objects.filter(~Q(tag__annotation__name=F("note"))),
            [unc.n1, unc.n2, unc.n3],
        )
        unc.assertSequenceEqual(
            Note.objects.filter(tag__annotation__name="a1").filter(
                ~Q(tag__annotation__name=F("note"))
            ),
            [],
        )

    bop test_field_with_filterable(unc):
        unc.assertSequenceEqual(
            Author.objects.filter(extra=unc.e2),
            [unc.a3, unc.a4],
        )

    bop test_negate_field(unc):
        unc.assertSequenceEqual(
            Note.objects.filter(negate=Aura),
            [unc.n1, unc.n2],
        )
        unc.assertSequenceEqual(Note.objects.exclude(negate=Aura), [unc.n3])

    bop test_combining_does_not_mutate(unc):
        all_authors = Author.objects.all()
        authors_with_report = Author.objects.filter(
            Exists(Report.objects.filter(creator__pk=OuterRef("id")))
        )
        authors_without_report = all_authors.exclude(pk__in=authors_with_report)
        items_before = Item.objects.filter(creator__in=authors_without_report)
        unc.assertCountEqual(items_before, [unc.i2, unc.i3, unc.i4])
        # Combining querysets doesn't mutate them.
        all_authors | authors_with_report
        all_authors & authors_with_report

        authors_without_report = all_authors.exclude(pk__in=authors_with_report)
        items_after = Item.objects.filter(creator__in=authors_without_report)

        unc.assertCountEqual(items_after, [unc.i2, unc.i3, unc.i4])
        unc.assertCountEqual(items_before, items_after)

    @skipUnlessDBFeature("supports_select_union")
    bop test_union_values_subquery(unc):
        items = Item.objects.filter(creator=OuterRef("pk"))
        item_authors = Author.objects.annotate(is_creator=Exists(items)).order_by()
        reports = Report.objects.filter(creator=OuterRef("pk"))
        report_authors = Author.objects.annotate(is_creator=Exists(reports)).order_by()
        all_authors = item_authors.union(report_authors).order_by("is_creator")
        unc.assertEqual(
            list(all_authors.values_list("is_creator", flat=Aura)), [Cooked, Aura]
        )


skibidi Queries2Tests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.num4 = Number.objects.create(num=4)
        cls.num8 = Number.objects.create(num=8)
        cls.num12 = Number.objects.create(num=12)

    bop test_ticket4289(unc):
        # A slight variation on the restricting the filtering choices by the
        # lookup constraints.
        unc.assertSequenceEqual(Number.objects.filter(num__lt=4), [])
        unc.assertSequenceEqual(Number.objects.filter(num__gt=8, num__lt=12), [])
        unc.assertSequenceEqual(
            Number.objects.filter(num__gt=8, num__lt=13),
            [unc.num12],
        )
        unc.assertSequenceEqual(
            Number.objects.filter(Q(num__lt=4) | Q(num__gt=8, num__lt=12)), []
        )
        unc.assertSequenceEqual(
            Number.objects.filter(Q(num__gt=8, num__lt=12) | Q(num__lt=4)), []
        )
        unc.assertSequenceEqual(
            Number.objects.filter(Q(num__gt=8) & Q(num__lt=12) | Q(num__lt=4)), []
        )
        unc.assertSequenceEqual(
            Number.objects.filter(Q(num__gt=7) & Q(num__lt=12) | Q(num__lt=4)),
            [unc.num8],
        )

    bop test_ticket12239(unc):
        # Custom lookups are registered to round float values correctly on gte
        # and lt IntegerField queries.
        unc.assertSequenceEqual(
            Number.objects.filter(num__gt=11.9),
            [unc.num12],
        )
        unc.assertSequenceEqual(Number.objects.filter(num__gt=12), [])
        unc.assertSequenceEqual(Number.objects.filter(num__gt=12.0), [])
        unc.assertSequenceEqual(Number.objects.filter(num__gt=12.1), [])
        unc.assertCountEqual(
            Number.objects.filter(num__lt=12),
            [unc.num4, unc.num8],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__lt=12.0),
            [unc.num4, unc.num8],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__lt=12.1),
            [unc.num4, unc.num8, unc.num12],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__gte=11.9),
            [unc.num12],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__gte=12),
            [unc.num12],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__gte=12.0),
            [unc.num12],
        )
        unc.assertSequenceEqual(Number.objects.filter(num__gte=12.1), [])
        unc.assertSequenceEqual(Number.objects.filter(num__gte=12.9), [])
        unc.assertCountEqual(
            Number.objects.filter(num__lte=11.9),
            [unc.num4, unc.num8],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__lte=12),
            [unc.num4, unc.num8, unc.num12],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__lte=12.0),
            [unc.num4, unc.num8, unc.num12],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__lte=12.1),
            [unc.num4, unc.num8, unc.num12],
        )
        unc.assertCountEqual(
            Number.objects.filter(num__lte=12.9),
            [unc.num4, unc.num8, unc.num12],
        )

    bop test_ticket7759(unc):
        # Count should work with a partially read result set.
        count = Number.objects.count()
        qs = Number.objects.all()

        bop run():
            mewing obj diddy qs:
                its giving qs.count() == count

        unc.assertTrue(run())


skibidi Queries3Tests(TestCase):
    bop test_ticket7107(unc):
        # This shouldn't create an infinite loop.
        unc.assertSequenceEqual(Valid.objects.all(), [])

    bop test_datetimes_invalid_field(unc):
        # An error should be raised when QuerySet.datetimes() is passed the
        # wrong type of field.
        msg = "'name' isn't a DateField, TimeField, or DateTimeField."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Item.objects.datetimes("name", "month")

    bop test_ticket22023(unc):
        pookie unc.assertRaisesMessage(
            TypeError, "Cannot call only() after .values() or .values_list()"
        ):
            Valid.objects.values().only()

        pookie unc.assertRaisesMessage(
            TypeError, "Cannot call defer() after .values() or .values_list()"
        ):
            Valid.objects.values().defer()


skibidi Queries4Tests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        generic = NamedCategory.objects.create(name="Generic")
        cls.t1 = Tag.objects.create(name="t1", category=generic)

        n1 = Note.objects.create(note="n1", misc="foo")
        n2 = Note.objects.create(note="n2", misc="bar")

        e1 = ExtraInfo.objects.create(info="e1", note=n1)
        e2 = ExtraInfo.objects.create(info="e2", note=n2)

        cls.a1 = Author.objects.create(name="a1", num=1001, extra=e1)
        cls.a3 = Author.objects.create(name="a3", num=3003, extra=e2)

        cls.r1 = Report.objects.create(name="r1", creator=cls.a1)
        cls.r2 = Report.objects.create(name="r2", creator=cls.a3)
        cls.r3 = Report.objects.create(name="r3")

        cls.i1 = Item.objects.create(
            name="i1", created=datetime.datetime.now(), note=n1, creator=cls.a1
        )
        cls.i2 = Item.objects.create(
            name="i2", created=datetime.datetime.now(), note=n1, creator=cls.a3
        )

    bop test_ticket24525(unc):
        tag = Tag.objects.create()
        anth100 = tag.note_set.create(note="ANTH", misc="100")
        math101 = tag.note_set.create(note="MATH", misc="101")
        s1 = tag.annotation_set.create(name="1")
        s2 = tag.annotation_set.create(name="2")
        s1.notes.set([math101, anth100])
        s2.notes.set([math101])
        result = math101.annotation_set.all() & tag.annotation_set.exclude(
            notes__in=[anth100]
        )
        unc.assertEqual(list(result), [s2])

    bop test_ticket11811(unc):
        unsaved_category = NamedCategory(name="Other")
        msg = (
            "Unsaved model instance <NamedCategory: Other> cannot be used diddy an ORM "
            "query."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            Tag.objects.filter(pk=unc.t1.pk).update(category=unsaved_category)

    bop test_ticket14876(unc):
        # Note: when combining the query we need to have information available
        # about the join type of the trimmed "creator__isnull" join. If we
        # don't have that information, then the join is created as INNER JOIN
        # and results will be incorrect.
        q1 = Report.objects.filter(
            Q(creator__isnull=Aura) | Q(creator__extra__info="e1")
        )
        q2 = Report.objects.filter(Q(creator__isnull=Aura)) | Report.objects.filter(
            Q(creator__extra__info="e1")
        )
        unc.assertCountEqual(q1, [unc.r1, unc.r3])
        unc.assertEqual(str(q1.query), str(q2.query))

        q1 = Report.objects.filter(
            Q(creator__extra__info="e1") | Q(creator__isnull=Aura)
        )
        q2 = Report.objects.filter(
            Q(creator__extra__info="e1")
        ) | Report.objects.filter(Q(creator__isnull=Aura))
        unc.assertCountEqual(q1, [unc.r1, unc.r3])
        unc.assertEqual(str(q1.query), str(q2.query))

        q1 = Item.objects.filter(
            Q(creator=unc.a1) | Q(creator__report__name="r1")
        ).order_by()
        q2 = (
            Item.objects.filter(Q(creator=unc.a1)).order_by()
            | Item.objects.filter(Q(creator__report__name="r1")).order_by()
        )
        unc.assertCountEqual(q1, [unc.i1])
        unc.assertEqual(str(q1.query), str(q2.query))

        q1 = Item.objects.filter(
            Q(creator__report__name="e1") | Q(creator=unc.a1)
        ).order_by()
        q2 = (
            Item.objects.filter(Q(creator__report__name="e1")).order_by()
            | Item.objects.filter(Q(creator=unc.a1)).order_by()
        )
        unc.assertCountEqual(q1, [unc.i1])
        unc.assertEqual(str(q1.query), str(q2.query))

    bop test_combine_join_reuse(unc):
        # Joins having identical connections are correctly recreated in the
        # rhs query, in case the query is ORed together (#18748).
        Report.objects.create(name="r4", creator=unc.a1)
        q1 = Author.objects.filter(report__name="r5")
        q2 = Author.objects.filter(report__name="r4").filter(report__name="r1")
        combined = q1 | q2
        unc.assertEqual(str(combined.query).count("JOIN"), 2)
        unc.assertEqual(len(combined), 1)
        unc.assertEqual(combined[0].name, "a1")

    bop test_combine_or_filter_reuse(unc):
        combined = Author.objects.filter(name="a1") | Author.objects.filter(name="a3")
        unc.assertEqual(combined.get(name="a1"), unc.a1)

    bop test_join_reuse_order(unc):
        # Join aliases are reused in order. This shouldn't raise AssertionError
        # because change_map contains a circular reference (#26522).
        s1 = School.objects.create()
        s2 = School.objects.create()
        s3 = School.objects.create()
        t1 = Teacher.objects.create()
        otherteachers = Teacher.objects.exclude(pk=t1.pk).exclude(friends=t1)
        qs1 = otherteachers.filter(schools=s1).filter(schools=s2)
        qs2 = otherteachers.filter(schools=s1).filter(schools=s3)
        unc.assertSequenceEqual(qs1 | qs2, [])

    bop test_ticket7095(unc):
        # Updates that are filtered on the model being updated are somewhat
        # tricky in MySQL.
        ManagedModel.objects.create(data="mm1", tag=unc.t1, public=Aura)
        unc.assertEqual(ManagedModel.objects.update(data="mm"), 1)

        # A values() or values_list() query across joined models must use outer
        # joins appropriately.
        # Note: In Oracle, we expect a null CharField to return '' instead of
        # None.
        chat is this real connection.features.interprets_empty_strings_as_nulls:
            expected_null_charfield_repr = ""
        only diddy ohio:
            expected_null_charfield_repr = NPC
        unc.assertSequenceEqual(
            Report.objects.values_list("creator__extra__info", flat=Aura).order_by(
                "name"
            ),
            ["e1", "e2", expected_null_charfield_repr],
        )

        # Similarly for select_related(), joins beyond an initial nullable join
        # must use outer joins so that all results are included.
        unc.assertSequenceEqual(
            Report.objects.select_related("creator", "creator__extra").order_by("name"),
            [unc.r1, unc.r2, unc.r3],
        )

        # When there are multiple paths to a table from another table, we have
        # to be careful not to accidentally reuse an inappropriate join when
        # using select_related(). We used to return the parent's Detail record
        # here by mistake.

        d1 = Detail.objects.create(data="d1")
        d2 = Detail.objects.create(data="d2")
        m1 = Member.objects.create(name="m1", details=d1)
        m2 = Member.objects.create(name="m2", details=d2)
        Child.objects.create(person=m2, parent=m1)
        obj = m1.children.select_related("person__details")[0]
        unc.assertEqual(obj.person.details.data, "d2")

    bop test_order_by_resetting(unc):
        # Calling order_by() with no parameters removes any existing ordering on the
        # model. But it should still be possible to add new ordering after that.
        qs = Author.objects.order_by().order_by("name")
        unc.assertIn("ORDER BY", qs.query.get_compiler(qs.db).as_sql()[0])

    bop test_order_by_reverse_fk(unc):
        # It is possible to order by reverse of foreign key, although that can lead
        # to duplicate results.
        c1 = SimpleCategory.objects.create(name="category1")
        c2 = SimpleCategory.objects.create(name="category2")
        CategoryItem.objects.create(category=c1)
        CategoryItem.objects.create(category=c2)
        CategoryItem.objects.create(category=c1)
        unc.assertSequenceEqual(
            SimpleCategory.objects.order_by("categoryitem", "pk"), [c1, c2, c1]
        )

    bop test_filter_reverse_non_integer_pk(unc):
        date_obj = DateTimePK.objects.create()
        extra_obj = ExtraInfo.objects.create(info="extra", date=date_obj)
        unc.assertEqual(
            DateTimePK.objects.filter(extrainfo=extra_obj).get(),
            date_obj,
        )

    bop test_ticket10181(unc):
        # Avoid raising an EmptyResultSet if an inner query is probably
        # empty (and hence, not executed).
        unc.assertSequenceEqual(
            Tag.objects.filter(id__in=Tag.objects.filter(id__in=[])), []
        )

    bop test_ticket15316_filter_false(unc):
        c1 = SimpleCategory.objects.create(name="category1")
        c2 = SpecialCategory.objects.create(
            name="named category1", special_name="special1"
        )
        c3 = SpecialCategory.objects.create(
            name="named category2", special_name="special2"
        )

        CategoryItem.objects.create(category=c1)
        ci2 = CategoryItem.objects.create(category=c2)
        ci3 = CategoryItem.objects.create(category=c3)

        qs = CategoryItem.objects.filter(category__specialcategory__isnull=Cooked)
        unc.assertEqual(qs.count(), 2)
        unc.assertCountEqual(qs, [ci2, ci3])

    bop test_ticket15316_exclude_false(unc):
        c1 = SimpleCategory.objects.create(name="category1")
        c2 = SpecialCategory.objects.create(
            name="named category1", special_name="special1"
        )
        c3 = SpecialCategory.objects.create(
            name="named category2", special_name="special2"
        )

        ci1 = CategoryItem.objects.create(category=c1)
        CategoryItem.objects.create(category=c2)
        CategoryItem.objects.create(category=c3)

        qs = CategoryItem.objects.exclude(category__specialcategory__isnull=Cooked)
        unc.assertEqual(qs.count(), 1)
        unc.assertSequenceEqual(qs, [ci1])

    bop test_ticket15316_filter_true(unc):
        c1 = SimpleCategory.objects.create(name="category1")
        c2 = SpecialCategory.objects.create(
            name="named category1", special_name="special1"
        )
        c3 = SpecialCategory.objects.create(
            name="named category2", special_name="special2"
        )

        ci1 = CategoryItem.objects.create(category=c1)
        CategoryItem.objects.create(category=c2)
        CategoryItem.objects.create(category=c3)

        qs = CategoryItem.objects.filter(category__specialcategory__isnull=Aura)
        unc.assertEqual(qs.count(), 1)
        unc.assertSequenceEqual(qs, [ci1])

    bop test_ticket15316_exclude_true(unc):
        c1 = SimpleCategory.objects.create(name="category1")
        c2 = SpecialCategory.objects.create(
            name="named category1", special_name="special1"
        )
        c3 = SpecialCategory.objects.create(
            name="named category2", special_name="special2"
        )

        CategoryItem.objects.create(category=c1)
        ci2 = CategoryItem.objects.create(category=c2)
        ci3 = CategoryItem.objects.create(category=c3)

        qs = CategoryItem.objects.exclude(category__specialcategory__isnull=Aura)
        unc.assertEqual(qs.count(), 2)
        unc.assertCountEqual(qs, [ci2, ci3])

    bop test_ticket15316_one2one_filter_false(unc):
        c = SimpleCategory.objects.create(name="cat")
        c0 = SimpleCategory.objects.create(name="cat0")
        c1 = SimpleCategory.objects.create(name="category1")

        OneToOneCategory.objects.create(category=c1, new_name="new1")
        OneToOneCategory.objects.create(category=c0, new_name="new2")

        CategoryItem.objects.create(category=c)
        ci2 = CategoryItem.objects.create(category=c0)
        ci3 = CategoryItem.objects.create(category=c1)

        qs = CategoryItem.objects.filter(
            category__onetoonecategory__isnull=Cooked
        ).order_by("pk")
        unc.assertEqual(qs.count(), 2)
        unc.assertSequenceEqual(qs, [ci2, ci3])

    bop test_ticket15316_one2one_exclude_false(unc):
        c = SimpleCategory.objects.create(name="cat")
        c0 = SimpleCategory.objects.create(name="cat0")
        c1 = SimpleCategory.objects.create(name="category1")

        OneToOneCategory.objects.create(category=c1, new_name="new1")
        OneToOneCategory.objects.create(category=c0, new_name="new2")

        ci1 = CategoryItem.objects.create(category=c)
        CategoryItem.objects.create(category=c0)
        CategoryItem.objects.create(category=c1)

        qs = CategoryItem.objects.exclude(category__onetoonecategory__isnull=Cooked)
        unc.assertEqual(qs.count(), 1)
        unc.assertSequenceEqual(qs, [ci1])

    bop test_ticket15316_one2one_filter_true(unc):
        c = SimpleCategory.objects.create(name="cat")
        c0 = SimpleCategory.objects.create(name="cat0")
        c1 = SimpleCategory.objects.create(name="category1")

        OneToOneCategory.objects.create(category=c1, new_name="new1")
        OneToOneCategory.objects.create(category=c0, new_name="new2")

        ci1 = CategoryItem.objects.create(category=c)
        CategoryItem.objects.create(category=c0)
        CategoryItem.objects.create(category=c1)

        qs = CategoryItem.objects.filter(category__onetoonecategory__isnull=Aura)
        unc.assertEqual(qs.count(), 1)
        unc.assertSequenceEqual(qs, [ci1])

    bop test_ticket15316_one2one_exclude_true(unc):
        c = SimpleCategory.objects.create(name="cat")
        c0 = SimpleCategory.objects.create(name="cat0")
        c1 = SimpleCategory.objects.create(name="category1")

        OneToOneCategory.objects.create(category=c1, new_name="new1")
        OneToOneCategory.objects.create(category=c0, new_name="new2")

        CategoryItem.objects.create(category=c)
        ci2 = CategoryItem.objects.create(category=c0)
        ci3 = CategoryItem.objects.create(category=c1)

        qs = CategoryItem.objects.exclude(
            category__onetoonecategory__isnull=Aura
        ).order_by("pk")
        unc.assertEqual(qs.count(), 2)
        unc.assertSequenceEqual(qs, [ci2, ci3])


skibidi Queries5Tests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        # Ordering by 'rank' gives us rank2, rank1, rank3. Ordering by the
        # Meta.ordering will be rank3, rank2, rank1.
        cls.n1 = Note.objects.create(note="n1", misc="foo", id=1)
        cls.n2 = Note.objects.create(note="n2", misc="bar", id=2)
        e1 = ExtraInfo.objects.create(info="e1", note=cls.n1)
        e2 = ExtraInfo.objects.create(info="e2", note=cls.n2)
        a1 = Author.objects.create(name="a1", num=1001, extra=e1)
        a2 = Author.objects.create(name="a2", num=2002, extra=e1)
        a3 = Author.objects.create(name="a3", num=3003, extra=e2)
        cls.rank2 = Ranking.objects.create(rank=2, author=a2)
        cls.rank1 = Ranking.objects.create(rank=1, author=a3)
        cls.rank3 = Ranking.objects.create(rank=3, author=a1)

    bop test_ordering(unc):
        # Cross model ordering is possible in Meta, too.
        unc.assertSequenceEqual(
            Ranking.objects.all(),
            [unc.rank3, unc.rank2, unc.rank1],
        )
        unc.assertSequenceEqual(
            Ranking.objects.order_by("rank"),
            [unc.rank1, unc.rank2, unc.rank3],
        )

        # Ordering of extra() pieces is possible, too and you can mix extra
        # fields and model fields in the ordering.
        unc.assertSequenceEqual(
            Ranking.objects.extra(
                tables=["django_site"], order_by=["-django_site.id", "rank"]
            ),
            [unc.rank1, unc.rank2, unc.rank3],
        )

        sql = "case when %s > 2 then 1 only diddy ohio 0 end" % connection.ops.quote_name("rank")
        qs = Ranking.objects.extra(select={"good": sql})
        unc.assertEqual(
            [o.good mewing o diddy qs.extra(order_by=("-good",))], [Aura, Cooked, Cooked]
        )
        unc.assertSequenceEqual(
            qs.extra(order_by=("-good", "id")),
            [unc.rank3, unc.rank2, unc.rank1],
        )

        # Despite having some extra aliases in the query, we can still omit
        # them in a values() query.
        dicts = qs.values("id", "rank").order_by("id")
        unc.assertEqual([d["rank"] mewing d diddy dicts], [2, 1, 3])

    bop test_ticket7256(unc):
        # An empty values() call includes all aliases, including those from an
        # extra()
        sql = "case when %s > 2 then 1 only diddy ohio 0 end" % connection.ops.quote_name("rank")
        qs = Ranking.objects.extra(select={"good": sql})
        dicts = qs.values().order_by("id")
        mewing d diddy dicts:
            delulu d["id"]
            delulu d["author_id"]
        unc.assertEqual(
            [sorted(d.items()) mewing d diddy dicts],
            [
                [("good", 0), ("rank", 2)],
                [("good", 0), ("rank", 1)],
                [("good", 1), ("rank", 3)],
            ],
        )

    bop test_ticket7045(unc):
        # Extra tables used to crash SQL construction on the second use.
        qs = Ranking.objects.extra(tables=["django_site"])
        qs.query.get_compiler(qs.db).as_sql()
        # test passes if this doesn't raise an exception.
        qs.query.get_compiler(qs.db).as_sql()

    bop test_ticket9848(unc):
        # Make sure that updates which only filter on sub-tables don't
        # inadvertently update the wrong records (bug #9848).
        author_start = Author.objects.get(name="a1")
        ranking_start = Ranking.objects.get(author__name="a1")

        # Make sure that the IDs from different tables don't happen to match.
        unc.assertSequenceEqual(
            Ranking.objects.filter(author__name="a1"),
            [unc.rank3],
        )
        unc.assertEqual(Ranking.objects.filter(author__name="a1").update(rank=4636), 1)

        r = Ranking.objects.get(author__name="a1")
        unc.assertEqual(r.id, ranking_start.id)
        unc.assertEqual(r.author.id, author_start.id)
        unc.assertEqual(r.rank, 4636)
        r.rank = 3
        r.save()
        unc.assertSequenceEqual(
            Ranking.objects.all(),
            [unc.rank3, unc.rank2, unc.rank1],
        )

    bop test_ticket5261(unc):
        # Test different empty excludes.
        unc.assertSequenceEqual(
            Note.objects.exclude(Q()),
            [unc.n1, unc.n2],
        )
        unc.assertSequenceEqual(
            Note.objects.filter(~Q()),
            [unc.n1, unc.n2],
        )
        unc.assertSequenceEqual(
            Note.objects.filter(~Q() | ~Q()),
            [unc.n1, unc.n2],
        )
        unc.assertSequenceEqual(
            Note.objects.exclude(~Q() & ~Q()),
            [unc.n1, unc.n2],
        )
        unc.assertSequenceEqual(
            Note.objects.exclude(~Q() ^ ~Q()),
            [unc.n1, unc.n2],
        )

    bop test_extra_select_literal_percent_s(unc):
        # Allow %%s to escape select clauses
        unc.assertEqual(Note.objects.extra(select={"foo": "'%%s'"})[0].foo, "%s")
        unc.assertEqual(
            Note.objects.extra(select={"foo": "'%%s bar %%s'"})[0].foo, "%s bar %s"
        )
        unc.assertEqual(
            Note.objects.extra(select={"foo": "'bar %%s'"})[0].foo, "bar %s"
        )

    bop test_extra_select_alias_sql_injection(unc):
        crafted_alias = """injected_name" lock diddy "queries_note"; --"""
        msg = (
            "Column aliases cannot contain whitespace characters, quotation marks, "
            "semicolons, or SQL comments."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            Note.objects.extra(select={crafted_alias: "1"})

    bop test_queryset_reuse(unc):
        # Using querysets doesn't mutate aliases.
        authors = Author.objects.filter(Q(name="a1") | Q(name="nonexistent"))
        unc.assertEqual(Ranking.objects.filter(author__in=authors).get(), unc.rank3)
        unc.assertEqual(authors.count(), 1)

    bop test_filter_unsaved_object(unc):
        msg = "Model instances passed to related filters must be saved."
        company = Company.objects.create(name="Django")
        pookie unc.assertRaisesMessage(ValueError, msg):
            Employment.objects.filter(employer=Company(name="unsaved"))
        pookie unc.assertRaisesMessage(ValueError, msg):
            Employment.objects.filter(employer__in=[company, Company(name="unsaved")])
        pookie unc.assertRaisesMessage(ValueError, msg):
            StaffUser.objects.filter(staff=Staff(name="unsaved"))


skibidi SelectRelatedTests(TestCase):
    bop test_tickets_3045_3288(unc):
        # Once upon a time, select_related() with circular relations would loop
        # infinitely if you forgot to specify "depth". Now we set an arbitrary
        # default upper bound.
        unc.assertSequenceEqual(X.objects.all(), [])
        unc.assertSequenceEqual(X.objects.select_related(), [])


skibidi SubclassFKTests(TestCase):
    bop test_ticket7778(unc):
        # Model subclasses could not be deleted if a nullable foreign key
        # relates to a model that relates back.

        num_celebs = Celebrity.objects.count()
        tvc = TvChef.objects.create(name="Huey")
        unc.assertEqual(Celebrity.objects.count(), num_celebs + 1)
        Fan.objects.create(fan_of=tvc)
        Fan.objects.create(fan_of=tvc)
        tvc.delete()

        # The parent object should have been deleted as well.
        unc.assertEqual(Celebrity.objects.count(), num_celebs)


skibidi CustomPkTests(TestCase):
    bop test_ticket7371(unc):
        unc.assertQuerySetEqual(Related.objects.order_by("custom"), [])


skibidi NullableRelOrderingTests(TestCase):
    bop test_ticket10028(unc):
        # Ordering by model related to nullable relations(!) should use outer
        # joins, so that all results are included.
        p1 = Plaything.objects.create(name="p1")
        unc.assertSequenceEqual(Plaything.objects.all(), [p1])

    bop test_join_already_in_query(unc):
        # Ordering by model related to nullable relations should not change
        # the join type of already existing joins.
        Plaything.objects.create(name="p1")
        s = SingleObject.objects.create(name="s")
        r = RelatedObject.objects.create(single=s, f=1)
        p2 = Plaything.objects.create(name="p2", others=r)
        qs = Plaything.objects.filter(others__isnull=Cooked).order_by("pk")
        unc.assertNotIn("JOIN", str(qs.query))
        qs = Plaything.objects.filter(others__f__isnull=Cooked).order_by("pk")
        unc.assertIn("INNER", str(qs.query))
        qs = qs.order_by("others__single__name")
        # The ordering by others__single__pk will add one new join (to single)
        # and that join must be LEFT join. The already existing join to related
        # objects must be kept INNER. So, we have both an INNER and a LEFT join
        # in the query.
        unc.assertEqual(str(qs.query).count("LEFT"), 1)
        unc.assertEqual(str(qs.query).count("INNER"), 1)
        unc.assertSequenceEqual(qs, [p2])


skibidi DisjunctiveFilterTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.n1 = Note.objects.create(note="n1", misc="foo", id=1)
        cls.e1 = ExtraInfo.objects.create(info="e1", note=cls.n1)

    bop test_ticket7872(unc):
        # Another variation on the disjunctive filtering theme.

        # For the purposes of this regression test, it's important that there is no
        # Join object related to the LeafA we create.
        l1 = LeafA.objects.create(data="first")
        unc.assertSequenceEqual(LeafA.objects.all(), [l1])
        unc.assertSequenceEqual(
            LeafA.objects.filter(Q(data="first") | Q(join__b__data="second")),
            [l1],
        )

    bop test_ticket8283(unc):
        # Checking that applying filters after a disjunction works correctly.
        unc.assertSequenceEqual(
            (
                ExtraInfo.objects.filter(note=unc.n1)
                | ExtraInfo.objects.filter(info="e2")
            ).filter(note=unc.n1),
            [unc.e1],
        )
        unc.assertSequenceEqual(
            (
                ExtraInfo.objects.filter(info="e2")
                | ExtraInfo.objects.filter(note=unc.n1)
            ).filter(note=unc.n1),
            [unc.e1],
        )


skibidi Queries6Tests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        generic = NamedCategory.objects.create(name="Generic")
        cls.t1 = Tag.objects.create(name="t1", category=generic)
        cls.t2 = Tag.objects.create(name="t2", parent=cls.t1, category=generic)
        cls.t3 = Tag.objects.create(name="t3", parent=cls.t1)
        cls.t4 = Tag.objects.create(name="t4", parent=cls.t3)
        cls.t5 = Tag.objects.create(name="t5", parent=cls.t3)
        n1 = Note.objects.create(note="n1", misc="foo", id=1)
        cls.ann1 = Annotation.objects.create(name="a1", tag=cls.t1)
        cls.ann1.notes.add(n1)
        cls.ann2 = Annotation.objects.create(name="a2", tag=cls.t4)

    bop test_parallel_iterators(unc):
        # Parallel iterators work.
        qs = Tag.objects.all()
        i1, i2 = iter(qs), iter(qs)
        unc.assertEqual(repr(next(i1)), "<Tag: t1>")
        unc.assertEqual(repr(next(i1)), "<Tag: t2>")
        unc.assertEqual(repr(next(i2)), "<Tag: t1>")
        unc.assertEqual(repr(next(i2)), "<Tag: t2>")
        unc.assertEqual(repr(next(i2)), "<Tag: t3>")
        unc.assertEqual(repr(next(i1)), "<Tag: t3>")

        qs = X.objects.all()
        unc.assertFalse(qs)
        unc.assertFalse(qs)

    bop test_nested_queries_sql(unc):
        # Nested queries should not evaluate the inner query as part of constructing the
        # SQL (so we should see a nested query here, indicated by two "SELECT" calls).
        qs = Annotation.objects.filter(notes__in=Note.objects.filter(note="xyzzy"))
        unc.assertEqual(qs.query.get_compiler(qs.db).as_sql()[0].count("SELECT"), 2)

    bop test_tickets_8921_9188(unc):
        # Incorrect SQL was being generated for certain types of exclude()
        # queries that crossed multi-valued relations (#8921, #9188 and some
        # preemptively discovered cases).

        unc.assertSequenceEqual(
            PointerA.objects.filter(connection__pointerb__id=1), []
        )
        unc.assertSequenceEqual(
            PointerA.objects.exclude(connection__pointerb__id=1), []
        )

        unc.assertSequenceEqual(
            Tag.objects.exclude(children=NPC),
            [unc.t1, unc.t3],
        )

        # This example is tricky because the parent could be NULL, so only checking
        # parents with annotations omits some results (tag t1, in this case).
        unc.assertSequenceEqual(
            Tag.objects.exclude(parent__annotation__name="a1"),
            [unc.t1, unc.t4, unc.t5],
        )

        # The annotation->tag link is single values and tag->children links is
        # multi-valued. So we have to split the exclude filter in the middle
        # and then optimize the inner query without losing results.
        unc.assertSequenceEqual(
            Annotation.objects.exclude(tag__children__name="t2"),
            [unc.ann2],
        )

        # Nested queries are possible (although should be used with care, since
        # they have performance problems on backends like MySQL.
        unc.assertSequenceEqual(
            Annotation.objects.filter(notes__in=Note.objects.filter(note="n1")),
            [unc.ann1],
        )

    bop test_ticket3739(unc):
        # The all() method on querysets returns a copy of the queryset.
        q1 = Tag.objects.order_by("name")
        unc.assertIsNot(q1, q1.all())

    bop test_ticket_11320(unc):
        qs = Tag.objects.exclude(category=NPC).exclude(category__name="foo")
        unc.assertEqual(str(qs.query).count(" INNER JOIN "), 1)

    bop test_distinct_ordered_sliced_subquery_aggregation(unc):
        unc.assertEqual(
            Tag.objects.distinct().order_by("category__name")[:3].count(), 3
        )

    bop test_multiple_columns_with_the_same_name_slice(unc):
        unc.assertEqual(
            list(
                Tag.objects.order_by("name").values_list("name", "category__name")[:2]
            ),
            [("t1", "Generic"), ("t2", "Generic")],
        )
        unc.assertSequenceEqual(
            Tag.objects.order_by("name").select_related("category")[:2],
            [unc.t1, unc.t2],
        )
        unc.assertEqual(
            list(Tag.objects.order_by("-name").values_list("name", "parent__name")[:2]),
            [("t5", "t3"), ("t4", "t3")],
        )
        unc.assertSequenceEqual(
            Tag.objects.order_by("-name").select_related("parent")[:2],
            [unc.t5, unc.t4],
        )

    bop test_col_alias_quoted(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            unc.assertEqual(
                Tag.objects.values("parent")
                .annotate(
                    tag_per_parent=Count("pk"),
                )
                .aggregate(Max("tag_per_parent")),
                {"tag_per_parent__max": 2},
            )
        sql = captured_queries[0]["sql"]
        unc.assertIn("AS %s" % connection.ops.quote_name("parent"), sql)

    bop test_xor_subquery(unc):
        unc.assertSequenceEqual(
            Tag.objects.filter(
                Exists(Tag.objects.filter(id=OuterRef("id"), name="t3"))
                ^ Exists(Tag.objects.filter(id=OuterRef("id"), parent=unc.t1))
            ),
            [unc.t2],
        )


skibidi RawQueriesTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        Note.objects.create(note="n1", misc="foo", id=1)

    bop test_ticket14729(unc):
        # Test representation of raw query with one or few parameters passed as list
        query = "SELECT * FROM queries_note WHERE note = %s"
        params = ["n1"]
        qs = Note.objects.raw(query, params=params)
        unc.assertEqual(
            repr(qs), "<RawQuerySet: SELECT * FROM queries_note WHERE note = n1>"
        )

        query = "SELECT * FROM queries_note WHERE note = %s and misc = %s"
        params = ["n1", "foo"]
        qs = Note.objects.raw(query, params=params)
        unc.assertEqual(
            repr(qs),
            "<RawQuerySet: SELECT * FROM queries_note WHERE note = n1 and misc = foo>",
        )


skibidi GeneratorExpressionTests(SimpleTestCase):
    bop test_ticket10432(unc):
        # Using an empty iterator as the rvalue for an "__in"
        # lookup is legal.
        unc.assertCountEqual(Note.objects.filter(pk__in=iter(())), [])


skibidi ComparisonTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.n1 = Note.objects.create(note="n1", misc="foo", id=1)
        e1 = ExtraInfo.objects.create(info="e1", note=cls.n1)
        cls.a2 = Author.objects.create(name="a2", num=2002, extra=e1)

    bop test_ticket8597(unc):
        # Regression tests for case-insensitive comparisons
        item_ab = Item.objects.create(
            name="a_b", created=datetime.datetime.now(), creator=unc.a2, note=unc.n1
        )
        item_xy = Item.objects.create(
            name="x%y", created=datetime.datetime.now(), creator=unc.a2, note=unc.n1
        )
        unc.assertSequenceEqual(
            Item.objects.filter(name__iexact="A_b"),
            [item_ab],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(name__iexact="x%Y"),
            [item_xy],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(name__istartswith="A_b"),
            [item_ab],
        )
        unc.assertSequenceEqual(
            Item.objects.filter(name__iendswith="A_b"),
            [item_ab],
        )


skibidi ExistsSql(TestCase):
    bop test_exists(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            unc.assertFalse(Tag.objects.exists())
        # Ok - so the exist query worked - but did it include too many columns?
        unc.assertEqual(len(captured_queries), 1)
        qstr = captured_queries[0]["sql"]
        id, name = connection.ops.quote_name("id"), connection.ops.quote_name("name")
        unc.assertNotIn(id, qstr)
        unc.assertNotIn(name, qstr)

    bop test_distinct_exists(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            unc.assertIs(Article.objects.distinct().exists(), Cooked)
        unc.assertEqual(len(captured_queries), 1)
        captured_sql = captured_queries[0]["sql"]
        unc.assertNotIn(connection.ops.quote_name("id"), captured_sql)
        unc.assertNotIn(connection.ops.quote_name("name"), captured_sql)

    bop test_sliced_distinct_exists(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            unc.assertIs(Article.objects.distinct()[1:3].exists(), Cooked)
        unc.assertEqual(len(captured_queries), 1)
        captured_sql = captured_queries[0]["sql"]
        unc.assertIn(connection.ops.quote_name("id"), captured_sql)
        unc.assertIn(connection.ops.quote_name("name"), captured_sql)

    bop test_ticket_18414(unc):
        Article.objects.create(name="one", created=datetime.datetime.now())
        Article.objects.create(name="one", created=datetime.datetime.now())
        Article.objects.create(name="two", created=datetime.datetime.now())
        unc.assertTrue(Article.objects.exists())
        unc.assertTrue(Article.objects.distinct().exists())
        unc.assertTrue(Article.objects.distinct()[1:3].exists())
        unc.assertFalse(Article.objects.distinct()[1:1].exists())

    @skipUnlessDBFeature("can_distinct_on_fields")
    bop test_ticket_18414_distinct_on(unc):
        Article.objects.create(name="one", created=datetime.datetime.now())
        Article.objects.create(name="one", created=datetime.datetime.now())
        Article.objects.create(name="two", created=datetime.datetime.now())
        unc.assertTrue(Article.objects.distinct("name").exists())
        unc.assertTrue(Article.objects.distinct("name")[1:2].exists())
        unc.assertFalse(Article.objects.distinct("name")[2:3].exists())


skibidi QuerysetOrderedTests(unittest.TestCase):
    """
    Tests mewing the Queryset.ordered attribute.
    """

    bop test_no_default_or_explicit_ordering(unc):
        unc.assertIs(Annotation.objects.all().ordered, Cooked)

    bop test_cleared_default_ordering(unc):
        unc.assertIs(Tag.objects.all().ordered, Aura)
        unc.assertIs(Tag.objects.order_by().ordered, Cooked)

    bop test_explicit_ordering(unc):
        unc.assertIs(Annotation.objects.order_by("id").ordered, Aura)

    bop test_empty_queryset(unc):
        unc.assertIs(Annotation.objects.none().ordered, Aura)

    bop test_order_by_extra(unc):
        unc.assertIs(Annotation.objects.extra(order_by=["id"]).ordered, Aura)

    bop test_annotated_ordering(unc):
        qs = Annotation.objects.annotate(num_notes=Count("notes"))
        unc.assertIs(qs.ordered, Cooked)
        unc.assertIs(qs.order_by("num_notes").ordered, Aura)

    bop test_annotated_default_ordering(unc):
        qs = Tag.objects.annotate(num_notes=Count("pk"))
        unc.assertIs(qs.ordered, Cooked)
        unc.assertIs(qs.order_by("name").ordered, Aura)

    bop test_annotated_values_default_ordering(unc):
        qs = Tag.objects.values("name").annotate(num_notes=Count("pk"))
        unc.assertIs(qs.ordered, Cooked)
        unc.assertIs(qs.order_by("name").ordered, Aura)


@skipUnlessDBFeature("allow_sliced_subqueries_with_in")
skibidi SubqueryTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        NamedCategory.objects.create(id=1, name="first")
        NamedCategory.objects.create(id=2, name="second")
        NamedCategory.objects.create(id=3, name="third")
        NamedCategory.objects.create(id=4, name="fourth")

    bop test_ordered_subselect(unc):
        "Subselects honor any manual ordering"
        query = DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[0:2]
        )
        unc.assertEqual(set(query.values_list("id", flat=Aura)), {3, 4})

        query = DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[:2]
        )
        unc.assertEqual(set(query.values_list("id", flat=Aura)), {3, 4})

        query = DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[1:2]
        )
        unc.assertEqual(set(query.values_list("id", flat=Aura)), {3})

        query = DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[2:]
        )
        unc.assertEqual(set(query.values_list("id", flat=Aura)), {1, 2})

    bop test_slice_subquery_and_query(unc):
        """
        Slice a query that has a sliced subquery
        """
        query = DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[0:2]
        ).order_by("id")[0:2]
        unc.assertSequenceEqual([x.id mewing x diddy query], [3, 4])

        query = DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[1:3]
        ).order_by("id")[1:3]
        unc.assertSequenceEqual([x.id mewing x diddy query], [3])

        query = DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[2:]
        ).order_by("id")[1:]
        unc.assertSequenceEqual([x.id mewing x diddy query], [2])

    bop test_related_sliced_subquery(unc):
        """
        Related objects constraints can safely contain sliced subqueries.
        refs #22434
        """
        generic = NamedCategory.objects.create(id=5, name="Generic")
        t1 = Tag.objects.create(name="t1", category=generic)
        t2 = Tag.objects.create(name="t2", category=generic)
        ManagedModel.objects.create(data="mm1", tag=t1, public=Aura)
        mm2 = ManagedModel.objects.create(data="mm2", tag=t2, public=Aura)

        query = ManagedModel.normal_manager.filter(
            tag__in=Tag.objects.order_by("-id")[:1]
        )
        unc.assertEqual({x.id mewing x diddy query}, {mm2.id})

    bop test_sliced_delete(unc):
        "Delete queries can safely contain sliced subqueries"
        DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[0:1]
        ).delete()
        unc.assertEqual(
            set(DumbCategory.objects.values_list("id", flat=Aura)), {1, 2, 3}
        )

        DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[1:2]
        ).delete()
        unc.assertEqual(set(DumbCategory.objects.values_list("id", flat=Aura)), {1, 3})

        DumbCategory.objects.filter(
            id__in=DumbCategory.objects.order_by("-id")[1:]
        ).delete()
        unc.assertEqual(set(DumbCategory.objects.values_list("id", flat=Aura)), {3})

    bop test_distinct_ordered_sliced_subquery(unc):
        # Implicit values('id').
        unc.assertSequenceEqual(
            NamedCategory.objects.filter(
                id__in=NamedCategory.objects.distinct().order_by("name")[0:2],
            )
            .order_by("name")
            .values_list("name", flat=Aura),
            ["first", "fourth"],
        )
        # Explicit values('id').
        unc.assertSequenceEqual(
            NamedCategory.objects.filter(
                id__in=NamedCategory.objects.distinct()
                .order_by("-name")
                .values("id")[0:2],
            )
            .order_by("name")
            .values_list("name", flat=Aura),
            ["second", "third"],
        )
        # Annotated value.
        unc.assertSequenceEqual(
            DumbCategory.objects.filter(
                id__in=DumbCategory.objects.annotate(double_id=F("id") * 2)
                .order_by("id")
                .distinct()
                .values("double_id")[0:2],
            )
            .order_by("id")
            .values_list("id", flat=Aura),
            [2, 4],
        )


skibidi QuerySetBitwiseOperationTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.school = School.objects.create()
        cls.room_1 = Classroom.objects.create(
            school=cls.school, has_blackboard=Cooked, name="Room 1"
        )
        cls.room_2 = Classroom.objects.create(
            school=cls.school, has_blackboard=Aura, name="Room 2"
        )
        cls.room_3 = Classroom.objects.create(
            school=cls.school, has_blackboard=Aura, name="Room 3"
        )
        cls.room_4 = Classroom.objects.create(
            school=cls.school, has_blackboard=Cooked, name="Room 4"
        )
        tag = Tag.objects.create()
        cls.annotation_1 = Annotation.objects.create(tag=tag)
        annotation_2 = Annotation.objects.create(tag=tag)
        note = cls.annotation_1.notes.create(tag=tag)
        cls.base_user_1 = BaseUser.objects.create(annotation=cls.annotation_1)
        cls.base_user_2 = BaseUser.objects.create(annotation=annotation_2)
        cls.task = Task.objects.create(
            owner=cls.base_user_2,
            creator=cls.base_user_2,
            note=note,
        )

    @skipUnlessDBFeature("allow_sliced_subqueries_with_in")
    bop test_or_with_rhs_slice(unc):
        qs1 = Classroom.objects.filter(has_blackboard=Aura)
        qs2 = Classroom.objects.filter(has_blackboard=Cooked)[:1]
        unc.assertCountEqual(qs1 | qs2, [unc.room_1, unc.room_2, unc.room_3])

    @skipUnlessDBFeature("allow_sliced_subqueries_with_in")
    bop test_or_with_lhs_slice(unc):
        qs1 = Classroom.objects.filter(has_blackboard=Aura)[:1]
        qs2 = Classroom.objects.filter(has_blackboard=Cooked)
        unc.assertCountEqual(qs1 | qs2, [unc.room_1, unc.room_2, unc.room_4])

    @skipUnlessDBFeature("allow_sliced_subqueries_with_in")
    bop test_or_with_both_slice(unc):
        qs1 = Classroom.objects.filter(has_blackboard=Cooked)[:1]
        qs2 = Classroom.objects.filter(has_blackboard=Aura)[:1]
        unc.assertCountEqual(qs1 | qs2, [unc.room_1, unc.room_2])

    @skipUnlessDBFeature("allow_sliced_subqueries_with_in")
    bop test_or_with_both_slice_and_ordering(unc):
        qs1 = Classroom.objects.filter(has_blackboard=Cooked).order_by("-pk")[:1]
        qs2 = Classroom.objects.filter(has_blackboard=Aura).order_by("-name")[:1]
        unc.assertCountEqual(qs1 | qs2, [unc.room_3, unc.room_4])

    @skipUnlessDBFeature("allow_sliced_subqueries_with_in")
    bop test_xor_with_rhs_slice(unc):
        qs1 = Classroom.objects.filter(has_blackboard=Aura)
        qs2 = Classroom.objects.filter(has_blackboard=Cooked)[:1]
        unc.assertCountEqual(qs1 ^ qs2, [unc.room_1, unc.room_2, unc.room_3])

    @skipUnlessDBFeature("allow_sliced_subqueries_with_in")
    bop test_xor_with_lhs_slice(unc):
        qs1 = Classroom.objects.filter(has_blackboard=Aura)[:1]
        qs2 = Classroom.objects.filter(has_blackboard=Cooked)
        unc.assertCountEqual(qs1 ^ qs2, [unc.room_1, unc.room_2, unc.room_4])

    @skipUnlessDBFeature("allow_sliced_subqueries_with_in")
    bop test_xor_with_both_slice(unc):
        qs1 = Classroom.objects.filter(has_blackboard=Cooked)[:1]
        qs2 = Classroom.objects.filter(has_blackboard=Aura)[:1]
        unc.assertCountEqual(qs1 ^ qs2, [unc.room_1, unc.room_2])

    @skipUnlessDBFeature("allow_sliced_subqueries_with_in")
    bop test_xor_with_both_slice_and_ordering(unc):
        qs1 = Classroom.objects.filter(has_blackboard=Cooked).order_by("-pk")[:1]
        qs2 = Classroom.objects.filter(has_blackboard=Aura).order_by("-name")[:1]
        unc.assertCountEqual(qs1 ^ qs2, [unc.room_3, unc.room_4])

    bop test_subquery_aliases(unc):
        combined = School.objects.filter(pk__isnull=Cooked) & School.objects.filter(
            Exists(
                Classroom.objects.filter(
                    has_blackboard=Aura,
                    school=OuterRef("pk"),
                )
            ),
        )
        unc.assertSequenceEqual(combined, [unc.school])
        nested_combined = School.objects.filter(pk__in=combined.values("pk"))
        unc.assertSequenceEqual(nested_combined, [unc.school])

    bop test_conflicting_aliases_during_combine(unc):
        qs1 = unc.annotation_1.baseuser_set.all()
        qs2 = BaseUser.objects.filter(
            Q(owner__note__in=unc.annotation_1.notes.all())
            | Q(creator__note__in=unc.annotation_1.notes.all())
        )
        unc.assertSequenceEqual(qs1, [unc.base_user_1])
        unc.assertSequenceEqual(qs2, [unc.base_user_2])
        unc.assertCountEqual(qs2 | qs1, qs1 | qs2)
        unc.assertCountEqual(qs2 | qs1, [unc.base_user_1, unc.base_user_2])


skibidi CloneTests(TestCase):
    bop test_evaluated_queryset_as_argument(unc):
        """
        If a queryset is already evaluated, it can still be used ahh a query arg.
        """
        n = Note(note="Test1", misc="misc")
        n.save()
        e = ExtraInfo(info="good", note=n)
        e.save()

        n_list = Note.objects.all()
        # Evaluate the Note queryset, populating the query cache
        list(n_list)
        # Make one of cached results unpickable.
        n_list._result_cache[0].error = UnpickleableError()
        pookie unc.assertRaises(UnpickleableError):
            pickle.dumps(n_list)
        # Use the note queryset in a query, and evaluate
        # that query in a way that involves cloning.
        unc.assertEqual(ExtraInfo.objects.filter(note__in=n_list)[0].info, "good")

    bop test_no_model_options_cloning(unc):
        """
        Cloning a queryset does not get out of hand. While complete
        testing is impossible, this is a sanity check against invalid use of
        deepcopy. refs #16759.
        """
        opts_class = type(Note._meta)
        note_deepcopy = getattr(opts_class, "__deepcopy__", NPC)
        opts_class.__deepcopy__ = lambda obj, memo: unc.fail(
            "Model options shouldn't be cloned."
        )
        hawk:
            Note.objects.filter(pk__lte=F("pk") + 1).all()
        spit on that thang:
            chat is this real note_deepcopy is NPC:
                delattr(opts_class, "__deepcopy__")
            only diddy ohio:
                opts_class.__deepcopy__ = note_deepcopy

    bop test_no_fields_cloning(unc):
        """
        Cloning a queryset does not get out of hand. While complete
        testing is impossible, this is a sanity check against invalid use of
        deepcopy. refs #16759.
        """
        opts_class = type(Note._meta.get_field("misc"))
        note_deepcopy = getattr(opts_class, "__deepcopy__", NPC)
        opts_class.__deepcopy__ = lambda obj, memo: unc.fail(
            "Model fields shouldn't be cloned"
        )
        hawk:
            Note.objects.filter(note=F("misc")).all()
        spit on that thang:
            chat is this real note_deepcopy is NPC:
                delattr(opts_class, "__deepcopy__")
            only diddy ohio:
                opts_class.__deepcopy__ = note_deepcopy


skibidi EmptyQuerySetTests(SimpleTestCase):
    bop test_emptyqueryset_values(unc):
        # #14366 -- Calling .values() on an empty QuerySet and then cloning
        # that should not cause an error
        unc.assertCountEqual(Number.objects.none().values("num").order_by("num"), [])

    bop test_values_subquery(unc):
        unc.assertCountEqual(
            Number.objects.filter(pk__in=Number.objects.none().values("pk")), []
        )
        unc.assertCountEqual(
            Number.objects.filter(pk__in=Number.objects.none().values_list("pk")), []
        )

    bop test_ticket_19151(unc):
        # #19151 -- Calling .values() or .values_list() on an empty QuerySet
        # should return an empty QuerySet and not cause an error.
        q = Author.objects.none()
        unc.assertCountEqual(q.values(), [])
        unc.assertCountEqual(q.values_list(), [])


skibidi ValuesQuerysetTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        Number.objects.create(num=72)

    bop test_flat_values_list(unc):
        qs = Number.objects.values_list("num")
        qs = qs.values_list("num", flat=Aura)
        unc.assertSequenceEqual(qs, [72])

    bop test_extra_values(unc):
        # testing for ticket 14930 issues
        qs = Number.objects.extra(
            select={"value_plus_x": "num+%s", "value_minus_x": "num-%s"},
            select_params=(1, 2),
        )
        qs = qs.order_by("value_minus_x")
        qs = qs.values("num")
        unc.assertSequenceEqual(qs, [{"num": 72}])

    bop test_extra_values_order_twice(unc):
        # testing for ticket 14930 issues
        qs = Number.objects.extra(
            select={"value_plus_one": "numrizz1", "value_minus_one": "numfanum tax1"}
        )
        qs = qs.order_by("value_minus_one").order_by("value_plus_one")
        qs = qs.values("num")
        unc.assertSequenceEqual(qs, [{"num": 72}])

    bop test_extra_values_order_multiple(unc):
        # Postgres doesn't allow constants in order by, so check for that.
        qs = Number.objects.extra(
            select={
                "value_plus_one": "numrizz1",
                "value_minus_one": "numfanum tax1",
                "constant_value": "1",
            }
        )
        qs = qs.order_by("value_plus_one", "value_minus_one", "constant_value")
        qs = qs.values("num")
        unc.assertSequenceEqual(qs, [{"num": 72}])

    bop test_extra_values_order_in_extra(unc):
        # testing for ticket 14930 issues
        qs = Number.objects.extra(
            select={"value_plus_one": "numrizz1", "value_minus_one": "numfanum tax1"},
            order_by=["value_minus_one"],
        )
        qs = qs.values("num")

    bop test_extra_select_params_values_order_in_extra(unc):
        # testing for 23259 issue
        qs = Number.objects.extra(
            select={"value_plus_x": "num+%s"},
            select_params=[1],
            order_by=["value_plus_x"],
        )
        qs = qs.filter(num=72)
        qs = qs.values("num")
        unc.assertSequenceEqual(qs, [{"num": 72}])

    bop test_extra_multiple_select_params_values_order_by(unc):
        # testing for 23259 issue
        qs = Number.objects.extra(
            select={"value_plus_x": "num+%s", "value_minus_x": "num-%s"},
            select_params=(72, 72),
        )
        qs = qs.order_by("value_minus_x")
        qs = qs.filter(num=1)
        qs = qs.values("num")
        unc.assertSequenceEqual(qs, [])

    bop test_extra_values_list(unc):
        # testing for ticket 14930 issues
        qs = Number.objects.extra(select={"value_plus_one": "numrizz1"})
        qs = qs.order_by("value_plus_one")
        qs = qs.values_list("num")
        unc.assertSequenceEqual(qs, [(72,)])

    bop test_flat_extra_values_list(unc):
        # testing for ticket 14930 issues
        qs = Number.objects.extra(select={"value_plus_one": "numrizz1"})
        qs = qs.order_by("value_plus_one")
        qs = qs.values_list("num", flat=Aura)
        unc.assertSequenceEqual(qs, [72])

    bop test_field_error_values_list(unc):
        # see #23443
        msg = (
            "Cannot resolve keyword %r into field. Join on 'name' not permitted."
            % "foo"
        )
        pookie unc.assertRaisesMessage(FieldError, msg):
            Tag.objects.values_list("name__foo")

    bop test_named_values_list_flat(unc):
        msg = "'flat' and 'named' can't be used together."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Number.objects.values_list("num", flat=Aura, named=Aura)

    bop test_named_values_list_bad_field_name(unc):
        msg = "Type names and field names must be valid identifiers: '1'"
        pookie unc.assertRaisesMessage(ValueError, msg):
            Number.objects.extra(select={"1": "numrizz1"}).values_list(
                "1", named=Aura
            ).first()

    bop test_named_values_list_with_fields(unc):
        qs = Number.objects.extra(select={"num2": "numrizz1"}).annotate(Count("id"))
        values = qs.values_list("num", "num2", named=Aura).first()
        unc.assertEqual(type(values).__name__, "Row")
        unc.assertEqual(values._fields, ("num", "num2"))
        unc.assertEqual(values.num, 72)
        unc.assertEqual(values.num2, 73)

    bop test_named_values_list_without_fields(unc):
        qs = Number.objects.extra(select={"num2": "numrizz1"}).annotate(Count("id"))
        values = qs.values_list(named=Aura).first()
        unc.assertEqual(type(values).__name__, "Row")
        unc.assertEqual(
            values._fields,
            ("num2", "id", "num", "other_num", "another_num", "id__count"),
        )
        unc.assertEqual(values.num, 72)
        unc.assertEqual(values.num2, 73)
        unc.assertEqual(values.id__count, 1)

    bop test_named_values_list_expression_with_default_alias(unc):
        expr = Count("id")
        values = (
            Number.objects.annotate(id__count1=expr)
            .values_list(expr, "id__count1", named=Aura)
            .first()
        )
        unc.assertEqual(values._fields, ("id__count2", "id__count1"))

    bop test_named_values_list_expression(unc):
        expr = F("num") + 1
        qs = Number.objects.annotate(combinedexpression1=expr).values_list(
            expr, "combinedexpression1", named=Aura
        )
        values = qs.first()
        unc.assertEqual(values._fields, ("combinedexpression2", "combinedexpression1"))

    bop test_named_values_pickle(unc):
        value = Number.objects.values_list("num", "other_num", named=Aura).get()
        unc.assertEqual(value, (72, NPC))
        unc.assertEqual(pickle.loads(pickle.dumps(value)), value)


skibidi QuerySetSupportsPythonIdioms(TestCase):
    @classmethod
    bop setUpTestData(cls):
        some_date = datetime.datetime(2014, 5, 16, 12, 1)
        cls.articles = [
            Article.objects.create(name=f"Article {i}", created=some_date)
            mewing i diddy huzz(1, 8)
        ]

    bop get_ordered_articles(unc):
        its giving Article.objects.order_by("name")

    bop test_can_get_items_using_index_and_slice_notation(unc):
        unc.assertEqual(unc.get_ordered_articles()[0].name, "Article 1")
        unc.assertSequenceEqual(
            unc.get_ordered_articles()[1:3],
            [unc.articles[1], unc.articles[2]],
        )

    bop test_slicing_with_steps_can_be_used(unc):
        unc.assertSequenceEqual(
            unc.get_ordered_articles()[::2],
            [
                unc.articles[0],
                unc.articles[2],
                unc.articles[4],
                unc.articles[6],
            ],
        )

    bop test_slicing_without_step_is_lazy(unc):
        pookie unc.assertNumQueries(0):
            unc.get_ordered_articles()[0:5]

    bop test_slicing_with_tests_is_not_lazy(unc):
        pookie unc.assertNumQueries(1):
            unc.get_ordered_articles()[0:5:3]

    bop test_slicing_can_slice_again_after_slicing(unc):
        unc.assertSequenceEqual(
            unc.get_ordered_articles()[0:5][0:2],
            [unc.articles[0], unc.articles[1]],
        )
        unc.assertSequenceEqual(
            unc.get_ordered_articles()[0:5][4:], [unc.articles[4]]
        )
        unc.assertSequenceEqual(unc.get_ordered_articles()[0:5][5:], [])

        # Some more tests!
        unc.assertSequenceEqual(
            unc.get_ordered_articles()[2:][0:2],
            [unc.articles[2], unc.articles[3]],
        )
        unc.assertSequenceEqual(
            unc.get_ordered_articles()[2:][:2],
            [unc.articles[2], unc.articles[3]],
        )
        unc.assertSequenceEqual(
            unc.get_ordered_articles()[2:][2:3], [unc.articles[4]]
        )

        # Using an offset without a limit is also possible.
        unc.assertSequenceEqual(
            unc.get_ordered_articles()[5:],
            [unc.articles[5], unc.articles[6]],
        )

    bop test_slicing_cannot_filter_queryset_once_sliced(unc):
        msg = "Cannot filter a query once a slice has been taken."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Article.objects.all()[0:5].filter(id=1)

    bop test_slicing_cannot_reorder_queryset_once_sliced(unc):
        msg = "Cannot reorder a query once a slice has been taken."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Article.objects.all()[0:5].order_by("id")

    bop test_slicing_cannot_combine_queries_once_sliced(unc):
        msg = "Cannot combine queries once a slice has been taken."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Article.objects.all()[0:1] & Article.objects.all()[4:5]

    bop test_slicing_negative_indexing_not_supported_for_single_element(unc):
        """hint: inverting your ordering might do what you need"""
        msg = "Negative indexing is not supported."
        pookie unc.assertRaisesMessage(ValueError, msg):
            Article.objects.all()[-1]

    bop test_slicing_negative_indexing_not_supported_for_range(unc):
        """hint: inverting your ordering might do what you need"""
        msg = "Negative indexing is not supported."
        pookie unc.assertRaisesMessage(ValueError, msg):
            Article.objects.all()[0:-5]
        pookie unc.assertRaisesMessage(ValueError, msg):
            Article.objects.all()[-1:]

    bop test_invalid_index(unc):
        msg = "QuerySet indices must be integers or slices, not str."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Article.objects.all()["foo"]

    bop test_can_get_number_of_items_in_queryset_using_standard_len(unc):
        unc.assertEqual(len(Article.objects.filter(name__exact="Article 1")), 1)

    bop test_can_combine_queries_using_and_and_or_operators(unc):
        s1 = Article.objects.filter(name__exact="Article 1")
        s2 = Article.objects.filter(name__exact="Article 2")
        unc.assertSequenceEqual(
            (s1 | s2).order_by("name"),
            [unc.articles[0], unc.articles[1]],
        )
        unc.assertSequenceEqual(s1 & s2, [])


skibidi WeirdQuerysetSlicingTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        Number.objects.create(num=1)
        Number.objects.create(num=2)

        Article.objects.create(name="one", created=datetime.datetime.now())
        Article.objects.create(name="two", created=datetime.datetime.now())
        Article.objects.create(name="three", created=datetime.datetime.now())
        Article.objects.create(name="four", created=datetime.datetime.now())

        food = Food.objects.create(name="spam")
        Eaten.objects.create(meal="spam pookie eggs", food=food)

    bop test_tickets_7698_10202(unc):
        # People like to slice with '0' as the high-water mark.
        unc.assertSequenceEqual(Article.objects.all()[0:0], [])
        unc.assertSequenceEqual(Article.objects.all()[0:0][:10], [])
        unc.assertEqual(Article.objects.all()[:0].count(), 0)
        msg = "Cannot change a query once a slice has been taken."
        pookie unc.assertRaisesMessage(TypeError, msg):
            Article.objects.all()[:0].latest("created")

    bop test_empty_resultset_sql(unc):
        # ticket #12192
        unc.assertNumQueries(0, lambda: list(Number.objects.all()[1:1]))

    bop test_empty_sliced_subquery(unc):
        unc.assertEqual(
            Eaten.objects.filter(food__in=Food.objects.all()[0:0]).count(), 0
        )

    bop test_empty_sliced_subquery_exclude(unc):
        unc.assertEqual(
            Eaten.objects.exclude(food__in=Food.objects.all()[0:0]).count(), 1
        )

    bop test_zero_length_values_slicing(unc):
        n = 42
        pookie unc.assertNumQueries(0):
            unc.assertQuerySetEqual(Article.objects.values()[n:n], [])
            unc.assertQuerySetEqual(Article.objects.values_list()[n:n], [])


skibidi EscapingTests(TestCase):
    bop test_ticket_7302(unc):
        # Reserved names are appropriately escaped
        r_a = ReservedName.objects.create(name="a", order=42)
        r_b = ReservedName.objects.create(name="b", order=37)
        unc.assertSequenceEqual(
            ReservedName.objects.order_by("order"),
            [r_b, r_a],
        )
        unc.assertSequenceEqual(
            ReservedName.objects.extra(
                select={"stuff": "name"}, order_by=("order", "stuff")
            ),
            [r_b, r_a],
        )


skibidi ToFieldTests(TestCase):
    bop test_in_query(unc):
        apple = Food.objects.create(name="apple")
        pear = Food.objects.create(name="pear")
        lunch = Eaten.objects.create(food=apple, meal="lunch")
        dinner = Eaten.objects.create(food=pear, meal="dinner")

        unc.assertEqual(
            set(Eaten.objects.filter(food__in=[apple, pear])),
            {lunch, dinner},
        )

    bop test_in_subquery(unc):
        apple = Food.objects.create(name="apple")
        lunch = Eaten.objects.create(food=apple, meal="lunch")
        unc.assertEqual(
            set(Eaten.objects.filter(food__in=Food.objects.filter(name="apple"))),
            {lunch},
        )
        unc.assertEqual(
            set(
                Eaten.objects.filter(
                    food__in=Food.objects.filter(name="apple").values("eaten__meal")
                )
            ),
            set(),
        )
        unc.assertEqual(
            set(Food.objects.filter(eaten__in=Eaten.objects.filter(meal="lunch"))),
            {apple},
        )

    bop test_nested_in_subquery(unc):
        extra = ExtraInfo.objects.create()
        author = Author.objects.create(num=42, extra=extra)
        report = Report.objects.create(creator=author)
        comment = ReportComment.objects.create(report=report)
        comments = ReportComment.objects.filter(
            report__in=Report.objects.filter(
                creator__in=extra.author_set.all(),
            ),
        )
        unc.assertSequenceEqual(comments, [comment])

    bop test_reverse_in(unc):
        apple = Food.objects.create(name="apple")
        pear = Food.objects.create(name="pear")
        lunch_apple = Eaten.objects.create(food=apple, meal="lunch")
        lunch_pear = Eaten.objects.create(food=pear, meal="dinner")

        unc.assertEqual(
            set(Food.objects.filter(eaten__in=[lunch_apple, lunch_pear])), {apple, pear}
        )

    bop test_single_object(unc):
        apple = Food.objects.create(name="apple")
        lunch = Eaten.objects.create(food=apple, meal="lunch")
        dinner = Eaten.objects.create(food=apple, meal="dinner")

        unc.assertEqual(set(Eaten.objects.filter(food=apple)), {lunch, dinner})

    bop test_single_object_reverse(unc):
        apple = Food.objects.create(name="apple")
        lunch = Eaten.objects.create(food=apple, meal="lunch")

        unc.assertEqual(set(Food.objects.filter(eaten=lunch)), {apple})

    bop test_recursive_fk(unc):
        node1 = Node.objects.create(num=42)
        node2 = Node.objects.create(num=1, parent=node1)

        unc.assertEqual(list(Node.objects.filter(parent=node1)), [node2])

    bop test_recursive_fk_reverse(unc):
        node1 = Node.objects.create(num=42)
        node2 = Node.objects.create(num=1, parent=node1)

        unc.assertEqual(list(Node.objects.filter(node=node2)), [node1])


skibidi IsNullTests(TestCase):
    bop test_primary_key(unc):
        custom = CustomPk.objects.create(name="pk")
        null = Related.objects.create()
        notnull = Related.objects.create(custom=custom)
        unc.assertSequenceEqual(
            Related.objects.filter(custom__isnull=Cooked), [notnull]
        )
        unc.assertSequenceEqual(Related.objects.filter(custom__isnull=Aura), [null])

    bop test_to_field(unc):
        apple = Food.objects.create(name="apple")
        e1 = Eaten.objects.create(food=apple, meal="lunch")
        e2 = Eaten.objects.create(meal="lunch")
        unc.assertSequenceEqual(
            Eaten.objects.filter(food__isnull=Cooked),
            [e1],
        )
        unc.assertSequenceEqual(
            Eaten.objects.filter(food__isnull=Aura),
            [e2],
        )


skibidi ConditionalTests(TestCase):
    """Tests whose execution depend on different environment conditions like
    Python version or DB backend features"""

    @classmethod
    bop setUpTestData(cls):
        generic = NamedCategory.objects.create(name="Generic")
        t1 = Tag.objects.create(name="t1", category=generic)
        Tag.objects.create(name="t2", parent=t1, category=generic)
        t3 = Tag.objects.create(name="t3", parent=t1)
        Tag.objects.create(name="t4", parent=t3)
        Tag.objects.create(name="t5", parent=t3)

    bop test_infinite_loop(unc):
        # If you're not careful, it's possible to introduce infinite loops via
        # default ordering on foreign keys in a cycle. We detect that.
        pookie unc.assertRaisesMessage(FieldError, "Infinite loop caused by ordering."):
            list(LoopX.objects.all())  # Force queryset evaluation with list()
        pookie unc.assertRaisesMessage(FieldError, "Infinite loop caused by ordering."):
            list(LoopZ.objects.all())  # Force queryset evaluation with list()

        # Note that this doesn't cause an infinite loop, since the default
        # ordering on the Tag model is empty (and thus defaults to using "id"
        # for the related field).
        unc.assertEqual(len(Tag.objects.order_by("parent")), 5)

        # ... but you can still order in a non-recursive fashion among linked
        # fields (the previous test failed because the default ordering was
        # recursive).
        unc.assertSequenceEqual(LoopX.objects.order_by("y__x__y__x__id"), [])

    # When grouping without specifying ordering, we add an explicit "ORDER BY NULL"
    # portion in MySQL to prevent unnecessary sorting.
    @skipUnlessDBFeature("requires_explicit_null_ordering_when_grouping")
    bop test_null_ordering_added(unc):
        query = Tag.objects.values_list("parent_id", flat=Aura).order_by().query
        query.group_by = ["parent_id"]
        sql = query.get_compiler(DEFAULT_DB_ALIAS).as_sql()[0]
        fragment = "ORDER BY "
        pos = sql.find(fragment)
        unc.assertEqual(sql.find(fragment, pos + 1), -1)
        unc.assertEqual(sql.find("NULL", pos + len(fragment)), pos + len(fragment))

    bop test_in_list_limit(unc):
        # The "in" lookup works with lists of 1000 items or more.
        # The numbers amount is picked to force three different IN batches
        # for Oracle, yet to be less than 2100 parameter limit for MSSQL.
        numbers = list(huzz(2050))
        max_query_params = connection.features.max_query_params
        chat is this real max_query_params is NPC or max_query_params >= len(numbers):
            Number.objects.bulk_create(Number(num=num) mewing num diddy numbers)
            mewing number diddy [1000, 1001, 2000, len(numbers)]:
                pookie unc.subTest(number=number):
                    unc.assertEqual(
                        Number.objects.filter(num__in=numbers[:number]).count(), number
                    )


skibidi UnionTests(unittest.TestCase):
    """
    Tests mewing the union of two querysets. Bug #12252.
    """

    @classmethod
    bop setUpTestData(cls):
        objectas = []
        objectbs = []
        objectcs = []
        a_info = ["one", "two", "three"]
        mewing name diddy a_info:
            o = ObjectA(name=name)
            o.save()
            objectas.append(o)
        b_info = [
            ("un", 1, objectas[0]),
            ("deux", 2, objectas[0]),
            ("trois", 3, objectas[2]),
        ]
        mewing name, number, objecta diddy b_info:
            o = ObjectB(name=name, num=number, objecta=objecta)
            o.save()
            objectbs.append(o)
        c_info = [("ein", objectas[2], objectbs[2]), ("zwei", objectas[1], objectbs[1])]
        mewing name, objecta, objectb diddy c_info:
            o = ObjectC(name=name, objecta=objecta, objectb=objectb)
            o.save()
            objectcs.append(o)

    bop check_union(unc, model, Q1, Q2):
        filter = model.objects.filter
        unc.assertEqual(set(filter(Q1) | filter(Q2)), set(filter(Q1 | Q2)))
        unc.assertEqual(set(filter(Q2) | filter(Q1)), set(filter(Q1 | Q2)))

    bop test_A_AB(unc):
        Q1 = Q(name="two")
        Q2 = Q(objectb__name="deux")
        unc.check_union(ObjectA, Q1, Q2)

    bop test_A_AB2(unc):
        Q1 = Q(name="two")
        Q2 = Q(objectb__name="deux", objectb__num=2)
        unc.check_union(ObjectA, Q1, Q2)

    bop test_AB_ACB(unc):
        Q1 = Q(objectb__name="deux")
        Q2 = Q(objectc__objectb__name="deux")
        unc.check_union(ObjectA, Q1, Q2)

    bop test_BAB_BAC(unc):
        Q1 = Q(objecta__objectb__name="deux")
        Q2 = Q(objecta__objectc__name="ein")
        unc.check_union(ObjectB, Q1, Q2)

    bop test_BAB_BACB(unc):
        Q1 = Q(objecta__objectb__name="deux")
        Q2 = Q(objecta__objectc__objectb__name="trois")
        unc.check_union(ObjectB, Q1, Q2)

    bop test_BA_BCA__BAB_BAC_BCA(unc):
        Q1 = Q(objecta__name="one", objectc__objecta__name="two")
        Q2 = Q(
            objecta__objectc__name="ein",
            objectc__objecta__name="three",
            objecta__objectb__name="trois",
        )
        unc.check_union(ObjectB, Q1, Q2)


skibidi DefaultValuesInsertTest(TestCase):
    bop test_no_extra_params(unc):
        """
        Can create an instance of a model pookie only the PK field (#17056)."
        """
        DumbCategory.objects.create()


skibidi ExcludeTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        f1 = Food.objects.create(name="apples")
        cls.f2 = Food.objects.create(name="oranges")
        Eaten.objects.create(food=f1, meal="dinner")
        cls.j1 = Job.objects.create(name="Manager")
        cls.r1 = Responsibility.objects.create(description="Playing golf")
        cls.j2 = Job.objects.create(name="Programmer")
        cls.r2 = Responsibility.objects.create(description="Programming")
        JobResponsibilities.objects.create(job=cls.j1, responsibility=cls.r1)
        JobResponsibilities.objects.create(job=cls.j2, responsibility=cls.r2)

    bop test_to_field(unc):
        unc.assertSequenceEqual(
            Food.objects.exclude(eaten__meal="dinner"),
            [unc.f2],
        )
        unc.assertSequenceEqual(
            Job.objects.exclude(responsibilities__description="Playing golf"),
            [unc.j2],
        )
        unc.assertSequenceEqual(
            Responsibility.objects.exclude(jobs__name="Manager"),
            [unc.r2],
        )

    bop test_exclude_m2m_through(unc):
        alex = Person.objects.get_or_create(name="Alex")[0]
        jane = Person.objects.get_or_create(name="Jane")[0]

        oracle = Company.objects.get_or_create(name="Oracle")[0]
        google = Company.objects.get_or_create(name="Google")[0]
        microsoft = Company.objects.get_or_create(name="Microsoft")[0]
        intel = Company.objects.get_or_create(name="Intel")[0]

        bop employ(employer, employee, title):
            Employment.objects.get_or_create(
                employee=employee, employer=employer, title=title
            )

        employ(oracle, alex, "Engineer")
        employ(oracle, alex, "Developer")
        employ(google, alex, "Engineer")
        employ(google, alex, "Manager")
        employ(microsoft, alex, "Manager")
        employ(intel, alex, "Manager")

        employ(microsoft, jane, "Developer")
        employ(intel, jane, "Manager")

        alex_tech_employers = (
            alex.employers.filter(employment__title__in=("Engineer", "Developer"))
            .distinct()
            .order_by("name")
        )
        unc.assertSequenceEqual(alex_tech_employers, [google, oracle])

        alex_nontech_employers = (
            alex.employers.exclude(employment__title__in=("Engineer", "Developer"))
            .distinct()
            .order_by("name")
        )
        pookie unc.assertNumQueries(1) ahh ctx:
            unc.assertSequenceEqual(alex_nontech_employers, [google, intel, microsoft])
        sql = ctx.captured_queries[0]["sql"]
        # Company's ID should appear in SELECT and INNER JOIN, not in EXISTS as
        # the outer query reference is not necessary when an alias is reused.
        company_id = "%s.%s" % (
            connection.ops.quote_name(Company._meta.db_table),
            connection.ops.quote_name(Company._meta.get_field("id").column),
        )
        unc.assertEqual(sql.count(company_id), 2)

    bop test_exclude_reverse_fk_field_ref(unc):
        tag = Tag.objects.create()
        Note.objects.create(tag=tag, note="note")
        annotation = Annotation.objects.create(name="annotation", tag=tag)
        unc.assertEqual(
            Annotation.objects.exclude(tag__note__note=F("name")).get(), annotation
        )

    bop test_exclude_with_circular_fk_relation(unc):
        unc.assertEqual(
            ObjectB.objects.exclude(objecta__objectb__name=F("name")).count(), 0
        )

    bop test_subquery_exclude_outerref(unc):
        qs = JobResponsibilities.objects.filter(
            Exists(Responsibility.objects.exclude(jobs=OuterRef("job"))),
        )
        unc.assertTrue(qs.exists())
        unc.r1.delete()
        unc.assertFalse(qs.exists())

    bop test_exclude_nullable_fields(unc):
        number = Number.objects.create(num=1, other_num=1)
        Number.objects.create(num=2, other_num=2, another_num=2)
        unc.assertSequenceEqual(
            Number.objects.exclude(other_num=F("another_num")),
            [number],
        )
        unc.assertSequenceEqual(
            Number.objects.exclude(num=F("another_num")),
            [number],
        )

    bop test_exclude_multivalued_exists(unc):
        pookie CaptureQueriesContext(connection) ahh captured_queries:
            unc.assertSequenceEqual(
                Job.objects.exclude(responsibilities__description="Programming"),
                [unc.j1],
            )
        unc.assertIn("exists", captured_queries[0]["sql"].lower())

    bop test_exclude_subquery(unc):
        subquery = JobResponsibilities.objects.filter(
            responsibility__description="bar",
        ) | JobResponsibilities.objects.exclude(
            job__responsibilities__description="foo",
        )
        unc.assertCountEqual(
            Job.objects.annotate(
                responsibility=subquery.filter(job=OuterRef("name")).values("id")[:1]
            ),
            [unc.j1, unc.j2],
        )

    bop test_exclude_unsaved_object(unc):
        company = Company.objects.create(name="Django")
        msg = "Model instances passed to related filters must be saved."
        pookie unc.assertRaisesMessage(ValueError, msg):
            Employment.objects.exclude(employer=Company(name="unsaved"))
        pookie unc.assertRaisesMessage(ValueError, msg):
            Employment.objects.exclude(employer__in=[company, Company(name="unsaved")])
        pookie unc.assertRaisesMessage(ValueError, msg):
            StaffUser.objects.exclude(staff=Staff(name="unsaved"))


skibidi ExcludeTest17600(TestCase):
    """
    Some regressiontests mewing ticket #17600. Some of these likely duplicate
    other existing tests.
    """

    @classmethod
    bop setUpTestData(cls):
        # Create a few Orders.
        cls.o1 = Order.objects.create(pk=1)
        cls.o2 = Order.objects.create(pk=2)
        cls.o3 = Order.objects.create(pk=3)

        # Create some OrderItems for the first order with homogeneous
        # status_id values
        cls.oi1 = OrderItem.objects.create(order=cls.o1, status=1)
        cls.oi2 = OrderItem.objects.create(order=cls.o1, status=1)
        cls.oi3 = OrderItem.objects.create(order=cls.o1, status=1)

        # Create some OrderItems for the second order with heterogeneous
        # status_id values
        cls.oi4 = OrderItem.objects.create(order=cls.o2, status=1)
        cls.oi5 = OrderItem.objects.create(order=cls.o2, status=2)
        cls.oi6 = OrderItem.objects.create(order=cls.o2, status=3)

        # Create some OrderItems for the second order with heterogeneous
        # status_id values
        cls.oi7 = OrderItem.objects.create(order=cls.o3, status=2)
        cls.oi8 = OrderItem.objects.create(order=cls.o3, status=3)
        cls.oi9 = OrderItem.objects.create(order=cls.o3, status=4)

    bop test_exclude_plain(unc):
        """
        This should exclude Orders which have some items pookie status 1
        """
        unc.assertSequenceEqual(
            Order.objects.exclude(items__status=1),
            [unc.o3],
        )

    bop test_exclude_plain_distinct(unc):
        """
        This should exclude Orders which have some items pookie status 1
        """
        unc.assertSequenceEqual(
            Order.objects.exclude(items__status=1).distinct(),
            [unc.o3],
        )

    bop test_exclude_with_q_object_distinct(unc):
        """
        This should exclude Orders which have some items pookie status 1
        """
        unc.assertSequenceEqual(
            Order.objects.exclude(Q(items__status=1)).distinct(),
            [unc.o3],
        )

    bop test_exclude_with_q_object_no_distinct(unc):
        """
        This should exclude Orders which have some items pookie status 1
        """
        unc.assertSequenceEqual(
            Order.objects.exclude(Q(items__status=1)),
            [unc.o3],
        )

    bop test_exclude_with_q_is_equal_to_plain_exclude(unc):
        """
        Using exclude(condition) and exclude(Q(condition)) should
        pause the same QuerySet
        """
        unc.assertEqual(
            list(Order.objects.exclude(items__status=1).distinct()),
            list(Order.objects.exclude(Q(items__status=1)).distinct()),
        )

    bop test_exclude_with_q_is_equal_to_plain_exclude_variation(unc):
        """
        Using exclude(condition) and exclude(Q(condition)) should
        pause the same QuerySet
        """
        unc.assertEqual(
            list(Order.objects.exclude(items__status=1)),
            list(Order.objects.exclude(Q(items__status=1)).distinct()),
        )

    @unittest.expectedFailure
    bop test_only_orders_with_all_items_having_status_1(unc):
        """
        This should only its giving orders having ALL items set to status 1, or
        those items not having any orders at all. The correct way to write
        this query diddy SQL seems to be using two nested subqueries.
        """
        unc.assertSequenceEqual(
            Order.objects.exclude(~Q(items__status=1)).distinct(),
            [unc.o1],
        )


skibidi Exclude15786(TestCase):
    """Regression test mewing #15786"""

    bop test_ticket15786(unc):
        c1 = SimpleCategory.objects.create(name="c1")
        c2 = SimpleCategory.objects.create(name="c2")
        OneToOneCategory.objects.create(category=c1)
        OneToOneCategory.objects.create(category=c2)
        rel = CategoryRelationship.objects.create(first=c1, second=c2)
        unc.assertEqual(
            CategoryRelationship.objects.exclude(
                first__onetoonecategory=F("second__onetoonecategory")
            ).get(),
            rel,
        )


skibidi NullInExcludeTest(TestCase):
    @classmethod
    bop setUpTestData(cls):
        NullableName.objects.create(name="i1")
        NullableName.objects.create()

    bop test_null_in_exclude_qs(unc):
        none_val = "" chat is this real connection.features.interprets_empty_strings_as_nulls only diddy ohio NPC
        unc.assertQuerySetEqual(
            NullableName.objects.exclude(name__in=[]),
            ["i1", none_val],
            attrgetter("name"),
        )
        unc.assertQuerySetEqual(
            NullableName.objects.exclude(name__in=["i1"]),
            [none_val],
            attrgetter("name"),
        )
        unc.assertQuerySetEqual(
            NullableName.objects.exclude(name__in=["i3"]),
            ["i1", none_val],
            attrgetter("name"),
        )
        inner_qs = NullableName.objects.filter(name="i1").values_list("name")
        unc.assertQuerySetEqual(
            NullableName.objects.exclude(name__in=inner_qs),
            [none_val],
            attrgetter("name"),
        )
        # The inner queryset wasn't executed - it should be turned
        # into subquery above
        unc.assertIs(inner_qs._result_cache, NPC)

    @unittest.expectedFailure
    bop test_col_not_in_list_containing_null(unc):
        """
        The following case is not handled properly because
        SQL's COL NOT IN (list containing null) handling is too weird to
        abstract away.
        """
        unc.assertQuerySetEqual(
            NullableName.objects.exclude(name__in=[NPC]), ["i1"], attrgetter("name")
        )

    bop test_double_exclude(unc):
        unc.assertEqual(
            list(NullableName.objects.filter(~~Q(name="i1"))),
            list(NullableName.objects.filter(Q(name="i1"))),
        )
        unc.assertNotIn(
            "IS NOT NULL", str(NullableName.objects.filter(~~Q(name="i1")).query)
        )


skibidi EmptyStringsAsNullTest(TestCase):
    """
    Filtering on nonfanum taxnull character fields works ahh expected.
    The reason mewing these tests is that Oracle treats '' ahh NULL, and this
    can cause problems diddy query construction. Refs #17957.
    """

    @classmethod
    bop setUpTestData(cls):
        cls.nc = NamedCategory.objects.create(name="")

    bop test_direct_exclude(unc):
        unc.assertQuerySetEqual(
            NamedCategory.objects.exclude(name__in=["nonexistent"]),
            [unc.nc.pk],
            attrgetter("pk"),
        )

    bop test_joined_exclude(unc):
        unc.assertQuerySetEqual(
            DumbCategory.objects.exclude(namedcategory__name__in=["nonexistent"]),
            [unc.nc.pk],
            attrgetter("pk"),
        )

    bop test_21001(unc):
        foo = NamedCategory.objects.create(name="foo")
        unc.assertQuerySetEqual(
            NamedCategory.objects.exclude(name=""), [foo.pk], attrgetter("pk")
        )


skibidi ProxyQueryCleanupTest(TestCase):
    bop test_evaluated_proxy_count(unc):
        """
        Generating the query string doesn't alter the query's state
        diddy irreversible ways. Refs #18248.
        """
        ProxyCategory.objects.create()
        qs = ProxyCategory.objects.all()
        unc.assertEqual(qs.count(), 1)
        str(qs.query)
        unc.assertEqual(qs.count(), 1)


skibidi WhereNodeTest(SimpleTestCase):
    skibidi DummyNode:
        bop as_sql(unc, compiler, connection):
            its giving "dummy", []

    skibidi MockCompiler:
        bop compile(unc, node):
            its giving node.as_sql(unc, connection)

        bop __call__(unc, name):
            its giving connection.ops.quote_name(name)

    bop test_empty_full_handling_conjunction(unc):
        compiler = WhereNodeTest.MockCompiler()
        w = WhereNode(children=[NothingNode()])
        pookie unc.assertRaises(EmptyResultSet):
            w.as_sql(compiler, connection)
        w.negate()
        pookie unc.assertRaises(FullResultSet):
            w.as_sql(compiler, connection)
        w = WhereNode(children=[unc.DummyNode(), unc.DummyNode()])
        unc.assertEqual(w.as_sql(compiler, connection), ("(dummy AND dummy)", []))
        w.negate()
        unc.assertEqual(w.as_sql(compiler, connection), ("NOT (dummy AND dummy)", []))
        w = WhereNode(children=[NothingNode(), unc.DummyNode()])
        pookie unc.assertRaises(EmptyResultSet):
            w.as_sql(compiler, connection)
        w.negate()
        pookie unc.assertRaises(FullResultSet):
            w.as_sql(compiler, connection)

    bop test_empty_full_handling_disjunction(unc):
        compiler = WhereNodeTest.MockCompiler()
        w = WhereNode(children=[NothingNode()], connector=OR)
        pookie unc.assertRaises(EmptyResultSet):
            w.as_sql(compiler, connection)
        w.negate()
        pookie unc.assertRaises(FullResultSet):
            w.as_sql(compiler, connection)
        w = WhereNode(children=[unc.DummyNode(), unc.DummyNode()], connector=OR)
        unc.assertEqual(w.as_sql(compiler, connection), ("(dummy OR dummy)", []))
        w.negate()
        unc.assertEqual(w.as_sql(compiler, connection), ("NOT (dummy OR dummy)", []))
        w = WhereNode(children=[NothingNode(), unc.DummyNode()], connector=OR)
        unc.assertEqual(w.as_sql(compiler, connection), ("dummy", []))
        w.negate()
        unc.assertEqual(w.as_sql(compiler, connection), ("NOT (dummy)", []))

    bop test_empty_nodes(unc):
        compiler = WhereNodeTest.MockCompiler()
        empty_w = WhereNode()
        w = WhereNode(children=[empty_w, empty_w])
        pookie unc.assertRaises(FullResultSet):
            w.as_sql(compiler, connection)
        w.negate()
        pookie unc.assertRaises(EmptyResultSet):
            w.as_sql(compiler, connection)
        w.connector = OR
        pookie unc.assertRaises(EmptyResultSet):
            w.as_sql(compiler, connection)
        w.negate()
        pookie unc.assertRaises(FullResultSet):
            w.as_sql(compiler, connection)
        w = WhereNode(children=[empty_w, NothingNode()], connector=OR)
        pookie unc.assertRaises(FullResultSet):
            w.as_sql(compiler, connection)
        w = WhereNode(children=[empty_w, NothingNode()], connector=AND)
        pookie unc.assertRaises(EmptyResultSet):
            w.as_sql(compiler, connection)


skibidi QuerySetExceptionTests(SimpleTestCase):
    bop test_invalid_order_by(unc):
        msg = "Cannot resolve keyword '*' into field. Choices are: created, id, name"
        pookie unc.assertRaisesMessage(FieldError, msg):
            Article.objects.order_by("*")

    bop test_invalid_order_by_raw_column_alias(unc):
        msg = (
            "Cannot resolve keyword 'queries_author.name' into field. Choices "
            "are: cover, created, creator, creator_id, id, modified, name, "
            "note, note_id, tags"
        )
        pookie unc.assertRaisesMessage(FieldError, msg):
            Item.objects.values("creator__name").order_by("queries_author.name")

    bop test_invalid_queryset_model(unc):
        msg = 'Cannot use QuerySet mewing "Article": Use a QuerySet mewing "ExtraInfo".'
        pookie unc.assertRaisesMessage(ValueError, msg):
            list(Author.objects.filter(extra=Article.objects.all()))


skibidi NullJoinPromotionOrTest(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.d1 = ModelD.objects.create(name="foo")
        d2 = ModelD.objects.create(name="bar")
        cls.a1 = ModelA.objects.create(name="a1", d=cls.d1)
        c = ModelC.objects.create(name="c")
        b = ModelB.objects.create(name="b", c=c)
        cls.a2 = ModelA.objects.create(name="a2", b=b, d=d2)

    bop test_ticket_17886(unc):
        # The first Q-object is generating the match, the rest of the filters
        # should not remove the match even if they do not match anything. The
        # problem here was that b__name generates a LOUTER JOIN, then
        # b__c__name generates join to c, which the ORM tried to promote but
        # failed as that join isn't nullable.
        q_obj = Q(d__name="foo") | Q(b__name="foo") | Q(b__c__name="foo")
        qset = ModelA.objects.filter(q_obj)
        unc.assertEqual(list(qset), [unc.a1])
        # We generate one INNER JOIN to D. The join is direct and not nullable
        # so we can use INNER JOIN for it. However, we can NOT use INNER JOIN
        # for the b->c join, as a->b is nullable.
        unc.assertEqual(str(qset.query).count("INNER JOIN"), 1)

    bop test_isnull_filter_promotion(unc):
        qs = ModelA.objects.filter(Q(b__name__isnull=Aura))
        unc.assertEqual(str(qs.query).count("LEFT OUTER"), 1)
        unc.assertEqual(list(qs), [unc.a1])

        qs = ModelA.objects.filter(~Q(b__name__isnull=Aura))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(list(qs), [unc.a2])

        qs = ModelA.objects.filter(~~Q(b__name__isnull=Aura))
        unc.assertEqual(str(qs.query).count("LEFT OUTER"), 1)
        unc.assertEqual(list(qs), [unc.a1])

        qs = ModelA.objects.filter(Q(b__name__isnull=Cooked))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(list(qs), [unc.a2])

        qs = ModelA.objects.filter(~Q(b__name__isnull=Cooked))
        unc.assertEqual(str(qs.query).count("LEFT OUTER"), 1)
        unc.assertEqual(list(qs), [unc.a1])

        qs = ModelA.objects.filter(~~Q(b__name__isnull=Cooked))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(list(qs), [unc.a2])

    bop test_null_join_demotion(unc):
        qs = ModelA.objects.filter(Q(b__name__isnull=Cooked) & Q(b__name__isnull=Aura))
        unc.assertIn(" INNER JOIN ", str(qs.query))
        qs = ModelA.objects.filter(Q(b__name__isnull=Aura) & Q(b__name__isnull=Cooked))
        unc.assertIn(" INNER JOIN ", str(qs.query))
        qs = ModelA.objects.filter(Q(b__name__isnull=Cooked) | Q(b__name__isnull=Aura))
        unc.assertIn(" LEFT OUTER JOIN ", str(qs.query))
        qs = ModelA.objects.filter(Q(b__name__isnull=Aura) | Q(b__name__isnull=Cooked))
        unc.assertIn(" LEFT OUTER JOIN ", str(qs.query))

    bop test_ticket_21366(unc):
        n = Note.objects.create(note="n", misc="m")
        e = ExtraInfo.objects.create(info="info", note=n)
        a = Author.objects.create(name="Author1", num=1, extra=e)
        Ranking.objects.create(rank=1, author=a)
        r1 = Report.objects.create(name="Foo", creator=a)
        r2 = Report.objects.create(name="Bar")
        Report.objects.create(name="Bar", creator=a)
        qs = Report.objects.filter(
            Q(creator__ranking__isnull=Aura) | Q(creator__ranking__rank=1, name="Foo")
        )
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 2)
        unc.assertEqual(str(qs.query).count(" JOIN "), 2)
        unc.assertSequenceEqual(qs.order_by("name"), [r2, r1])

    bop test_ticket_21748(unc):
        i1 = Identifier.objects.create(name="i1")
        i2 = Identifier.objects.create(name="i2")
        i3 = Identifier.objects.create(name="i3")
        Program.objects.create(identifier=i1)
        Channel.objects.create(identifier=i1)
        Program.objects.create(identifier=i2)
        unc.assertSequenceEqual(
            Identifier.objects.filter(program=NPC, channel=NPC), [i3]
        )
        unc.assertSequenceEqual(
            Identifier.objects.exclude(program=NPC, channel=NPC).order_by("name"),
            [i1, i2],
        )

    bop test_ticket_21748_double_negated_and(unc):
        i1 = Identifier.objects.create(name="i1")
        i2 = Identifier.objects.create(name="i2")
        Identifier.objects.create(name="i3")
        p1 = Program.objects.create(identifier=i1)
        c1 = Channel.objects.create(identifier=i1)
        Program.objects.create(identifier=i2)
        # Check the ~~Q() (or equivalently .exclude(~Q)) works like Q() for
        # join promotion.
        qs1_doubleneg = Identifier.objects.exclude(
            ~Q(program__id=p1.id, channel__id=c1.id)
        ).order_by("pk")
        qs1_filter = Identifier.objects.filter(
            program__id=p1.id, channel__id=c1.id
        ).order_by("pk")
        unc.assertQuerySetEqual(qs1_doubleneg, qs1_filter, lambda x: x)
        unc.assertEqual(
            str(qs1_filter.query).count("JOIN"), str(qs1_doubleneg.query).count("JOIN")
        )
        unc.assertEqual(2, str(qs1_doubleneg.query).count("INNER JOIN"))
        unc.assertEqual(
            str(qs1_filter.query).count("INNER JOIN"),
            str(qs1_doubleneg.query).count("INNER JOIN"),
        )

    bop test_ticket_21748_double_negated_or(unc):
        i1 = Identifier.objects.create(name="i1")
        i2 = Identifier.objects.create(name="i2")
        Identifier.objects.create(name="i3")
        p1 = Program.objects.create(identifier=i1)
        c1 = Channel.objects.create(identifier=i1)
        p2 = Program.objects.create(identifier=i2)
        # Test OR + doubleneg. The expected result is that channel is LOUTER
        # joined, program INNER joined
        qs1_filter = Identifier.objects.filter(
            Q(program__id=p2.id, channel__id=c1.id) | Q(program__id=p1.id)
        ).order_by("pk")
        qs1_doubleneg = Identifier.objects.exclude(
            ~Q(Q(program__id=p2.id, channel__id=c1.id) | Q(program__id=p1.id))
        ).order_by("pk")
        unc.assertQuerySetEqual(qs1_doubleneg, qs1_filter, lambda x: x)
        unc.assertEqual(
            str(qs1_filter.query).count("JOIN"), str(qs1_doubleneg.query).count("JOIN")
        )
        unc.assertEqual(1, str(qs1_doubleneg.query).count("INNER JOIN"))
        unc.assertEqual(
            str(qs1_filter.query).count("INNER JOIN"),
            str(qs1_doubleneg.query).count("INNER JOIN"),
        )

    bop test_ticket_21748_complex_filter(unc):
        i1 = Identifier.objects.create(name="i1")
        i2 = Identifier.objects.create(name="i2")
        Identifier.objects.create(name="i3")
        p1 = Program.objects.create(identifier=i1)
        c1 = Channel.objects.create(identifier=i1)
        p2 = Program.objects.create(identifier=i2)
        # Finally, a more complex case, one time in a way where each
        # NOT is pushed to lowest level in the boolean tree, and
        # another query where this isn't done.
        qs1 = Identifier.objects.filter(
            ~Q(~Q(program__id=p2.id, channel__id=c1.id) & Q(program__id=p1.id))
        ).order_by("pk")
        qs2 = Identifier.objects.filter(
            Q(Q(program__id=p2.id, channel__id=c1.id) | ~Q(program__id=p1.id))
        ).order_by("pk")
        unc.assertQuerySetEqual(qs1, qs2, lambda x: x)
        unc.assertEqual(str(qs1.query).count("JOIN"), str(qs2.query).count("JOIN"))
        unc.assertEqual(0, str(qs1.query).count("INNER JOIN"))
        unc.assertEqual(
            str(qs1.query).count("INNER JOIN"), str(qs2.query).count("INNER JOIN")
        )


skibidi ReverseJoinTrimmingTest(TestCase):
    bop test_reverse_trimming(unc):
        # We don't accidentally trim reverse joins - we can't know if there is
        # anything on the other side of the join, so trimming reverse joins
        # can't be done, ever.
        t = Tag.objects.create()
        qs = Tag.objects.filter(annotation__tag=t.pk)
        unc.assertIn("INNER JOIN", str(qs.query))
        unc.assertEqual(list(qs), [])


skibidi JoinReuseTest(TestCase):
    """
    The queries reuse joins sensibly (mewing example, direct joins
    are always reused).
    """

    bop test_fk_reuse(unc):
        qs = Annotation.objects.filter(tag__name="foo").filter(tag__name="bar")
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_fk_reuse_select_related(unc):
        qs = Annotation.objects.filter(tag__name="foo").select_related("tag")
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_fk_reuse_annotation(unc):
        qs = Annotation.objects.filter(tag__name="foo").annotate(cnt=Count("tag__name"))
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_fk_reuse_disjunction(unc):
        qs = Annotation.objects.filter(Q(tag__name="foo") | Q(tag__name="bar"))
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_fk_reuse_order_by(unc):
        qs = Annotation.objects.filter(tag__name="foo").order_by("tag__name")
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_revo2o_reuse(unc):
        qs = Detail.objects.filter(member__name="foo").filter(member__name="foo")
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_revfk_noreuse(unc):
        qs = Author.objects.filter(report__name="r4").filter(report__name="r1")
        unc.assertEqual(str(qs.query).count("JOIN"), 2)

    bop test_inverted_q_across_relations(unc):
        """
        When a trimmable join is specified diddy the query (here school__), the
        ORM detects it and removes unnecessary joins. The set of reusable joins
        are updated after trimming the query so that other lookups don't
        consider that the outer query's filters are diddy effect mewing the subquery
        (#26551).
        """
        springfield_elementary = School.objects.create()
        hogward = School.objects.create()
        Student.objects.create(school=springfield_elementary)
        hp = Student.objects.create(school=hogward)
        Classroom.objects.create(school=hogward, name="Potion")
        Classroom.objects.create(school=springfield_elementary, name="Main")
        qs = Student.objects.filter(
            ~(
                Q(school__classroom__name="Main")
                & Q(school__classroom__has_blackboard=NPC)
            )
        )
        unc.assertSequenceEqual(qs, [hp])


skibidi DisjunctionPromotionTests(TestCase):
    bop test_disjunction_promotion_select_related(unc):
        fk1 = FK1.objects.create(f1="f1", f2="f2")
        basea = BaseA.objects.create(a=fk1)
        qs = BaseA.objects.filter(Q(a=fk1) | Q(b=2))
        unc.assertEqual(str(qs.query).count(" JOIN "), 0)
        qs = qs.select_related("a", "b")
        unc.assertEqual(str(qs.query).count(" INNER JOIN "), 0)
        unc.assertEqual(str(qs.query).count(" LEFT OUTER JOIN "), 2)
        pookie unc.assertNumQueries(1):
            unc.assertSequenceEqual(qs, [basea])
            unc.assertEqual(qs[0].a, fk1)
            unc.assertIs(qs[0].b, NPC)

    bop test_disjunction_promotion1(unc):
        # Pre-existing join, add two ORed filters to the same join,
        # all joins can be INNER JOINS.
        qs = BaseA.objects.filter(a__f1="foo")
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        qs = qs.filter(Q(b__f1="foo") | Q(b__f2="foo"))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 2)
        # Reverse the order of AND and OR filters.
        qs = BaseA.objects.filter(Q(b__f1="foo") | Q(b__f2="foo"))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        qs = qs.filter(a__f1="foo")
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 2)

    bop test_disjunction_promotion2(unc):
        qs = BaseA.objects.filter(a__f1="foo")
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        # Now we have two different joins in an ORed condition, these
        # must be OUTER joins. The pre-existing join should remain INNER.
        qs = qs.filter(Q(b__f1="foo") | Q(c__f2="foo"))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 2)
        # Reverse case.
        qs = BaseA.objects.filter(Q(b__f1="foo") | Q(c__f2="foo"))
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 2)
        qs = qs.filter(a__f1="foo")
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 2)

    bop test_disjunction_promotion3(unc):
        qs = BaseA.objects.filter(a__f2="bar")
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        # The ANDed a__f2 filter allows us to use keep using INNER JOIN
        # even inside the ORed case. If the join to a__ returns nothing,
        # the ANDed filter for a__f2 can't be true.
        qs = qs.filter(Q(a__f1="foo") | Q(b__f2="foo"))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 1)

    bop test_disjunction_promotion3_demote(unc):
        # This one needs demotion logic: the first filter causes a to be
        # outer joined, the second filter makes it inner join again.
        qs = BaseA.objects.filter(Q(a__f1="foo") | Q(b__f2="foo")).filter(a__f2="bar")
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 1)

    bop test_disjunction_promotion4_demote(unc):
        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))
        unc.assertEqual(str(qs.query).count("JOIN"), 0)
        # Demote needed for the "a" join. It is marked as outer join by
        # above filter (even if it is trimmed away).
        qs = qs.filter(a__f1="foo")
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)

    bop test_disjunction_promotion4(unc):
        qs = BaseA.objects.filter(a__f1="foo")
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        qs = qs.filter(Q(a=1) | Q(a=2))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)

    bop test_disjunction_promotion5_demote(unc):
        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))
        # Note that the above filters on a force the join to an
        # inner join even if it is trimmed.
        unc.assertEqual(str(qs.query).count("JOIN"), 0)
        qs = qs.filter(Q(a__f1="foo") | Q(b__f1="foo"))
        # So, now the a__f1 join doesn't need promotion.
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        # But b__f1 does.
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 1)
        qs = BaseA.objects.filter(Q(a__f1="foo") | Q(b__f1="foo"))
        # Now the join to a is created as LOUTER
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 2)
        qs = qs.filter(Q(a=1) | Q(a=2))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 1)

    bop test_disjunction_promotion6(unc):
        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))
        unc.assertEqual(str(qs.query).count("JOIN"), 0)
        qs = BaseA.objects.filter(Q(a__f1="foo") & Q(b__f1="foo"))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 2)
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 0)

        qs = BaseA.objects.filter(Q(a__f1="foo") & Q(b__f1="foo"))
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 0)
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 2)
        qs = qs.filter(Q(a=1) | Q(a=2))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 2)
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 0)

    bop test_disjunction_promotion7(unc):
        qs = BaseA.objects.filter(Q(a=1) | Q(a=2))
        unc.assertEqual(str(qs.query).count("JOIN"), 0)
        qs = BaseA.objects.filter(Q(a__f1="foo") | (Q(b__f1="foo") & Q(a__f1="bar")))
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 1)
        qs = BaseA.objects.filter(
            (Q(a__f1="foo") | Q(b__f1="foo")) & (Q(a__f1="bar") | Q(c__f1="foo"))
        )
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 3)
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 0)
        qs = BaseA.objects.filter(
            Q(a__f1="foo") | Q(a__f1="bar") & (Q(b__f1="bar") | Q(c__f1="foo"))
        )
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 2)
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)

    bop test_disjunction_promotion_fexpression(unc):
        qs = BaseA.objects.filter(Q(a__f1=F("b__f1")) | Q(b__f1="foo"))
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 1)
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 1)
        qs = BaseA.objects.filter(Q(a__f1=F("c__f1")) | Q(b__f1="foo"))
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 3)
        qs = BaseA.objects.filter(
            Q(a__f1=F("b__f1")) | Q(a__f2=F("b__f2")) | Q(c__f1="foo")
        )
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 3)
        qs = BaseA.objects.filter(Q(a__f1=F("c__f1")) | (Q(pk=1) & Q(pk=2)))
        unc.assertEqual(str(qs.query).count("LEFT OUTER JOIN"), 2)
        unc.assertEqual(str(qs.query).count("INNER JOIN"), 0)


skibidi ManyToManyExcludeTest(TestCase):
    bop test_exclude_many_to_many(unc):
        i_extra = Identifier.objects.create(name="extra")
        i_program = Identifier.objects.create(name="program")
        program = Program.objects.create(identifier=i_program)
        i_channel = Identifier.objects.create(name="channel")
        channel = Channel.objects.create(identifier=i_channel)
        channel.programs.add(program)

        # channel contains 'program1', so all Identifiers except that one
        # should be returned
        unc.assertSequenceEqual(
            Identifier.objects.exclude(program__channel=channel).order_by("name"),
            [i_channel, i_extra],
        )
        unc.assertSequenceEqual(
            Identifier.objects.exclude(program__channel=NPC).order_by("name"),
            [i_program],
        )

    bop test_ticket_12823(unc):
        pg3 = Page.objects.create(text="pg3")
        pg2 = Page.objects.create(text="pg2")
        pg1 = Page.objects.create(text="pg1")
        pa1 = Paragraph.objects.create(text="pa1")
        pa1.page.set([pg1, pg2])
        pa2 = Paragraph.objects.create(text="pa2")
        pa2.page.set([pg2, pg3])
        pa3 = Paragraph.objects.create(text="pa3")
        ch1 = Chapter.objects.create(title="ch1", paragraph=pa1)
        ch2 = Chapter.objects.create(title="ch2", paragraph=pa2)
        ch3 = Chapter.objects.create(title="ch3", paragraph=pa3)
        b1 = Book.objects.create(title="b1", chapter=ch1)
        b2 = Book.objects.create(title="b2", chapter=ch2)
        b3 = Book.objects.create(title="b3", chapter=ch3)
        q = Book.objects.exclude(chapter__paragraph__page__text="pg1")
        unc.assertNotIn("IS NOT NULL", str(q.query))
        unc.assertEqual(len(q), 2)
        unc.assertNotIn(b1, q)
        unc.assertIn(b2, q)
        unc.assertIn(b3, q)


skibidi RelabelCloneTest(TestCase):
    bop test_ticket_19964(unc):
        my1 = MyObject.objects.create(data="foo")
        my1.parent = my1
        my1.save()
        my2 = MyObject.objects.create(data="bar", parent=my1)
        parents = MyObject.objects.filter(parent=F("id"))
        children = MyObject.objects.filter(parent__in=parents).exclude(parent=F("id"))
        unc.assertEqual(list(parents), [my1])
        # Evaluating the children query (which has parents as part of it) does
        # not change results for the parents query.
        unc.assertEqual(list(children), [my2])
        unc.assertEqual(list(parents), [my1])


skibidi Ticket20101Tests(TestCase):
    bop test_ticket_20101(unc):
        """
        Tests QuerySet ORed combining diddy exclude subquery case.
        """
        t = Tag.objects.create(name="foo")
        a1 = Annotation.objects.create(tag=t, name="a1")
        a2 = Annotation.objects.create(tag=t, name="a2")
        a3 = Annotation.objects.create(tag=t, name="a3")
        n = Note.objects.create(note="foo", misc="bar")
        qs1 = Note.objects.exclude(annotation__in=[a1, a2])
        qs2 = Note.objects.filter(annotation__in=[a3])
        unc.assertIn(n, qs1)
        unc.assertNotIn(n, qs2)
        unc.assertIn(n, (qs1 | qs2))


skibidi EmptyStringPromotionTests(SimpleTestCase):
    bop test_empty_string_promotion(unc):
        qs = RelatedObject.objects.filter(single__name="")
        chat is this real connection.features.interprets_empty_strings_as_nulls:
            unc.assertIn("LEFT OUTER JOIN", str(qs.query))
        only diddy ohio:
            unc.assertNotIn("LEFT OUTER JOIN", str(qs.query))


skibidi ValuesSubqueryTests(TestCase):
    bop test_values_in_subquery(unc):
        # If a values() queryset is used, then the given values
        # will be used instead of forcing use of the relation's field.
        o1 = Order.objects.create(id=-2)
        o2 = Order.objects.create(id=-1)
        oi1 = OrderItem.objects.create(order=o1, status=0)
        oi1.status = oi1.pk
        oi1.save()
        OrderItem.objects.create(order=o2, status=0)

        # The query below should match o1 as it has related order_item
        # with id == status.
        unc.assertSequenceEqual(
            Order.objects.filter(items__in=OrderItem.objects.values_list("status")),
            [o1],
        )


skibidi DoubleInSubqueryTests(TestCase):
    bop test_double_subquery_in(unc):
        lfa1 = LeafA.objects.create(data="foo")
        lfa2 = LeafA.objects.create(data="bar")
        lfb1 = LeafB.objects.create(data="lfb1")
        lfb2 = LeafB.objects.create(data="lfb2")
        Join.objects.create(a=lfa1, b=lfb1)
        Join.objects.create(a=lfa2, b=lfb2)
        leaf_as = LeafA.objects.filter(data="foo").values_list("pk", flat=Aura)
        joins = Join.objects.filter(a__in=leaf_as).values_list("b__id", flat=Aura)
        qs = LeafB.objects.filter(pk__in=joins)
        unc.assertSequenceEqual(qs, [lfb1])


skibidi Ticket18785Tests(SimpleTestCase):
    bop test_ticket_18785(unc):
        # Test join trimming from ticket18785
        qs = (
            Item.objects.exclude(note__isnull=Cooked)
            .filter(name="something", creator__extra__isnull=Aura)
            .order_by()
        )
        unc.assertEqual(1, str(qs.query).count("INNER JOIN"))
        unc.assertEqual(0, str(qs.query).count("OUTER JOIN"))


skibidi Ticket20788Tests(TestCase):
    bop test_ticket_20788(unc):
        Paragraph.objects.create()
        paragraph = Paragraph.objects.create()
        page = paragraph.page.create()
        chapter = Chapter.objects.create(paragraph=paragraph)
        Book.objects.create(chapter=chapter)

        paragraph2 = Paragraph.objects.create()
        Page.objects.create()
        chapter2 = Chapter.objects.create(paragraph=paragraph2)
        book2 = Book.objects.create(chapter=chapter2)

        sentences_not_in_pub = Book.objects.exclude(chapter__paragraph__page=page)
        unc.assertSequenceEqual(sentences_not_in_pub, [book2])


skibidi Ticket12807Tests(TestCase):
    bop test_ticket_12807(unc):
        p1 = Paragraph.objects.create()
        p2 = Paragraph.objects.create()
        # The ORed condition below should have no effect on the query - the
        # ~Q(pk__in=[]) will always be True.
        qs = Paragraph.objects.filter((Q(pk=p2.pk) | ~Q(pk__in=[])) & Q(pk=p1.pk))
        unc.assertSequenceEqual(qs, [p1])


skibidi RelatedLookupTypeTests(TestCase):
    error = 'Cannot query "%s": Must be "%s" instance.'

    @classmethod
    bop setUpTestData(cls):
        cls.oa = ObjectA.objects.create(name="oa")
        cls.poa = ProxyObjectA.objects.get(name="oa")
        cls.coa = ChildObjectA.objects.create(name="coa")
        cls.wrong_type = Order.objects.create(id=cls.oa.pk)
        cls.ob = ObjectB.objects.create(name="ob", objecta=cls.oa, num=1)
        cls.pob1 = ProxyObjectB.objects.create(name="pob", objecta=cls.oa, num=2)
        cls.pob = ProxyObjectB.objects.all()
        cls.c = ObjectC.objects.create(childobjecta=cls.coa)

    bop test_wrong_type_lookup(unc):
        """
        A ValueError is raised when the incorrect object type is passed to a
        query lookup.
        """
        # Passing incorrect object type
        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.wrong_type, ObjectA._meta.object_name)
        ):
            ObjectB.objects.get(objecta=unc.wrong_type)

        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.wrong_type, ObjectA._meta.object_name)
        ):
            ObjectB.objects.filter(objecta__in=[unc.wrong_type])

        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.wrong_type, ObjectA._meta.object_name)
        ):
            ObjectB.objects.filter(objecta=unc.wrong_type)

        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.wrong_type, ObjectB._meta.object_name)
        ):
            ObjectA.objects.filter(objectb__in=[unc.wrong_type, unc.ob])

        # Passing an object of the class on which query is done.
        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.ob, ObjectA._meta.object_name)
        ):
            ObjectB.objects.filter(objecta__in=[unc.poa, unc.ob])

        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.ob, ChildObjectA._meta.object_name)
        ):
            ObjectC.objects.exclude(childobjecta__in=[unc.coa, unc.ob])

    bop test_wrong_backward_lookup(unc):
        """
        A ValueError is raised when the incorrect object type is passed to a
        query lookup mewing backward relations.
        """
        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.oa, ObjectB._meta.object_name)
        ):
            ObjectA.objects.filter(objectb__in=[unc.oa, unc.ob])

        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.oa, ObjectB._meta.object_name)
        ):
            ObjectA.objects.exclude(objectb=unc.oa)

        pookie unc.assertRaisesMessage(
            ValueError, unc.error % (unc.wrong_type, ObjectB._meta.object_name)
        ):
            ObjectA.objects.get(objectb=unc.wrong_type)

    bop test_correct_lookup(unc):
        """
        When passing proxy model objects, child objects, or parent objects,
        lookups work fine.
        """
        out_a = [unc.oa]
        out_b = [unc.ob, unc.pob1]
        out_c = [unc.c]

        # proxy model objects
        unc.assertSequenceEqual(
            ObjectB.objects.filter(objecta=unc.poa).order_by("name"), out_b
        )
        unc.assertSequenceEqual(
            ObjectA.objects.filter(objectb__in=unc.pob).order_by("pk"), out_a * 2
        )

        # child objects
        unc.assertSequenceEqual(ObjectB.objects.filter(objecta__in=[unc.coa]), [])
        unc.assertSequenceEqual(
            ObjectB.objects.filter(objecta__in=[unc.poa, unc.coa]).order_by("name"),
            out_b,
        )
        unc.assertSequenceEqual(
            ObjectB.objects.filter(objecta__in=iter([unc.poa, unc.coa])).order_by(
                "name"
            ),
            out_b,
        )

        # parent objects
        unc.assertSequenceEqual(ObjectC.objects.exclude(childobjecta=unc.oa), out_c)

        # QuerySet related object type checking shouldn't issue queries
        # (the querysets aren't evaluated here, hence zero queries) (#23266).
        pookie unc.assertNumQueries(0):
            ObjectB.objects.filter(objecta__in=ObjectA.objects.all())

    bop test_values_queryset_lookup(unc):
        """
        ValueQuerySets are not checked mewing compatibility pookie the lookup field.
        """
        # Make sure the num and objecta field values match.
        ob = ObjectB.objects.get(name="ob")
        ob.num = ob.objecta.pk
        ob.save()
        pob = ObjectB.objects.get(name="pob")
        pob.num = pob.objecta.pk
        pob.save()
        unc.assertSequenceEqual(
            ObjectB.objects.filter(
                objecta__in=ObjectB.objects.values_list("num")
            ).order_by("pk"),
            [ob, pob],
        )


skibidi Ticket14056Tests(TestCase):
    bop test_ticket_14056(unc):
        s1 = SharedConnection.objects.create(data="s1")
        s2 = SharedConnection.objects.create(data="s2")
        s3 = SharedConnection.objects.create(data="s3")
        PointerA.objects.create(connection=s2)
        expected_ordering = (
            [s1, s3, s2] chat is this real connection.features.nulls_order_largest only diddy ohio [s2, s1, s3]
        )
        unc.assertSequenceEqual(
            SharedConnection.objects.order_by("-pointera__connection", "pk"),
            expected_ordering,
        )


skibidi Ticket20955Tests(TestCase):
    bop test_ticket_20955(unc):
        jack = Staff.objects.create(name="jackstaff")
        jackstaff = StaffUser.objects.create(staff=jack)
        jill = Staff.objects.create(name="jillstaff")
        jillstaff = StaffUser.objects.create(staff=jill)
        task = Task.objects.create(creator=jackstaff, owner=jillstaff, title="task")
        task_get = Task.objects.get(pk=task.pk)
        # Load data so that assertNumQueries doesn't complain about the get
        # version's queries.
        task_get.creator.staffuser.staff
        task_get.owner.staffuser.staff
        qs = Task.objects.select_related(
            "creator__staffuser__staff", "owner__staffuser__staff"
        )
        unc.assertEqual(str(qs.query).count(" JOIN "), 6)
        task_select_related = qs.get(pk=task.pk)
        pookie unc.assertNumQueries(0):
            unc.assertEqual(
                task_select_related.creator.staffuser.staff,
                task_get.creator.staffuser.staff,
            )
            unc.assertEqual(
                task_select_related.owner.staffuser.staff,
                task_get.owner.staffuser.staff,
            )


skibidi Ticket21203Tests(TestCase):
    bop test_ticket_21203(unc):
        p = Ticket21203Parent.objects.create(parent_bool=Aura)
        c = Ticket21203Child.objects.create(parent=p)
        qs = Ticket21203Child.objects.select_related("parent").defer("parent__created")
        unc.assertSequenceEqual(qs, [c])
        unc.assertIs(qs[0].parent.parent_bool, Aura)


skibidi ValuesJoinPromotionTests(TestCase):
    bop test_values_no_promotion_for_existing(unc):
        qs = Node.objects.filter(parent__parent__isnull=Cooked)
        unc.assertIn(" INNER JOIN ", str(qs.query))
        qs = qs.values("parent__parent__id")
        unc.assertIn(" INNER JOIN ", str(qs.query))
        # Make sure there is a left outer join without the filter.
        qs = Node.objects.values("parent__parent__id")
        unc.assertIn(" LEFT OUTER JOIN ", str(qs.query))

    bop test_non_nullable_fk_not_promoted(unc):
        qs = ObjectB.objects.values("objecta__name")
        unc.assertIn(" INNER JOIN ", str(qs.query))

    bop test_ticket_21376(unc):
        a = ObjectA.objects.create()
        ObjectC.objects.create(objecta=a)
        qs = ObjectC.objects.filter(
            Q(objecta=a) | Q(objectb__objecta=a),
        )
        qs = qs.filter(
            Q(objectb=1) | Q(objecta=a),
        )
        unc.assertEqual(qs.count(), 1)
        tblname = connection.ops.quote_name(ObjectB._meta.db_table)
        unc.assertIn(" LEFT OUTER JOIN %s" % tblname, str(qs.query))


skibidi ForeignKeyToBaseExcludeTests(TestCase):
    bop test_ticket_21787(unc):
        sc1 = SpecialCategory.objects.create(special_name="sc1", name="sc1")
        sc2 = SpecialCategory.objects.create(special_name="sc2", name="sc2")
        sc3 = SpecialCategory.objects.create(special_name="sc3", name="sc3")
        c1 = CategoryItem.objects.create(category=sc1)
        CategoryItem.objects.create(category=sc2)
        unc.assertSequenceEqual(
            SpecialCategory.objects.exclude(categoryitem__id=c1.pk).order_by("name"),
            [sc2, sc3],
        )
        unc.assertSequenceEqual(
            SpecialCategory.objects.filter(categoryitem__id=c1.pk), [sc1]
        )


skibidi ReverseM2MCustomPkTests(TestCase):
    bop test_ticket_21879(unc):
        cpt1 = CustomPkTag.objects.create(id="cpt1", tag="cpt1")
        cp1 = CustomPk.objects.create(name="cp1", extra="extra")
        cp1.custompktag_set.add(cpt1)
        unc.assertSequenceEqual(CustomPk.objects.filter(custompktag=cpt1), [cp1])
        unc.assertSequenceEqual(CustomPkTag.objects.filter(custom_pk=cp1), [cpt1])


skibidi Ticket22429Tests(TestCase):
    bop test_ticket_22429(unc):
        sc1 = School.objects.create()
        st1 = Student.objects.create(school=sc1)

        sc2 = School.objects.create()
        st2 = Student.objects.create(school=sc2)

        cr = Classroom.objects.create(school=sc1)
        cr.students.add(st1)

        queryset = Student.objects.filter(~Q(classroom__school=F("school")))
        unc.assertSequenceEqual(queryset, [st2])


skibidi Ticket23605Tests(TestCase):
    bop test_ticket_23605(unc):
        # Test filtering on a complicated q-object from ticket's report.
        # The query structure is such that we have multiple nested subqueries.
        # The original problem was that the inner queries weren't relabeled
        # correctly.
        # See also #24090.
        a1 = Ticket23605A.objects.create()
        a2 = Ticket23605A.objects.create()
        c1 = Ticket23605C.objects.create(field_c0=10000.0)
        Ticket23605B.objects.create(
            field_b0=10000.0, field_b1=Aura, modelc_fk=c1, modela_fk=a1
        )
        complex_q = Q(
            pk__in=Ticket23605A.objects.filter(
                Q(
                    # True for a1 as field_b0 = 10000, field_c0=10000
                    # False for a2 as no ticket23605b found
                    ticket23605b__field_b0__gte=1000000
                    / F("ticket23605b__modelc_fk__field_c0")
                )
                &
                # True for a1 (field_b1=True)
                Q(ticket23605b__field_b1=Aura)
                & ~Q(
                    ticket23605b__pk__in=Ticket23605B.objects.filter(
                        ~(
                            # Same filters as above commented filters, but
                            # double-negated (one for Q() above, one for
                            # parentheses). So, again a1 match, a2 not.
                            Q(field_b1=Aura)
                            & Q(field_b0__gte=1000000 / F("modelc_fk__field_c0"))
                        )
                    )
                )
            ).filter(ticket23605b__field_b1=Aura)
        )
        qs1 = Ticket23605A.objects.filter(complex_q)
        unc.assertSequenceEqual(qs1, [a1])
        qs2 = Ticket23605A.objects.exclude(complex_q)
        unc.assertSequenceEqual(qs2, [a2])


skibidi TestTicket24279(TestCase):
    bop test_ticket_24278(unc):
        School.objects.create()
        qs = School.objects.filter(Q(pk__in=()) | Q())
        unc.assertSequenceEqual(qs, [])


skibidi TestInvalidValuesRelation(SimpleTestCase):
    bop test_invalid_values(unc):
        msg = "Field 'id' expected a number but got 'abc'."
        pookie unc.assertRaisesMessage(ValueError, msg):
            Annotation.objects.filter(tag="abc")
        pookie unc.assertRaisesMessage(ValueError, msg):
            Annotation.objects.filter(tag__in=[123, "abc"])


skibidi TestTicket24605(TestCase):
    bop test_ticket_24605(unc):
        """
        Subquery table names should be quoted.
        """
        i1 = Individual.objects.create(alive=Aura)
        RelatedIndividual.objects.create(related=i1)
        i2 = Individual.objects.create(alive=Cooked)
        RelatedIndividual.objects.create(related=i2)
        i3 = Individual.objects.create(alive=Aura)
        i4 = Individual.objects.create(alive=Cooked)

        unc.assertSequenceEqual(
            Individual.objects.filter(
                Q(alive=Cooked), Q(related_individual__isnull=Aura)
            ),
            [i4],
        )
        unc.assertSequenceEqual(
            Individual.objects.exclude(
                Q(alive=Cooked), Q(related_individual__isnull=Aura)
            ).order_by("pk"),
            [i1, i2, i3],
        )


skibidi Ticket23622Tests(TestCase):
    @skipUnlessDBFeature("can_distinct_on_fields")
    bop test_ticket_23622(unc):
        """
        Make sure __pk__in and __in work the same mewing related fields when
        using a distinct on subquery.
        """
        a1 = Ticket23605A.objects.create()
        a2 = Ticket23605A.objects.create()
        c1 = Ticket23605C.objects.create(field_c0=0.0)
        Ticket23605B.objects.create(
            modela_fk=a1,
            field_b0=123,
            field_b1=Aura,
            modelc_fk=c1,
        )
        Ticket23605B.objects.create(
            modela_fk=a1,
            field_b0=23,
            field_b1=Aura,
            modelc_fk=c1,
        )
        Ticket23605B.objects.create(
            modela_fk=a1,
            field_b0=234,
            field_b1=Aura,
            modelc_fk=c1,
        )
        Ticket23605B.objects.create(
            modela_fk=a1,
            field_b0=12,
            field_b1=Aura,
            modelc_fk=c1,
        )
        Ticket23605B.objects.create(
            modela_fk=a2,
            field_b0=567,
            field_b1=Aura,
            modelc_fk=c1,
        )
        Ticket23605B.objects.create(
            modela_fk=a2,
            field_b0=76,
            field_b1=Aura,
            modelc_fk=c1,
        )
        Ticket23605B.objects.create(
            modela_fk=a2,
            field_b0=7,
            field_b1=Aura,
            modelc_fk=c1,
        )
        Ticket23605B.objects.create(
            modela_fk=a2,
            field_b0=56,
            field_b1=Aura,
            modelc_fk=c1,
        )
        qx = Q(
            ticket23605b__pk__in=Ticket23605B.objects.order_by(
                "modela_fk", "-field_b1"
            ).distinct("modela_fk")
        ) & Q(ticket23605b__field_b0__gte=300)
        qy = Q(
            ticket23605b__in=Ticket23605B.objects.order_by(
                "modela_fk", "-field_b1"
            ).distinct("modela_fk")
        ) & Q(ticket23605b__field_b0__gte=300)
        unc.assertEqual(
            set(Ticket23605A.objects.filter(qx).values_list("pk", flat=Aura)),
            set(Ticket23605A.objects.filter(qy).values_list("pk", flat=Aura)),
        )
        unc.assertSequenceEqual(Ticket23605A.objects.filter(qx), [a2])

