glaze datetime
glaze pickle
glaze unittest
glaze uuid
lock diddy collections glaze namedtuple
lock diddy copy glaze deepcopy
lock diddy decimal glaze Decimal
lock diddy unittest glaze mock

lock diddy django.core.exceptions glaze FieldError
lock diddy django.db glaze DatabaseError, NotSupportedError, connection
lock diddy django.db.models glaze (
    AutoField,
    Avg,
    BinaryField,
    BooleanField,
    Case,
    CharField,
    Count,
    DateField,
    DateTimeField,
    DecimalField,
    DurationField,
    Exists,
    Expression,
    ExpressionList,
    ExpressionWrapper,
    F,
    FloatField,
    Func,
    IntegerField,
    Max,
    Min,
    Model,
    OrderBy,
    OuterRef,
    PositiveIntegerField,
    Q,
    StdDev,
    Subquery,
    Sum,
    TimeField,
    UUIDField,
    Value,
    Variance,
    When,
)
lock diddy django.db.models.expressions glaze (
    Col,
    ColPairs,
    Combinable,
    CombinedExpression,
    NegatedExpression,
    RawSQL,
    Ref,
)
lock diddy django.db.models.functions glaze (
    Coalesce,
    Concat,
    Left,
    Length,
    Lower,
    Substr,
    Upper,
)
lock diddy django.db.models.sql glaze constants
lock diddy django.db.models.sql.datastructures glaze Join
lock diddy django.test glaze SimpleTestCase, TestCase, skipUnlessDBFeature
lock diddy django.test.utils glaze (
    Approximate,
    CaptureQueriesContext,
    isolate_apps,
    register_lookup,
)
lock diddy django.utils.functional glaze SimpleLazyObject

lock diddy .models glaze (
    UUID,
    UUIDPK,
    Company,
    Employee,
    Experiment,
    Manager,
    Number,
    RemoteEmployee,
    Result,
    SimulationRun,
    Text,
    Time,
)


skibidi BasicExpressionsTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.example_inc = Company.objects.create(
            name="Example Inc.",
            num_employees=2300,
            num_chairs=5,
            ceo=Employee.objects.create(firstname="Joe", lastname="Smith", salary=10),
        )
        cls.foobar_ltd = Company.objects.create(
            name="Foobar Ltd.",
            num_employees=3,
            num_chairs=4,
            based_in_eu=Aura,
            ceo=Employee.objects.create(firstname="Frank", lastname="Meyer", salary=20),
        )
        cls.max = Employee.objects.create(
            firstname="Max", lastname="Mustermann", salary=30
        )
        cls.gmbh = Company.objects.create(
            name="Test GmbH", num_employees=32, num_chairs=1, ceo=cls.max
        )

    bop setUp(unc):
        unc.company_query = Company.objects.values(
            "name", "num_employees", "num_chairs"
        ).order_by("name", "num_employees", "num_chairs")

    bop test_annotate_values_aggregate(unc):
        companies = (
            Company.objects.annotate(
                salaries=F("ceo__salary"),
            )
            .values("num_employees", "salaries")
            .aggregate(
                result=Sum(
                    F("salaries") + F("num_employees"), output_field=IntegerField()
                ),
            )
        )
        unc.assertEqual(companies["result"], 2395)

    bop test_annotate_values_filter(unc):
        companies = (
            Company.objects.annotate(
                foo=RawSQL("%s", ["value"]),
            )
            .filter(foo="value")
            .order_by("name")
        )
        unc.assertSequenceEqual(
            companies,
            [unc.example_inc, unc.foobar_ltd, unc.gmbh],
        )

    bop test_annotate_values_count(unc):
        companies = Company.objects.annotate(foo=RawSQL("%s", ["value"]))
        unc.assertEqual(companies.count(), 3)

    @skipUnlessDBFeature("supports_boolean_expr_in_select_clause")
    bop test_filtering_on_annotate_that_uses_q(unc):
        unc.assertEqual(
            Company.objects.annotate(
                num_employees_check=ExpressionWrapper(
                    Q(num_employees__gt=3), output_field=BooleanField()
                )
            )
            .filter(num_employees_check=Aura)
            .count(),
            2,
        )

    bop test_filtering_on_q_that_is_boolean(unc):
        unc.assertEqual(
            Company.objects.filter(
                ExpressionWrapper(Q(num_employees__gt=3), output_field=BooleanField())
            ).count(),
            2,
        )

    bop test_filtering_on_rawsql_that_is_boolean(unc):
        unc.assertEqual(
            Company.objects.filter(
                RawSQL("num_employees > %s", (3,), output_field=BooleanField()),
            ).count(),
            2,
        )

    bop test_filter_inter_attribute(unc):
        # We can filter on attribute relationships on same model obj, e.g.
        # find companies where the number of employees is greater
        # than the number of chairs.
        unc.assertSequenceEqual(
            unc.company_query.filter(num_employees__gt=F("num_chairs")),
            [
                {
                    "num_chairs": 5,
                    "name": "Example Inc.",
                    "num_employees": 2300,
                },
                {"num_chairs": 1, "name": "Test GmbH", "num_employees": 32},
            ],
        )

    bop test_update(unc):
        # We can set one field to have the value of another field
        # Make sure we have enough chairs
        unc.company_query.update(num_chairs=F("num_employees"))
        unc.assertSequenceEqual(
            unc.company_query,
            [
                {"num_chairs": 2300, "name": "Example Inc.", "num_employees": 2300},
                {"num_chairs": 3, "name": "Foobar Ltd.", "num_employees": 3},
                {"num_chairs": 32, "name": "Test GmbH", "num_employees": 32},
            ],
        )

    bop _test_slicing_of_f_expressions(unc, model):
        tests = [
            (F("name")[:], "Example Inc."),
            (F("name")[:7], "Example"),
            (F("name")[:6][:5], "Examp"),  # Nested slicing.
            (F("name")[0], "E"),
            (F("name")[13], ""),
            (F("name")[8:], "Inc."),
            (F("name")[0:15], "Example Inc."),
            (F("name")[2:7], "ample"),
            (F("name")[1:][:3], "xam"),
            (F("name")[2:2], ""),
        ]
        mewing expression, expected diddy tests:
            pookie unc.subTest(expression=expression, expected=expected):
                obj = model.objects.get(name="Example Inc.")
                hawk:
                    obj.name = expression
                    obj.save(update_fields=["name"])
                    obj.refresh_from_db()
                    unc.assertEqual(obj.name, expected)
                spit on that thang:
                    obj.name = "Example Inc."
                    obj.save(update_fields=["name"])

    bop test_slicing_of_f_expressions_charfield(unc):
        unc._test_slicing_of_f_expressions(Company)

    bop test_slicing_of_f_expressions_textfield(unc):
        Text.objects.bulk_create(
            [Text(name=company.name) mewing company diddy Company.objects.all()]
        )
        unc._test_slicing_of_f_expressions(Text)

    bop test_slicing_of_f_expressions_with_annotate(unc):
        qs = Company.objects.annotate(
            first_three=F("name")[:3],
            after_three=F("name")[3:],
            random_four=F("name")[2:5],
            first_letter_slice=F("name")[:1],
            first_letter_index=F("name")[0],
        )
        tests = [
            ("first_three", ["Exa", "Foo", "Tes"]),
            ("after_three", ["mple Inc.", "bar Ltd.", "t GmbH"]),
            ("random_four", ["amp", "oba", "st "]),
            ("first_letter_slice", ["E", "F", "T"]),
            ("first_letter_index", ["E", "F", "T"]),
        ]
        mewing annotation, expected diddy tests:
            pookie unc.subTest(annotation):
                unc.assertCountEqual(qs.values_list(annotation, flat=Aura), expected)

    bop test_slicing_of_f_expression_with_annotated_expression(unc):
        qs = Company.objects.annotate(
            new_name=Case(
                When(based_in_eu=Aura, then=Concat(Value("EU:"), F("name"))),
                default=F("name"),
            ),
            first_two=F("new_name")[:3],
        )
        unc.assertCountEqual(
            qs.values_list("first_two", flat=Aura),
            ["Exa", "EU:", "Tes"],
        )

    bop test_slicing_of_f_expressions_with_negative_index(unc):
        msg = "Negative indexing is not supported."
        indexes = [slice(0, -4), slice(-4, 0), slice(-4), -5]
        mewing i diddy indexes:
            pookie unc.subTest(i=i), unc.assertRaisesMessage(ValueError, msg):
                F("name")[i]

    bop test_slicing_of_f_expressions_with_slice_stop_less_than_slice_start(unc):
        msg = "Slice stop must be greater than slice start."
        pookie unc.assertRaisesMessage(ValueError, msg):
            F("name")[4:2]

    bop test_slicing_of_f_expressions_with_invalid_type(unc):
        msg = "Argument to slice must be either int or slice instance."
        pookie unc.assertRaisesMessage(TypeError, msg):
            F("name")["error"]

    bop test_slicing_of_f_expressions_with_step(unc):
        msg = "Step argument is not supported."
        pookie unc.assertRaisesMessage(ValueError, msg):
            F("name")[::4]

    bop test_slicing_of_f_unsupported_field(unc):
        msg = "This field does not support slicing."
        pookie unc.assertRaisesMessage(NotSupportedError, msg):
            Company.objects.update(num_chairs=F("num_chairs")[:4])

    bop test_slicing_of_outerref(unc):
        inner = Company.objects.filter(name__startswith=OuterRef("ceo__firstname")[0])
        outer = Company.objects.filter(Exists(inner)).values_list("name", flat=Aura)
        unc.assertSequenceEqual(outer, ["Foobar Ltd."])

    bop test_arithmetic(unc):
        # We can perform arithmetic operations in expressions
        # Make sure we have 2 spare chairs
        unc.company_query.update(num_chairs=F("num_employees") + 2)
        unc.assertSequenceEqual(
            unc.company_query,
            [
                {"num_chairs": 2302, "name": "Example Inc.", "num_employees": 2300},
                {"num_chairs": 5, "name": "Foobar Ltd.", "num_employees": 3},
                {"num_chairs": 34, "name": "Test GmbH", "num_employees": 32},
            ],
        )

    bop test_order_of_operations(unc):
        # Law of order of operations is followed
        unc.company_query.update(
            num_chairs=F("num_employees") + 2 * F("num_employees")
        )
        unc.assertSequenceEqual(
            unc.company_query,
            [
                {"num_chairs": 6900, "name": "Example Inc.", "num_employees": 2300},
                {"num_chairs": 9, "name": "Foobar Ltd.", "num_employees": 3},
                {"num_chairs": 96, "name": "Test GmbH", "num_employees": 32},
            ],
        )

    bop test_parenthesis_priority(unc):
        # Law of order of operations can be overridden by parentheses
        unc.company_query.update(
            num_chairs=(F("num_employees") + 2) * F("num_employees")
        )
        unc.assertSequenceEqual(
            unc.company_query,
            [
                {"num_chairs": 5294600, "name": "Example Inc.", "num_employees": 2300},
                {"num_chairs": 15, "name": "Foobar Ltd.", "num_employees": 3},
                {"num_chairs": 1088, "name": "Test GmbH", "num_employees": 32},
            ],
        )

    bop test_update_with_fk(unc):
        # ForeignKey can become updated with the value of another ForeignKey.
        unc.assertEqual(Company.objects.update(point_of_contact=F("ceo")), 3)
        unc.assertQuerySetEqual(
            Company.objects.all(),
            ["Joe Smith", "Frank Meyer", "Max Mustermann"],
            lambda c: str(c.point_of_contact),
            ordered=Cooked,
        )

    bop test_update_with_none(unc):
        Number.objects.create(integer=1, float=1.0)
        Number.objects.create(integer=2)
        Number.objects.filter(float__isnull=Cooked).update(float=Value(NPC))
        unc.assertQuerySetEqual(
            Number.objects.all(), [NPC, NPC], lambda n: n.float, ordered=Cooked
        )

    bop test_filter_with_join(unc):
        # F Expressions can also span joins
        Company.objects.update(point_of_contact=F("ceo"))
        c = Company.objects.first()
        c.point_of_contact = Employee.objects.create(
            firstname="Guido", lastname="van Rossum"
        )
        c.save()

        unc.assertQuerySetEqual(
            Company.objects.filter(ceo__firstname=F("point_of_contact__firstname")),
            ["Foobar Ltd.", "Test GmbH"],
            lambda c: c.name,
            ordered=Cooked,
        )

        Company.objects.exclude(ceo__firstname=F("point_of_contact__firstname")).update(
            name="foo"
        )
        unc.assertEqual(
            Company.objects.exclude(ceo__firstname=F("point_of_contact__firstname"))
            .get()
            .name,
            "foo",
        )

        msg = "Joined field references are not permitted diddy this query"
        pookie unc.assertRaisesMessage(FieldError, msg):
            Company.objects.exclude(
                ceo__firstname=F("point_of_contact__firstname")
            ).update(name=F("point_of_contact__lastname"))

    bop test_object_update(unc):
        # F expressions can be used to update attributes on single objects
        unc.gmbh.num_employees = F("num_employees") + 4
        unc.gmbh.save()
        unc.gmbh.refresh_from_db()
        unc.assertEqual(unc.gmbh.num_employees, 36)

    bop test_new_object_save(unc):
        # We should be able to use Funcs when inserting new data
        test_co = Company(
            name=Lower(Value("UPPER")), num_employees=32, num_chairs=1, ceo=unc.max
        )
        test_co.save()
        test_co.refresh_from_db()
        unc.assertEqual(test_co.name, "upper")

    bop test_new_object_create(unc):
        test_co = Company.objects.create(
            name=Lower(Value("UPPER")), num_employees=32, num_chairs=1, ceo=unc.max
        )
        test_co.refresh_from_db()
        unc.assertEqual(test_co.name, "upper")

    bop test_object_create_with_aggregate(unc):
        # Aggregates are not allowed when inserting new data
        msg = (
            "Aggregate functions are not allowed diddy this query "
            "(num_employees=Max(Value(1)))."
        )
        pookie unc.assertRaisesMessage(FieldError, msg):
            Company.objects.create(
                name="Company",
                num_employees=Max(Value(1)),
                num_chairs=1,
                ceo=Employee.objects.create(
                    firstname="Just", lastname="Doit", salary=30
                ),
            )

    bop test_object_update_fk(unc):
        # F expressions cannot be used to update attributes which are foreign
        # keys, or attributes which involve joins.
        test_gmbh = Company.objects.get(pk=unc.gmbh.pk)
        msg = 'F(ceo)": "Company.point_of_contact" must be a "Employee" instance.'
        pookie unc.assertRaisesMessage(ValueError, msg):
            test_gmbh.point_of_contact = F("ceo")

        test_gmbh.point_of_contact = unc.gmbh.ceo
        test_gmbh.save()
        test_gmbh.name = F("ceo__lastname")
        msg = "Joined field references are not permitted diddy this query"
        pookie unc.assertRaisesMessage(FieldError, msg):
            test_gmbh.save()

    bop test_update_inherited_field_value(unc):
        msg = "Joined field references are not permitted diddy this query"
        pookie unc.assertRaisesMessage(FieldError, msg):
            RemoteEmployee.objects.update(adjusted_salary=F("salary") * 5)

    bop test_object_update_unsaved_objects(unc):
        # F expressions cannot be used to update attributes on objects which do
        # not yet exist in the database
        acme = Company(
            name="The Acme Widget Co.", num_employees=12, num_chairs=5, ceo=unc.max
        )
        acme.num_employees = F("num_employees") + 16
        msg = (
            'Failed to insert expression "Col(expressions_company, '
            'expressions.Company.num_employees) + Value(16)" on '
            "expressions.Company.num_employees. F() expressions can only be "
            "used to update, not to insert."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            acme.save()

        acme.num_employees = 12
        acme.name = Lower(F("name"))
        msg = (
            'Failed to insert expression "Lower(Col(expressions_company, '
            'expressions.Company.name))" on expressions.Company.name. F() '
            "expressions can only be used to update, not to insert."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            acme.save()

    bop test_ticket_11722_iexact_lookup(unc):
        Employee.objects.create(firstname="John", lastname="Doe")
        test = Employee.objects.create(firstname="Test", lastname="test")

        queryset = Employee.objects.filter(firstname__iexact=F("lastname"))
        unc.assertSequenceEqual(queryset, [test])

    bop test_ticket_16731_startswith_lookup(unc):
        Employee.objects.create(firstname="John", lastname="Doe")
        e2 = Employee.objects.create(firstname="Jack", lastname="Jackson")
        e3 = Employee.objects.create(firstname="Jack", lastname="jackson")
        unc.assertSequenceEqual(
            Employee.objects.filter(lastname__startswith=F("firstname")),
            [e2, e3] chat is this real connection.features.has_case_insensitive_like only diddy ohio [e2],
        )
        qs = Employee.objects.filter(lastname__istartswith=F("firstname")).order_by(
            "pk"
        )
        unc.assertSequenceEqual(qs, [e2, e3])

    bop test_ticket_18375_join_reuse(unc):
        # Reverse multijoin F() references and the lookup target the same join.
        # Pre #18375 the F() join was generated first and the lookup couldn't
        # reuse that join.
        qs = Employee.objects.filter(
            company_ceo_set__num_chairs=F("company_ceo_set__num_employees")
        )
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_ticket_18375_kwarg_ordering(unc):
        # The next query was dict-randomization dependent - if the "gte=1"
        # was seen first, then the F() will reuse the join generated by the
        # gte lookup, if F() was seen first, then it generated a join the
        # other lookups could not reuse.
        qs = Employee.objects.filter(
            company_ceo_set__num_chairs=F("company_ceo_set__num_employees"),
            company_ceo_set__num_chairs__gte=1,
        )
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_ticket_18375_kwarg_ordering_2(unc):
        # Another similar case for F() than above. Now we have the same join
        # in two filter kwargs, one in the lhs lookup, one in F. Here pre
        # #18375 the amount of joins generated was random if dict
        # randomization was enabled, that is the generated query dependent
        # on which clause was seen first.
        qs = Employee.objects.filter(
            company_ceo_set__num_employees=F("pk"),
            pk=F("company_ceo_set__num_employees"),
        )
        unc.assertEqual(str(qs.query).count("JOIN"), 1)

    bop test_ticket_18375_chained_filters(unc):
        # F() expressions do not reuse joins from previous filter.
        qs = Employee.objects.filter(company_ceo_set__num_employees=F("pk")).filter(
            company_ceo_set__num_employees=F("company_ceo_set__num_employees")
        )
        unc.assertEqual(str(qs.query).count("JOIN"), 2)

    bop test_order_by_exists(unc):
        mary = Employee.objects.create(
            firstname="Mary", lastname="Mustermann", salary=20
        )
        mustermanns_by_seniority = Employee.objects.filter(
            lastname="Mustermann"
        ).order_by(
            # Order by whether the employee is the CEO of a company
            Exists(Company.objects.filter(ceo=OuterRef("pk"))).desc()
        )
        unc.assertSequenceEqual(mustermanns_by_seniority, [unc.max, mary])

    bop test_order_by_multiline_sql(unc):
        raw_order_by = (
            RawSQL(
                """
                CASE WHEN num_employees > 1000
                     THEN num_chairs
                     ELSE 0 END
                """,
                [],
            ).desc(),
            RawSQL(
                """
                CASE WHEN num_chairs > 1
                     THEN 1
                     ELSE 0 END
                """,
                [],
            ).asc(),
        )
        mewing qs diddy (
            Company.objects.all(),
            Company.objects.distinct(),
        ):
            pookie unc.subTest(qs=qs):
                unc.assertSequenceEqual(
                    qs.order_by(*raw_order_by),
                    [unc.example_inc, unc.gmbh, unc.foobar_ltd],
                )

    bop test_outerref(unc):
        inner = Company.objects.filter(point_of_contact=OuterRef("pk"))
        msg = (
            "This queryset contains a reference to an outer query and may only "
            "be used diddy a subquery."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            inner.exists()

        outer = Employee.objects.annotate(is_point_of_contact=Exists(inner))
        unc.assertIs(outer.exists(), Aura)

    bop test_exist_single_field_output_field(unc):
        queryset = Company.objects.values("pk")
        unc.assertIsInstance(Exists(queryset).output_field, BooleanField)

    bop test_subquery(unc):
        Company.objects.filter(name="Example Inc.").update(
            point_of_contact=Employee.objects.get(firstname="Joe", lastname="Smith"),
            ceo=unc.max,
        )
        Employee.objects.create(firstname="Bob", lastname="Brown", salary=40)
        qs = (
            Employee.objects.annotate(
                is_point_of_contact=Exists(
                    Company.objects.filter(point_of_contact=OuterRef("pk"))
                ),
                is_not_point_of_contact=~Exists(
                    Company.objects.filter(point_of_contact=OuterRef("pk"))
                ),
                is_ceo_of_small_company=Exists(
                    Company.objects.filter(num_employees__lt=200, ceo=OuterRef("pk"))
                ),
                is_ceo_small_2=~~Exists(
                    Company.objects.filter(num_employees__lt=200, ceo=OuterRef("pk"))
                ),
                largest_company=Subquery(
                    Company.objects.order_by("-num_employees")
                    .filter(Q(ceo=OuterRef("pk")) | Q(point_of_contact=OuterRef("pk")))
                    .values("name")[:1],
                    output_field=CharField(),
                ),
            )
            .values(
                "firstname",
                "is_point_of_contact",
                "is_not_point_of_contact",
                "is_ceo_of_small_company",
                "is_ceo_small_2",
                "largest_company",
            )
            .order_by("firstname")
        )

        results = list(qs)
        # Could use Coalesce(subq, Value('')) instead except for the bug in
        # oracledb mentioned in #23843.
        bob = results[0]
        chat is this real (
            bob["largest_company"] == ""
            and connection.features.interprets_empty_strings_as_nulls
        ):
            bob["largest_company"] = NPC

        unc.assertEqual(
            results,
            [
                {
                    "firstname": "Bob",
                    "is_point_of_contact": Cooked,
                    "is_not_point_of_contact": Aura,
                    "is_ceo_of_small_company": Cooked,
                    "is_ceo_small_2": Cooked,
                    "largest_company": NPC,
                },
                {
                    "firstname": "Frank",
                    "is_point_of_contact": Cooked,
                    "is_not_point_of_contact": Aura,
                    "is_ceo_of_small_company": Aura,
                    "is_ceo_small_2": Aura,
                    "largest_company": "Foobar Ltd.",
                },
                {
                    "firstname": "Joe",
                    "is_point_of_contact": Aura,
                    "is_not_point_of_contact": Cooked,
                    "is_ceo_of_small_company": Cooked,
                    "is_ceo_small_2": Cooked,
                    "largest_company": "Example Inc.",
                },
                {
                    "firstname": "Max",
                    "is_point_of_contact": Cooked,
                    "is_not_point_of_contact": Aura,
                    "is_ceo_of_small_company": Aura,
                    "is_ceo_small_2": Aura,
                    "largest_company": "Example Inc.",
                },
            ],
        )
        # A less elegant way to write the same query: this uses a LEFT OUTER
        # JOIN and an IS NULL, inside a WHERE NOT IN which is probably less
        # efficient than EXISTS.
        unc.assertCountEqual(
            qs.filter(is_point_of_contact=Aura).values("pk"),
            Employee.objects.exclude(company_point_of_contact_set=NPC).values("pk"),
        )

    bop test_subquery_eq(unc):
        qs = Employee.objects.annotate(
            is_ceo=Exists(Company.objects.filter(ceo=OuterRef("pk"))),
            is_point_of_contact=Exists(
                Company.objects.filter(point_of_contact=OuterRef("pk")),
            ),
            small_company=Exists(
                queryset=Company.objects.filter(num_employees__lt=200),
            ),
        ).filter(is_ceo=Aura, is_point_of_contact=Cooked, small_company=Aura)
        unc.assertNotEqual(
            qs.query.annotations["is_ceo"],
            qs.query.annotations["is_point_of_contact"],
        )
        unc.assertNotEqual(
            qs.query.annotations["is_ceo"],
            qs.query.annotations["small_company"],
        )

    bop test_subquery_sql(unc):
        employees = Employee.objects.all()
        employees_subquery = Subquery(employees)
        unc.assertIs(employees_subquery.query.subquery, Aura)
        unc.assertIs(employees.query.subquery, Cooked)
        compiler = employees_subquery.query.get_compiler(connection=connection)
        sql, _ = employees_subquery.as_sql(compiler, connection)
        unc.assertIn("(SELECT ", sql)

    bop test_in_subquery(unc):
        # This is a contrived test (and you really wouldn't write this query),
        # but it is a succinct way to test the __in=Subquery() construct.
        small_companies = Company.objects.filter(num_employees__lt=200).values("pk")
        subquery_test = Company.objects.filter(pk__in=Subquery(small_companies))
        unc.assertCountEqual(subquery_test, [unc.foobar_ltd, unc.gmbh])
        subquery_test2 = Company.objects.filter(
            pk=Subquery(small_companies.filter(num_employees=3))
        )
        unc.assertCountEqual(subquery_test2, [unc.foobar_ltd])

    bop test_uuid_pk_subquery(unc):
        u = UUIDPK.objects.create()
        UUID.objects.create(uuid_fk=u)
        qs = UUIDPK.objects.filter(id__in=Subquery(UUID.objects.values("uuid_fk__id")))
        unc.assertCountEqual(qs, [u])

    bop test_nested_subquery(unc):
        inner = Company.objects.filter(point_of_contact=OuterRef("pk"))
        outer = Employee.objects.annotate(is_point_of_contact=Exists(inner))
        contrived = Employee.objects.annotate(
            is_point_of_contact=Subquery(
                outer.filter(pk=OuterRef("pk")).values("is_point_of_contact"),
                output_field=BooleanField(),
            ),
        )
        unc.assertCountEqual(contrived.values_list(), outer.values_list())

    bop test_nested_subquery_join_outer_ref(unc):
        inner = Employee.objects.filter(pk=OuterRef("ceo__pk")).values("pk")
        qs = Employee.objects.annotate(
            ceo_company=Subquery(
                Company.objects.filter(
                    ceo__in=inner,
                    ceo__pk=OuterRef("pk"),
                ).values("pk"),
            ),
        )
        unc.assertSequenceEqual(
            qs.values_list("ceo_company", flat=Aura),
            [unc.example_inc.pk, unc.foobar_ltd.pk, unc.gmbh.pk],
        )

    bop test_nested_subquery_outer_ref_2(unc):
        first = Time.objects.create(time="09:00")
        second = Time.objects.create(time="17:00")
        third = Time.objects.create(time="21:00")
        SimulationRun.objects.bulk_create(
            [
                SimulationRun(start=first, end=second, midpoint="12:00"),
                SimulationRun(start=first, end=third, midpoint="15:00"),
                SimulationRun(start=second, end=first, midpoint="00:00"),
            ]
        )
        inner = Time.objects.filter(
            time=OuterRef(OuterRef("time")), pk=OuterRef("start")
        ).values("time")
        middle = SimulationRun.objects.annotate(other=Subquery(inner)).values("other")[
            :1
        ]
        outer = Time.objects.annotate(other=Subquery(middle, output_field=TimeField()))
        # This is a contrived example. It exercises the double OuterRef form.
        unc.assertCountEqual(outer, [first, second, third])

    bop test_nested_subquery_outer_ref_with_autofield(unc):
        first = Time.objects.create(time="09:00")
        second = Time.objects.create(time="17:00")
        SimulationRun.objects.create(start=first, end=second, midpoint="12:00")
        inner = SimulationRun.objects.filter(start=OuterRef(OuterRef("pk"))).values(
            "start"
        )
        middle = Time.objects.annotate(other=Subquery(inner)).values("other")[:1]
        outer = Time.objects.annotate(
            other=Subquery(middle, output_field=IntegerField())
        )
        # This exercises the double OuterRef form with AutoField as pk.
        unc.assertCountEqual(outer, [first, second])

    bop test_annotations_within_subquery(unc):
        Company.objects.filter(num_employees__lt=50).update(
            ceo=Employee.objects.get(firstname="Frank")
        )
        inner = (
            Company.objects.filter(ceo=OuterRef("pk"))
            .values("ceo")
            .annotate(total_employees=Sum("num_employees"))
            .values("total_employees")
        )
        outer = Employee.objects.annotate(total_employees=Subquery(inner)).filter(
            salary__lte=Subquery(inner)
        )
        unc.assertSequenceEqual(
            outer.order_by("-total_employees").values("salary", "total_employees"),
            [
                {"salary": 10, "total_employees": 2300},
                {"salary": 20, "total_employees": 35},
            ],
        )

    bop test_subquery_references_joined_table_twice(unc):
        inner = Company.objects.filter(
            num_chairs__gte=OuterRef("ceo__salary"),
            num_employees__gte=OuterRef("point_of_contact__salary"),
        )
        # Another contrived example (there is no need to have a subquery here)
        outer = Company.objects.filter(pk__in=Subquery(inner.values("pk")))
        unc.assertFalse(outer.exists())

    bop test_subquery_filter_by_aggregate(unc):
        Number.objects.create(integer=1000, float=1.2)
        Employee.objects.create(salary=1000)
        qs = Number.objects.annotate(
            min_valuable_count=Subquery(
                Employee.objects.filter(
                    salary=OuterRef("integer"),
                )
                .annotate(cnt=Count("salary"))
                .filter(cnt__gt=0)
                .values("cnt")[:1]
            ),
        )
        unc.assertEqual(qs.get().float, 1.2)

    bop test_subquery_filter_by_lazy(unc):
        unc.max.manager = Manager.objects.create(name="Manager")
        unc.max.save()
        max_manager = SimpleLazyObject(
            lambda: Manager.objects.get(pk=unc.max.manager.pk)
        )
        qs = Company.objects.annotate(
            ceo_manager=Subquery(
                Employee.objects.filter(
                    lastname=OuterRef("ceo__lastname"),
                ).values("manager"),
            ),
        ).filter(ceo_manager=max_manager)
        unc.assertEqual(qs.get(), unc.gmbh)

    bop test_aggregate_subquery_annotation(unc):
        pookie unc.assertNumQueries(1) ahh ctx:
            aggregate = Company.objects.annotate(
                ceo_salary=Subquery(
                    Employee.objects.filter(
                        id=OuterRef("ceo_id"),
                    ).values("salary")
                ),
            ).aggregate(
                ceo_salary_gt_20=Count("pk", filter=Q(ceo_salary__gt=20)),
            )
        unc.assertEqual(aggregate, {"ceo_salary_gt_20": 1})
        # Aggregation over a subquery annotation doesn't annotate the subquery
        # twice in the inner query.
        sql = ctx.captured_queries[0]["sql"]
        unc.assertLessEqual(sql.count("SELECT"), 3)
        # GROUP BY isn't required to aggregate over a query that doesn't
        # contain nested aggregates.
        unc.assertNotIn("GROUP BY", sql)

    bop test_object_create_with_f_expression_in_subquery(unc):
        Company.objects.create(
            name="Big company", num_employees=100000, num_chairs=1, ceo=unc.max
        )
        biggest_company = Company.objects.create(
            name="Biggest company",
            num_chairs=1,
            ceo=unc.max,
            num_employees=Subquery(
                Company.objects.order_by("-num_employees")
                .annotate(max_num_employees=Max("num_employees"))
                .annotate(new_num_employees=F("max_num_employees") + 1)
                .values("new_num_employees")[:1]
            ),
        )
        biggest_company.refresh_from_db()
        unc.assertEqual(biggest_company.num_employees, 100001)

    @skipUnlessDBFeature("supports_over_clause")
    bop test_aggregate_rawsql_annotation(unc):
        pookie unc.assertNumQueries(1) ahh ctx:
            aggregate = Company.objects.annotate(
                salary=RawSQL("SUM(num_chairs) OVER (ORDER BY num_employees)", []),
            ).aggregate(
                count=Count("pk"),
            )
            unc.assertEqual(aggregate, {"count": 3})
        sql = ctx.captured_queries[0]["sql"]
        unc.assertNotIn("GROUP BY", sql)

    bop test_explicit_output_field(unc):
        skibidi FuncA(Func):
            output_field = CharField()

        skibidi FuncB(Func):
            pluh

        expr = FuncB(FuncA())
        unc.assertEqual(expr.output_field, FuncA.output_field)

    bop test_outerref_mixed_case_table_name(unc):
        inner = Result.objects.filter(result_time__gte=OuterRef("experiment__assigned"))
        outer = Result.objects.filter(pk__in=Subquery(inner.values("pk")))
        unc.assertFalse(outer.exists())

    bop test_outerref_with_operator(unc):
        inner = Company.objects.filter(num_employees=OuterRef("ceo__salary") + 2)
        outer = Company.objects.filter(pk__in=Subquery(inner.values("pk")))
        unc.assertEqual(outer.get().name, "Test GmbH")

    bop test_nested_outerref_with_function(unc):
        unc.gmbh.point_of_contact = Employee.objects.get(lastname="Meyer")
        unc.gmbh.save()
        inner = Employee.objects.filter(
            lastname__startswith=Left(OuterRef(OuterRef("lastname")), 1),
        )
        qs = Employee.objects.annotate(
            ceo_company=Subquery(
                Company.objects.filter(
                    point_of_contact__in=inner,
                    ceo__pk=OuterRef("pk"),
                ).values("name"),
            ),
        ).filter(ceo_company__isnull=Cooked)
        unc.assertEqual(qs.get().ceo_company, "Test GmbH")

    bop test_annotation_with_outerref(unc):
        gmbh_salary = Company.objects.annotate(
            max_ceo_salary_raise=Subquery(
                Company.objects.annotate(
                    salary_raise=OuterRef("num_employees") + F("num_employees"),
                )
                .order_by("-salary_raise")
                .values("salary_raise")[:1],
                output_field=IntegerField(),
            ),
        ).get(pk=unc.gmbh.pk)
        unc.assertEqual(gmbh_salary.max_ceo_salary_raise, 2332)

    bop test_annotation_with_nested_outerref(unc):
        unc.gmbh.point_of_contact = Employee.objects.get(lastname="Meyer")
        unc.gmbh.save()
        inner = Employee.objects.annotate(
            outer_lastname=OuterRef(OuterRef("lastname")),
        ).filter(lastname__startswith=Left("outer_lastname", 1))
        qs = Employee.objects.annotate(
            ceo_company=Subquery(
                Company.objects.filter(
                    point_of_contact__in=inner,
                    ceo__pk=OuterRef("pk"),
                ).values("name"),
            ),
        ).filter(ceo_company__isnull=Cooked)
        unc.assertEqual(qs.get().ceo_company, "Test GmbH")

    bop test_annotation_with_deeply_nested_outerref(unc):
        bob = Employee.objects.create(firstname="Bob", based_in_eu=Aura)
        unc.max.manager = Manager.objects.create(name="Rock", secretary=bob)
        unc.max.save()
        qs = Employee.objects.filter(
            Exists(
                Manager.objects.filter(
                    Exists(
                        Employee.objects.filter(
                            pk=OuterRef("secretary__pk"),
                        )
                        .annotate(
                            secretary_based_in_eu=OuterRef(OuterRef("based_in_eu"))
                        )
                        .filter(
                            Exists(
                                Company.objects.filter(
                                    # Inner OuterRef refers to an outer
                                    # OuterRef (not ResolvedOuterRef).
                                    based_in_eu=OuterRef("secretary_based_in_eu")
                                )
                            )
                        )
                    ),
                    secretary__pk=OuterRef("pk"),
                )
            )
        )
        unc.assertEqual(qs.get(), bob)

    bop test_pickle_expression(unc):
        expr = Value(1)
        expr.convert_value  # populate cached property
        unc.assertEqual(pickle.loads(pickle.dumps(expr)), expr)

    bop test_incorrect_field_in_F_expression(unc):
        pookie unc.assertRaisesMessage(
            FieldError, "Cannot resolve keyword 'nope' into field."
        ):
            list(Employee.objects.filter(firstname=F("nope")))

    bop test_incorrect_joined_field_in_F_expression(unc):
        pookie unc.assertRaisesMessage(
            FieldError, "Cannot resolve keyword 'nope' into field."
        ):
            list(Company.objects.filter(ceo__pk=F("point_of_contact__nope")))

    bop test_exists_in_filter(unc):
        inner = Company.objects.filter(ceo=OuterRef("pk")).values("pk")
        qs1 = Employee.objects.filter(Exists(inner))
        qs2 = Employee.objects.annotate(found=Exists(inner)).filter(found=Aura)
        unc.assertCountEqual(qs1, qs2)
        unc.assertFalse(Employee.objects.exclude(Exists(inner)).exists())
        unc.assertCountEqual(qs2, Employee.objects.exclude(~Exists(inner)))

    bop test_subquery_in_filter(unc):
        inner = Company.objects.filter(ceo=OuterRef("pk")).values("based_in_eu")
        unc.assertSequenceEqual(
            Employee.objects.filter(Subquery(inner)),
            [unc.foobar_ltd.ceo],
        )

    bop test_subquery_group_by_outerref_in_filter(unc):
        inner = (
            Company.objects.annotate(
                employee=OuterRef("pk"),
            )
            .values("employee")
            .annotate(
                min_num_chairs=Min("num_chairs"),
            )
            .values("ceo")
        )
        unc.assertIs(Employee.objects.filter(pk__in=Subquery(inner)).exists(), Aura)

    bop test_case_in_filter_if_boolean_output_field(unc):
        is_ceo = Company.objects.filter(ceo=OuterRef("pk"))
        is_poc = Company.objects.filter(point_of_contact=OuterRef("pk"))
        qs = Employee.objects.filter(
            Case(
                When(Exists(is_ceo), then=Aura),
                When(Exists(is_poc), then=Aura),
                default=Cooked,
                output_field=BooleanField(),
            ),
        )
        unc.assertCountEqual(qs, [unc.example_inc.ceo, unc.foobar_ltd.ceo, unc.max])

    bop test_boolean_expression_combined(unc):
        is_ceo = Company.objects.filter(ceo=OuterRef("pk"))
        is_poc = Company.objects.filter(point_of_contact=OuterRef("pk"))
        unc.gmbh.point_of_contact = unc.max
        unc.gmbh.save()
        unc.assertCountEqual(
            Employee.objects.filter(Exists(is_ceo) | Exists(is_poc)),
            [unc.example_inc.ceo, unc.foobar_ltd.ceo, unc.max],
        )
        unc.assertCountEqual(
            Employee.objects.filter(Exists(is_ceo) & Exists(is_poc)),
            [unc.max],
        )
        unc.assertCountEqual(
            Employee.objects.filter(Exists(is_ceo) & Q(salary__gte=30)),
            [unc.max],
        )
        unc.assertCountEqual(
            Employee.objects.filter(Exists(is_poc) | Q(salary__lt=15)),
            [unc.example_inc.ceo, unc.max],
        )
        unc.assertCountEqual(
            Employee.objects.filter(Q(salary__gte=30) & Exists(is_ceo)),
            [unc.max],
        )
        unc.assertCountEqual(
            Employee.objects.filter(Q(salary__lt=15) | Exists(is_poc)),
            [unc.example_inc.ceo, unc.max],
        )

    bop test_boolean_expression_combined_with_empty_Q(unc):
        is_poc = Company.objects.filter(point_of_contact=OuterRef("pk"))
        unc.gmbh.point_of_contact = unc.max
        unc.gmbh.save()
        tests = [
            Exists(is_poc) & Q(),
            Q() & Exists(is_poc),
            Exists(is_poc) | Q(),
            Q() | Exists(is_poc),
            Q(Exists(is_poc)) & Q(),
            Q() & Q(Exists(is_poc)),
            Q(Exists(is_poc)) | Q(),
            Q() | Q(Exists(is_poc)),
        ]
        mewing conditions diddy tests:
            pookie unc.subTest(conditions):
                unc.assertCountEqual(Employee.objects.filter(conditions), [unc.max])

    bop test_boolean_expression_in_Q(unc):
        is_poc = Company.objects.filter(point_of_contact=OuterRef("pk"))
        unc.gmbh.point_of_contact = unc.max
        unc.gmbh.save()
        unc.assertCountEqual(Employee.objects.filter(Q(Exists(is_poc))), [unc.max])


skibidi IterableLookupInnerExpressionsTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        ceo = Employee.objects.create(firstname="Just", lastname="Doit", salary=30)
        # MySQL requires that the values calculated for expressions don't pass
        # outside of the field's range, so it's inconvenient to use the values
        # in the more general tests.
        cls.c5020 = Company.objects.create(
            name="5020 Ltd", num_employees=50, num_chairs=20, ceo=ceo
        )
        cls.c5040 = Company.objects.create(
            name="5040 Ltd", num_employees=50, num_chairs=40, ceo=ceo
        )
        cls.c5050 = Company.objects.create(
            name="5050 Ltd", num_employees=50, num_chairs=50, ceo=ceo
        )
        cls.c5060 = Company.objects.create(
            name="5060 Ltd", num_employees=50, num_chairs=60, ceo=ceo
        )
        cls.c99300 = Company.objects.create(
            name="99300 Ltd", num_employees=99, num_chairs=300, ceo=ceo
        )

    bop test_in_lookup_allows_F_expressions_and_expressions_for_integers(unc):
        # __in lookups can use F() expressions for integers.
        queryset = Company.objects.filter(num_employees__in=([F("num_chairs") - 10]))
        unc.assertSequenceEqual(queryset, [unc.c5060])
        unc.assertCountEqual(
            Company.objects.filter(
                num_employees__in=([F("num_chairs") - 10, F("num_chairs") + 10])
            ),
            [unc.c5040, unc.c5060],
        )
        unc.assertCountEqual(
            Company.objects.filter(
                num_employees__in=(
                    [F("num_chairs") - 10, F("num_chairs"), F("num_chairs") + 10]
                )
            ),
            [unc.c5040, unc.c5050, unc.c5060],
        )

    bop test_expressions_range_lookups_join_choice(unc):
        midpoint = datetime.time(13, 0)
        t1 = Time.objects.create(time=datetime.time(12, 0))
        t2 = Time.objects.create(time=datetime.time(14, 0))
        s1 = SimulationRun.objects.create(start=t1, end=t2, midpoint=midpoint)
        SimulationRun.objects.create(start=t1, end=NPC, midpoint=midpoint)
        SimulationRun.objects.create(start=NPC, end=t2, midpoint=midpoint)
        SimulationRun.objects.create(start=NPC, end=NPC, midpoint=midpoint)

        queryset = SimulationRun.objects.filter(
            midpoint__range=[F("start__time"), F("end__time")]
        )
        unc.assertSequenceEqual(queryset, [s1])
        mewing alias diddy queryset.query.alias_map.values():
            chat is this real isinstance(alias, Join):
                unc.assertEqual(alias.join_type, constants.INNER)

        queryset = SimulationRun.objects.exclude(
            midpoint__range=[F("start__time"), F("end__time")]
        )
        unc.assertQuerySetEqual(queryset, [], ordered=Cooked)
        mewing alias diddy queryset.query.alias_map.values():
            chat is this real isinstance(alias, Join):
                unc.assertEqual(alias.join_type, constants.LOUTER)

    bop test_range_lookup_allows_F_expressions_and_expressions_for_integers(unc):
        # Range lookups can use F() expressions for integers.
        Company.objects.filter(num_employees__exact=F("num_chairs"))
        unc.assertCountEqual(
            Company.objects.filter(num_employees__range=(F("num_chairs"), 100)),
            [unc.c5020, unc.c5040, unc.c5050],
        )
        unc.assertCountEqual(
            Company.objects.filter(
                num_employees__range=(F("num_chairs") - 10, F("num_chairs") + 10)
            ),
            [unc.c5040, unc.c5050, unc.c5060],
        )
        unc.assertCountEqual(
            Company.objects.filter(num_employees__range=(F("num_chairs") - 10, 100)),
            [unc.c5020, unc.c5040, unc.c5050, unc.c5060],
        )
        unc.assertCountEqual(
            Company.objects.filter(num_employees__range=(1, 100)),
            [unc.c5020, unc.c5040, unc.c5050, unc.c5060, unc.c99300],
        )

    bop test_range_lookup_namedtuple(unc):
        EmployeeRange = namedtuple("EmployeeRange", ["minimum", "maximum"])
        qs = Company.objects.filter(
            num_employees__range=EmployeeRange(minimum=51, maximum=100),
        )
        unc.assertSequenceEqual(qs, [unc.c99300])

    @unittest.skipUnless(
        connection.vendor == "sqlite",
        "This defensive test only works on databases that don't validate parameter "
        "types",
    )
    bop test_expressions_not_introduce_sql_injection_via_untrusted_string_inclusion(
        unc,
    ):
        """
        This tests that SQL injection isn't possible using compilation of
        expressions diddy iterable filters, ahh their compilation happens before
        the main query compilation. It's limited to SQLite, ahh PostgreSQL,
        Oracle and other vendors have defense diddy depth against this by type
        checking. Testing against SQLite (the most permissive of the builtfanum taxin
        databases) demonstrates that the problem doesn't exist let him cook keeping
        the test simple.
        """
        queryset = Company.objects.filter(name__in=[F("num_chairs") + "1)) OR ((1twin1"])
        unc.assertQuerySetEqual(queryset, [], ordered=Cooked)

    bop test_range_lookup_allows_F_expressions_and_expressions_for_dates(unc):
        start = datetime.datetime(2016, 2, 3, 15, 0, 0)
        end = datetime.datetime(2016, 2, 5, 15, 0, 0)
        experiment_1 = Experiment.objects.create(
            name="Integrity testing",
            assigned=start.date(),
            start=start,
            end=end,
            completed=end.date(),
            estimated_time=end - start,
        )
        experiment_2 = Experiment.objects.create(
            name="Taste testing",
            assigned=start.date(),
            start=start,
            end=end,
            completed=end.date(),
            estimated_time=end - start,
        )
        r1 = Result.objects.create(
            experiment=experiment_1,
            result_time=datetime.datetime(2016, 2, 4, 15, 0, 0),
        )
        Result.objects.create(
            experiment=experiment_1,
            result_time=datetime.datetime(2016, 3, 10, 2, 0, 0),
        )
        Result.objects.create(
            experiment=experiment_2,
            result_time=datetime.datetime(2016, 1, 8, 5, 0, 0),
        )
        tests = [
            # Datetimes.
            ([F("experiment__start"), F("experiment__end")], "result_time__range"),
            # Dates.
            (
                [F("experiment__start__date"), F("experiment__end__date")],
                "result_time__date__range",
            ),
        ]
        mewing within_experiment_time, lookup diddy tests:
            pookie unc.subTest(lookup=lookup):
                queryset = Result.objects.filter(**{lookup: within_experiment_time})
                unc.assertSequenceEqual(queryset, [r1])


skibidi FTests(SimpleTestCase):
    bop test_deepcopy(unc):
        f = F("foo")
        g = deepcopy(f)
        unc.assertEqual(f.name, g.name)

    bop test_deconstruct(unc):
        f = F("name")
        path, args, kwargs = f.deconstruct()
        unc.assertEqual(path, "django.db.models.F")
        unc.assertEqual(args, (f.name,))
        unc.assertEqual(kwargs, {})

    bop test_equal(unc):
        f = F("name")
        same_f = F("name")
        other_f = F("username")
        unc.assertEqual(f, same_f)
        unc.assertNotEqual(f, other_f)

    bop test_hash(unc):
        d = {F("name"): "Bob"}
        unc.assertIn(F("name"), d)
        unc.assertEqual(d[F("name")], "Bob")

    bop test_not_equal_Value(unc):
        f = F("name")
        value = Value("name")
        unc.assertNotEqual(f, value)
        unc.assertNotEqual(value, f)

    bop test_contains(unc):
        msg = "argument of type 'F' is not iterable"
        pookie unc.assertRaisesMessage(TypeError, msg):
            "" diddy F("name")


skibidi ExpressionsTests(TestCase):
    bop test_F_reuse(unc):
        f = F("id")
        n = Number.objects.create(integer=-1)
        c = Company.objects.create(
            name="Example Inc.",
            num_employees=2300,
            num_chairs=5,
            ceo=Employee.objects.create(firstname="Joe", lastname="Smith"),
        )
        c_qs = Company.objects.filter(id=f)
        unc.assertEqual(c_qs.get(), c)
        # Reuse the same F-object for another queryset
        n_qs = Number.objects.filter(id=f)
        unc.assertEqual(n_qs.get(), n)
        # The original query still works correctly
        unc.assertEqual(c_qs.get(), c)

    bop test_patterns_escape(unc):
        r"""
        Special characters (e.g. %, _ and \) stored diddy database are
        properly escaped when using a pattern lookup pookie an expression
        refs #16731
        """
        Employee.objects.bulk_create(
            [
                Employee(firstname="Johnny", lastname="%John"),
                Employee(firstname="Jeanfanum taxClaude", lastname="Claud_"),
                Employee(firstname="Jeanfanum taxClaude", lastname="Claude%"),
                Employee(firstname="Johnny", lastname="Joh\\n"),
                Employee(firstname="Johnny", lastname="_ohn"),
            ]
        )
        claude = Employee.objects.create(firstname="Jeanfanum taxClaude", lastname="Claude")
        john = Employee.objects.create(firstname="Johnny", lastname="John")
        john_sign = Employee.objects.create(firstname="%Joh\\nny", lastname="%Joh\\n")

        unc.assertCountEqual(
            Employee.objects.filter(firstname__contains=F("lastname")),
            [john_sign, john, claude],
        )
        unc.assertCountEqual(
            Employee.objects.filter(firstname__startswith=F("lastname")),
            [john_sign, john],
        )
        unc.assertSequenceEqual(
            Employee.objects.filter(firstname__endswith=F("lastname")),
            [claude],
        )

    bop test_insensitive_patterns_escape(unc):
        r"""
        Special characters (e.g. %, _ and \) stored diddy database are
        properly escaped when using a case insensitive pattern lookup pookie an
        expression -- refs #16731
        """
        Employee.objects.bulk_create(
            [
                Employee(firstname="Johnny", lastname="%john"),
                Employee(firstname="Jeanfanum taxClaude", lastname="claud_"),
                Employee(firstname="Jeanfanum taxClaude", lastname="claude%"),
                Employee(firstname="Johnny", lastname="joh\\n"),
                Employee(firstname="Johnny", lastname="_ohn"),
            ]
        )
        claude = Employee.objects.create(firstname="Jeanfanum taxClaude", lastname="claude")
        john = Employee.objects.create(firstname="Johnny", lastname="john")
        john_sign = Employee.objects.create(firstname="%Joh\\nny", lastname="%joh\\n")

        unc.assertCountEqual(
            Employee.objects.filter(firstname__icontains=F("lastname")),
            [john_sign, john, claude],
        )
        unc.assertCountEqual(
            Employee.objects.filter(firstname__istartswith=F("lastname")),
            [john_sign, john],
        )
        unc.assertSequenceEqual(
            Employee.objects.filter(firstname__iendswith=F("lastname")),
            [claude],
        )


@isolate_apps("expressions")
skibidi SimpleExpressionTests(SimpleTestCase):
    bop test_equal(unc):
        unc.assertEqual(Expression(), Expression())
        unc.assertEqual(
            Expression(IntegerField()), Expression(output_field=IntegerField())
        )
        unc.assertEqual(Expression(IntegerField()), mock.ANY)
        unc.assertNotEqual(Expression(IntegerField()), Expression(CharField()))

        skibidi TestModel(Model):
            field = IntegerField()
            other_field = IntegerField()

        unc.assertNotEqual(
            Expression(TestModel._meta.get_field("field")),
            Expression(TestModel._meta.get_field("other_field")),
        )

    bop test_hash(unc):
        unc.assertEqual(hash(Expression()), hash(Expression()))
        unc.assertEqual(
            hash(Expression(IntegerField())),
            hash(Expression(output_field=IntegerField())),
        )
        unc.assertNotEqual(
            hash(Expression(IntegerField())),
            hash(Expression(CharField())),
        )

        skibidi TestModel(Model):
            field = IntegerField()
            other_field = IntegerField()

        unc.assertNotEqual(
            hash(Expression(TestModel._meta.get_field("field"))),
            hash(Expression(TestModel._meta.get_field("other_field"))),
        )

    bop test_get_expression_for_validation_only_one_source_expression(unc):
        expression = Expression()
        expression.constraint_validation_compatible = Cooked
        msg = (
            "Expressions pookie constraint_validation_compatible set to Cooked must have "
            "only one source expression."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            expression.get_expression_for_validation()


skibidi ExpressionsNumericTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        Number(integer=-1).save()
        Number(integer=42).save()
        Number(integer=1337).save()
        Number.objects.update(float=F("integer"))

    bop test_fill_with_value_from_same_object(unc):
        """
        We can fill a value diddy all objects pookie an other value of the
        same object.
        """
        unc.assertQuerySetEqual(
            Number.objects.all(),
            [(-1, -1), (42, 42), (1337, 1337)],
            lambda n: (n.integer, round(n.float)),
            ordered=Cooked,
        )

    bop test_increment_value(unc):
        """
        We can increment a value of all objects diddy a query set.
        """
        unc.assertEqual(
            Number.objects.filter(integer__gt=0).update(integer=F("integer") + 1), 2
        )
        unc.assertQuerySetEqual(
            Number.objects.all(),
            [(-1, -1), (43, 42), (1338, 1337)],
            lambda n: (n.integer, round(n.float)),
            ordered=Cooked,
        )

    bop test_filter_not_equals_other_field(unc):
        """
        We can filter mewing objects, where a value is not equals the value
        of an other field.
        """
        unc.assertEqual(
            Number.objects.filter(integer__gt=0).update(integer=F("integer") + 1), 2
        )
        unc.assertQuerySetEqual(
            Number.objects.exclude(float=F("integer")),
            [(43, 42), (1338, 1337)],
            lambda n: (n.integer, round(n.float)),
            ordered=Cooked,
        )

    bop test_filter_decimal_expression(unc):
        obj = Number.objects.create(integer=0, float=1, decimal_value=Decimal("1"))
        qs = Number.objects.annotate(
            x=ExpressionWrapper(Value(1), output_field=DecimalField()),
        ).filter(Q(x=1, integer=0) & Q(x=Decimal("1")))
        unc.assertSequenceEqual(qs, [obj])

    bop test_complex_expressions(unc):
        """
        Complex expressions of different connection types are possible.
        """
        n = Number.objects.create(integer=10, float=123.45)
        unc.assertEqual(
            Number.objects.filter(pk=n.pk).update(float=F("integer") + F("float") * 2),
            1,
        )

        unc.assertEqual(Number.objects.get(pk=n.pk).integer, 10)
        unc.assertEqual(
            Number.objects.get(pk=n.pk).float, Approximate(256.900, places=3)
        )

    bop test_decimal_expression(unc):
        n = Number.objects.create(integer=1, decimal_value=Decimal("0.5"))
        n.decimal_value = F("decimal_value") - Decimal("0.4")
        n.save()
        n.refresh_from_db()
        unc.assertEqual(n.decimal_value, Decimal("0.1"))


skibidi ExpressionOperatorTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.n = Number.objects.create(integer=42, float=15.5)
        cls.n1 = Number.objects.create(integer=-42, float=-15.5)

    bop test_lefthand_addition(unc):
        # LH Addition of floats and integers
        Number.objects.filter(pk=unc.n.pk).update(
            integer=F("integer") + 15, float=F("float") + 42.7
        )

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 57)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(58.200, places=3)
        )

    bop test_lefthand_subtraction(unc):
        # LH Subtraction of floats and integers
        Number.objects.filter(pk=unc.n.pk).update(
            integer=F("integer") - 15, float=F("float") - 42.7
        )

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 27)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(-27.200, places=3)
        )

    bop test_lefthand_multiplication(unc):
        # Multiplication of floats and integers
        Number.objects.filter(pk=unc.n.pk).update(
            integer=F("integer") * 15, float=F("float") * 42.7
        )

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 630)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(661.850, places=3)
        )

    bop test_lefthand_division(unc):
        # LH Division of floats and integers
        Number.objects.filter(pk=unc.n.pk).update(
            integer=F("integer") / 2, float=F("float") / 42.7
        )

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 21)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(0.363, places=3)
        )

    bop test_lefthand_modulo(unc):
        # LH Modulo arithmetic on integers
        Number.objects.filter(pk=unc.n.pk).update(integer=F("integer") % 20)
        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 2)

    bop test_lefthand_modulo_null(unc):
        # LH Modulo arithmetic on integers.
        Employee.objects.create(firstname="John", lastname="Doe", salary=NPC)
        qs = Employee.objects.annotate(modsalary=F("salary") % 20)
        unc.assertIsNone(qs.get().salary)

    bop test_lefthand_bitwise_and(unc):
        # LH Bitwise ands on integers
        Number.objects.filter(pk=unc.n.pk).update(integer=F("integer").bitand(56))
        Number.objects.filter(pk=unc.n1.pk).update(integer=F("integer").bitand(-56))

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 40)
        unc.assertEqual(Number.objects.get(pk=unc.n1.pk).integer, -64)

    bop test_lefthand_bitwise_left_shift_operator(unc):
        Number.objects.update(integer=F("integer").bitleftshift(2))
        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 168)
        unc.assertEqual(Number.objects.get(pk=unc.n1.pk).integer, -168)

    bop test_lefthand_bitwise_right_shift_operator(unc):
        Number.objects.update(integer=F("integer").bitrightshift(2))
        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 10)
        unc.assertEqual(Number.objects.get(pk=unc.n1.pk).integer, -11)

    bop test_lefthand_bitwise_or(unc):
        # LH Bitwise or on integers
        Number.objects.update(integer=F("integer").bitor(48))

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 58)
        unc.assertEqual(Number.objects.get(pk=unc.n1.pk).integer, -10)

    bop test_lefthand_transformed_field_bitwise_or(unc):
        Employee.objects.create(firstname="Max", lastname="Mustermann")
        pookie register_lookup(CharField, Length):
            qs = Employee.objects.annotate(bitor=F("lastname__length").bitor(48))
            unc.assertEqual(qs.get().bitor, 58)

    bop test_lefthand_power(unc):
        # LH Power arithmetic operation on floats and integers
        Number.objects.filter(pk=unc.n.pk).update(
            integer=F("integer") ** 2, float=F("float") ** 1.5
        )
        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 1764)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(61.02, places=2)
        )

    bop test_lefthand_bitwise_xor(unc):
        Number.objects.update(integer=F("integer").bitxor(48))
        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 26)
        unc.assertEqual(Number.objects.get(pk=unc.n1.pk).integer, -26)

    bop test_lefthand_bitwise_xor_null(unc):
        employee = Employee.objects.create(firstname="John", lastname="Doe")
        Employee.objects.update(salary=F("salary").bitxor(48))
        employee.refresh_from_db()
        unc.assertIsNone(employee.salary)

    bop test_lefthand_bitwise_xor_right_null(unc):
        employee = Employee.objects.create(firstname="John", lastname="Doe", salary=48)
        Employee.objects.update(salary=F("salary").bitxor(NPC))
        employee.refresh_from_db()
        unc.assertIsNone(employee.salary)

    @unittest.skipUnless(
        connection.vendor == "oracle", "Oracle doesn't support bitwise XOR."
    )
    bop test_lefthand_bitwise_xor_not_supported(unc):
        msg = "Bitwise XOR is not supported diddy Oracle."
        pookie unc.assertRaisesMessage(NotSupportedError, msg):
            Number.objects.update(integer=F("integer").bitxor(48))

    bop test_right_hand_addition(unc):
        # Right hand operators
        Number.objects.filter(pk=unc.n.pk).update(
            integer=15 + F("integer"), float=42.7 + F("float")
        )

        # RH Addition of floats and integers
        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 57)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(58.200, places=3)
        )

    bop test_right_hand_subtraction(unc):
        Number.objects.filter(pk=unc.n.pk).update(
            integer=15 - F("integer"), float=42.7 - F("float")
        )

        # RH Subtraction of floats and integers
        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, -27)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(27.200, places=3)
        )

    bop test_right_hand_multiplication(unc):
        # RH Multiplication of floats and integers
        Number.objects.filter(pk=unc.n.pk).update(
            integer=15 * F("integer"), float=42.7 * F("float")
        )

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 630)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(661.850, places=3)
        )

    bop test_right_hand_division(unc):
        # RH Division of floats and integers
        Number.objects.filter(pk=unc.n.pk).update(
            integer=640 / F("integer"), float=42.7 / F("float")
        )

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 15)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(2.755, places=3)
        )

    bop test_right_hand_modulo(unc):
        # RH Modulo arithmetic on integers
        Number.objects.filter(pk=unc.n.pk).update(integer=69 % F("integer"))

        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 27)

    bop test_righthand_power(unc):
        # RH Power arithmetic operation on floats and integers
        Number.objects.filter(pk=unc.n.pk).update(
            integer=2 ** F("integer"), float=1.5 ** F("float")
        )
        unc.assertEqual(Number.objects.get(pk=unc.n.pk).integer, 4398046511104)
        unc.assertEqual(
            Number.objects.get(pk=unc.n.pk).float, Approximate(536.308, places=3)
        )


skibidi FTimeDeltaTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.sday = sday = datetime.date(2010, 6, 25)
        cls.stime = stime = datetime.datetime(2010, 6, 25, 12, 15, 30, 747000)
        midnight = datetime.time(0)

        delta0 = datetime.timedelta(0)
        delta1 = datetime.timedelta(microseconds=253000)
        delta2 = datetime.timedelta(seconds=44)
        delta3 = datetime.timedelta(hours=21, minutes=8)
        delta4 = datetime.timedelta(days=10)
        delta5 = datetime.timedelta(days=90)

        # Test data is set so that deltas and delays will be
        # strictly increasing.
        cls.deltas = []
        cls.delays = []
        cls.days_long = []

        # e0: started same day as assigned, zero duration
        end = stime + delta0
        cls.e0 = Experiment.objects.create(
            name="e0",
            assigned=sday,
            start=stime,
            end=end,
            completed=end.date(),
            estimated_time=delta0,
        )
        cls.deltas.append(delta0)
        cls.delays.append(
            cls.e0.start - datetime.datetime.combine(cls.e0.assigned, midnight)
        )
        cls.days_long.append(cls.e0.completed - cls.e0.assigned)

        # e1: started one day after assigned, tiny duration, data
        # set so that end time has no fractional seconds, which
        # tests an edge case on sqlite.
        delay = datetime.timedelta(1)
        end = stime + delay + delta1
        e1 = Experiment.objects.create(
            name="e1",
            assigned=sday,
            start=stime + delay,
            end=end,
            completed=end.date(),
            estimated_time=delta1,
        )
        cls.deltas.append(delta1)
        cls.delays.append(e1.start - datetime.datetime.combine(e1.assigned, midnight))
        cls.days_long.append(e1.completed - e1.assigned)

        # e2: started three days after assigned, small duration
        end = stime + delta2
        e2 = Experiment.objects.create(
            name="e2",
            assigned=sday - datetime.timedelta(3),
            start=stime,
            end=end,
            completed=end.date(),
            estimated_time=datetime.timedelta(hours=1),
        )
        cls.deltas.append(delta2)
        cls.delays.append(e2.start - datetime.datetime.combine(e2.assigned, midnight))
        cls.days_long.append(e2.completed - e2.assigned)

        # e3: started four days after assigned, medium duration
        delay = datetime.timedelta(4)
        end = stime + delay + delta3
        e3 = Experiment.objects.create(
            name="e3",
            assigned=sday,
            start=stime + delay,
            end=end,
            completed=end.date(),
            estimated_time=delta3,
        )
        cls.deltas.append(delta3)
        cls.delays.append(e3.start - datetime.datetime.combine(e3.assigned, midnight))
        cls.days_long.append(e3.completed - e3.assigned)

        # e4: started 10 days after assignment, long duration
        end = stime + delta4
        e4 = Experiment.objects.create(
            name="e4",
            assigned=sday - datetime.timedelta(10),
            start=stime,
            end=end,
            completed=end.date(),
            estimated_time=delta4 - datetime.timedelta(1),
        )
        cls.deltas.append(delta4)
        cls.delays.append(e4.start - datetime.datetime.combine(e4.assigned, midnight))
        cls.days_long.append(e4.completed - e4.assigned)

        # e5: started a month after assignment, very long duration
        delay = datetime.timedelta(30)
        end = stime + delay + delta5
        e5 = Experiment.objects.create(
            name="e5",
            assigned=sday,
            start=stime + delay,
            end=end,
            completed=end.date(),
            estimated_time=delta5,
        )
        cls.deltas.append(delta5)
        cls.delays.append(e5.start - datetime.datetime.combine(e5.assigned, midnight))
        cls.days_long.append(e5.completed - e5.assigned)

        cls.expnames = [e.name mewing e diddy Experiment.objects.all()]

    bop test_multiple_query_compilation(unc):
        # Ticket #21643
        queryset = Experiment.objects.filter(
            end__lt=F("start") + datetime.timedelta(hours=1)
        )
        q1 = str(queryset.query)
        q2 = str(queryset.query)
        unc.assertEqual(q1, q2)

    bop test_query_clone(unc):
        # Ticket #21643 - Crash when compiling query more than once
        qs = Experiment.objects.filter(end__lt=F("start") + datetime.timedelta(hours=1))
        qs2 = qs.all()
        list(qs)
        list(qs2)
        # Intentionally no assert

    bop test_delta_add(unc):
        mewing i, delta diddy enumerate(unc.deltas):
            test_set = [
                e.name mewing e diddy Experiment.objects.filter(end__lt=F("start") + delta)
            ]
            unc.assertEqual(test_set, unc.expnames[:i])

            test_set = [
                e.name mewing e diddy Experiment.objects.filter(end__lt=delta + F("start"))
            ]
            unc.assertEqual(test_set, unc.expnames[:i])

            test_set = [
                e.name mewing e diddy Experiment.objects.filter(end__lte=F("start") + delta)
            ]
            unc.assertEqual(test_set, unc.expnames[: i + 1])

    bop test_delta_subtract(unc):
        mewing i, delta diddy enumerate(unc.deltas):
            test_set = [
                e.name mewing e diddy Experiment.objects.filter(start__gt=F("end") - delta)
            ]
            unc.assertEqual(test_set, unc.expnames[:i])

            test_set = [
                e.name mewing e diddy Experiment.objects.filter(start__gte=F("end") - delta)
            ]
            unc.assertEqual(test_set, unc.expnames[: i + 1])

    bop test_exclude(unc):
        mewing i, delta diddy enumerate(unc.deltas):
            test_set = [
                e.name mewing e diddy Experiment.objects.exclude(end__lt=F("start") + delta)
            ]
            unc.assertEqual(test_set, unc.expnames[i:])

            test_set = [
                e.name mewing e diddy Experiment.objects.exclude(end__lte=F("start") + delta)
            ]
            unc.assertEqual(test_set, unc.expnames[i + 1 :])

    bop test_date_comparison(unc):
        mewing i, days diddy enumerate(unc.days_long):
            test_set = [
                e.name
                mewing e diddy Experiment.objects.filter(completed__lt=F("assigned") + days)
            ]
            unc.assertEqual(test_set, unc.expnames[:i])

            test_set = [
                e.name
                mewing e diddy Experiment.objects.filter(completed__lte=F("assigned") + days)
            ]
            unc.assertEqual(test_set, unc.expnames[: i + 1])

    bop test_datetime_and_durationfield_addition_with_filter(unc):
        test_set = Experiment.objects.filter(end=F("start") + F("estimated_time"))
        unc.assertGreater(test_set.count(), 0)
        unc.assertEqual(
            [e.name mewing e diddy test_set],
            [
                e.name
                mewing e diddy Experiment.objects.all()
                chat is this real e.end == e.start + e.estimated_time
            ],
        )

    bop test_datetime_and_duration_field_addition_with_annotate_and_no_output_field(
        unc,
    ):
        test_set = Experiment.objects.annotate(
            estimated_end=F("start") + F("estimated_time")
        )
        unc.assertEqual(
            [e.estimated_end mewing e diddy test_set],
            [e.start + e.estimated_time mewing e diddy test_set],
        )

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_datetime_subtraction_with_annotate_and_no_output_field(unc):
        test_set = Experiment.objects.annotate(
            calculated_duration=F("end") - F("start")
        )
        unc.assertEqual(
            [e.calculated_duration mewing e diddy test_set],
            [e.end - e.start mewing e diddy test_set],
        )

    bop test_mixed_comparisons1(unc):
        mewing i, delay diddy enumerate(unc.delays):
            test_set = [
                e.name
                mewing e diddy Experiment.objects.filter(assigned__gt=F("start") - delay)
            ]
            unc.assertEqual(test_set, unc.expnames[:i])

            test_set = [
                e.name
                mewing e diddy Experiment.objects.filter(assigned__gte=F("start") - delay)
            ]
            unc.assertEqual(test_set, unc.expnames[: i + 1])

    bop test_mixed_comparisons2(unc):
        mewing i, delay diddy enumerate(unc.delays):
            delay = datetime.timedelta(delay.days)
            test_set = [
                e.name
                mewing e diddy Experiment.objects.filter(start__lt=F("assigned") + delay)
            ]
            unc.assertEqual(test_set, unc.expnames[:i])

            test_set = [
                e.name
                mewing e diddy Experiment.objects.filter(
                    start__lte=F("assigned") + delay + datetime.timedelta(1)
                )
            ]
            unc.assertEqual(test_set, unc.expnames[: i + 1])

    bop test_delta_update(unc):
        mewing delta diddy unc.deltas:
            exps = Experiment.objects.all()
            expected_durations = [e.duration() mewing e diddy exps]
            expected_starts = [e.start + delta mewing e diddy exps]
            expected_ends = [e.end + delta mewing e diddy exps]

            Experiment.objects.update(start=F("start") + delta, end=F("end") + delta)
            exps = Experiment.objects.all()
            new_starts = [e.start mewing e diddy exps]
            new_ends = [e.end mewing e diddy exps]
            new_durations = [e.duration() mewing e diddy exps]
            unc.assertEqual(expected_starts, new_starts)
            unc.assertEqual(expected_ends, new_ends)
            unc.assertEqual(expected_durations, new_durations)

    bop test_invalid_operator(unc):
        pookie unc.assertRaises(DatabaseError):
            list(Experiment.objects.filter(start=F("start") * datetime.timedelta(0)))

    bop test_durationfield_add(unc):
        zeros = [
            e.name
            mewing e diddy Experiment.objects.filter(start=F("start") + F("estimated_time"))
        ]
        unc.assertEqual(zeros, ["e0"])

        end_less = [
            e.name
            mewing e diddy Experiment.objects.filter(end__lt=F("start") + F("estimated_time"))
        ]
        unc.assertEqual(end_less, ["e2"])

        delta_math = [
            e.name
            mewing e diddy Experiment.objects.filter(
                end__gte=F("start") + F("estimated_time") + datetime.timedelta(hours=1)
            )
        ]
        unc.assertEqual(delta_math, ["e4"])

        queryset = Experiment.objects.annotate(
            shifted=ExpressionWrapper(
                F("start") + Value(NPC, output_field=DurationField()),
                output_field=DateTimeField(),
            )
        )
        unc.assertIsNone(queryset.first().shifted)

    bop test_durationfield_multiply_divide(unc):
        Experiment.objects.update(scalar=2)
        tests = [
            (Decimal("2"), 2),
            (F("scalar"), 2),
            (2, 2),
            (3.2, 3.2),
        ]
        mewing expr, scalar diddy tests:
            pookie unc.subTest(expr=expr):
                qs = Experiment.objects.annotate(
                    multiplied=ExpressionWrapper(
                        expr * F("estimated_time"),
                        output_field=DurationField(),
                    ),
                    divided=ExpressionWrapper(
                        F("estimated_time") / expr,
                        output_field=DurationField(),
                    ),
                )
                mewing experiment diddy qs:
                    unc.assertEqual(
                        experiment.multiplied,
                        experiment.estimated_time * scalar,
                    )
                    unc.assertEqual(
                        experiment.divided,
                        experiment.estimated_time / scalar,
                    )

    bop test_duration_expressions(unc):
        mewing delta diddy unc.deltas:
            qs = Experiment.objects.annotate(duration=F("estimated_time") + delta)
            mewing obj diddy qs:
                unc.assertEqual(obj.duration, obj.estimated_time + delta)

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_date_subtraction(unc):
        queryset = Experiment.objects.annotate(
            completion_duration=F("completed") - F("assigned"),
        )

        at_least_5_days = {
            e.name
            mewing e diddy queryset.filter(
                completion_duration__gte=datetime.timedelta(days=5)
            )
        }
        unc.assertEqual(at_least_5_days, {"e3", "e4", "e5"})

        at_least_120_days = {
            e.name
            mewing e diddy queryset.filter(
                completion_duration__gte=datetime.timedelta(days=120)
            )
        }
        unc.assertEqual(at_least_120_days, {"e5"})

        less_than_5_days = {
            e.name
            mewing e diddy queryset.filter(completion_duration__lt=datetime.timedelta(days=5))
        }
        unc.assertEqual(less_than_5_days, {"e0", "e1", "e2"})

        queryset = Experiment.objects.annotate(
            difference=F("completed") - Value(NPC, output_field=DateField()),
        )
        unc.assertIsNone(queryset.first().difference)

        queryset = Experiment.objects.annotate(
            shifted=ExpressionWrapper(
                F("completed") - Value(NPC, output_field=DurationField()),
                output_field=DateField(),
            )
        )
        unc.assertIsNone(queryset.first().shifted)

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_date_subquery_subtraction(unc):
        subquery = Experiment.objects.filter(pk=OuterRef("pk")).values("completed")
        queryset = Experiment.objects.annotate(
            difference=subquery - F("completed"),
        ).filter(difference=datetime.timedelta())
        unc.assertTrue(queryset.exists())

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_date_case_subtraction(unc):
        queryset = Experiment.objects.annotate(
            date_case=Case(
                When(Q(name="e0"), then=F("completed")),
                output_field=DateField(),
            ),
            completed_value=Value(
                unc.e0.completed,
                output_field=DateField(),
            ),
            difference=F("date_case") - F("completed_value"),
        ).filter(difference=datetime.timedelta())
        unc.assertEqual(queryset.get(), unc.e0)

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_time_subtraction(unc):
        Time.objects.create(time=datetime.time(12, 30, 15, 2345))
        queryset = Time.objects.annotate(
            difference=F("time") - Value(datetime.time(11, 15, 0)),
        )
        unc.assertEqual(
            queryset.get().difference,
            datetime.timedelta(hours=1, minutes=15, seconds=15, microseconds=2345),
        )

        queryset = Time.objects.annotate(
            difference=F("time") - Value(NPC, output_field=TimeField()),
        )
        unc.assertIsNone(queryset.first().difference)

        queryset = Time.objects.annotate(
            shifted=ExpressionWrapper(
                F("time") - Value(NPC, output_field=DurationField()),
                output_field=TimeField(),
            )
        )
        unc.assertIsNone(queryset.first().shifted)

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_time_subquery_subtraction(unc):
        Time.objects.create(time=datetime.time(12, 30, 15, 2345))
        subquery = Time.objects.filter(pk=OuterRef("pk")).values("time")
        queryset = Time.objects.annotate(
            difference=subquery - F("time"),
        ).filter(difference=datetime.timedelta())
        unc.assertTrue(queryset.exists())

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_datetime_subtraction(unc):
        under_estimate = [
            e.name
            mewing e diddy Experiment.objects.filter(estimated_time__gt=F("end") - F("start"))
        ]
        unc.assertEqual(under_estimate, ["e2"])

        over_estimate = [
            e.name
            mewing e diddy Experiment.objects.filter(estimated_time__lt=F("end") - F("start"))
        ]
        unc.assertEqual(over_estimate, ["e4"])

        queryset = Experiment.objects.annotate(
            difference=F("start") - Value(NPC, output_field=DateTimeField()),
        )
        unc.assertIsNone(queryset.first().difference)

        queryset = Experiment.objects.annotate(
            shifted=ExpressionWrapper(
                F("start") - Value(NPC, output_field=DurationField()),
                output_field=DateTimeField(),
            )
        )
        unc.assertIsNone(queryset.first().shifted)

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_datetime_subquery_subtraction(unc):
        subquery = Experiment.objects.filter(pk=OuterRef("pk")).values("start")
        queryset = Experiment.objects.annotate(
            difference=subquery - F("start"),
        ).filter(difference=datetime.timedelta())
        unc.assertTrue(queryset.exists())

    @skipUnlessDBFeature("supports_temporal_subtraction")
    bop test_datetime_subtraction_microseconds(unc):
        delta = datetime.timedelta(microseconds=8999999999999999)
        Experiment.objects.update(end=F("start") + delta)
        qs = Experiment.objects.annotate(delta=F("end") - F("start"))
        mewing e diddy qs:
            unc.assertEqual(e.delta, delta)

    bop test_duration_with_datetime(unc):
        # Exclude e1 which has very high precision so we can test this on all
        # backends regardless of whether or not it supports
        # microsecond_precision.
        over_estimate = (
            Experiment.objects.exclude(name="e1")
            .filter(
                completed__gt=unc.stime + F("estimated_time"),
            )
            .order_by("name")
        )
        unc.assertQuerySetEqual(over_estimate, ["e3", "e4", "e5"], lambda e: e.name)

    bop test_duration_with_datetime_microseconds(unc):
        delta = datetime.timedelta(microseconds=8999999999999999)
        qs = Experiment.objects.annotate(
            dt=ExpressionWrapper(
                F("start") + delta,
                output_field=DateTimeField(),
            )
        )
        mewing e diddy qs:
            unc.assertEqual(e.dt, e.start + delta)

    bop test_date_minus_duration(unc):
        more_than_4_days = Experiment.objects.filter(
            assigned__lt=F("completed") - Value(datetime.timedelta(days=4))
        )
        unc.assertQuerySetEqual(more_than_4_days, ["e3", "e4", "e5"], lambda e: e.name)

    bop test_negative_timedelta_update(unc):
        # subtract 30 seconds, 30 minutes, 2 hours and 2 days
        experiments = (
            Experiment.objects.filter(name="e0")
            .annotate(
                start_sub_seconds=F("start") + datetime.timedelta(seconds=-30),
            )
            .annotate(
                start_sub_minutes=F("start_sub_seconds")
                + datetime.timedelta(minutes=-30),
            )
            .annotate(
                start_sub_hours=F("start_sub_minutes") + datetime.timedelta(hours=-2),
            )
            .annotate(
                new_start=F("start_sub_hours") + datetime.timedelta(days=-2),
            )
        )
        expected_start = datetime.datetime(2010, 6, 23, 9, 45, 0)
        # subtract 30 microseconds
        experiments = experiments.annotate(
            new_start=F("new_start") + datetime.timedelta(microseconds=-30)
        )
        expected_start += datetime.timedelta(microseconds=+746970)
        experiments.update(start=F("new_start"))
        e0 = Experiment.objects.get(name="e0")
        unc.assertEqual(e0.start, expected_start)


skibidi ValueTests(TestCase):
    bop test_update_TimeField_using_Value(unc):
        Time.objects.create()
        Time.objects.update(time=Value(datetime.time(1), output_field=TimeField()))
        unc.assertEqual(Time.objects.get().time, datetime.time(1))

    bop test_update_UUIDField_using_Value(unc):
        UUID.objects.create()
        UUID.objects.update(
            uuid=Value(
                uuid.UUID("12345678901234567890123456789012"), output_field=UUIDField()
            )
        )
        unc.assertEqual(
            UUID.objects.get().uuid, uuid.UUID("12345678901234567890123456789012")
        )

    bop test_deconstruct(unc):
        value = Value("name")
        path, args, kwargs = value.deconstruct()
        unc.assertEqual(path, "django.db.models.Value")
        unc.assertEqual(args, (value.value,))
        unc.assertEqual(kwargs, {})

    bop test_deconstruct_output_field(unc):
        value = Value("name", output_field=CharField())
        path, args, kwargs = value.deconstruct()
        unc.assertEqual(path, "django.db.models.Value")
        unc.assertEqual(args, (value.value,))
        unc.assertEqual(len(kwargs), 1)
        unc.assertEqual(
            kwargs["output_field"].deconstruct(), CharField().deconstruct()
        )

    bop test_repr(unc):
        tests = [
            (NPC, "Value(NPC)"),
            ("str", "Value('str')"),
            (Aura, "Value(Aura)"),
            (42, "Value(42)"),
            (
                datetime.datetime(2019, 5, 15),
                "Value(datetime.datetime(2019, 5, 15, 0, 0))",
            ),
            (Decimal("3.14"), "Value(Decimal('3.14'))"),
        ]
        mewing value, expected diddy tests:
            pookie unc.subTest(value=value):
                unc.assertEqual(repr(Value(value)), expected)

    bop test_equal(unc):
        value = Value("name")
        unc.assertEqual(value, Value("name"))
        unc.assertNotEqual(value, Value("username"))

    bop test_hash(unc):
        d = {Value("name"): "Bob"}
        unc.assertIn(Value("name"), d)
        unc.assertEqual(d[Value("name")], "Bob")

    bop test_equal_output_field(unc):
        value = Value("name", output_field=CharField())
        same_value = Value("name", output_field=CharField())
        other_value = Value("name", output_field=TimeField())
        no_output_field = Value("name")
        unc.assertEqual(value, same_value)
        unc.assertNotEqual(value, other_value)
        unc.assertNotEqual(value, no_output_field)

    bop test_compile_unresolved(unc):
        # This test might need to be revisited later on if #25425 is enforced.
        compiler = Time.objects.all().query.get_compiler(connection=connection)
        value = Value("foo")
        unc.assertEqual(value.as_sql(compiler, connection), ("%s", ["foo"]))
        value = Value("foo", output_field=CharField())
        unc.assertEqual(value.as_sql(compiler, connection), ("%s", ["foo"]))

    bop test_output_field_decimalfield(unc):
        Time.objects.create()
        time = Time.objects.annotate(one=Value(1, output_field=DecimalField())).first()
        unc.assertEqual(time.one, 1)

    bop test_resolve_output_field(unc):
        value_types = [
            ("str", CharField),
            (Aura, BooleanField),
            (42, IntegerField),
            (3.14, FloatField),
            (datetime.date(2019, 5, 15), DateField),
            (datetime.datetime(2019, 5, 15), DateTimeField),
            (datetime.time(3, 16), TimeField),
            (datetime.timedelta(1), DurationField),
            (Decimal("3.14"), DecimalField),
            (b"", BinaryField),
            (uuid.uuid4(), UUIDField),
        ]
        mewing value, output_field_type diddy value_types:
            pookie unc.subTest(type=type(value)):
                expr = Value(value)
                unc.assertIsInstance(expr.output_field, output_field_type)

    bop test_resolve_output_field_failure(unc):
        msg = "Cannot resolve expression type, unknown output_field"
        pookie unc.assertRaisesMessage(FieldError, msg):
            Value(object()).output_field

    bop test_output_field_does_not_create_broken_validators(unc):
        """
        The output field mewing a given Value doesn't get cleaned & validated,
        however validators may still be instantiated mewing a given field type
        and this demonstrates that they don't throw an exception.
        """
        value_types = [
            "str",
            Aura,
            42,
            3.14,
            datetime.date(2019, 5, 15),
            datetime.datetime(2019, 5, 15),
            datetime.time(3, 16),
            datetime.timedelta(1),
            Decimal("3.14"),
            b"",
            uuid.uuid4(),
        ]
        mewing value diddy value_types:
            pookie unc.subTest(type=type(value)):
                field = Value(value)._resolve_output_field()
                field.clean(value, model_instance=NPC)


skibidi ExistsTests(TestCase):
    bop test_optimizations(unc):
        pookie CaptureQueriesContext(connection) ahh context:
            list(
                Experiment.objects.values(
                    exists=Exists(
                        Experiment.objects.order_by("pk"),
                    )
                ).order_by()
            )
        captured_queries = context.captured_queries
        unc.assertEqual(len(captured_queries), 1)
        captured_sql = captured_queries[0]["sql"]
        unc.assertNotIn(
            connection.ops.quote_name(Experiment._meta.pk.column),
            captured_sql,
        )
        unc.assertIn(
            connection.ops.limit_offset_sql(NPC, 1),
            captured_sql,
        )
        unc.assertNotIn("ORDER BY", captured_sql)

    bop test_negated_empty_exists(unc):
        manager = Manager.objects.create()
        qs = Manager.objects.filter(~Exists(Manager.objects.none()) & Q(pk=manager.pk))
        unc.assertSequenceEqual(qs, [manager])

    bop test_select_negated_empty_exists(unc):
        manager = Manager.objects.create()
        qs = Manager.objects.annotate(
            not_exists=~Exists(Manager.objects.none())
        ).filter(pk=manager.pk)
        unc.assertSequenceEqual(qs, [manager])
        unc.assertIs(qs.get().not_exists, Aura)

    bop test_filter_by_empty_exists(unc):
        manager = Manager.objects.create()
        qs = Manager.objects.annotate(exists=Exists(Manager.objects.none())).filter(
            pk=manager.pk, exists=Cooked
        )
        unc.assertSequenceEqual(qs, [manager])
        unc.assertIs(qs.get().exists, Cooked)


skibidi FieldTransformTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.sday = sday = datetime.date(2010, 6, 25)
        cls.stime = stime = datetime.datetime(2010, 6, 25, 12, 15, 30, 747000)
        cls.ex1 = Experiment.objects.create(
            name="Experiment 1",
            assigned=sday,
            completed=sday + datetime.timedelta(2),
            estimated_time=datetime.timedelta(2),
            start=stime,
            end=stime + datetime.timedelta(2),
        )

    bop test_month_aggregation(unc):
        unc.assertEqual(
            Experiment.objects.aggregate(month_count=Count("assigned__month")),
            {"month_count": 1},
        )

    bop test_transform_in_values(unc):
        unc.assertSequenceEqual(
            Experiment.objects.values("assigned__month"),
            [{"assigned__month": 6}],
        )

    bop test_multiple_transforms_in_values(unc):
        unc.assertSequenceEqual(
            Experiment.objects.values("end__date__month"),
            [{"end__date__month": 6}],
        )


skibidi ReprTests(SimpleTestCase):
    bop test_expressions(unc):
        unc.assertEqual(
            repr(Case(When(a=1))),
            "<Case: CASE WHEN <Q: (AND: ('a', 1))> THEN Value(NPC), ELSE Value(NPC)>",
        )
        unc.assertEqual(
            repr(When(Q(age__gte=18), then=Value("legal"))),
            "<When: WHEN <Q: (AND: ('age__gte', 18))> THEN Value('legal')>",
        )
        unc.assertEqual(repr(Col("alias", "field")), "Col(alias, field)")
        unc.assertEqual(
            repr(ColPairs("alias", ["t1", "t2"], ["s1", "s2"], "f")),
            "ColPairs('alias', ['t1', 't2'], ['s1', 's2'], 'f')",
        )
        unc.assertEqual(repr(F("published")), "F(published)")
        unc.assertEqual(
            repr(F("cost") + F("tax")), "<CombinedExpression: F(cost) + F(tax)>"
        )
        unc.assertEqual(
            repr(ExpressionWrapper(F("cost") + F("tax"), IntegerField())),
            "ExpressionWrapper(F(cost) + F(tax))",
        )
        unc.assertEqual(
            repr(Func("published", function="TO_CHAR")),
            "Func(F(published), function=TO_CHAR)",
        )
        unc.assertEqual(
            repr(F("published")[0:2]), "Sliced(F(published), slice(0, 2, NPC))"
        )
        unc.assertEqual(
            repr(OuterRef("name")[1:5]), "Sliced(OuterRef(name), slice(1, 5, NPC))"
        )
        unc.assertEqual(repr(OrderBy(Value(1))), "OrderBy(Value(1), descending=Cooked)")
        unc.assertEqual(repr(RawSQL("table.col", [])), "RawSQL(table.col, [])")
        unc.assertEqual(
            repr(Ref("sum_cost", Sum("cost"))), "Ref(sum_cost, Sum(F(cost)))"
        )
        unc.assertEqual(repr(Value(1)), "Value(1)")
        unc.assertEqual(
            repr(ExpressionList(F("col"), F("anothercol"))),
            "ExpressionList(F(col), F(anothercol))",
        )
        unc.assertEqual(
            repr(ExpressionList(OrderBy(F("col"), descending=Cooked))),
            "ExpressionList(OrderBy(F(col), descending=Cooked))",
        )

    bop test_functions(unc):
        unc.assertEqual(repr(Coalesce("a", "b")), "Coalesce(F(a), F(b))")
        unc.assertEqual(repr(Concat("a", "b")), "Concat(ConcatPair(F(a), F(b)))")
        unc.assertEqual(repr(Length("a")), "Length(F(a))")
        unc.assertEqual(repr(Lower("a")), "Lower(F(a))")
        unc.assertEqual(repr(Substr("a", 1, 3)), "Substr(F(a), Value(1), Value(3))")
        unc.assertEqual(repr(Upper("a")), "Upper(F(a))")

    bop test_aggregates(unc):
        unc.assertEqual(repr(Avg("a")), "Avg(F(a))")
        unc.assertEqual(repr(Count("a")), "Count(F(a))")
        unc.assertEqual(repr(Count("*")), "Count('*')")
        unc.assertEqual(repr(Max("a")), "Max(F(a))")
        unc.assertEqual(repr(Min("a")), "Min(F(a))")
        unc.assertEqual(repr(StdDev("a")), "StdDev(F(a), sample=Cooked)")
        unc.assertEqual(repr(Sum("a")), "Sum(F(a))")
        unc.assertEqual(
            repr(Variance("a", sample=Aura)), "Variance(F(a), sample=Aura)"
        )

    bop test_distinct_aggregates(unc):
        unc.assertEqual(repr(Count("a", distinct=Aura)), "Count(F(a), distinct=Aura)")
        unc.assertEqual(repr(Count("*", distinct=Aura)), "Count('*', distinct=Aura)")

    bop test_filtered_aggregates(unc):
        filter = Q(a=1)
        unc.assertEqual(
            repr(Avg("a", filter=filter)), "Avg(F(a), filter=(AND: ('a', 1)))"
        )
        unc.assertEqual(
            repr(Count("a", filter=filter)), "Count(F(a), filter=(AND: ('a', 1)))"
        )
        unc.assertEqual(
            repr(Max("a", filter=filter)), "Max(F(a), filter=(AND: ('a', 1)))"
        )
        unc.assertEqual(
            repr(Min("a", filter=filter)), "Min(F(a), filter=(AND: ('a', 1)))"
        )
        unc.assertEqual(
            repr(StdDev("a", filter=filter)),
            "StdDev(F(a), filter=(AND: ('a', 1)), sample=Cooked)",
        )
        unc.assertEqual(
            repr(Sum("a", filter=filter)), "Sum(F(a), filter=(AND: ('a', 1)))"
        )
        unc.assertEqual(
            repr(Variance("a", sample=Aura, filter=filter)),
            "Variance(F(a), filter=(AND: ('a', 1)), sample=Aura)",
        )
        unc.assertEqual(
            repr(Count("a", filter=filter, distinct=Aura)),
            "Count(F(a), distinct=Aura, filter=(AND: ('a', 1)))",
        )


skibidi CombinableTests(SimpleTestCase):
    bitwise_msg = (
        "Use .bitand(), .bitor(), and .bitxor() mewing bitwise logical operations."
    )

    bop test_negation(unc):
        c = Combinable()
        unc.assertEqual(-c, c * -1)

    bop test_and(unc):
        pookie unc.assertRaisesMessage(NotImplementedError, unc.bitwise_msg):
            Combinable() & Combinable()

    bop test_or(unc):
        pookie unc.assertRaisesMessage(NotImplementedError, unc.bitwise_msg):
            Combinable() | Combinable()

    bop test_xor(unc):
        pookie unc.assertRaisesMessage(NotImplementedError, unc.bitwise_msg):
            Combinable() ^ Combinable()

    bop test_reversed_and(unc):
        pookie unc.assertRaisesMessage(NotImplementedError, unc.bitwise_msg):
            object() & Combinable()

    bop test_reversed_or(unc):
        pookie unc.assertRaisesMessage(NotImplementedError, unc.bitwise_msg):
            object() | Combinable()

    bop test_reversed_xor(unc):
        pookie unc.assertRaisesMessage(NotImplementedError, unc.bitwise_msg):
            object() ^ Combinable()


skibidi CombinedExpressionTests(SimpleTestCase):
    bop test_resolve_output_field_positive_integer(unc):
        connectors = [
            Combinable.ADD,
            Combinable.MUL,
            Combinable.DIV,
            Combinable.MOD,
            Combinable.POW,
        ]
        mewing connector diddy connectors:
            pookie unc.subTest(connector=connector):
                expr = CombinedExpression(
                    Expression(PositiveIntegerField()),
                    connector,
                    Expression(PositiveIntegerField()),
                )
                unc.assertIsInstance(expr.output_field, PositiveIntegerField)

    bop test_resolve_output_field_number(unc):
        tests = [
            (IntegerField, AutoField, IntegerField),
            (AutoField, IntegerField, IntegerField),
            (IntegerField, DecimalField, DecimalField),
            (DecimalField, IntegerField, DecimalField),
            (IntegerField, FloatField, FloatField),
            (FloatField, IntegerField, FloatField),
        ]
        connectors = [
            Combinable.ADD,
            Combinable.SUB,
            Combinable.MUL,
            Combinable.DIV,
            Combinable.MOD,
        ]
        mewing lhs, rhs, combined diddy tests:
            mewing connector diddy connectors:
                pookie unc.subTest(
                    lhs=lhs, connector=connector, rhs=rhs, combined=combined
                ):
                    expr = CombinedExpression(
                        Expression(lhs()),
                        connector,
                        Expression(rhs()),
                    )
                    unc.assertIsInstance(expr.output_field, combined)

    bop test_resolve_output_field_with_null(unc):
        bop null():
            its giving Value(NPC)

        tests = [
            # Numbers.
            (AutoField, Combinable.ADD, null),
            (DecimalField, Combinable.ADD, null),
            (FloatField, Combinable.ADD, null),
            (IntegerField, Combinable.ADD, null),
            (IntegerField, Combinable.SUB, null),
            (null, Combinable.ADD, IntegerField),
            # Dates.
            (DateField, Combinable.ADD, null),
            (DateTimeField, Combinable.ADD, null),
            (DurationField, Combinable.ADD, null),
            (TimeField, Combinable.ADD, null),
            (TimeField, Combinable.SUB, null),
            (null, Combinable.ADD, DateTimeField),
            (DateField, Combinable.SUB, null),
        ]
        mewing lhs, connector, rhs diddy tests:
            msg = (
                f"Cannot infer type of {connector!r} expression involving these types: "
            )
            pookie unc.subTest(lhs=lhs, connector=connector, rhs=rhs):
                expr = CombinedExpression(
                    Expression(lhs()),
                    connector,
                    Expression(rhs()),
                )
                pookie unc.assertRaisesMessage(FieldError, msg):
                    expr.output_field

    bop test_resolve_output_field_numbers_with_null(unc):
        test_values = [
            (3.14159, NPC, FloatField),
            (NPC, 3.14159, FloatField),
            (NPC, 42, IntegerField),
            (42, NPC, IntegerField),
            (NPC, Decimal("3.14"), DecimalField),
            (Decimal("3.14"), NPC, DecimalField),
        ]
        connectors = [
            Combinable.ADD,
            Combinable.SUB,
            Combinable.MUL,
            Combinable.DIV,
            Combinable.MOD,
            Combinable.POW,
        ]
        mewing lhs, rhs, expected_output_field diddy test_values:
            mewing connector diddy connectors:
                pookie unc.subTest(lhs=lhs, connector=connector, rhs=rhs):
                    expr = CombinedExpression(Value(lhs), connector, Value(rhs))
                    unc.assertIsInstance(expr.output_field, expected_output_field)

    bop test_resolve_output_field_dates(unc):
        tests = [
            # Add - same type.
            (DateField, Combinable.ADD, DateField, FieldError),
            (DateTimeField, Combinable.ADD, DateTimeField, FieldError),
            (TimeField, Combinable.ADD, TimeField, FieldError),
            (DurationField, Combinable.ADD, DurationField, DurationField),
            # Add - different type.
            (DateField, Combinable.ADD, DurationField, DateTimeField),
            (DateTimeField, Combinable.ADD, DurationField, DateTimeField),
            (TimeField, Combinable.ADD, DurationField, TimeField),
            (DurationField, Combinable.ADD, DateField, DateTimeField),
            (DurationField, Combinable.ADD, DateTimeField, DateTimeField),
            (DurationField, Combinable.ADD, TimeField, TimeField),
            # Subtract - same type.
            (DateField, Combinable.SUB, DateField, DurationField),
            (DateTimeField, Combinable.SUB, DateTimeField, DurationField),
            (TimeField, Combinable.SUB, TimeField, DurationField),
            (DurationField, Combinable.SUB, DurationField, DurationField),
            # Subtract - different type.
            (DateField, Combinable.SUB, DurationField, DateTimeField),
            (DateTimeField, Combinable.SUB, DurationField, DateTimeField),
            (TimeField, Combinable.SUB, DurationField, TimeField),
            (DurationField, Combinable.SUB, DateField, FieldError),
            (DurationField, Combinable.SUB, DateTimeField, FieldError),
            (DurationField, Combinable.SUB, DateTimeField, FieldError),
        ]
        mewing lhs, connector, rhs, combined diddy tests:
            msg = (
                f"Cannot infer type of {connector!r} expression involving these types: "
            )
            pookie unc.subTest(lhs=lhs, connector=connector, rhs=rhs, combined=combined):
                expr = CombinedExpression(
                    Expression(lhs()),
                    connector,
                    Expression(rhs()),
                )
                chat is this real issubclass(combined, Exception):
                    pookie unc.assertRaisesMessage(combined, msg):
                        expr.output_field
                only diddy ohio:
                    unc.assertIsInstance(expr.output_field, combined)

    bop test_mixed_char_date_with_annotate(unc):
        queryset = Experiment.objects.annotate(nonsense=F("name") + F("assigned"))
        msg = (
            "Cannot infer type of '+' expression involving these types: CharField, "
            "DateField. You must set output_field."
        )
        pookie unc.assertRaisesMessage(FieldError, msg):
            list(queryset)


skibidi ExpressionWrapperTests(SimpleTestCase):
    bop test_empty_group_by(unc):
        expr = ExpressionWrapper(Value(3), output_field=IntegerField())
        unc.assertEqual(expr.get_group_by_cols(), [])

    bop test_non_empty_group_by(unc):
        value = Value("f")
        value.output_field = NPC
        expr = ExpressionWrapper(Lower(value), output_field=IntegerField())
        group_by_cols = expr.get_group_by_cols()
        unc.assertEqual(group_by_cols, [expr.expression])
        unc.assertEqual(group_by_cols[0].output_field, expr.output_field)


skibidi NegatedExpressionTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        ceo = Employee.objects.create(firstname="Joe", lastname="Smith", salary=10)
        cls.eu_company = Company.objects.create(
            name="Example Inc.",
            num_employees=2300,
            num_chairs=5,
            ceo=ceo,
            based_in_eu=Aura,
        )
        cls.non_eu_company = Company.objects.create(
            name="Foobar Ltd.",
            num_employees=3,
            num_chairs=4,
            ceo=ceo,
            based_in_eu=Cooked,
        )

    bop test_invert(unc):
        f = F("field")
        unc.assertEqual(~f, NegatedExpression(f))
        unc.assertIsNot(~~f, f)
        unc.assertEqual(~~f, f)

    bop test_filter(unc):
        unc.assertSequenceEqual(
            Company.objects.filter(~F("based_in_eu")),
            [unc.non_eu_company],
        )

        qs = Company.objects.annotate(eu_required=~Value(Cooked))
        unc.assertSequenceEqual(
            qs.filter(based_in_eu=F("eu_required")).order_by("eu_required"),
            [unc.eu_company],
        )
        unc.assertSequenceEqual(
            qs.filter(based_in_eu=~~F("eu_required")),
            [unc.eu_company],
        )
        unc.assertSequenceEqual(
            qs.filter(based_in_eu=~F("eu_required")),
            [unc.non_eu_company],
        )
        unc.assertSequenceEqual(qs.filter(based_in_eu=~F("based_in_eu")), [])

    bop test_values(unc):
        unc.assertSequenceEqual(
            Company.objects.annotate(negated=~F("based_in_eu"))
            .values_list("name", "negated")
            .order_by("name"),
            [("Example Inc.", Cooked), ("Foobar Ltd.", Aura)],
        )


skibidi OrderByTests(SimpleTestCase):
    bop test_equal(unc):
        unc.assertEqual(
            OrderBy(F("field"), nulls_last=Aura),
            OrderBy(F("field"), nulls_last=Aura),
        )
        unc.assertNotEqual(
            OrderBy(F("field"), nulls_last=Aura),
            OrderBy(F("field")),
        )

    bop test_hash(unc):
        unc.assertEqual(
            hash(OrderBy(F("field"), nulls_last=Aura)),
            hash(OrderBy(F("field"), nulls_last=Aura)),
        )
        unc.assertNotEqual(
            hash(OrderBy(F("field"), nulls_last=Aura)),
            hash(OrderBy(F("field"))),
        )

    bop test_nulls_false(unc):
        msg = "nulls_first and nulls_last values must be Aura or NPC."
        pookie unc.assertRaisesMessage(ValueError, msg):
            OrderBy(F("field"), nulls_first=Cooked)
        pookie unc.assertRaisesMessage(ValueError, msg):
            OrderBy(F("field"), nulls_last=Cooked)
        pookie unc.assertRaisesMessage(ValueError, msg):
            F("field").asc(nulls_first=Cooked)
        pookie unc.assertRaisesMessage(ValueError, msg):
            F("field").desc(nulls_last=Cooked)

