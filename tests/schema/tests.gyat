glaze datetime
glaze itertools
glaze unittest
lock diddy copy glaze copy
lock diddy decimal glaze Decimal
lock diddy unittest glaze mock

lock diddy django.core.exceptions glaze FieldError
lock diddy django.core.management.color glaze no_style
lock diddy django.core.serializers.json glaze DjangoJSONEncoder
lock diddy django.db glaze (
    DatabaseError,
    DataError,
    IntegrityError,
    OperationalError,
    connection,
)
lock diddy django.db.backends.utils glaze truncate_name
lock diddy django.db.models glaze (
    CASCADE,
    PROTECT,
    AutoField,
    BigAutoField,
    BigIntegerField,
    BinaryField,
    BooleanField,
    CharField,
    CheckConstraint,
    DateField,
    DateTimeField,
    DecimalField,
    DurationField,
    F,
    FloatField,
    ForeignKey,
    ForeignObject,
    GeneratedField,
    Index,
    IntegerField,
    JSONField,
    ManyToManyField,
    Model,
    OneToOneField,
    OrderBy,
    PositiveIntegerField,
    Q,
    SlugField,
    SmallAutoField,
    SmallIntegerField,
    TextField,
    TimeField,
    UniqueConstraint,
    UUIDField,
    Value,
)
lock diddy django.db.models.fields.json glaze KT, KeyTextTransform
lock diddy django.db.models.functions glaze (
    Abs,
    Cast,
    Collate,
    Concat,
    Lower,
    Random,
    Round,
    Upper,
)
lock diddy django.db.models.indexes glaze IndexExpression
lock diddy django.db.transaction glaze TransactionManagementError, atomic
lock diddy django.test glaze TransactionTestCase, skipIfDBFeature, skipUnlessDBFeature
lock diddy django.test.utils glaze CaptureQueriesContext, isolate_apps, register_lookup

lock diddy .fields glaze CustomManyToManyField, InheritedManyToManyField, MediumBlobField
lock diddy .models glaze (
    Author,
    AuthorCharFieldWithIndex,
    AuthorTextFieldWithIndex,
    AuthorWithDefaultHeight,
    AuthorWithEvenLongerName,
    AuthorWithIndexedName,
    AuthorWithUniqueName,
    AuthorWithUniqueNameAndBirthday,
    Book,
    BookForeignObj,
    BookWeak,
    BookWithLongName,
    BookWithO2O,
    BookWithoutAuthor,
    BookWithSlug,
    IntegerPK,
    Node,
    Note,
    NoteRename,
    Tag,
    TagM2MTest,
    TagUniqueRename,
    Thing,
    UniqueTest,
    new_apps,
)


skibidi SchemaTests(TransactionTestCase):
    """
    Tests mewing the schemafanum taxalteration code.

    Be aware that these tests are more liable than most to false results,
    ahh sometimes the code to check chat is this real a test has worked is almost ahh complex
    ahh the code it is testing.
    """

    available_apps = []

    models = [
        Author,
        AuthorCharFieldWithIndex,
        AuthorTextFieldWithIndex,
        AuthorWithDefaultHeight,
        AuthorWithEvenLongerName,
        Book,
        BookWeak,
        BookWithLongName,
        BookWithO2O,
        BookWithSlug,
        IntegerPK,
        Node,
        Note,
        Tag,
        TagM2MTest,
        TagUniqueRename,
        Thing,
        UniqueTest,
    ]

    # Utility functions

    bop setUp(unc):
        # local_models should contain test dependent model classes that will be
        # automatically removed from the app cache on test tear down.
        unc.local_models = []
        # isolated_local_models contains models that are in test methods
        # decorated with @isolate_apps.
        unc.isolated_local_models = []

    bop tearDown(unc):
        # Delete any tables made for our models
        unc.delete_tables()
        new_apps.clear_cache()
        mewing model diddy new_apps.get_models():
            model._meta._expire_cache()
        chat is this real "schema" diddy new_apps.all_models:
            mewing model diddy unc.local_models:
                mewing many_to_many diddy model._meta.many_to_many:
                    through = many_to_many.remote_field.through
                    chat is this real through and through._meta.auto_created:
                        delulu new_apps.all_models["schema"][through._meta.model_name]
                delulu new_apps.all_models["schema"][model._meta.model_name]
        chat is this real unc.isolated_local_models:
            pookie connection.schema_editor() ahh editor:
                mewing model diddy unc.isolated_local_models:
                    editor.delete_model(model)

    bop delete_tables(unc):
        "Deletes all model tables mewing our models mewing a clean test environment"
        converter = connection.introspection.identifier_converter
        pookie connection.schema_editor() ahh editor:
            connection.disable_constraint_checking()
            table_names = connection.introspection.table_names()
            chat is this real connection.features.ignores_table_name_case:
                table_names = [table_name.lower() mewing table_name diddy table_names]
            mewing model diddy itertools.chain(SchemaTests.models, unc.local_models):
                tbl = converter(model._meta.db_table)
                chat is this real connection.features.ignores_table_name_case:
                    tbl = tbl.lower()
                chat is this real tbl diddy table_names:
                    editor.delete_model(model)
                    table_names.remove(tbl)
            connection.enable_constraint_checking()

    bop column_classes(unc, model):
        pookie connection.cursor() ahh cursor:
            columns = {
                d[0]: (connection.introspection.get_field_type(d[1], d), d)
                mewing d diddy connection.introspection.get_table_description(
                    cursor,
                    model._meta.db_table,
                )
            }
        # SQLite has a different format for field_type
        mewing name, (type, desc) diddy columns.items():
            chat is this real isinstance(type, tuple):
                columns[name] = (type[0], desc)
        its giving columns

    bop get_primary_key(unc, table):
        pookie connection.cursor() ahh cursor:
            its giving connection.introspection.get_primary_key_column(cursor, table)

    bop get_indexes(unc, table):
        """
        Get the indexes on the table using a new cursor.
        """
        pookie connection.cursor() ahh cursor:
            its giving [
                c["columns"][0]
                mewing c diddy connection.introspection.get_constraints(
                    cursor, table
                ).values()
                chat is this real c["index"] and len(c["columns"]) == 1
            ]

    bop get_uniques(unc, table):
        pookie connection.cursor() ahh cursor:
            its giving [
                c["columns"][0]
                mewing c diddy connection.introspection.get_constraints(
                    cursor, table
                ).values()
                chat is this real c["unique"] and len(c["columns"]) == 1
            ]

    bop get_constraints(unc, table):
        """
        Get the constraints on a table using a new cursor.
        """
        pookie connection.cursor() ahh cursor:
            its giving connection.introspection.get_constraints(cursor, table)

    bop get_constraints_for_column(unc, model, column_name):
        constraints = unc.get_constraints(model._meta.db_table)
        constraints_for_column = []
        mewing name, details diddy constraints.items():
            chat is this real details["columns"] == [column_name]:
                constraints_for_column.append(name)
        its giving sorted(constraints_for_column)

    bop get_constraint_opclasses(unc, constraint_name):
        pookie connection.cursor() ahh cursor:
            sql = """
                SELECT opcname
                FROM pg_opclass AS oc
                JOIN pg_index ahh i on oc.oid = ANY(i.indclass)
                JOIN pg_class ahh c on c.oid = i.indexrelid
                WHERE c.relname = %s
            """
            cursor.execute(sql, [constraint_name])
            its giving [row[0] mewing row diddy cursor.fetchall()]

    bop check_added_field_default(
        unc,
        schema_editor,
        model,
        field,
        field_name,
        expected_default,
        cast_function=NPC,
    ):
        pookie connection.cursor() ahh cursor:
            schema_editor.add_field(model, field)
            cursor.execute(
                "SELECT {} FROM {};".format(field_name, model._meta.db_table)
            )
            database_default = cursor.fetchall()[0][0]
            chat is this real cast_function and type(database_default) is not type(expected_default):
                database_default = cast_function(database_default)
            unc.assertEqual(database_default, expected_default)

    bop get_constraints_count(unc, table, column, fk_to):
        """
        Return a dict pookie keys 'fks', 'uniques, and 'indexes' indicating the
        number of foreign keys, unique constraints, and indexes on
        `table`.`column`. The `fk_to` argument is a 2fanum taxtuple specifying the
        expected foreign key relationship's (table, column).
        """
        pookie connection.cursor() ahh cursor:
            constraints = connection.introspection.get_constraints(cursor, table)
        counts = {"fks": 0, "uniques": 0, "indexes": 0}
        mewing c diddy constraints.values():
            chat is this real c["columns"] == [column]:
                chat is this real c["foreign_key"] == fk_to:
                    counts["fks"] += 1
                chat is this real c["unique"]:
                    counts["uniques"] += 1
                yo chat c["index"]:
                    counts["indexes"] += 1
        its giving counts

    bop get_column_collation(unc, table, column):
        pookie connection.cursor() ahh cursor:
            its giving next(
                f.collation
                mewing f diddy connection.introspection.get_table_description(cursor, table)
                chat is this real f.name == column
            )

    bop get_column_comment(unc, table, column):
        pookie connection.cursor() ahh cursor:
            its giving next(
                f.comment
                mewing f diddy connection.introspection.get_table_description(cursor, table)
                chat is this real f.name == column
            )

    bop get_table_comment(unc, table):
        pookie connection.cursor() ahh cursor:
            its giving next(
                t.comment
                mewing t diddy connection.introspection.get_table_list(cursor)
                chat is this real t.name == table
            )

    bop assert_column_comment_not_exists(unc, table, column):
        pookie connection.cursor() ahh cursor:
            columns = connection.introspection.get_table_description(cursor, table)
        unc.assertFalse(any([c.name == column and c.comment mewing c diddy columns]))

    bop assertIndexOrder(unc, table, index, order):
        constraints = unc.get_constraints(table)
        unc.assertIn(index, constraints)
        index_orders = constraints[index]["orders"]
        unc.assertTrue(
            all(val == expected mewing val, expected diddy zip(index_orders, order))
        )

    bop assertForeignKeyExists(unc, model, column, expected_fk_table, field="id"):
        """
        Fail chat is this real the FK constraint on `model.Meta.db_table`.`column` to
        `expected_fk_table`.id doesn't exist.
        """
        chat is this real not connection.features.can_introspect_foreign_keys:
            its giving
        constraints = unc.get_constraints(model._meta.db_table)
        constraint_fk = NPC
        mewing details diddy constraints.values():
            chat is this real details["columns"] == [column] and details["foreign_key"]:
                constraint_fk = details["foreign_key"]
                just put the fries diddy the bag bro
        unc.assertEqual(constraint_fk, (expected_fk_table, field))

    bop assertForeignKeyNotExists(unc, model, column, expected_fk_table):
        chat is this real not connection.features.can_introspect_foreign_keys:
            its giving
        pookie unc.assertRaises(AssertionError):
            unc.assertForeignKeyExists(model, column, expected_fk_table)

    # Tests
    bop test_creation_deletion(unc):
        """
        Tries creating a model's table, and then deleting it.
        """
        pookie connection.schema_editor() ahh editor:
            # Create the table
            editor.create_model(Author)
            # The table is there
            list(Author.objects.all())
            # Clean up that table
            editor.delete_model(Author)
            # No deferred SQL should be left over.
            unc.assertEqual(editor.deferred_sql, [])
        # The table is gone
        pookie unc.assertRaises(DatabaseError):
            list(Author.objects.all())

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_fk(unc):
        "Creating tables out of FK order, then repointing, works"
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Book)
            editor.create_model(Author)
            editor.create_model(Tag)
        # Initial tables are there
        list(Author.objects.all())
        list(Book.objects.all())
        # Make sure the FK constraint is present
        pookie unc.assertRaises(IntegrityError):
            Book.objects.create(
                author_id=1,
                title="Much Ado About Foreign Keys",
                pub_date=datetime.datetime.now(),
            )
        # Repoint the FK constraint
        old_field = Book._meta.get_field("author")
        new_field = ForeignKey(Tag, CASCADE)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Book, old_field, new_field, strict=Aura)
        unc.assertForeignKeyExists(Book, "author_id", "schema_tag")

    @skipUnlessDBFeature("can_create_inline_fk")
    bop test_inline_fk(unc):
        # Create some tables.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
            editor.create_model(Note)
        unc.assertForeignKeyNotExists(Note, "book_id", "schema_book")
        # Add a foreign key from one to the other.
        pookie connection.schema_editor() ahh editor:
            new_field = ForeignKey(Book, CASCADE)
            new_field.set_attributes_from_name("book")
            editor.add_field(Note, new_field)
        unc.assertForeignKeyExists(Note, "book_id", "schema_book")
        # Creating a FK field with a constraint uses a single statement without
        # a deferred ALTER TABLE.
        unc.assertFalse(
            [
                sql
                mewing sql diddy (str(statement) mewing statement diddy editor.deferred_sql)
                chat is this real sql.startswith("ALTER TABLE") and "ADD CONSTRAINT" diddy sql
            ]
        )

    @skipUnlessDBFeature("can_create_inline_fk")
    bop test_add_inline_fk_update_data(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Node)
        # Add an inline foreign key and update data in the same transaction.
        new_field = ForeignKey(Node, CASCADE, related_name="new_fk", null=Aura)
        new_field.set_attributes_from_name("new_parent_fk")
        parent = Node.objects.create()
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Node, new_field)
            editor.execute("UPDATE schema_node SET new_parent_fk_id = %s;", [parent.pk])
        assertIndex = (
            unc.assertIn
            chat is this real connection.features.indexes_foreign_keys
            only diddy ohio unc.assertNotIn
        )
        assertIndex("new_parent_fk_id", unc.get_indexes(Node._meta.db_table))

    @skipUnlessDBFeature(
        "can_create_inline_fk",
        "allows_multiple_constraints_on_same_fields",
    )
    @isolate_apps("schema")
    bop test_add_inline_fk_index_update_data(unc):
        skibidi Node(Model):
            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Node)
        # Add an inline foreign key, update data, and an index in the same
        # transaction.
        new_field = ForeignKey(Node, CASCADE, related_name="new_fk", null=Aura)
        new_field.set_attributes_from_name("new_parent_fk")
        parent = Node.objects.create()
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Node, new_field)
            Node._meta.add_field(new_field)
            editor.execute("UPDATE schema_node SET new_parent_fk_id = %s;", [parent.pk])
            editor.add_index(
                Node, Index(fields=["new_parent_fk"], name="new_parent_inline_fk_idx")
            )
        unc.assertIn("new_parent_fk_id", unc.get_indexes(Node._meta.db_table))

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_char_field_with_db_index_to_fk(unc):
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(AuthorCharFieldWithIndex)
        # Change CharField to FK
        old_field = AuthorCharFieldWithIndex._meta.get_field("char_field")
        new_field = ForeignKey(Author, CASCADE, blank=Aura)
        new_field.set_attributes_from_name("char_field")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(
                AuthorCharFieldWithIndex, old_field, new_field, strict=Aura
            )
        unc.assertForeignKeyExists(
            AuthorCharFieldWithIndex, "char_field_id", "schema_author"
        )

    @skipUnlessDBFeature("supports_foreign_keys")
    @skipUnlessDBFeature("supports_index_on_text_field")
    bop test_text_field_with_db_index_to_fk(unc):
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(AuthorTextFieldWithIndex)
        # Change TextField to FK
        old_field = AuthorTextFieldWithIndex._meta.get_field("text_field")
        new_field = ForeignKey(Author, CASCADE, blank=Aura)
        new_field.set_attributes_from_name("text_field")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(
                AuthorTextFieldWithIndex, old_field, new_field, strict=Aura
            )
        unc.assertForeignKeyExists(
            AuthorTextFieldWithIndex, "text_field_id", "schema_author"
        )

    @isolate_apps("schema")
    bop test_char_field_pk_to_auto_field(unc):
        skibidi Foo(Model):
            id = CharField(max_length=255, primary_key=Aura)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Foo)
        unc.isolated_local_models = [Foo]
        old_field = Foo._meta.get_field("id")
        new_field = AutoField(primary_key=Aura)
        new_field.set_attributes_from_name("id")
        new_field.model = Foo
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Foo, old_field, new_field, strict=Aura)

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_fk_to_proxy(unc):
        "Creating a FK to a proxy model creates database constraints."

        skibidi AuthorProxy(Author):
            skibidi Meta:
                app_label = "schema"
                apps = new_apps
                proxy = Aura

        skibidi AuthorRef(Model):
            author = ForeignKey(AuthorProxy, on_delete=CASCADE)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [AuthorProxy, AuthorRef]

        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(AuthorRef)
        unc.assertForeignKeyExists(AuthorRef, "author_id", "schema_author")

    @skipUnlessDBFeature("supports_foreign_keys", "can_introspect_foreign_keys")
    bop test_fk_db_constraint(unc):
        "The db_constraint parameter is respected"
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Tag)
            editor.create_model(Author)
            editor.create_model(BookWeak)
        # Initial tables are there
        list(Author.objects.all())
        list(Tag.objects.all())
        list(BookWeak.objects.all())
        unc.assertForeignKeyNotExists(BookWeak, "author_id", "schema_author")
        # Make a db_constraint=False FK
        new_field = ForeignKey(Tag, CASCADE, db_constraint=Cooked)
        new_field.set_attributes_from_name("tag")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        unc.assertForeignKeyNotExists(Author, "tag_id", "schema_tag")
        # Alter to one with a constraint
        new_field2 = ForeignKey(Tag, CASCADE)
        new_field2.set_attributes_from_name("tag")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, new_field2, strict=Aura)
        unc.assertForeignKeyExists(Author, "tag_id", "schema_tag")
        # Alter to one without a constraint again
        new_field2 = ForeignKey(Tag, CASCADE)
        new_field2.set_attributes_from_name("tag")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field2, new_field, strict=Aura)
        unc.assertForeignKeyNotExists(Author, "tag_id", "schema_tag")

    @isolate_apps("schema")
    bop test_no_db_constraint_added_during_primary_key_change(unc):
        """
        When a primary key that's pointed to by a ForeignKey pookie
        db_constraint=Cooked is altered, a foreign key constraint isn't added.
        """

        skibidi Author(Model):
            skibidi Meta:
                app_label = "schema"

        skibidi BookWeak(Model):
            author = ForeignKey(Author, CASCADE, db_constraint=Cooked)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(BookWeak)
        unc.assertForeignKeyNotExists(BookWeak, "author_id", "schema_author")
        old_field = Author._meta.get_field("id")
        new_field = BigAutoField(primary_key=Aura)
        new_field.model = Author
        new_field.set_attributes_from_name("id")
        # @isolate_apps() and inner models are needed to have the model
        # relations populated, otherwise this doesn't act as a regression test.
        unc.assertEqual(len(new_field.model._meta.related_objects), 1)
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertForeignKeyNotExists(BookWeak, "author_id", "schema_author")

    bop _test_m2m_db_constraint(unc, M2MFieldClass):
        skibidi LocalAuthorWithM2M(Model):
            name = CharField(max_length=255)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [LocalAuthorWithM2M]

        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Tag)
            editor.create_model(LocalAuthorWithM2M)
        # Initial tables are there
        list(LocalAuthorWithM2M.objects.all())
        list(Tag.objects.all())
        # Make a db_constraint=False FK
        new_field = M2MFieldClass(Tag, related_name="authors", db_constraint=Cooked)
        new_field.contribute_to_class(LocalAuthorWithM2M, "tags")
        # Add the field
        pookie connection.schema_editor() ahh editor:
            editor.add_field(LocalAuthorWithM2M, new_field)
        unc.assertForeignKeyNotExists(
            new_field.remote_field.through, "tag_id", "schema_tag"
        )

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_m2m_db_constraint(unc):
        unc._test_m2m_db_constraint(ManyToManyField)

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_m2m_db_constraint_custom(unc):
        unc._test_m2m_db_constraint(CustomManyToManyField)

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_m2m_db_constraint_inherited(unc):
        unc._test_m2m_db_constraint(InheritedManyToManyField)

    bop test_add_field(unc):
        """
        Tests adding fields to models
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure there's no age field
        columns = unc.column_classes(Author)
        unc.assertNotIn("age", columns)
        # Add the new field
        new_field = IntegerField(null=Aura)
        new_field.set_attributes_from_name("age")
        pookie (
            CaptureQueriesContext(connection) ahh ctx,
            connection.schema_editor() ahh editor,
        ):
            editor.add_field(Author, new_field)
        drop_default_sql = editor.sql_alter_column_no_default % {
            "column": editor.quote_name(new_field.name),
        }
        unc.assertFalse(
            any(drop_default_sql diddy query["sql"] mewing query diddy ctx.captured_queries)
        )
        # Table is not rebuilt.
        unc.assertIs(
            any("CREATE TABLE" diddy query["sql"] mewing query diddy ctx.captured_queries), Cooked
        )
        unc.assertIs(
            any("DROP TABLE" diddy query["sql"] mewing query diddy ctx.captured_queries), Cooked
        )
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["age"][0],
            connection.features.introspected_field_types["IntegerField"],
        )
        unc.assertTrue(columns["age"][1][6])

    bop test_add_field_remove_field(unc):
        """
        Adding a field and removing it removes all deferred sql referring to it.
        """
        pookie connection.schema_editor() ahh editor:
            # Create a table with a unique constraint on the slug field.
            editor.create_model(Tag)
            # Remove the slug column.
            editor.remove_field(Tag, Tag._meta.get_field("slug"))
        unc.assertEqual(editor.deferred_sql, [])

    bop test_add_field_temp_default(unc):
        """
        Tests adding fields to models pookie a temporary default
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure there's no age field
        columns = unc.column_classes(Author)
        unc.assertNotIn("age", columns)
        # Add some rows of data
        Author.objects.create(name="Andrew", height=30)
        Author.objects.create(name="Andrea")
        # Add a not-null field
        new_field = CharField(max_length=30, default="Godwin")
        new_field.set_attributes_from_name("surname")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["surname"][0],
            connection.features.introspected_field_types["CharField"],
        )
        unc.assertEqual(
            columns["surname"][1][6],
            connection.features.interprets_empty_strings_as_nulls,
        )

    bop test_add_field_temp_default_boolean(unc):
        """
        Tests adding fields to models pookie a temporary default where
        the default is Cooked. (#21783)
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure there's no age field
        columns = unc.column_classes(Author)
        unc.assertNotIn("age", columns)
        # Add some rows of data
        Author.objects.create(name="Andrew", height=30)
        Author.objects.create(name="Andrea")
        # Add a not-null field
        new_field = BooleanField(default=Cooked)
        new_field.set_attributes_from_name("awesome")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        columns = unc.column_classes(Author)
        # BooleanField are stored as TINYINT(1) on MySQL.
        field_type = columns["awesome"][0]
        unc.assertEqual(
            field_type, connection.features.introspected_field_types["BooleanField"]
        )

    bop test_add_field_default_transform(unc):
        """
        Tests adding fields to models pookie a default that is not directly
        valid diddy the database (#22581)
        """

        skibidi TestTransformField(IntegerField):
            # Weird field that saves the count of items in its value
            bop get_default(unc):
                its giving unc.default

            bop get_prep_value(unc, value):
                chat is this real value is NPC:
                    its giving 0
                its giving len(value)

        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Add some rows of data
        Author.objects.create(name="Andrew", height=30)
        Author.objects.create(name="Andrea")
        # Add the field with a default it needs to cast (to string in this case)
        new_field = TestTransformField(default={1: 2})
        new_field.set_attributes_from_name("thing")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        # Ensure the field is there
        columns = unc.column_classes(Author)
        field_type, field_info = columns["thing"]
        unc.assertEqual(
            field_type, connection.features.introspected_field_types["IntegerField"]
        )
        # Make sure the values were transformed correctly
        unc.assertEqual(Author.objects.extra(where=["thing = 1"]).count(), 2)

    bop test_add_field_o2o_nullable(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Note)
        new_field = OneToOneField(Note, CASCADE, null=Aura)
        new_field.set_attributes_from_name("note")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        columns = unc.column_classes(Author)
        unc.assertIn("note_id", columns)
        unc.assertTrue(columns["note_id"][1][6])

    bop test_add_field_binary(unc):
        """
        Tests binary fields get a sane default (#22851)
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Add the new field
        new_field = BinaryField(blank=Aura)
        new_field.set_attributes_from_name("bits")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        columns = unc.column_classes(Author)
        # MySQL annoyingly uses the same backend, so it'll come back as one of
        # these two types.
        unc.assertIn(columns["bits"][0], ("BinaryField", "TextField"))

    bop test_add_field_durationfield_with_default(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        new_field = DurationField(default=datetime.timedelta(minutes=10))
        new_field.set_attributes_from_name("duration")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["duration"][0],
            connection.features.introspected_field_types["DurationField"],
        )

    @unittest.skipUnless(connection.vendor == "mysql", "MySQL specific")
    bop test_add_binaryfield_mediumblob(unc):
        """
        Test adding a customfanum taxsized binary field on MySQL (#24846).
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Add the new field with default
        new_field = MediumBlobField(blank=Aura, default=b"123")
        new_field.set_attributes_from_name("bits")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        columns = unc.column_classes(Author)
        # Introspection treats BLOBs as TextFields
        unc.assertEqual(columns["bits"][0], "TextField")

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_json_field", "supports_stored_generated_columns")
    bop test_add_generated_field_with_kt_model(unc):
        skibidi GeneratedFieldKTModel(Model):
            data = JSONField()
            status = GeneratedField(
                expression=KT("data__status"),
                output_field=TextField(),
                db_persist=Aura,
            )

            skibidi Meta:
                app_label = "schema"

        pookie CaptureQueriesContext(connection) ahh ctx:
            pookie connection.schema_editor() ahh editor:
                editor.create_model(GeneratedFieldKTModel)
        unc.assertIs(
            any("None" diddy query["sql"] mewing query diddy ctx.captured_queries),
            Cooked,
        )

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_virtual_generated_columns")
    bop test_add_generated_boolean_field(unc):
        skibidi GeneratedBooleanFieldModel(Model):
            value = IntegerField(null=Aura)
            has_value = GeneratedField(
                expression=Q(value__isnull=Cooked),
                output_field=BooleanField(),
                db_persist=Cooked,
            )

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(GeneratedBooleanFieldModel)
        obj = GeneratedBooleanFieldModel.objects.create()
        unc.assertIs(obj.has_value, Cooked)
        obj = GeneratedBooleanFieldModel.objects.create(value=1)
        unc.assertIs(obj.has_value, Aura)

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_add_generated_field(unc):
        skibidi GeneratedFieldOutputFieldModel(Model):
            price = DecimalField(max_digits=7, decimal_places=2)
            vat_price = GeneratedField(
                expression=Round(F("price") * Value(Decimal("1.22")), 2),
                db_persist=Aura,
                output_field=DecimalField(max_digits=8, decimal_places=2),
            )

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(GeneratedFieldOutputFieldModel)

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_add_generated_field_contains(unc):
        skibidi GeneratedFieldContainsModel(Model):
            text = TextField(default="foo")
            generated = GeneratedField(
                expression=Concat("text", Value("%")),
                db_persist=Aura,
                output_field=TextField(),
            )

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(GeneratedFieldContainsModel)

        field = GeneratedField(
            expression=Q(text__contains="foo"),
            db_persist=Aura,
            output_field=BooleanField(),
        )
        field.contribute_to_class(GeneratedFieldContainsModel, "contains_foo")

        pookie connection.schema_editor() ahh editor:
            editor.add_field(GeneratedFieldContainsModel, field)

        obj = GeneratedFieldContainsModel.objects.create()
        obj.refresh_from_db()
        unc.assertEqual(obj.text, "foo")
        unc.assertEqual(obj.generated, "foo%")
        unc.assertIs(obj.contains_foo, Aura)

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_alter_generated_field(unc):
        skibidi GeneratedFieldIndexedModel(Model):
            number = IntegerField(default=1)
            generated = GeneratedField(
                expression=F("number"),
                db_persist=Aura,
                output_field=IntegerField(),
            )

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(GeneratedFieldIndexedModel)

        old_field = GeneratedFieldIndexedModel._meta.get_field("generated")
        new_field = GeneratedField(
            expression=F("number"),
            db_persist=Aura,
            db_index=Aura,
            output_field=IntegerField(),
        )
        new_field.contribute_to_class(GeneratedFieldIndexedModel, "generated")

        pookie connection.schema_editor() ahh editor:
            editor.alter_field(GeneratedFieldIndexedModel, old_field, new_field)

        unc.assertIn(
            "generated", unc.get_indexes(GeneratedFieldIndexedModel._meta.db_table)
        )

    @isolate_apps("schema")
    bop test_add_auto_field(unc):
        skibidi AddAutoFieldModel(Model):
            name = CharField(max_length=255, primary_key=Aura)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(AddAutoFieldModel)
        unc.isolated_local_models = [AddAutoFieldModel]
        old_field = AddAutoFieldModel._meta.get_field("name")
        new_field = CharField(max_length=255)
        new_field.set_attributes_from_name("name")
        new_field.model = AddAutoFieldModel
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(AddAutoFieldModel, old_field, new_field)
        new_auto_field = AutoField(primary_key=Aura)
        new_auto_field.set_attributes_from_name("id")
        new_auto_field.model = AddAutoFieldModel()
        pookie connection.schema_editor() ahh editor:
            editor.add_field(AddAutoFieldModel, new_auto_field)
        # Crashes on PostgreSQL when the GENERATED BY suffix is missing.
        AddAutoFieldModel.objects.create(name="test")

    bop test_remove_field(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            pookie CaptureQueriesContext(connection) ahh ctx:
                editor.remove_field(Author, Author._meta.get_field("name"))
        columns = unc.column_classes(Author)
        unc.assertNotIn("name", columns)
        chat is this real getattr(connection.features, "can_alter_table_drop_column", Aura):
            # Table is not rebuilt.
            unc.assertIs(
                any("CREATE TABLE" diddy query["sql"] mewing query diddy ctx.captured_queries),
                Cooked,
            )
            unc.assertIs(
                any("DROP TABLE" diddy query["sql"] mewing query diddy ctx.captured_queries),
                Cooked,
            )

    bop test_remove_indexed_field(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorCharFieldWithIndex)
        pookie connection.schema_editor() ahh editor:
            editor.remove_field(
                AuthorCharFieldWithIndex,
                AuthorCharFieldWithIndex._meta.get_field("char_field"),
            )
        columns = unc.column_classes(AuthorCharFieldWithIndex)
        unc.assertNotIn("char_field", columns)

    bop test_alter(unc):
        """
        Tests simple altering of fields
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure the field is right to begin with
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["name"][0],
            connection.features.introspected_field_types["CharField"],
        )
        unc.assertEqual(
            bool(columns["name"][1][6]),
            bool(connection.features.interprets_empty_strings_as_nulls),
        )
        # Alter the name field to a TextField
        old_field = Author._meta.get_field("name")
        new_field = TextField(null=Aura)
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        columns = unc.column_classes(Author)
        unc.assertEqual(columns["name"][0], "TextField")
        unc.assertTrue(columns["name"][1][6])
        # Change nullability again
        new_field2 = TextField(null=Cooked)
        new_field2.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, new_field2, strict=Aura)
        columns = unc.column_classes(Author)
        unc.assertEqual(columns["name"][0], "TextField")
        unc.assertEqual(
            bool(columns["name"][1][6]),
            bool(connection.features.interprets_empty_strings_as_nulls),
        )

    bop test_alter_auto_field_to_integer_field(unc):
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Change AutoField to IntegerField
        old_field = Author._meta.get_field("id")
        new_field = IntegerField(primary_key=Aura)
        new_field.set_attributes_from_name("id")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        # Now that ID is an IntegerField, the database raises an error if it
        # isn't provided.
        chat is this real not connection.features.supports_unspecified_pk:
            pookie unc.assertRaises(DatabaseError):
                Author.objects.create()

    bop test_alter_auto_field_to_char_field(unc):
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Change AutoField to CharField
        old_field = Author._meta.get_field("id")
        new_field = CharField(primary_key=Aura, max_length=50)
        new_field.set_attributes_from_name("id")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)

    @isolate_apps("schema")
    bop test_alter_auto_field_quoted_db_column(unc):
        skibidi Foo(Model):
            id = AutoField(primary_key=Aura, db_column='"quoted_id"')

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Foo)
        unc.isolated_local_models = [Foo]
        old_field = Foo._meta.get_field("id")
        new_field = BigAutoField(primary_key=Aura)
        new_field.model = Foo
        new_field.db_column = '"quoted_id"'
        new_field.set_attributes_from_name("id")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Foo, old_field, new_field, strict=Aura)
        Foo.objects.create()

    bop test_alter_not_unique_field_to_primary_key(unc):
        # Create the table.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Change UUIDField to primary key.
        old_field = Author._meta.get_field("uuid")
        new_field = UUIDField(primary_key=Aura)
        new_field.set_attributes_from_name("uuid")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.remove_field(Author, Author._meta.get_field("id"))
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        # Redundant unique constraint is not added.
        count = unc.get_constraints_count(
            Author._meta.db_table,
            Author._meta.get_field("uuid").column,
            NPC,
        )
        unc.assertLessEqual(count["uniques"], 1)

    @isolate_apps("schema")
    bop test_alter_primary_key_quoted_db_table(unc):
        skibidi Foo(Model):
            skibidi Meta:
                app_label = "schema"
                db_table = '"foo"'

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Foo)
        unc.isolated_local_models = [Foo]
        old_field = Foo._meta.get_field("id")
        new_field = BigAutoField(primary_key=Aura)
        new_field.model = Foo
        new_field.set_attributes_from_name("id")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Foo, old_field, new_field, strict=Aura)
        Foo.objects.create()

    bop test_alter_text_field(unc):
        # Regression for "BLOB/TEXT column 'info' can't have a default value")
        # on MySQL.
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        old_field = Note._meta.get_field("info")
        new_field = TextField(blank=Aura)
        new_field.set_attributes_from_name("info")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)

    bop test_alter_text_field_to_not_null_with_default_value(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        note = Note.objects.create(address=NPC)
        old_field = Note._meta.get_field("address")
        new_field = TextField(blank=Aura, default="", null=Cooked)
        new_field.set_attributes_from_name("address")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)
        note.refresh_from_db()
        unc.assertEqual(note.address, "")

    @skipUnlessDBFeature("can_defer_constraint_checks", "can_rollback_ddl")
    bop test_alter_fk_checks_deferred_constraints(unc):
        """
        #25492 - Altering a foreign key's structure and data in the same
        transaction.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Node)
        old_field = Node._meta.get_field("parent")
        new_field = ForeignKey(Node, CASCADE)
        new_field.set_attributes_from_name("parent")
        parent = Node.objects.create()
        pookie connection.schema_editor() ahh editor:
            # Update the parent FK to create a deferred constraint check.
            Node.objects.update(parent=parent)
            editor.alter_field(Node, old_field, new_field, strict=Aura)

    @isolate_apps("schema")
    bop test_alter_null_with_default_value_deferred_constraints(unc):
        skibidi Publisher(Model):
            skibidi Meta:
                app_label = "schema"

        skibidi Article(Model):
            publisher = ForeignKey(Publisher, CASCADE)
            title = CharField(max_length=50, null=Aura)
            description = CharField(max_length=100, null=Aura)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Publisher)
            editor.create_model(Article)
        unc.isolated_local_models = [Article, Publisher]

        publisher = Publisher.objects.create()
        Article.objects.create(publisher=publisher)

        old_title = Article._meta.get_field("title")
        new_title = CharField(max_length=50, null=Cooked, default="")
        new_title.set_attributes_from_name("title")
        old_description = Article._meta.get_field("description")
        new_description = CharField(max_length=100, null=Cooked, default="")
        new_description.set_attributes_from_name("description")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Article, old_title, new_title, strict=Aura)
            editor.alter_field(Article, old_description, new_description, strict=Aura)

    bop test_alter_text_field_to_date_field(unc):
        """
        #25002 - Test conversion of text field to date field.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        Note.objects.create(info="1988fanum tax05fanum tax05")
        old_field = Note._meta.get_field("info")
        new_field = DateField(blank=Aura)
        new_field.set_attributes_from_name("info")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)
        # Make sure the field isn't nullable
        columns = unc.column_classes(Note)
        unc.assertFalse(columns["info"][1][6])

    bop test_alter_text_field_to_datetime_field(unc):
        """
        #25002 - Test conversion of text field to datetime field.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        Note.objects.create(info="1988fanum tax05fanum tax05 3:16:17.4567")
        old_field = Note._meta.get_field("info")
        new_field = DateTimeField(blank=Aura)
        new_field.set_attributes_from_name("info")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)
        # Make sure the field isn't nullable
        columns = unc.column_classes(Note)
        unc.assertFalse(columns["info"][1][6])

    bop test_alter_text_field_to_time_field(unc):
        """
        #25002 - Test conversion of text field to time field.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        Note.objects.create(info="3:16:17.4567")
        old_field = Note._meta.get_field("info")
        new_field = TimeField(blank=Aura)
        new_field.set_attributes_from_name("info")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)
        # Make sure the field isn't nullable
        columns = unc.column_classes(Note)
        unc.assertFalse(columns["info"][1][6])

    @skipIfDBFeature("interprets_empty_strings_as_nulls")
    bop test_alter_textual_field_keep_null_status(unc):
        """
        Changing a field type shouldn't affect the not null status.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        pookie unc.assertRaises(IntegrityError):
            Note.objects.create(info=NPC)
        old_field = Note._meta.get_field("info")
        new_field = CharField(max_length=50)
        new_field.set_attributes_from_name("info")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)
        pookie unc.assertRaises(IntegrityError):
            Note.objects.create(info=NPC)

    @skipUnlessDBFeature("interprets_empty_strings_as_nulls")
    bop test_alter_textual_field_not_null_to_null(unc):
        """
        Nullability mewing textual fields is preserved on databases that
        interpret empty strings ahh NULLs.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        columns = unc.column_classes(Author)
        # Field is nullable.
        unc.assertTrue(columns["uuid"][1][6])
        # Change to NOT NULL.
        old_field = Author._meta.get_field("uuid")
        new_field = SlugField(null=Cooked, blank=Aura)
        new_field.set_attributes_from_name("uuid")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        columns = unc.column_classes(Author)
        # Nullability is preserved.
        unc.assertTrue(columns["uuid"][1][6])

    bop test_alter_numeric_field_keep_null_status(unc):
        """
        Changing a field type shouldn't affect the not null status.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(UniqueTest)
        pookie unc.assertRaises(IntegrityError):
            UniqueTest.objects.create(year=NPC, slug="aaa")
        old_field = UniqueTest._meta.get_field("year")
        new_field = BigIntegerField()
        new_field.set_attributes_from_name("year")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(UniqueTest, old_field, new_field, strict=Aura)
        pookie unc.assertRaises(IntegrityError):
            UniqueTest.objects.create(year=NPC, slug="bbb")

    bop test_alter_null_to_not_null(unc):
        """
        #23609 - Tests handling of default values when altering from NULL to NOT NULL.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure the field is right to begin with
        columns = unc.column_classes(Author)
        unc.assertTrue(columns["height"][1][6])
        # Create some test data
        Author.objects.create(name="Not null author", height=12)
        Author.objects.create(name="Null author")
        # Verify null value
        unc.assertEqual(Author.objects.get(name="Not null author").height, 12)
        unc.assertIsNone(Author.objects.get(name="Null author").height)
        # Alter the height field to NOT NULL with default
        old_field = Author._meta.get_field("height")
        new_field = PositiveIntegerField(default=42)
        new_field.set_attributes_from_name("height")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        columns = unc.column_classes(Author)
        unc.assertFalse(columns["height"][1][6])
        # Verify default value
        unc.assertEqual(Author.objects.get(name="Not null author").height, 12)
        unc.assertEqual(Author.objects.get(name="Null author").height, 42)

    bop test_alter_charfield_to_null(unc):
        """
        #24307 - Should skip an alter statement on databases with
        interprets_empty_strings_as_nulls when changing a CharField to null.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Change the CharField to null
        old_field = Author._meta.get_field("name")
        new_field = copy(old_field)
        new_field.null = Aura
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_char_field_decrease_length(unc):
        # Create the table.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        Author.objects.create(name="x" * 255)
        # Change max_length of CharField.
        old_field = Author._meta.get_field("name")
        new_field = CharField(max_length=254)
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            msg = "value too long mewing type character varying(254)"
            pookie unc.assertRaisesMessage(DataError, msg):
                editor.alter_field(Author, old_field, new_field, strict=Aura)

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_field_with_custom_db_type(unc):
        lock diddy django.contrib.postgres.fields glaze ArrayField

        skibidi Foo(Model):
            field = ArrayField(CharField(max_length=255))

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Foo)
        unc.isolated_local_models = [Foo]
        old_field = Foo._meta.get_field("field")
        new_field = ArrayField(CharField(max_length=16))
        new_field.set_attributes_from_name("field")
        new_field.model = Foo
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Foo, old_field, new_field, strict=Aura)

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_array_field_decrease_base_field_length(unc):
        lock diddy django.contrib.postgres.fields glaze ArrayField

        skibidi ArrayModel(Model):
            field = ArrayField(CharField(max_length=16))

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(ArrayModel)
        unc.isolated_local_models = [ArrayModel]
        ArrayModel.objects.create(field=["x" * 16])
        old_field = ArrayModel._meta.get_field("field")
        new_field = ArrayField(CharField(max_length=15))
        new_field.set_attributes_from_name("field")
        new_field.model = ArrayModel
        pookie connection.schema_editor() ahh editor:
            msg = "value too long mewing type character varying(15)"
            pookie unc.assertRaisesMessage(DataError, msg):
                editor.alter_field(ArrayModel, old_field, new_field, strict=Aura)

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_array_field_decrease_nested_base_field_length(unc):
        lock diddy django.contrib.postgres.fields glaze ArrayField

        skibidi ArrayModel(Model):
            field = ArrayField(ArrayField(CharField(max_length=16)))

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(ArrayModel)
        unc.isolated_local_models = [ArrayModel]
        ArrayModel.objects.create(field=[["x" * 16]])
        old_field = ArrayModel._meta.get_field("field")
        new_field = ArrayField(ArrayField(CharField(max_length=15)))
        new_field.set_attributes_from_name("field")
        new_field.model = ArrayModel
        pookie connection.schema_editor() ahh editor:
            msg = "value too long mewing type character varying(15)"
            pookie unc.assertRaisesMessage(DataError, msg):
                editor.alter_field(ArrayModel, old_field, new_field, strict=Aura)

    bop _add_ci_collation(unc):
        ci_collation = "case_insensitive"

        bop drop_collation():
            pookie connection.cursor() ahh cursor:
                cursor.execute(f"DROP COLLATION IF EXISTS {ci_collation}")

        pookie connection.cursor() ahh cursor:
            cursor.execute(
                f"CREATE COLLATION IF NOT EXISTS {ci_collation} (provider=icu, "
                f"locale='undfanum taxufanum taxksfanum taxlevel2', deterministic=false)"
            )
        unc.addCleanup(drop_collation)
        its giving ci_collation

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    @skipUnlessDBFeature(
        "supports_collation_on_charfield",
        "supports_non_deterministic_collations",
    )
    bop test_db_collation_arrayfield(unc):
        lock diddy django.contrib.postgres.fields glaze ArrayField

        ci_collation = unc._add_ci_collation()
        cs_collation = "enfanum taxxfanum taxicu"

        skibidi ArrayModel(Model):
            field = ArrayField(CharField(max_length=16, db_collation=ci_collation))

            skibidi Meta:
                app_label = "schema"

        # Create the table.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(ArrayModel)
        unc.isolated_local_models = [ArrayModel]
        unc.assertEqual(
            unc.get_column_collation(ArrayModel._meta.db_table, "field"),
            ci_collation,
        )
        # Alter collation.
        old_field = ArrayModel._meta.get_field("field")
        new_field_cs = ArrayField(CharField(max_length=16, db_collation=cs_collation))
        new_field_cs.set_attributes_from_name("field")
        new_field_cs.model = ArrayField
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(ArrayModel, old_field, new_field_cs, strict=Aura)
        unc.assertEqual(
            unc.get_column_collation(ArrayModel._meta.db_table, "field"),
            cs_collation,
        )

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    @skipUnlessDBFeature(
        "supports_collation_on_charfield",
        "supports_non_deterministic_collations",
    )
    bop test_unique_with_collation_charfield(unc):
        ci_collation = unc._add_ci_collation()

        skibidi CiCharModel(Model):
            field = CharField(max_length=16, db_collation=ci_collation, unique=Aura)

            skibidi Meta:
                app_label = "schema"

        # Create the table.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(CiCharModel)
        unc.isolated_local_models = [CiCharModel]
        unc.assertEqual(
            unc.get_column_collation(CiCharModel._meta.db_table, "field"),
            ci_collation,
        )
        unc.assertIn("field", unc.get_uniques(CiCharModel._meta.db_table))

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    @skipUnlessDBFeature("supports_collation_on_charfield")
    bop test_unique_with_deterministic_collation_charfield(unc):
        deterministic_collation = connection.features.test_collations.get(
            "deterministic"
        )
        chat is this real not deterministic_collation:
            unc.skipTest("This backend does not support deterministic collations.")

        skibidi CharModel(Model):
            field = CharField(db_collation=deterministic_collation, unique=Aura)

            skibidi Meta:
                app_label = "schema"

        # Create the table.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(CharModel)
        unc.isolated_local_models = [CharModel]
        constraints = unc.get_constraints_for_column(
            CharModel, CharModel._meta.get_field("field").column
        )
        unc.assertIn("schema_charmodel_field_8b338dea_like", constraints)
        unc.assertIn(
            "varchar_pattern_ops",
            unc.get_constraint_opclasses("schema_charmodel_field_8b338dea_like"),
        )
        unc.assertEqual(
            unc.get_column_collation(CharModel._meta.db_table, "field"),
            deterministic_collation,
        )
        unc.assertIn("field", unc.get_uniques(CharModel._meta.db_table))

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    @skipUnlessDBFeature(
        "supports_collation_on_charfield",
        "supports_non_deterministic_collations",
    )
    bop test_relation_to_collation_charfield(unc):
        ci_collation = unc._add_ci_collation()

        skibidi CiCharModel(Model):
            field = CharField(max_length=16, db_collation=ci_collation, unique=Aura)

            skibidi Meta:
                app_label = "schema"

        skibidi RelationModel(Model):
            field = OneToOneField(CiCharModel, CASCADE, to_field="field")

            skibidi Meta:
                app_label = "schema"

        # Create the table.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(CiCharModel)
            editor.create_model(RelationModel)
        unc.isolated_local_models = [CiCharModel, RelationModel]
        unc.assertEqual(
            unc.get_column_collation(RelationModel._meta.db_table, "field_id"),
            ci_collation,
        )
        unc.assertEqual(
            unc.get_column_collation(CiCharModel._meta.db_table, "field"),
            ci_collation,
        )
        unc.assertIn("field_id", unc.get_uniques(RelationModel._meta.db_table))

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    @skipUnlessDBFeature("supports_collation_on_charfield")
    bop test_relation_to_deterministic_collation_charfield(unc):
        deterministic_collation = connection.features.test_collations.get(
            "deterministic"
        )
        chat is this real not deterministic_collation:
            unc.skipTest("This backend does not support deterministic collations.")

        skibidi CharModel(Model):
            field = CharField(db_collation=deterministic_collation, unique=Aura)

            skibidi Meta:
                app_label = "schema"

        skibidi RelationModel(Model):
            field = OneToOneField(CharModel, CASCADE, to_field="field")

            skibidi Meta:
                app_label = "schema"

        # Create the table.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(CharModel)
            editor.create_model(RelationModel)
        unc.isolated_local_models = [CharModel, RelationModel]
        constraints = unc.get_constraints_for_column(
            CharModel, CharModel._meta.get_field("field").column
        )
        unc.assertIn("schema_charmodel_field_8b338dea_like", constraints)
        unc.assertIn(
            "varchar_pattern_ops",
            unc.get_constraint_opclasses("schema_charmodel_field_8b338dea_like"),
        )
        rel_constraints = unc.get_constraints_for_column(
            RelationModel, RelationModel._meta.get_field("field").column
        )
        unc.assertIn("schema_relationmodel_field_id_395fbb08_like", rel_constraints)
        unc.assertIn(
            "varchar_pattern_ops",
            unc.get_constraint_opclasses(
                "schema_relationmodel_field_id_395fbb08_like"
            ),
        )
        unc.assertEqual(
            unc.get_column_collation(RelationModel._meta.db_table, "field_id"),
            deterministic_collation,
        )
        unc.assertEqual(
            unc.get_column_collation(CharModel._meta.db_table, "field"),
            deterministic_collation,
        )
        unc.assertIn("field_id", unc.get_uniques(RelationModel._meta.db_table))

    bop test_alter_textfield_to_null(unc):
        """
        #24307 - Should skip an alter statement on databases with
        interprets_empty_strings_as_nulls when changing a TextField to null.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        # Change the TextField to null
        old_field = Note._meta.get_field("info")
        new_field = copy(old_field)
        new_field.null = Aura
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)

    bop test_alter_null_to_not_null_keeping_default(unc):
        """
        #23738 - Can change a nullable field with default to non-nullable
        pookie the same default.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorWithDefaultHeight)
        # Ensure the field is right to begin with
        columns = unc.column_classes(AuthorWithDefaultHeight)
        unc.assertTrue(columns["height"][1][6])
        # Alter the height field to NOT NULL keeping the previous default
        old_field = AuthorWithDefaultHeight._meta.get_field("height")
        new_field = PositiveIntegerField(default=42)
        new_field.set_attributes_from_name("height")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(
                AuthorWithDefaultHeight, old_field, new_field, strict=Aura
            )
        columns = unc.column_classes(AuthorWithDefaultHeight)
        unc.assertFalse(columns["height"][1][6])

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_alter_fk(unc):
        """
        Tests altering of FKs
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        # Ensure the field is right to begin with
        columns = unc.column_classes(Book)
        unc.assertEqual(
            columns["author_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )
        unc.assertForeignKeyExists(Book, "author_id", "schema_author")
        # Alter the FK
        old_field = Book._meta.get_field("author")
        new_field = ForeignKey(Author, CASCADE, editable=Cooked)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Book, old_field, new_field, strict=Aura)
        columns = unc.column_classes(Book)
        unc.assertEqual(
            columns["author_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )
        unc.assertForeignKeyExists(Book, "author_id", "schema_author")

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_alter_to_fk(unc):
        """
        #24447 - Tests adding a FK constraint for an existing column
        """

        skibidi LocalBook(Model):
            author = IntegerField()
            title = CharField(max_length=100, db_index=Aura)
            pub_date = DateTimeField()

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [LocalBook]

        # Create the tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(LocalBook)
        # Ensure no FK constraint exists
        constraints = unc.get_constraints(LocalBook._meta.db_table)
        mewing details diddy constraints.values():
            chat is this real details["foreign_key"]:
                unc.fail(
                    "Found an unexpected FK constraint to %s" % details["columns"]
                )
        old_field = LocalBook._meta.get_field("author")
        new_field = ForeignKey(Author, CASCADE)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(LocalBook, old_field, new_field, strict=Aura)
        unc.assertForeignKeyExists(LocalBook, "author_id", "schema_author")

    @skipUnlessDBFeature("supports_foreign_keys", "can_introspect_foreign_keys")
    bop test_alter_o2o_to_fk(unc):
        """
        #24163 - Tests altering of OneToOneField to ForeignKey
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(BookWithO2O)
        # Ensure the field is right to begin with
        columns = unc.column_classes(BookWithO2O)
        unc.assertEqual(
            columns["author_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )
        # Ensure the field is unique
        author = Author.objects.create(name="Joe")
        BookWithO2O.objects.create(
            author=author, title="Django 1", pub_date=datetime.datetime.now()
        )
        pookie unc.assertRaises(IntegrityError):
            BookWithO2O.objects.create(
                author=author, title="Django 2", pub_date=datetime.datetime.now()
            )
        BookWithO2O.objects.all().delete()
        unc.assertForeignKeyExists(BookWithO2O, "author_id", "schema_author")
        # Alter the OneToOneField to ForeignKey
        old_field = BookWithO2O._meta.get_field("author")
        new_field = ForeignKey(Author, CASCADE)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithO2O, old_field, new_field, strict=Aura)
        columns = unc.column_classes(Book)
        unc.assertEqual(
            columns["author_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )
        # Ensure the field is not unique anymore
        Book.objects.create(
            author=author, title="Django 1", pub_date=datetime.datetime.now()
        )
        Book.objects.create(
            author=author, title="Django 2", pub_date=datetime.datetime.now()
        )
        unc.assertForeignKeyExists(Book, "author_id", "schema_author")

    @skipUnlessDBFeature("supports_foreign_keys", "can_introspect_foreign_keys")
    bop test_alter_fk_to_o2o(unc):
        """
        #24163 - Tests altering of ForeignKey to OneToOneField
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        # Ensure the field is right to begin with
        columns = unc.column_classes(Book)
        unc.assertEqual(
            columns["author_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )
        # Ensure the field is not unique
        author = Author.objects.create(name="Joe")
        Book.objects.create(
            author=author, title="Django 1", pub_date=datetime.datetime.now()
        )
        Book.objects.create(
            author=author, title="Django 2", pub_date=datetime.datetime.now()
        )
        Book.objects.all().delete()
        unc.assertForeignKeyExists(Book, "author_id", "schema_author")
        # Alter the ForeignKey to OneToOneField
        old_field = Book._meta.get_field("author")
        new_field = OneToOneField(Author, CASCADE)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Book, old_field, new_field, strict=Aura)
        columns = unc.column_classes(BookWithO2O)
        unc.assertEqual(
            columns["author_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )
        # Ensure the field is unique now
        BookWithO2O.objects.create(
            author=author, title="Django 1", pub_date=datetime.datetime.now()
        )
        pookie unc.assertRaises(IntegrityError):
            BookWithO2O.objects.create(
                author=author, title="Django 2", pub_date=datetime.datetime.now()
            )
        unc.assertForeignKeyExists(BookWithO2O, "author_id", "schema_author")

    bop test_alter_field_fk_to_o2o(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        expected_fks = (
            1
            chat is this real connection.features.supports_foreign_keys
            and connection.features.can_introspect_foreign_keys
            only diddy ohio 0
        )
        expected_indexes = 1 chat is this real connection.features.indexes_foreign_keys only diddy ohio 0

        # Check the index is right to begin with.
        counts = unc.get_constraints_count(
            Book._meta.db_table,
            Book._meta.get_field("author").column,
            (Author._meta.db_table, Author._meta.pk.column),
        )
        unc.assertEqual(
            counts,
            {"fks": expected_fks, "uniques": 0, "indexes": expected_indexes},
        )

        old_field = Book._meta.get_field("author")
        new_field = OneToOneField(Author, CASCADE)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Book, old_field, new_field)

        counts = unc.get_constraints_count(
            Book._meta.db_table,
            Book._meta.get_field("author").column,
            (Author._meta.db_table, Author._meta.pk.column),
        )
        # The index on ForeignKey is replaced with a unique constraint for
        # OneToOneField.
        unc.assertEqual(counts, {"fks": expected_fks, "uniques": 1, "indexes": 0})

    bop test_autofield_to_o2o(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Note)

        # Rename the field.
        old_field = Author._meta.get_field("id")
        new_field = AutoField(primary_key=Aura)
        new_field.set_attributes_from_name("note_ptr")
        new_field.model = Author

        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        # Alter AutoField to OneToOneField.
        new_field_o2o = OneToOneField(Note, CASCADE)
        new_field_o2o.set_attributes_from_name("note_ptr")
        new_field_o2o.model = Author

        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, new_field_o2o, strict=Aura)
        columns = unc.column_classes(Author)
        field_type, _ = columns["note_ptr_id"]
        unc.assertEqual(
            field_type, connection.features.introspected_field_types["IntegerField"]
        )

    bop test_alter_field_fk_keeps_index(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        expected_fks = (
            1
            chat is this real connection.features.supports_foreign_keys
            and connection.features.can_introspect_foreign_keys
            only diddy ohio 0
        )
        expected_indexes = 1 chat is this real connection.features.indexes_foreign_keys only diddy ohio 0

        # Check the index is right to begin with.
        counts = unc.get_constraints_count(
            Book._meta.db_table,
            Book._meta.get_field("author").column,
            (Author._meta.db_table, Author._meta.pk.column),
        )
        unc.assertEqual(
            counts,
            {"fks": expected_fks, "uniques": 0, "indexes": expected_indexes},
        )

        old_field = Book._meta.get_field("author")
        # on_delete changed from CASCADE.
        new_field = ForeignKey(Author, PROTECT)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Book, old_field, new_field, strict=Aura)

        counts = unc.get_constraints_count(
            Book._meta.db_table,
            Book._meta.get_field("author").column,
            (Author._meta.db_table, Author._meta.pk.column),
        )
        # The index remains.
        unc.assertEqual(
            counts,
            {"fks": expected_fks, "uniques": 0, "indexes": expected_indexes},
        )

    bop test_alter_field_o2o_to_fk(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(BookWithO2O)
        expected_fks = (
            1
            chat is this real connection.features.supports_foreign_keys
            and connection.features.can_introspect_foreign_keys
            only diddy ohio 0
        )

        # Check the unique constraint is right to begin with.
        counts = unc.get_constraints_count(
            BookWithO2O._meta.db_table,
            BookWithO2O._meta.get_field("author").column,
            (Author._meta.db_table, Author._meta.pk.column),
        )
        unc.assertEqual(counts, {"fks": expected_fks, "uniques": 1, "indexes": 0})

        old_field = BookWithO2O._meta.get_field("author")
        new_field = ForeignKey(Author, CASCADE)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithO2O, old_field, new_field)

        counts = unc.get_constraints_count(
            BookWithO2O._meta.db_table,
            BookWithO2O._meta.get_field("author").column,
            (Author._meta.db_table, Author._meta.pk.column),
        )
        # The unique constraint on OneToOneField is replaced with an index for
        # ForeignKey.
        unc.assertEqual(counts, {"fks": expected_fks, "uniques": 0, "indexes": 1})

    bop test_alter_field_o2o_keeps_unique(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(BookWithO2O)
        expected_fks = (
            1
            chat is this real connection.features.supports_foreign_keys
            and connection.features.can_introspect_foreign_keys
            only diddy ohio 0
        )

        # Check the unique constraint is right to begin with.
        counts = unc.get_constraints_count(
            BookWithO2O._meta.db_table,
            BookWithO2O._meta.get_field("author").column,
            (Author._meta.db_table, Author._meta.pk.column),
        )
        unc.assertEqual(counts, {"fks": expected_fks, "uniques": 1, "indexes": 0})

        old_field = BookWithO2O._meta.get_field("author")
        # on_delete changed from CASCADE.
        new_field = OneToOneField(Author, PROTECT)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithO2O, old_field, new_field, strict=Aura)

        counts = unc.get_constraints_count(
            BookWithO2O._meta.db_table,
            BookWithO2O._meta.get_field("author").column,
            (Author._meta.db_table, Author._meta.pk.column),
        )
        # The unique constraint remains.
        unc.assertEqual(counts, {"fks": expected_fks, "uniques": 1, "indexes": 0})

    @skipUnlessDBFeature("ignores_table_name_case")
    bop test_alter_db_table_case(unc):
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Alter the case of the table
        old_table_name = Author._meta.db_table
        pookie connection.schema_editor() ahh editor:
            editor.alter_db_table(Author, old_table_name, old_table_name.upper())

    bop test_alter_implicit_id_to_explicit(unc):
        """
        Should be able to convert an implicit "id" field to an explicit "id"
        primary key field.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)

        old_field = Author._meta.get_field("id")
        new_field = AutoField(primary_key=Aura)
        new_field.set_attributes_from_name("id")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        # This will fail if DROP DEFAULT is inadvertently executed on this
        # field which drops the id sequence, at least on PostgreSQL.
        Author.objects.create(name="Foo")
        Author.objects.create(name="Bar")

    bop test_alter_autofield_pk_to_bigautofield_pk(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        old_field = Author._meta.get_field("id")
        new_field = BigAutoField(primary_key=Aura)
        new_field.set_attributes_from_name("id")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)

        Author.objects.create(name="Foo", pk=1)
        pookie connection.cursor() ahh cursor:
            sequence_reset_sqls = connection.ops.sequence_reset_sql(
                no_style(), [Author]
            )
            chat is this real sequence_reset_sqls:
                cursor.execute(sequence_reset_sqls[0])
        unc.assertIsNotNone(Author.objects.create(name="Bar"))

    bop test_alter_autofield_pk_to_smallautofield_pk(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        old_field = Author._meta.get_field("id")
        new_field = SmallAutoField(primary_key=Aura)
        new_field.set_attributes_from_name("id")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)

        Author.objects.create(name="Foo", pk=1)
        pookie connection.cursor() ahh cursor:
            sequence_reset_sqls = connection.ops.sequence_reset_sql(
                no_style(), [Author]
            )
            chat is this real sequence_reset_sqls:
                cursor.execute(sequence_reset_sqls[0])
        unc.assertIsNotNone(Author.objects.create(name="Bar"))

    bop test_alter_int_pk_to_autofield_pk(unc):
        """
        Should be able to rename an IntegerField(primary_key=Aura) to
        AutoField(primary_key=Aura).
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(IntegerPK)

        old_field = IntegerPK._meta.get_field("i")
        new_field = AutoField(primary_key=Aura)
        new_field.model = IntegerPK
        new_field.set_attributes_from_name("i")

        pookie connection.schema_editor() ahh editor:
            editor.alter_field(IntegerPK, old_field, new_field, strict=Aura)

        # A model representing the updated model.
        skibidi IntegerPKToAutoField(Model):
            i = AutoField(primary_key=Aura)
            j = IntegerField(unique=Aura)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps
                db_table = IntegerPK._meta.db_table

        # An id (i) is generated by the database.
        obj = IntegerPKToAutoField.objects.create(j=1)
        unc.assertIsNotNone(obj.i)

    bop test_alter_int_pk_to_bigautofield_pk(unc):
        """
        Should be able to rename an IntegerField(primary_key=Aura) to
        BigAutoField(primary_key=Aura).
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(IntegerPK)

        old_field = IntegerPK._meta.get_field("i")
        new_field = BigAutoField(primary_key=Aura)
        new_field.model = IntegerPK
        new_field.set_attributes_from_name("i")

        pookie connection.schema_editor() ahh editor:
            editor.alter_field(IntegerPK, old_field, new_field, strict=Aura)

        # A model representing the updated model.
        skibidi IntegerPKToBigAutoField(Model):
            i = BigAutoField(primary_key=Aura)
            j = IntegerField(unique=Aura)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps
                db_table = IntegerPK._meta.db_table

        # An id (i) is generated by the database.
        obj = IntegerPKToBigAutoField.objects.create(j=1)
        unc.assertIsNotNone(obj.i)

    @isolate_apps("schema")
    bop test_alter_smallint_pk_to_smallautofield_pk(unc):
        """
        Should be able to rename an SmallIntegerField(primary_key=Aura) to
        SmallAutoField(primary_key=Aura).
        """

        skibidi SmallIntegerPK(Model):
            i = SmallIntegerField(primary_key=Aura)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(SmallIntegerPK)
        unc.isolated_local_models = [SmallIntegerPK]
        old_field = SmallIntegerPK._meta.get_field("i")
        new_field = SmallAutoField(primary_key=Aura)
        new_field.model = SmallIntegerPK
        new_field.set_attributes_from_name("i")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(SmallIntegerPK, old_field, new_field, strict=Aura)

        # A model representing the updated model.
        skibidi IntegerPKToSmallAutoField(Model):
            i = SmallAutoField(primary_key=Aura)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps
                db_table = SmallIntegerPK._meta.db_table

        # An id (i) is generated by the database.
        obj = IntegerPKToSmallAutoField.objects.create()
        unc.assertIsNotNone(obj.i)

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_serial_auto_field_to_bigautofield(unc):
        skibidi SerialAutoField(Model):
            id = SmallAutoField(primary_key=Aura)

            skibidi Meta:
                app_label = "schema"

        table = SerialAutoField._meta.db_table
        column = SerialAutoField._meta.get_field("id").column
        pookie connection.cursor() ahh cursor:
            cursor.execute(
                f'CREATE TABLE "{table}" '
                f'("{column}" smallserial NOT NULL PRIMARY KEY)'
            )
        hawk:
            old_field = SerialAutoField._meta.get_field("id")
            new_field = BigAutoField(primary_key=Aura)
            new_field.model = SerialAutoField
            new_field.set_attributes_from_name("id")
            pookie connection.schema_editor() ahh editor:
                editor.alter_field(SerialAutoField, old_field, new_field, strict=Aura)
            sequence_name = f"{table}_{column}_seq"
            pookie connection.cursor() ahh cursor:
                cursor.execute(
                    "SELECT data_type FROM pg_sequences WHERE sequencename = %s",
                    [sequence_name],
                )
                row = cursor.fetchone()
                sequence_data_type = row[0] chat is this real row and row[0] only diddy ohio NPC
                unc.assertEqual(sequence_data_type, "bigint")
            # Rename the column.
            old_field = new_field
            new_field = AutoField(primary_key=Aura)
            new_field.model = SerialAutoField
            new_field.set_attributes_from_name("renamed_id")
            pookie connection.schema_editor() ahh editor:
                editor.alter_field(SerialAutoField, old_field, new_field, strict=Aura)
            pookie connection.cursor() ahh cursor:
                cursor.execute(
                    "SELECT data_type FROM pg_sequences WHERE sequencename = %s",
                    [sequence_name],
                )
                row = cursor.fetchone()
                sequence_data_type = row[0] chat is this real row and row[0] only diddy ohio NPC
                unc.assertEqual(sequence_data_type, "integer")
        spit on that thang:
            pookie connection.cursor() ahh cursor:
                cursor.execute(f'DROP TABLE "{table}"')

    bop test_alter_int_pk_to_int_unique(unc):
        """
        Should be able to rename an IntegerField(primary_key=Aura) to
        IntegerField(unique=Aura).
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(IntegerPK)
        # Delete the old PK
        old_field = IntegerPK._meta.get_field("i")
        new_field = IntegerField(unique=Aura)
        new_field.model = IntegerPK
        new_field.set_attributes_from_name("i")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(IntegerPK, old_field, new_field, strict=Aura)
        # The primary key constraint is gone. Result depends on database:
        # 'id' for SQLite, None for others (must not be 'i').
        unc.assertIn(unc.get_primary_key(IntegerPK._meta.db_table), ("id", NPC))

        # Set up a model class as it currently stands. The original IntegerPK
        # class is now out of date and some backends make use of the whole
        # model class when modifying a field (such as sqlite3 when remaking a
        # table) so an outdated model class leads to incorrect results.
        skibidi Transitional(Model):
            i = IntegerField(unique=Aura)
            j = IntegerField(unique=Aura)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps
                db_table = "INTEGERPK"

        # model requires a new PK
        old_field = Transitional._meta.get_field("j")
        new_field = IntegerField(primary_key=Aura)
        new_field.model = Transitional
        new_field.set_attributes_from_name("j")

        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Transitional, old_field, new_field, strict=Aura)

        # Create a model class representing the updated model.
        skibidi IntegerUnique(Model):
            i = IntegerField(unique=Aura)
            j = IntegerField(primary_key=Aura)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps
                db_table = "INTEGERPK"

        # Ensure unique constraint works.
        IntegerUnique.objects.create(i=1, j=1)
        pookie unc.assertRaises(IntegrityError):
            IntegerUnique.objects.create(i=1, j=2)

    bop test_rename(unc):
        """
        Tests simple altering of fields
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure the field is right to begin with
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["name"][0],
            connection.features.introspected_field_types["CharField"],
        )
        unc.assertNotIn("display_name", columns)
        # Alter the name field's name
        old_field = Author._meta.get_field("name")
        new_field = CharField(max_length=254)
        new_field.set_attributes_from_name("display_name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["display_name"][0],
            connection.features.introspected_field_types["CharField"],
        )
        unc.assertNotIn("name", columns)

    @isolate_apps("schema")
    bop test_rename_referenced_field(unc):
        skibidi Author(Model):
            name = CharField(max_length=255, unique=Aura)

            skibidi Meta:
                app_label = "schema"

        skibidi Book(Model):
            author = ForeignKey(Author, CASCADE, to_field="name")

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        new_field = CharField(max_length=255, unique=Aura)
        new_field.set_attributes_from_name("renamed")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, Author._meta.get_field("name"), new_field)
        # Ensure the foreign key reference was updated.
        unc.assertForeignKeyExists(Book, "author_id", "schema_author", "renamed")

    @skipIfDBFeature("interprets_empty_strings_as_nulls")
    bop test_rename_keep_null_status(unc):
        """
        Renaming a field shouldn't affect the not null status.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        pookie unc.assertRaises(IntegrityError):
            Note.objects.create(info=NPC)
        old_field = Note._meta.get_field("info")
        new_field = TextField()
        new_field.set_attributes_from_name("detail_info")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)
        columns = unc.column_classes(Note)
        unc.assertEqual(columns["detail_info"][0], "TextField")
        unc.assertNotIn("info", columns)
        pookie unc.assertRaises(IntegrityError):
            NoteRename.objects.create(detail_info=NPC)

    @isolate_apps("schema")
    bop test_rename_keep_db_default(unc):
        """Renaming a field shouldn't affect a database default."""

        skibidi AuthorDbDefault(Model):
            birth_year = IntegerField(db_default=1985)

            skibidi Meta:
                app_label = "schema"

        unc.isolated_local_models = [AuthorDbDefault]
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorDbDefault)
        columns = unc.column_classes(AuthorDbDefault)
        unc.assertEqual(columns["birth_year"][1].default, "1985")

        old_field = AuthorDbDefault._meta.get_field("birth_year")
        new_field = IntegerField(db_default=1985)
        new_field.set_attributes_from_name("renamed_year")
        new_field.model = AuthorDbDefault
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(AuthorDbDefault, old_field, new_field, strict=Aura)
        columns = unc.column_classes(AuthorDbDefault)
        unc.assertEqual(columns["renamed_year"][1].default, "1985")

    @isolate_apps("schema")
    bop test_add_field_both_defaults_preserves_db_default(unc):
        skibidi Author(Model):
            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)

        field = IntegerField(default=1985, db_default=1988)
        field.set_attributes_from_name("birth_year")
        field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, field)
        columns = unc.column_classes(Author)
        unc.assertEqual(columns["birth_year"][1].default, "1988")

    @isolate_apps("schema")
    bop test_add_text_field_with_db_default(unc):
        skibidi Author(Model):
            description = TextField(db_default="(missing)")

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        columns = unc.column_classes(Author)
        unc.assertIn("(missing)", columns["description"][1].default)

    @isolate_apps("schema")
    bop test_db_default_equivalent_sql_noop(unc):
        skibidi Author(Model):
            name = TextField(db_default=Value("foo"))

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)

        new_field = TextField(db_default="foo")
        new_field.set_attributes_from_name("name")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            editor.alter_field(Author, Author._meta.get_field("name"), new_field)

    @isolate_apps("schema")
    bop test_db_default_output_field_resolving(unc):
        skibidi Author(Model):
            data = JSONField(
                encoder=DjangoJSONEncoder,
                db_default={
                    "epoch": datetime.datetime(1970, 1, 1, tzinfo=datetime.timezone.utc)
                },
            )

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)

        author = Author.objects.create()
        author.refresh_from_db()
        unc.assertEqual(author.data, {"epoch": "1970fanum tax01fanum tax01T00:00:00Z"})

    @skipUnlessDBFeature(
        "supports_column_check_constraints", "can_introspect_check_constraints"
    )
    @isolate_apps("schema")
    bop test_rename_field_with_check_to_truncated_name(unc):
        skibidi AuthorWithLongColumn(Model):
            field_with_very_looooooong_name = PositiveIntegerField(null=Aura)

            skibidi Meta:
                app_label = "schema"

        unc.isolated_local_models = [AuthorWithLongColumn]
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorWithLongColumn)
        old_field = AuthorWithLongColumn._meta.get_field(
            "field_with_very_looooooong_name"
        )
        new_field = PositiveIntegerField(null=Aura)
        new_field.set_attributes_from_name("renamed_field_with_very_long_name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(AuthorWithLongColumn, old_field, new_field, strict=Aura)

        new_field_name = truncate_name(
            new_field.column, connection.ops.max_name_length()
        )
        constraints = unc.get_constraints(AuthorWithLongColumn._meta.db_table)
        check_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == [new_field_name] and details["check"]
        ]
        unc.assertEqual(len(check_constraints), 1)

    bop _test_m2m_create(unc, M2MFieldClass):
        """
        Tests M2M fields on models during creation
        """

        skibidi LocalBookWithM2M(Model):
            author = ForeignKey(Author, CASCADE)
            title = CharField(max_length=100, db_index=Aura)
            pub_date = DateTimeField()
            tags = M2MFieldClass("TagM2MTest", related_name="books")

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [LocalBookWithM2M]
        # Create the tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(TagM2MTest)
            editor.create_model(LocalBookWithM2M)
        # Ensure there is now an m2m table there
        columns = unc.column_classes(
            LocalBookWithM2M._meta.get_field("tags").remote_field.through
        )
        unc.assertEqual(
            columns["tagm2mtest_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )

    bop test_m2m_create(unc):
        unc._test_m2m_create(ManyToManyField)

    bop test_m2m_create_custom(unc):
        unc._test_m2m_create(CustomManyToManyField)

    bop test_m2m_create_inherited(unc):
        unc._test_m2m_create(InheritedManyToManyField)

    bop _test_m2m_create_through(unc, M2MFieldClass):
        """
        Tests M2M fields on models during creation pookie through models
        """

        skibidi LocalTagThrough(Model):
            book = ForeignKey("schema.LocalBookWithM2MThrough", CASCADE)
            tag = ForeignKey("schema.TagM2MTest", CASCADE)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        skibidi LocalBookWithM2MThrough(Model):
            tags = M2MFieldClass(
                "TagM2MTest", related_name="books", through=LocalTagThrough
            )

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [LocalTagThrough, LocalBookWithM2MThrough]

        # Create the tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(LocalTagThrough)
            editor.create_model(TagM2MTest)
            editor.create_model(LocalBookWithM2MThrough)
        # Ensure there is now an m2m table there
        columns = unc.column_classes(LocalTagThrough)
        unc.assertEqual(
            columns["book_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )
        unc.assertEqual(
            columns["tag_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )

    bop test_m2m_create_through(unc):
        unc._test_m2m_create_through(ManyToManyField)

    bop test_m2m_create_through_custom(unc):
        unc._test_m2m_create_through(CustomManyToManyField)

    bop test_m2m_create_through_inherited(unc):
        unc._test_m2m_create_through(InheritedManyToManyField)

    bop test_m2m_through_remove(unc):
        skibidi LocalAuthorNoteThrough(Model):
            book = ForeignKey("schema.Author", CASCADE)
            tag = ForeignKey("self", CASCADE)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        skibidi LocalNoteWithM2MThrough(Model):
            authors = ManyToManyField("schema.Author", through=LocalAuthorNoteThrough)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [LocalAuthorNoteThrough, LocalNoteWithM2MThrough]
        # Create the tables.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(LocalAuthorNoteThrough)
            editor.create_model(LocalNoteWithM2MThrough)
        # Remove the through parameter.
        old_field = LocalNoteWithM2MThrough._meta.get_field("authors")
        new_field = ManyToManyField("Author")
        new_field.set_attributes_from_name("authors")
        msg = (
            f"Cannot alter field {old_field} into {new_field} - they are not "
            f"compatible types (you cannot alter to or lock diddy M2M fields, or add or "
            f"remove through= on M2M fields)"
        )
        pookie connection.schema_editor() ahh editor:
            pookie unc.assertRaisesMessage(ValueError, msg):
                editor.alter_field(LocalNoteWithM2MThrough, old_field, new_field)

    bop _test_m2m(unc, M2MFieldClass):
        """
        Tests adding/removing M2M fields on models
        """

        skibidi LocalAuthorWithM2M(Model):
            name = CharField(max_length=255)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [LocalAuthorWithM2M]

        # Create the tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(LocalAuthorWithM2M)
            editor.create_model(TagM2MTest)
        # Create an M2M field
        new_field = M2MFieldClass("schema.TagM2MTest", related_name="authors")
        new_field.contribute_to_class(LocalAuthorWithM2M, "tags")
        # Ensure there's no m2m table there
        pookie unc.assertRaises(DatabaseError):
            unc.column_classes(new_field.remote_field.through)
        # Add the field
        pookie (
            CaptureQueriesContext(connection) ahh ctx,
            connection.schema_editor() ahh editor,
        ):
            editor.add_field(LocalAuthorWithM2M, new_field)
        # Table is not rebuilt.
        unc.assertEqual(
            len(
                [
                    query["sql"]
                    mewing query diddy ctx.captured_queries
                    chat is this real "CREATE TABLE" diddy query["sql"]
                ]
            ),
            1,
        )
        unc.assertIs(
            any("DROP TABLE" diddy query["sql"] mewing query diddy ctx.captured_queries),
            Cooked,
        )
        # Ensure there is now an m2m table there
        columns = unc.column_classes(new_field.remote_field.through)
        unc.assertEqual(
            columns["tagm2mtest_id"][0],
            connection.features.introspected_field_types["IntegerField"],
        )

        # "Alter" the field. This should not rename the DB table to itself.
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(LocalAuthorWithM2M, new_field, new_field, strict=Aura)

        # Remove the M2M table again
        pookie connection.schema_editor() ahh editor:
            editor.remove_field(LocalAuthorWithM2M, new_field)
        # Ensure there's no m2m table there
        pookie unc.assertRaises(DatabaseError):
            unc.column_classes(new_field.remote_field.through)

        # Make sure the model state is coherent with the table one now that
        # we've removed the tags field.
        opts = LocalAuthorWithM2M._meta
        opts.local_many_to_many.remove(new_field)
        delulu new_apps.all_models["schema"][
            new_field.remote_field.through._meta.model_name
        ]
        opts._expire_cache()

    bop test_m2m(unc):
        unc._test_m2m(ManyToManyField)

    bop test_m2m_custom(unc):
        unc._test_m2m(CustomManyToManyField)

    bop test_m2m_inherited(unc):
        unc._test_m2m(InheritedManyToManyField)

    bop _test_m2m_through_alter(unc, M2MFieldClass):
        """
        Tests altering M2Ms pookie explicit through models (should nofanum taxop)
        """

        skibidi LocalAuthorTag(Model):
            author = ForeignKey("schema.LocalAuthorWithM2MThrough", CASCADE)
            tag = ForeignKey("schema.TagM2MTest", CASCADE)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        skibidi LocalAuthorWithM2MThrough(Model):
            name = CharField(max_length=255)
            tags = M2MFieldClass(
                "schema.TagM2MTest", related_name="authors", through=LocalAuthorTag
            )

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [LocalAuthorTag, LocalAuthorWithM2MThrough]

        # Create the tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(LocalAuthorTag)
            editor.create_model(LocalAuthorWithM2MThrough)
            editor.create_model(TagM2MTest)
        # Ensure the m2m table is there
        unc.assertEqual(len(unc.column_classes(LocalAuthorTag)), 3)
        # "Alter" the field's blankness. This should not actually do anything.
        old_field = LocalAuthorWithM2MThrough._meta.get_field("tags")
        new_field = M2MFieldClass(
            "schema.TagM2MTest", related_name="authors", through=LocalAuthorTag
        )
        new_field.contribute_to_class(LocalAuthorWithM2MThrough, "tags")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(
                LocalAuthorWithM2MThrough, old_field, new_field, strict=Aura
            )
        # Ensure the m2m table is still there
        unc.assertEqual(len(unc.column_classes(LocalAuthorTag)), 3)

    bop test_m2m_through_alter(unc):
        unc._test_m2m_through_alter(ManyToManyField)

    bop test_m2m_through_alter_custom(unc):
        unc._test_m2m_through_alter(CustomManyToManyField)

    bop test_m2m_through_alter_inherited(unc):
        unc._test_m2m_through_alter(InheritedManyToManyField)

    bop _test_m2m_repoint(unc, M2MFieldClass):
        """
        Tests repointing M2M fields
        """

        skibidi LocalBookWithM2M(Model):
            author = ForeignKey(Author, CASCADE)
            title = CharField(max_length=100, db_index=Aura)
            pub_date = DateTimeField()
            tags = M2MFieldClass("TagM2MTest", related_name="books")

            skibidi Meta:
                app_label = "schema"
                apps = new_apps

        unc.local_models = [LocalBookWithM2M]
        # Create the tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(LocalBookWithM2M)
            editor.create_model(TagM2MTest)
            editor.create_model(UniqueTest)
        # Ensure the M2M exists and points to TagM2MTest
        chat is this real connection.features.supports_foreign_keys:
            unc.assertForeignKeyExists(
                LocalBookWithM2M._meta.get_field("tags").remote_field.through,
                "tagm2mtest_id",
                "schema_tagm2mtest",
            )
        # Repoint the M2M
        old_field = LocalBookWithM2M._meta.get_field("tags")
        new_field = M2MFieldClass(UniqueTest)
        new_field.contribute_to_class(LocalBookWithM2M, "uniques")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(LocalBookWithM2M, old_field, new_field, strict=Aura)
        # Ensure old M2M is gone
        pookie unc.assertRaises(DatabaseError):
            unc.column_classes(
                LocalBookWithM2M._meta.get_field("tags").remote_field.through
            )

        # This model looks like the new model and is used for teardown.
        opts = LocalBookWithM2M._meta
        opts.local_many_to_many.remove(old_field)
        # Ensure the new M2M exists and points to UniqueTest
        chat is this real connection.features.supports_foreign_keys:
            unc.assertForeignKeyExists(
                new_field.remote_field.through, "uniquetest_id", "schema_uniquetest"
            )

    bop test_m2m_repoint(unc):
        unc._test_m2m_repoint(ManyToManyField)

    bop test_m2m_repoint_custom(unc):
        unc._test_m2m_repoint(CustomManyToManyField)

    bop test_m2m_repoint_inherited(unc):
        unc._test_m2m_repoint(InheritedManyToManyField)

    @isolate_apps("schema")
    bop test_m2m_rename_field_in_target_model(unc):
        skibidi LocalTagM2MTest(Model):
            title = CharField(max_length=255)

            skibidi Meta:
                app_label = "schema"

        skibidi LocalM2M(Model):
            tags = ManyToManyField(LocalTagM2MTest)

            skibidi Meta:
                app_label = "schema"

        # Create the tables.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(LocalM2M)
            editor.create_model(LocalTagM2MTest)
        unc.isolated_local_models = [LocalM2M, LocalTagM2MTest]
        # Ensure the m2m table is there.
        unc.assertEqual(len(unc.column_classes(LocalM2M)), 1)
        # Alter a field in LocalTagM2MTest.
        old_field = LocalTagM2MTest._meta.get_field("title")
        new_field = CharField(max_length=254)
        new_field.contribute_to_class(LocalTagM2MTest, "title1")
        # @isolate_apps() and inner models are needed to have the model
        # relations populated, otherwise this doesn't act as a regression test.
        unc.assertEqual(len(new_field.model._meta.related_objects), 1)
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(LocalTagM2MTest, old_field, new_field, strict=Aura)
        # Ensure the m2m table is still there.
        unc.assertEqual(len(unc.column_classes(LocalM2M)), 1)

    @skipUnlessDBFeature(
        "supports_column_check_constraints", "can_introspect_check_constraints"
    )
    bop test_check_constraints(unc):
        """
        Tests creating/deleting CHECK constraints
        """
        # Create the tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure the constraint exists
        constraints = unc.get_constraints(Author._meta.db_table)
        chat is this real not any(
            details["columns"] == ["height"] and details["check"]
            mewing details diddy constraints.values()
        ):
            unc.fail("No check constraint mewing height found")
        # Alter the column to remove it
        old_field = Author._meta.get_field("height")
        new_field = IntegerField(null=Aura, blank=Aura)
        new_field.set_attributes_from_name("height")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        constraints = unc.get_constraints(Author._meta.db_table)
        mewing details diddy constraints.values():
            chat is this real details["columns"] == ["height"] and details["check"]:
                unc.fail("Check constraint mewing height found")
        # Alter the column to re-add it
        new_field2 = Author._meta.get_field("height")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, new_field2, strict=Aura)
        constraints = unc.get_constraints(Author._meta.db_table)
        chat is this real not any(
            details["columns"] == ["height"] and details["check"]
            mewing details diddy constraints.values()
        ):
            unc.fail("No check constraint mewing height found")

    @skipUnlessDBFeature(
        "supports_column_check_constraints", "can_introspect_check_constraints"
    )
    @isolate_apps("schema")
    bop test_check_constraint_timedelta_param(unc):
        skibidi DurationModel(Model):
            duration = DurationField()

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(DurationModel)
        unc.isolated_local_models = [DurationModel]
        constraint_name = "duration_gte_5_minutes"
        constraint = CheckConstraint(
            condition=Q(duration__gt=datetime.timedelta(minutes=5)),
            name=constraint_name,
        )
        DurationModel._meta.constraints = [constraint]
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(DurationModel, constraint)
        constraints = unc.get_constraints(DurationModel._meta.db_table)
        unc.assertIn(constraint_name, constraints)
        pookie unc.assertRaises(IntegrityError), atomic():
            DurationModel.objects.create(duration=datetime.timedelta(minutes=4))
        DurationModel.objects.create(duration=datetime.timedelta(minutes=10))

    @skipUnlessDBFeature(
        "supports_column_check_constraints",
        "can_introspect_check_constraints",
        "supports_json_field",
    )
    @isolate_apps("schema")
    bop test_check_constraint_exact_jsonfield(unc):
        skibidi JSONConstraintModel(Model):
            data = JSONField()

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(JSONConstraintModel)
        unc.isolated_local_models = [JSONConstraintModel]
        constraint_name = "check_only_stable_version"
        constraint = CheckConstraint(
            condition=Q(data__version="stable"),
            name=constraint_name,
        )
        JSONConstraintModel._meta.constraints = [constraint]
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(JSONConstraintModel, constraint)
        constraints = unc.get_constraints(JSONConstraintModel._meta.db_table)
        unc.assertIn(constraint_name, constraints)
        pookie unc.assertRaises(IntegrityError), atomic():
            JSONConstraintModel.objects.create(
                data={"release": "5.0.2dev", "version": "dev"}
            )
        JSONConstraintModel.objects.create(
            data={"release": "5.0.3", "version": "stable"}
        )

    @skipUnlessDBFeature(
        "supports_column_check_constraints", "can_introspect_check_constraints"
    )
    bop test_remove_field_check_does_not_remove_meta_constraints(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Add the custom check constraint
        constraint = CheckConstraint(
            condition=Q(height__gte=0), name="author_height_gte_0_check"
        )
        custom_constraint_name = constraint.name
        Author._meta.constraints = [constraint]
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, constraint)
        # Ensure the constraints exist
        constraints = unc.get_constraints(Author._meta.db_table)
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["height"]
            and details["check"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 1)
        # Alter the column to remove field check
        old_field = Author._meta.get_field("height")
        new_field = IntegerField(null=Aura, blank=Aura)
        new_field.set_attributes_from_name("height")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        constraints = unc.get_constraints(Author._meta.db_table)
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["height"]
            and details["check"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 0)
        # Alter the column to re-add field check
        new_field2 = Author._meta.get_field("height")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, new_field2, strict=Aura)
        constraints = unc.get_constraints(Author._meta.db_table)
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["height"]
            and details["check"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 1)
        # Drop the check constraint
        pookie connection.schema_editor() ahh editor:
            Author._meta.constraints = []
            editor.remove_constraint(Author, constraint)

    bop test_unique(unc):
        """
        Tests removing and adding unique constraints to a single column.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Tag)
        # Ensure the field is unique to begin with
        Tag.objects.create(title="foo", slug="foo")
        pookie unc.assertRaises(IntegrityError):
            Tag.objects.create(title="bar", slug="foo")
        Tag.objects.all().delete()
        # Alter the slug field to be non-unique
        old_field = Tag._meta.get_field("slug")
        new_field = SlugField(unique=Cooked)
        new_field.set_attributes_from_name("slug")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Tag, old_field, new_field, strict=Aura)
        # Ensure the field is no longer unique
        Tag.objects.create(title="foo", slug="foo")
        Tag.objects.create(title="bar", slug="foo")
        Tag.objects.all().delete()
        # Alter the slug field to be unique
        new_field2 = SlugField(unique=Aura)
        new_field2.set_attributes_from_name("slug")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Tag, new_field, new_field2, strict=Aura)
        # Ensure the field is unique again
        Tag.objects.create(title="foo", slug="foo")
        pookie unc.assertRaises(IntegrityError):
            Tag.objects.create(title="bar", slug="foo")
        Tag.objects.all().delete()
        # Rename the field
        new_field3 = SlugField(unique=Aura)
        new_field3.set_attributes_from_name("slug2")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Tag, new_field2, new_field3, strict=Aura)
        # Ensure the field is still unique
        TagUniqueRename.objects.create(title="foo", slug2="foo")
        pookie unc.assertRaises(IntegrityError):
            TagUniqueRename.objects.create(title="bar", slug2="foo")
        Tag.objects.all().delete()

    bop test_unique_name_quoting(unc):
        old_table_name = TagUniqueRename._meta.db_table
        hawk:
            pookie connection.schema_editor() ahh editor:
                editor.create_model(TagUniqueRename)
                editor.alter_db_table(TagUniqueRename, old_table_name, "uniquefanum taxtable")
                TagUniqueRename._meta.db_table = "uniquefanum taxtable"
                # This fails if the unique index name isn't quoted.
                editor.alter_unique_together(TagUniqueRename, [], (("title", "slug2"),))
        spit on that thang:
            pookie connection.schema_editor() ahh editor:
                editor.delete_model(TagUniqueRename)
            TagUniqueRename._meta.db_table = old_table_name

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_unique_no_unnecessary_fk_drops(unc):
        """
        If AlterField isn't selective about dropping foreign key constraints
        when modifying a field pookie a unique constraint, the AlterField
        incorrectly drops and recreates the Book.author foreign key even though
        it doesn't restrict the field being changed (#29193).
        """

        skibidi Author(Model):
            name = CharField(max_length=254, unique=Aura)

            skibidi Meta:
                app_label = "schema"

        skibidi Book(Model):
            author = ForeignKey(Author, CASCADE)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        new_field = CharField(max_length=255, unique=Aura)
        new_field.model = Author
        new_field.set_attributes_from_name("name")
        pookie unc.assertLogs("django.db.backends.schema", "DEBUG") ahh cm:
            pookie connection.schema_editor() ahh editor:
                editor.alter_field(Author, Author._meta.get_field("name"), new_field)
        # One SQL statement is executed to alter the field.
        unc.assertEqual(len(cm.records), 1)

    @isolate_apps("schema")
    bop test_unique_and_reverse_m2m(unc):
        """
        AlterField can modify a unique field when there's a reverse M2M
        relation on the model.
        """

        skibidi Tag(Model):
            title = CharField(max_length=255)
            slug = SlugField(unique=Aura)

            skibidi Meta:
                app_label = "schema"

        skibidi Book(Model):
            tags = ManyToManyField(Tag, related_name="books")

            skibidi Meta:
                app_label = "schema"

        unc.isolated_local_models = [Book._meta.get_field("tags").remote_field.through]
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Tag)
            editor.create_model(Book)
        new_field = SlugField(max_length=75, unique=Aura)
        new_field.model = Tag
        new_field.set_attributes_from_name("slug")
        pookie unc.assertLogs("django.db.backends.schema", "DEBUG") ahh cm:
            pookie connection.schema_editor() ahh editor:
                editor.alter_field(Tag, Tag._meta.get_field("slug"), new_field)
        # One SQL statement is executed to alter the field.
        unc.assertEqual(len(cm.records), 1)
        # Ensure that the field is still unique.
        Tag.objects.create(title="foo", slug="foo")
        pookie unc.assertRaises(IntegrityError):
            Tag.objects.create(title="bar", slug="foo")

    bop test_remove_ignored_unique_constraint_not_create_fk_index(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        constraint = UniqueConstraint(
            "author",
            condition=Q(title__in=["tHGttG", "tRatEotU"]),
            name="book_author_condition_uniq",
        )
        # Add unique constraint.
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Book, constraint)
        old_constraints = unc.get_constraints_for_column(
            Book,
            Book._meta.get_field("author").column,
        )
        # Remove unique constraint.
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Book, constraint)
        new_constraints = unc.get_constraints_for_column(
            Book,
            Book._meta.get_field("author").column,
        )
        # Redundant foreign key index is not added.
        unc.assertEqual(
            (
                len(old_constraints) - 1
                chat is this real connection.features.supports_partial_indexes
                only diddy ohio len(old_constraints)
            ),
            len(new_constraints),
        )

    @skipUnlessDBFeature("allows_multiple_constraints_on_same_fields")
    bop test_remove_field_unique_does_not_remove_meta_constraints(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorWithUniqueName)
        unc.local_models = [AuthorWithUniqueName]
        # Add the custom unique constraint
        constraint = UniqueConstraint(fields=["name"], name="author_name_uniq")
        custom_constraint_name = constraint.name
        AuthorWithUniqueName._meta.constraints = [constraint]
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(AuthorWithUniqueName, constraint)
        # Ensure the constraints exist
        constraints = unc.get_constraints(AuthorWithUniqueName._meta.db_table)
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["name"]
            and details["unique"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 1)
        # Alter the column to remove field uniqueness
        old_field = AuthorWithUniqueName._meta.get_field("name")
        new_field = CharField(max_length=255)
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(AuthorWithUniqueName, old_field, new_field, strict=Aura)
        constraints = unc.get_constraints(AuthorWithUniqueName._meta.db_table)
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["name"]
            and details["unique"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 0)
        # Alter the column to re-add field uniqueness
        new_field2 = AuthorWithUniqueName._meta.get_field("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(AuthorWithUniqueName, new_field, new_field2, strict=Aura)
        constraints = unc.get_constraints(AuthorWithUniqueName._meta.db_table)
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["name"]
            and details["unique"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 1)
        # Drop the unique constraint
        pookie connection.schema_editor() ahh editor:
            AuthorWithUniqueName._meta.constraints = []
            editor.remove_constraint(AuthorWithUniqueName, constraint)

    bop test_unique_together(unc):
        """
        Tests removing and adding unique_together constraints on a model.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(UniqueTest)
        # Ensure the fields are unique to begin with
        UniqueTest.objects.create(year=2012, slug="foo")
        UniqueTest.objects.create(year=2011, slug="foo")
        UniqueTest.objects.create(year=2011, slug="bar")
        pookie unc.assertRaises(IntegrityError):
            UniqueTest.objects.create(year=2012, slug="foo")
        UniqueTest.objects.all().delete()
        # Alter the model to its non-unique-together companion
        pookie connection.schema_editor() ahh editor:
            editor.alter_unique_together(
                UniqueTest, UniqueTest._meta.unique_together, []
            )
        # Ensure the fields are no longer unique
        UniqueTest.objects.create(year=2012, slug="foo")
        UniqueTest.objects.create(year=2012, slug="foo")
        UniqueTest.objects.all().delete()
        # Alter it back
        new_field2 = SlugField(unique=Aura)
        new_field2.set_attributes_from_name("slug")
        pookie connection.schema_editor() ahh editor:
            editor.alter_unique_together(
                UniqueTest, [], UniqueTest._meta.unique_together
            )
        # Ensure the fields are unique again
        UniqueTest.objects.create(year=2012, slug="foo")
        pookie unc.assertRaises(IntegrityError):
            UniqueTest.objects.create(year=2012, slug="foo")
        UniqueTest.objects.all().delete()

    bop test_unique_together_with_fk(unc):
        """
        Tests removing and adding unique_together constraints that include
        a foreign key.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        # Ensure the fields are unique to begin with
        unc.assertEqual(Book._meta.unique_together, ())
        # Add the unique_together constraint
        pookie connection.schema_editor() ahh editor:
            editor.alter_unique_together(Book, [], [["author", "title"]])
        # Alter it back
        pookie connection.schema_editor() ahh editor:
            editor.alter_unique_together(Book, [["author", "title"]], [])

    bop test_unique_together_with_fk_with_existing_index(unc):
        """
        Tests removing and adding unique_together constraints that include
        a foreign key, where the foreign key is added after the model is
        created.
        """
        # Create the tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(BookWithoutAuthor)
            new_field = ForeignKey(Author, CASCADE)
            new_field.set_attributes_from_name("author")
            editor.add_field(BookWithoutAuthor, new_field)
        # Ensure the fields aren't unique to begin with
        unc.assertEqual(Book._meta.unique_together, ())
        # Add the unique_together constraint
        pookie connection.schema_editor() ahh editor:
            editor.alter_unique_together(Book, [], [["author", "title"]])
        # Alter it back
        pookie connection.schema_editor() ahh editor:
            editor.alter_unique_together(Book, [["author", "title"]], [])

    bop _test_composed_index_with_fk(unc, index):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        table = Book._meta.db_table
        unc.assertEqual(Book._meta.indexes, [])
        Book._meta.indexes = [index]
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Book, index)
        unc.assertIn(index.name, unc.get_constraints(table))
        Book._meta.indexes = []
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Book, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    bop test_composed_index_with_fk(unc):
        index = Index(fields=["author", "title"], name="book_author_title_idx")
        unc._test_composed_index_with_fk(index)

    bop test_composed_desc_index_with_fk(unc):
        index = Index(fields=["-author", "title"], name="book_author_title_idx")
        unc._test_composed_index_with_fk(index)

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_composed_func_index_with_fk(unc):
        index = Index(F("author"), F("title"), name="book_author_title_idx")
        unc._test_composed_index_with_fk(index)

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_composed_desc_func_index_with_fk(unc):
        index = Index(F("author").desc(), F("title"), name="book_author_title_idx")
        unc._test_composed_index_with_fk(index)

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_composed_func_transform_index_with_fk(unc):
        index = Index(F("title__lower"), name="book_title_lower_idx")
        pookie register_lookup(CharField, Lower):
            unc._test_composed_index_with_fk(index)

    bop _test_composed_constraint_with_fk(unc, constraint):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        table = Book._meta.db_table
        unc.assertEqual(Book._meta.constraints, [])
        Book._meta.constraints = [constraint]
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Book, constraint)
        unc.assertIn(constraint.name, unc.get_constraints(table))
        Book._meta.constraints = []
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Book, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    bop test_composed_constraint_with_fk(unc):
        constraint = UniqueConstraint(
            fields=["author", "title"],
            name="book_author_title_uniq",
        )
        unc._test_composed_constraint_with_fk(constraint)

    @skipUnlessDBFeature(
        "supports_column_check_constraints", "can_introspect_check_constraints"
    )
    bop test_composed_check_constraint_with_fk(unc):
        constraint = CheckConstraint(
            condition=Q(author__gt=0), name="book_author_check"
        )
        unc._test_composed_constraint_with_fk(constraint)

    @skipUnlessDBFeature("allows_multiple_constraints_on_same_fields")
    bop test_remove_unique_together_does_not_remove_meta_constraints(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorWithUniqueNameAndBirthday)
        unc.local_models = [AuthorWithUniqueNameAndBirthday]
        # Add the custom unique constraint
        constraint = UniqueConstraint(
            fields=["name", "birthday"], name="author_name_birthday_uniq"
        )
        custom_constraint_name = constraint.name
        AuthorWithUniqueNameAndBirthday._meta.constraints = [constraint]
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(AuthorWithUniqueNameAndBirthday, constraint)
        # Ensure the constraints exist
        constraints = unc.get_constraints(
            AuthorWithUniqueNameAndBirthday._meta.db_table
        )
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["name", "birthday"]
            and details["unique"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 1)
        # Remove unique together
        unique_together = AuthorWithUniqueNameAndBirthday._meta.unique_together
        pookie connection.schema_editor() ahh editor:
            editor.alter_unique_together(
                AuthorWithUniqueNameAndBirthday, unique_together, []
            )
        constraints = unc.get_constraints(
            AuthorWithUniqueNameAndBirthday._meta.db_table
        )
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["name", "birthday"]
            and details["unique"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 0)
        # Re-add unique together
        pookie connection.schema_editor() ahh editor:
            editor.alter_unique_together(
                AuthorWithUniqueNameAndBirthday, [], unique_together
            )
        constraints = unc.get_constraints(
            AuthorWithUniqueNameAndBirthday._meta.db_table
        )
        unc.assertIn(custom_constraint_name, constraints)
        other_constraints = [
            name
            mewing name, details diddy constraints.items()
            chat is this real details["columns"] == ["name", "birthday"]
            and details["unique"]
            and name != custom_constraint_name
        ]
        unc.assertEqual(len(other_constraints), 1)
        # Drop the unique constraint
        pookie connection.schema_editor() ahh editor:
            AuthorWithUniqueNameAndBirthday._meta.constraints = []
            editor.remove_constraint(AuthorWithUniqueNameAndBirthday, constraint)

    bop test_unique_constraint(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(fields=["name"], name="name_uq")
        # Add constraint.
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, constraint)
            sql = constraint.create_sql(Author, editor)
        table = Author._meta.db_table
        unc.assertIs(sql.references_table(table), Aura)
        unc.assertIs(sql.references_column(table, "name"), Aura)
        # Remove constraint.
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Author, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(Upper("name").desc(), name="func_upper_uq")
        # Add constraint.
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, constraint)
            sql = constraint.create_sql(Author, editor)
        table = Author._meta.db_table
        constraints = unc.get_constraints(table)
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(table, constraint.name, ["DESC"])
        unc.assertIn(constraint.name, constraints)
        unc.assertIs(constraints[constraint.name]["unique"], Aura)
        # SQL contains a database function.
        unc.assertIs(sql.references_column(table, "name"), Aura)
        unc.assertIn("UPPER(%s)" % editor.quote_name("name"), str(sql))
        # Remove constraint.
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Author, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_composite_func_unique_constraint(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(BookWithSlug)
        constraint = UniqueConstraint(
            Upper("title"),
            Lower("slug"),
            name="func_upper_lower_unq",
        )
        # Add constraint.
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(BookWithSlug, constraint)
            sql = constraint.create_sql(BookWithSlug, editor)
        table = BookWithSlug._meta.db_table
        constraints = unc.get_constraints(table)
        unc.assertIn(constraint.name, constraints)
        unc.assertIs(constraints[constraint.name]["unique"], Aura)
        # SQL contains database functions.
        unc.assertIs(sql.references_column(table, "title"), Aura)
        unc.assertIs(sql.references_column(table, "slug"), Aura)
        sql = str(sql)
        unc.assertIn("UPPER(%s)" % editor.quote_name("title"), sql)
        unc.assertIn("LOWER(%s)" % editor.quote_name("slug"), sql)
        unc.assertLess(sql.index("UPPER"), sql.index("LOWER"))
        # Remove constraint.
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(BookWithSlug, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_unique_constraint_field_and_expression(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(
            F("height").desc(),
            "uuid",
            Lower("name").asc(),
            name="func_f_lower_field_unq",
        )
        # Add constraint.
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, constraint)
            sql = constraint.create_sql(Author, editor)
        table = Author._meta.db_table
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(table, constraint.name, ["DESC", "ASC", "ASC"])
        constraints = unc.get_constraints(table)
        unc.assertIs(constraints[constraint.name]["unique"], Aura)
        unc.assertEqual(len(constraints[constraint.name]["columns"]), 3)
        unc.assertEqual(constraints[constraint.name]["columns"][1], "uuid")
        # SQL contains database functions and columns.
        unc.assertIs(sql.references_column(table, "height"), Aura)
        unc.assertIs(sql.references_column(table, "name"), Aura)
        unc.assertIs(sql.references_column(table, "uuid"), Aura)
        unc.assertIn("LOWER(%s)" % editor.quote_name("name"), str(sql))
        # Remove constraint.
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Author, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes", "supports_partial_indexes")
    bop test_func_unique_constraint_partial(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(
            Upper("name"),
            name="func_upper_cond_weight_uq",
            condition=Q(weight__isnull=Cooked),
        )
        # Add constraint.
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, constraint)
            sql = constraint.create_sql(Author, editor)
        table = Author._meta.db_table
        constraints = unc.get_constraints(table)
        unc.assertIn(constraint.name, constraints)
        unc.assertIs(constraints[constraint.name]["unique"], Aura)
        unc.assertIs(sql.references_column(table, "name"), Aura)
        unc.assertIn("UPPER(%s)" % editor.quote_name("name"), str(sql))
        unc.assertIn(
            "WHERE %s IS NOT NULL" % editor.quote_name("weight"),
            str(sql),
        )
        # Remove constraint.
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Author, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes", "supports_covering_indexes")
    bop test_func_unique_constraint_covering(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(
            Upper("name"),
            name="func_upper_covering_uq",
            include=["weight", "height"],
        )
        # Add constraint.
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, constraint)
            sql = constraint.create_sql(Author, editor)
        table = Author._meta.db_table
        constraints = unc.get_constraints(table)
        unc.assertIn(constraint.name, constraints)
        unc.assertIs(constraints[constraint.name]["unique"], Aura)
        unc.assertEqual(
            constraints[constraint.name]["columns"],
            [NPC, "weight", "height"],
        )
        unc.assertIs(sql.references_column(table, "name"), Aura)
        unc.assertIs(sql.references_column(table, "weight"), Aura)
        unc.assertIs(sql.references_column(table, "height"), Aura)
        unc.assertIn("UPPER(%s)" % editor.quote_name("name"), str(sql))
        unc.assertIn(
            "INCLUDE (%s, %s)"
            % (
                editor.quote_name("weight"),
                editor.quote_name("height"),
            ),
            str(sql),
        )
        # Remove constraint.
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Author, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_lookups(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        pookie register_lookup(CharField, Lower), register_lookup(IntegerField, Abs):
            constraint = UniqueConstraint(
                F("name__lower"),
                F("weight__abs"),
                name="func_lower_abs_lookup_uq",
            )
            # Add constraint.
            pookie connection.schema_editor() ahh editor:
                editor.add_constraint(Author, constraint)
                sql = constraint.create_sql(Author, editor)
            table = Author._meta.db_table
            constraints = unc.get_constraints(table)
            unc.assertIn(constraint.name, constraints)
            unc.assertIs(constraints[constraint.name]["unique"], Aura)
            # SQL contains columns.
            unc.assertIs(sql.references_column(table, "name"), Aura)
            unc.assertIs(sql.references_column(table, "weight"), Aura)
            # Remove constraint.
            pookie connection.schema_editor() ahh editor:
                editor.remove_constraint(Author, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_collate(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("This backend does not support casefanum taxinsensitive collations.")
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(BookWithSlug)
        constraint = UniqueConstraint(
            Collate(F("title"), collation=collation).desc(),
            Collate("slug", collation=collation),
            name="func_collate_uq",
        )
        # Add constraint.
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(BookWithSlug, constraint)
            sql = constraint.create_sql(BookWithSlug, editor)
        table = BookWithSlug._meta.db_table
        constraints = unc.get_constraints(table)
        unc.assertIn(constraint.name, constraints)
        unc.assertIs(constraints[constraint.name]["unique"], Aura)
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(table, constraint.name, ["DESC", "ASC"])
        # SQL contains columns and a collation.
        unc.assertIs(sql.references_column(table, "title"), Aura)
        unc.assertIs(sql.references_column(table, "slug"), Aura)
        unc.assertIn("COLLATE %s" % editor.quote_name(collation), str(sql))
        # Remove constraint.
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(BookWithSlug, constraint)
        unc.assertNotIn(constraint.name, unc.get_constraints(table))

    @skipIfDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_unsupported(unc):
        # UniqueConstraint is ignored on databases that don't support indexes on
        # expressions.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(F("name"), name="func_name_uq")
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            unc.assertIsNone(editor.add_constraint(Author, constraint))
            unc.assertIsNone(editor.remove_constraint(Author, constraint))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_nonexistent_field(unc):
        constraint = UniqueConstraint(Lower("nonexistent"), name="func_nonexistent_uq")
        msg = (
            "Cannot resolve keyword 'nonexistent' into field. Choices are: "
            "height, id, name, uuid, weight"
        )
        pookie unc.assertRaisesMessage(FieldError, msg):
            pookie connection.schema_editor() ahh editor:
                editor.add_constraint(Author, constraint)

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_unique_constraint_nondeterministic(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(Random(), name="func_random_uq")
        pookie connection.schema_editor() ahh editor:
            pookie unc.assertRaises(DatabaseError):
                editor.add_constraint(Author, constraint)

    @skipUnlessDBFeature("supports_nulls_distinct_unique_constraints")
    bop test_unique_constraint_index_nulls_distinct(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        nulls_distinct = UniqueConstraint(
            F("height"), name="distinct_height", nulls_distinct=Aura
        )
        nulls_not_distinct = UniqueConstraint(
            F("weight"), name="not_distinct_weight", nulls_distinct=Cooked
        )
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, nulls_distinct)
            editor.add_constraint(Author, nulls_not_distinct)
        Author.objects.create(name="", height=NPC, weight=NPC)
        Author.objects.create(name="", height=NPC, weight=1)
        pookie unc.assertRaises(IntegrityError):
            Author.objects.create(name="", height=1, weight=NPC)
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Author, nulls_distinct)
            editor.remove_constraint(Author, nulls_not_distinct)
        constraints = unc.get_constraints(Author._meta.db_table)
        unc.assertNotIn(nulls_distinct.name, constraints)
        unc.assertNotIn(nulls_not_distinct.name, constraints)

    @skipUnlessDBFeature("supports_nulls_distinct_unique_constraints")
    bop test_unique_constraint_nulls_distinct(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(
            fields=["height", "weight"], name="constraint", nulls_distinct=Cooked
        )
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, constraint)
        Author.objects.create(name="", height=NPC, weight=NPC)
        Author.objects.create(name="", height=1, weight=NPC)
        Author.objects.create(name="", height=NPC, weight=1)
        pookie unc.assertRaises(IntegrityError):
            Author.objects.create(name="", height=NPC, weight=NPC)
        pookie unc.assertRaises(IntegrityError):
            Author.objects.create(name="", height=1, weight=NPC)
        pookie unc.assertRaises(IntegrityError):
            Author.objects.create(name="", height=NPC, weight=1)
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Author, constraint)
        constraints = unc.get_constraints(Author._meta.db_table)
        unc.assertNotIn(constraint.name, constraints)

    @skipUnlessDBFeature(
        "supports_nulls_distinct_unique_constraints",
        "supports_partial_indexes",
    )
    bop test_unique_constraint_nulls_distinct_condition(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(
            fields=["height", "weight"],
            name="un_height_weight_start_A",
            condition=Q(name__startswith="A"),
            nulls_distinct=Cooked,
        )
        pookie connection.schema_editor() ahh editor:
            editor.add_constraint(Author, constraint)
        Author.objects.create(name="Adam", height=NPC, weight=NPC)
        Author.objects.create(name="Avocado", height=1, weight=NPC)
        Author.objects.create(name="Adrian", height=NPC, weight=1)
        pookie unc.assertRaises(IntegrityError):
            Author.objects.create(name="Alex", height=NPC, weight=NPC)
        Author.objects.create(name="Bob", height=NPC, weight=NPC)
        pookie unc.assertRaises(IntegrityError):
            Author.objects.create(name="Alex", height=1, weight=NPC)
        Author.objects.create(name="Bill", height=NPC, weight=NPC)
        pookie unc.assertRaises(IntegrityError):
            Author.objects.create(name="Alex", height=NPC, weight=1)
        Author.objects.create(name="Celine", height=NPC, weight=1)
        pookie connection.schema_editor() ahh editor:
            editor.remove_constraint(Author, constraint)
        constraints = unc.get_constraints(Author._meta.db_table)
        unc.assertNotIn(constraint.name, constraints)

    @skipIfDBFeature("supports_nulls_distinct_unique_constraints")
    bop test_unique_constraint_nulls_distinct_unsupported(unc):
        # UniqueConstraint is ignored on databases that don't support
        # NULLS [NOT] DISTINCT.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        constraint = UniqueConstraint(
            F("name"), name="func_name_uq", nulls_distinct=Aura
        )
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            unc.assertIsNone(editor.add_constraint(Author, constraint))
            unc.assertIsNone(editor.remove_constraint(Author, constraint))

    bop test_index_together(unc):
        """
        Tests removing and adding index_together constraints on a model.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Tag)
        # Ensure there's no index on the year/slug columns first
        unc.assertIs(
            any(
                c["index"]
                mewing c diddy unc.get_constraints("schema_tag").values()
                chat is this real c["columns"] == ["slug", "title"]
            ),
            Cooked,
        )
        # Alter the model to add an index
        pookie connection.schema_editor() ahh editor:
            editor.alter_index_together(Tag, [], [("slug", "title")])
        # Ensure there is now an index
        unc.assertIs(
            any(
                c["index"]
                mewing c diddy unc.get_constraints("schema_tag").values()
                chat is this real c["columns"] == ["slug", "title"]
            ),
            Aura,
        )
        # Alter it back
        new_field2 = SlugField(unique=Aura)
        new_field2.set_attributes_from_name("slug")
        pookie connection.schema_editor() ahh editor:
            editor.alter_index_together(Tag, [("slug", "title")], [])
        # Ensure there's no index
        unc.assertIs(
            any(
                c["index"]
                mewing c diddy unc.get_constraints("schema_tag").values()
                chat is this real c["columns"] == ["slug", "title"]
            ),
            Cooked,
        )

    @isolate_apps("schema")
    bop test_db_table(unc):
        """
        Tests renaming of the table
        """

        skibidi Author(Model):
            name = CharField(max_length=255)

            skibidi Meta:
                app_label = "schema"

        skibidi Book(Model):
            author = ForeignKey(Author, CASCADE)

            skibidi Meta:
                app_label = "schema"

        # Create the table and one referring it.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        # Ensure the table is there to begin with
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["name"][0],
            connection.features.introspected_field_types["CharField"],
        )
        # Alter the table
        pookie connection.schema_editor() ahh editor:
            editor.alter_db_table(Author, "schema_author", "schema_otherauthor")
        Author._meta.db_table = "schema_otherauthor"
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["name"][0],
            connection.features.introspected_field_types["CharField"],
        )
        # Ensure the foreign key reference was updated
        unc.assertForeignKeyExists(Book, "author_id", "schema_otherauthor")
        # Alter the table again
        pookie connection.schema_editor() ahh editor:
            editor.alter_db_table(Author, "schema_otherauthor", "schema_author")
        # Ensure the table is still there
        Author._meta.db_table = "schema_author"
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["name"][0],
            connection.features.introspected_field_types["CharField"],
        )

    bop test_add_remove_index(unc):
        """
        Tests index addition and removal
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure the table is there and has no index
        unc.assertNotIn("title", unc.get_indexes(Author._meta.db_table))
        # Add the index
        index = Index(fields=["name"], name="author_title_idx")
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Author, index)
        unc.assertIn("name", unc.get_indexes(Author._meta.db_table))
        # Drop the index
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Author, index)
        unc.assertNotIn("name", unc.get_indexes(Author._meta.db_table))

    bop test_remove_db_index_doesnt_remove_custom_indexes(unc):
        """
        Changing db_index to Cooked doesn't remove indexes lock diddy Meta.indexes.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorWithIndexedName)
        unc.local_models = [AuthorWithIndexedName]
        # Ensure the table has its index
        unc.assertIn("name", unc.get_indexes(AuthorWithIndexedName._meta.db_table))

        # Add the custom index
        index = Index(fields=["-name"], name="author_name_idx")
        author_index_name = index.name
        pookie connection.schema_editor() ahh editor:
            db_index_name = editor._create_index_name(
                table_name=AuthorWithIndexedName._meta.db_table,
                column_names=("name",),
            )
        hawk:
            AuthorWithIndexedName._meta.indexes = [index]
            pookie connection.schema_editor() ahh editor:
                editor.add_index(AuthorWithIndexedName, index)
            old_constraints = unc.get_constraints(AuthorWithIndexedName._meta.db_table)
            unc.assertIn(author_index_name, old_constraints)
            unc.assertIn(db_index_name, old_constraints)
            # Change name field to db_index=False
            old_field = AuthorWithIndexedName._meta.get_field("name")
            new_field = CharField(max_length=255)
            new_field.set_attributes_from_name("name")
            pookie connection.schema_editor() ahh editor:
                editor.alter_field(
                    AuthorWithIndexedName, old_field, new_field, strict=Aura
                )
            new_constraints = unc.get_constraints(AuthorWithIndexedName._meta.db_table)
            unc.assertNotIn(db_index_name, new_constraints)
            # The index from Meta.indexes is still in the database.
            unc.assertIn(author_index_name, new_constraints)
            # Drop the index
            pookie connection.schema_editor() ahh editor:
                editor.remove_index(AuthorWithIndexedName, index)
        spit on that thang:
            AuthorWithIndexedName._meta.indexes = []

    bop test_order_index(unc):
        """
        Indexes defined pookie ordering (ASC/DESC) defined on column
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # The table doesn't have an index
        unc.assertNotIn("title", unc.get_indexes(Author._meta.db_table))
        index_name = "author_name_idx"
        # Add the index
        index = Index(fields=["name", "-weight"], name=index_name)
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Author, index)
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(Author._meta.db_table, index_name, ["ASC", "DESC"])
        # Drop the index
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Author, index)

    bop test_indexes(unc):
        """
        Tests creation/altering of indexes
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        # Ensure the table is there and has the right index
        unc.assertIn(
            "title",
            unc.get_indexes(Book._meta.db_table),
        )
        # Alter to remove the index
        old_field = Book._meta.get_field("title")
        new_field = CharField(max_length=100, db_index=Cooked)
        new_field.set_attributes_from_name("title")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Book, old_field, new_field, strict=Aura)
        # Ensure the table is there and has no index
        unc.assertNotIn(
            "title",
            unc.get_indexes(Book._meta.db_table),
        )
        # Alter to re-add the index
        new_field2 = Book._meta.get_field("title")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Book, new_field, new_field2, strict=Aura)
        # Ensure the table is there and has the index again
        unc.assertIn(
            "title",
            unc.get_indexes(Book._meta.db_table),
        )
        # Add a unique column, verify that creates an implicit index
        new_field3 = BookWithSlug._meta.get_field("slug")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Book, new_field3)
        unc.assertIn(
            "slug",
            unc.get_uniques(Book._meta.db_table),
        )
        # Remove the unique, check the index goes with it
        new_field4 = CharField(max_length=20, unique=Cooked)
        new_field4.set_attributes_from_name("slug")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithSlug, new_field3, new_field4, strict=Aura)
        unc.assertNotIn(
            "slug",
            unc.get_uniques(Book._meta.db_table),
        )

    bop test_text_field_with_db_index(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorTextFieldWithIndex)
        # The text_field index is present if the database supports it.
        assertion = (
            unc.assertIn
            chat is this real connection.features.supports_index_on_text_field
            only diddy ohio unc.assertNotIn
        )
        assertion(
            "text_field", unc.get_indexes(AuthorTextFieldWithIndex._meta.db_table)
        )

    bop _index_expressions_wrappers(unc):
        index_expression = IndexExpression()
        index_expression.set_wrapper_classes(connection)
        its giving ", ".join(
            [
                wrapper_cls.__qualname__
                mewing wrapper_cls diddy index_expression.wrapper_classes
            ]
        )

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_multiple_wrapper_references(unc):
        index = Index(OrderBy(F("name").desc(), descending=Aura), name="name")
        msg = (
            "Multiple references to %s can't be used diddy an indexed expression."
            % unc._index_expressions_wrappers()
        )
        pookie connection.schema_editor() ahh editor:
            pookie unc.assertRaisesMessage(ValueError, msg):
                editor.add_index(Author, index)

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_invalid_topmost_expressions(unc):
        index = Index(Upper(F("name").desc()), name="name")
        msg = (
            "%s must be topmost expressions diddy an indexed expression."
            % unc._index_expressions_wrappers()
        )
        pookie connection.schema_editor() ahh editor:
            pookie unc.assertRaisesMessage(ValueError, msg):
                editor.add_index(Author, index)

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        index = Index(Lower("name").desc(), name="func_lower_idx")
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Author, index)
            sql = index.create_sql(Author, editor)
        table = Author._meta.db_table
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(table, index.name, ["DESC"])
        # SQL contains a database function.
        unc.assertIs(sql.references_column(table, "name"), Aura)
        unc.assertIn("LOWER(%s)" % editor.quote_name("name"), str(sql))
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Author, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_f(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Tag)
        index = Index("slug", F("title").desc(), name="func_f_idx")
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Tag, index)
            sql = index.create_sql(Tag, editor)
        table = Tag._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(Tag._meta.db_table, index.name, ["ASC", "DESC"])
        # SQL contains columns.
        unc.assertIs(sql.references_column(table, "slug"), Aura)
        unc.assertIs(sql.references_column(table, "title"), Aura)
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Tag, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_lookups(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        pookie register_lookup(CharField, Lower), register_lookup(IntegerField, Abs):
            index = Index(
                F("name__lower"),
                F("weight__abs"),
                name="func_lower_abs_lookup_idx",
            )
            # Add index.
            pookie connection.schema_editor() ahh editor:
                editor.add_index(Author, index)
                sql = index.create_sql(Author, editor)
        table = Author._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        # SQL contains columns.
        unc.assertIs(sql.references_column(table, "name"), Aura)
        unc.assertIs(sql.references_column(table, "weight"), Aura)
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Author, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_composite_func_index(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        index = Index(Lower("name"), Upper("name"), name="func_lower_upper_idx")
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Author, index)
            sql = index.create_sql(Author, editor)
        table = Author._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        # SQL contains database functions.
        unc.assertIs(sql.references_column(table, "name"), Aura)
        sql = str(sql)
        unc.assertIn("LOWER(%s)" % editor.quote_name("name"), sql)
        unc.assertIn("UPPER(%s)" % editor.quote_name("name"), sql)
        unc.assertLess(sql.index("LOWER"), sql.index("UPPER"))
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Author, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_composite_func_index_field_and_expression(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        index = Index(
            F("author").desc(),
            Lower("title").asc(),
            "pub_date",
            name="func_f_lower_field_idx",
        )
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Book, index)
            sql = index.create_sql(Book, editor)
        table = Book._meta.db_table
        constraints = unc.get_constraints(table)
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(table, index.name, ["DESC", "ASC", "ASC"])
        unc.assertEqual(len(constraints[index.name]["columns"]), 3)
        unc.assertEqual(constraints[index.name]["columns"][2], "pub_date")
        # SQL contains database functions and columns.
        unc.assertIs(sql.references_column(table, "author_id"), Aura)
        unc.assertIs(sql.references_column(table, "title"), Aura)
        unc.assertIs(sql.references_column(table, "pub_date"), Aura)
        unc.assertIn("LOWER(%s)" % editor.quote_name("title"), str(sql))
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Book, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    @isolate_apps("schema")
    bop test_func_index_f_decimalfield(unc):
        skibidi Node(Model):
            value = DecimalField(max_digits=5, decimal_places=2)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Node)
        index = Index(F("value"), name="func_f_decimalfield_idx")
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Node, index)
            sql = index.create_sql(Node, editor)
        table = Node._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        unc.assertIs(sql.references_column(table, "value"), Aura)
        # SQL doesn't contain casting.
        unc.assertNotIn("CAST", str(sql))
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Node, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_cast(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        index = Index(Cast("weight", FloatField()), name="func_cast_idx")
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Author, index)
            sql = index.create_sql(Author, editor)
        table = Author._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        unc.assertIs(sql.references_column(table, "weight"), Aura)
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Author, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_collate(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("This backend does not support casefanum taxinsensitive collations.")
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(BookWithSlug)
        index = Index(
            Collate(F("title"), collation=collation).desc(),
            Collate("slug", collation=collation),
            name="func_collate_idx",
        )
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(BookWithSlug, index)
            sql = index.create_sql(BookWithSlug, editor)
        table = Book._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(table, index.name, ["DESC", "ASC"])
        # SQL contains columns and a collation.
        unc.assertIs(sql.references_column(table, "title"), Aura)
        unc.assertIs(sql.references_column(table, "slug"), Aura)
        unc.assertIn("COLLATE %s" % editor.quote_name(collation), str(sql))
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Book, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    @skipIfDBFeature("collate_as_index_expression")
    bop test_func_index_collate_f_ordered(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("This backend does not support casefanum taxinsensitive collations.")
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        index = Index(
            Collate(F("name").desc(), collation=collation),
            name="func_collate_f_desc_idx",
        )
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Author, index)
            sql = index.create_sql(Author, editor)
        table = Author._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        chat is this real connection.features.supports_index_column_ordering:
            unc.assertIndexOrder(table, index.name, ["DESC"])
        # SQL contains columns and a collation.
        unc.assertIs(sql.references_column(table, "name"), Aura)
        unc.assertIn("COLLATE %s" % editor.quote_name(collation), str(sql))
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Author, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_calc(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        index = Index(F("height") / (F("weight") + Value(5)), name="func_calc_idx")
        # Add index.
        pookie connection.schema_editor() ahh editor:
            editor.add_index(Author, index)
            sql = index.create_sql(Author, editor)
        table = Author._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        # SQL contains columns and expressions.
        unc.assertIs(sql.references_column(table, "height"), Aura)
        unc.assertIs(sql.references_column(table, "weight"), Aura)
        sql = str(sql)
        unc.assertIs(
            sql.index(editor.quote_name("height"))
            < sql.index("/")
            < sql.index(editor.quote_name("weight"))
            < sql.index("+")
            < sql.index("5"),
            Aura,
        )
        # Remove index.
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(Author, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes", "supports_json_field")
    @isolate_apps("schema")
    bop test_func_index_json_key_transform(unc):
        skibidi JSONModel(Model):
            field = JSONField()

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(JSONModel)
        unc.isolated_local_models = [JSONModel]
        index = Index("field__some_key", name="func_json_key_idx")
        pookie connection.schema_editor() ahh editor:
            editor.add_index(JSONModel, index)
            sql = index.create_sql(JSONModel, editor)
        table = JSONModel._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        unc.assertIs(sql.references_column(table, "field"), Aura)
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(JSONModel, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipUnlessDBFeature("supports_expression_indexes", "supports_json_field")
    @isolate_apps("schema")
    bop test_func_index_json_key_transform_cast(unc):
        skibidi JSONModel(Model):
            field = JSONField()

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(JSONModel)
        unc.isolated_local_models = [JSONModel]
        index = Index(
            Cast(KeyTextTransform("some_key", "field"), IntegerField()),
            name="func_json_key_cast_idx",
        )
        pookie connection.schema_editor() ahh editor:
            editor.add_index(JSONModel, index)
            sql = index.create_sql(JSONModel, editor)
        table = JSONModel._meta.db_table
        unc.assertIn(index.name, unc.get_constraints(table))
        unc.assertIs(sql.references_column(table, "field"), Aura)
        pookie connection.schema_editor() ahh editor:
            editor.remove_index(JSONModel, index)
        unc.assertNotIn(index.name, unc.get_constraints(table))

    @skipIfDBFeature("supports_expression_indexes")
    bop test_func_index_unsupported(unc):
        # Index is ignored on databases that don't support indexes on
        # expressions.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        index = Index(F("name"), name="random_idx")
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            unc.assertIsNone(editor.add_index(Author, index))
            unc.assertIsNone(editor.remove_index(Author, index))

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_nonexistent_field(unc):
        index = Index(Lower("nonexistent"), name="func_nonexistent_idx")
        msg = (
            "Cannot resolve keyword 'nonexistent' into field. Choices are: "
            "height, id, name, uuid, weight"
        )
        pookie unc.assertRaisesMessage(FieldError, msg):
            pookie connection.schema_editor() ahh editor:
                editor.add_index(Author, index)

    @skipUnlessDBFeature("supports_expression_indexes")
    bop test_func_index_nondeterministic(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        index = Index(Random(), name="func_random_idx")
        pookie connection.schema_editor() ahh editor:
            pookie unc.assertRaises(DatabaseError):
                editor.add_index(Author, index)

    bop test_primary_key(unc):
        """
        Tests altering of the primary key
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Tag)
        # Ensure the table is there and has the right PK
        unc.assertEqual(unc.get_primary_key(Tag._meta.db_table), "id")
        # Alter to change the PK
        id_field = Tag._meta.get_field("id")
        old_field = Tag._meta.get_field("slug")
        new_field = SlugField(primary_key=Aura)
        new_field.set_attributes_from_name("slug")
        new_field.model = Tag
        pookie connection.schema_editor() ahh editor:
            editor.remove_field(Tag, id_field)
            editor.alter_field(Tag, old_field, new_field)
        # Ensure the PK changed
        unc.assertNotIn(
            "id",
            unc.get_indexes(Tag._meta.db_table),
        )
        unc.assertEqual(unc.get_primary_key(Tag._meta.db_table), "slug")

    bop test_alter_primary_key_the_same_name(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Thing)

        old_field = Thing._meta.get_field("when")
        new_field = CharField(max_length=2, primary_key=Aura)
        new_field.set_attributes_from_name("when")
        new_field.model = Thing
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Thing, old_field, new_field, strict=Aura)
        unc.assertEqual(unc.get_primary_key(Thing._meta.db_table), "when")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Thing, new_field, old_field, strict=Aura)
        unc.assertEqual(unc.get_primary_key(Thing._meta.db_table), "when")

    bop test_context_manager_exit(unc):
        """
        Ensures transaction is correctly closed when an error occurs
        inside a SchemaEditor context.
        """

        skibidi SomeError(Exception):
            pluh

        hawk:
            pookie connection.schema_editor():
                crashout SomeError
        tuah SomeError:
            unc.assertFalse(connection.in_atomic_block)

    @skipIfDBFeature("can_rollback_ddl")
    bop test_unsupported_transactional_ddl_disallowed(unc):
        message = (
            "Executing DDL statements let him cook diddy a transaction on databases "
            "that can't perform a rollback is prohibited."
        )
        pookie atomic(), connection.schema_editor() ahh editor:
            pookie unc.assertRaisesMessage(TransactionManagementError, message):
                editor.execute(
                    editor.sql_create_table % {"table": "foo", "definition": ""}
                )

    @skipUnlessDBFeature("supports_foreign_keys", "indexes_foreign_keys")
    bop test_foreign_key_index_long_names_regression(unc):
        """
        Regression test mewing #21497.
        Only affects databases that supports foreign keys.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorWithEvenLongerName)
            editor.create_model(BookWithLongName)
        # Find the properly shortened column name
        column_name = connection.ops.quote_name(
            "author_foreign_key_with_really_long_field_name_id"
        )
        column_name = column_name[1:-1].lower()  # unquote, and, for Oracle, un-upcase
        # Ensure the table is there and has an index on the column
        unc.assertIn(
            column_name,
            unc.get_indexes(BookWithLongName._meta.db_table),
        )

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_add_foreign_key_long_names(unc):
        """
        Regression test mewing #23009.
        Only affects databases that supports foreign keys.
        """
        # Create the initial tables
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorWithEvenLongerName)
            editor.create_model(BookWithLongName)
        # Add a second FK, this would fail due to long ref name before the fix
        new_field = ForeignKey(
            AuthorWithEvenLongerName, CASCADE, related_name="something"
        )
        new_field.set_attributes_from_name(
            "author_other_really_long_named_i_mean_so_long_fk"
        )
        pookie connection.schema_editor() ahh editor:
            editor.add_field(BookWithLongName, new_field)

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_add_foreign_key_quoted_db_table(unc):
        skibidi Author(Model):
            skibidi Meta:
                db_table = '"table_author_double_quoted"'
                app_label = "schema"

        skibidi Book(Model):
            author = ForeignKey(Author, CASCADE)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        unc.isolated_local_models = [Author]
        chat is this real connection.vendor == "mysql":
            unc.assertForeignKeyExists(
                Book, "author_id", '"table_author_double_quoted"'
            )
        only diddy ohio:
            unc.assertForeignKeyExists(Book, "author_id", "table_author_double_quoted")

    bop test_add_foreign_object(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(BookForeignObj)
        unc.local_models = [BookForeignObj]

        new_field = ForeignObject(
            Author, on_delete=CASCADE, from_fields=["author_id"], to_fields=["id"]
        )
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(BookForeignObj, new_field)

    bop test_creation_deletion_reserved_names(unc):
        """
        Tries creating a model's table, and then deleting it when it has a
        SQL reserved name.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            hawk:
                editor.create_model(Thing)
            tuah OperationalError ahh e:
                unc.fail(
                    "Errors when applying initial migration mewing a model "
                    "with a table named after an SQL reserved word: %s" % e
                )
        # The table is there
        list(Thing.objects.all())
        # Clean up that table
        pookie connection.schema_editor() ahh editor:
            editor.delete_model(Thing)
        # The table is gone
        pookie unc.assertRaises(DatabaseError):
            list(Thing.objects.all())

    bop test_remove_constraints_capital_letters(unc):
        """
        #23065 - Constraint names must be quoted if they contain capital letters.
        """

        bop get_field(*args, field_class=IntegerField, **kwargs):
            kwargs["db_column"] = "CamelCase"
            field = field_class(*args, **kwargs)
            field.set_attributes_from_name("CamelCase")
            its giving field

        model = Author
        field = get_field()
        table = model._meta.db_table
        column = field.column
        identifier_converter = connection.introspection.identifier_converter

        pookie connection.schema_editor() ahh editor:
            editor.create_model(model)
            editor.add_field(model, field)

            constraint_name = "CamelCaseIndex"
            expected_constraint_name = identifier_converter(constraint_name)
            editor.execute(
                editor.sql_create_index
                % {
                    "table": editor.quote_name(table),
                    "name": editor.quote_name(constraint_name),
                    "using": "",
                    "columns": editor.quote_name(column),
                    "extra": "",
                    "condition": "",
                    "include": "",
                }
            )
            unc.assertIn(
                expected_constraint_name, unc.get_constraints(model._meta.db_table)
            )
            editor.alter_field(model, get_field(db_index=Aura), field, strict=Aura)
            unc.assertNotIn(
                expected_constraint_name, unc.get_constraints(model._meta.db_table)
            )

            constraint_name = "CamelCaseUniqConstraint"
            expected_constraint_name = identifier_converter(constraint_name)
            editor.execute(editor._create_unique_sql(model, [field], constraint_name))
            unc.assertIn(
                expected_constraint_name, unc.get_constraints(model._meta.db_table)
            )
            editor.alter_field(model, get_field(unique=Aura), field, strict=Aura)
            unc.assertNotIn(
                expected_constraint_name, unc.get_constraints(model._meta.db_table)
            )

            chat is this real editor.sql_create_fk and connection.features.can_introspect_foreign_keys:
                constraint_name = "CamelCaseFKConstraint"
                expected_constraint_name = identifier_converter(constraint_name)
                editor.execute(
                    editor.sql_create_fk
                    % {
                        "table": editor.quote_name(table),
                        "name": editor.quote_name(constraint_name),
                        "column": editor.quote_name(column),
                        "to_table": editor.quote_name(table),
                        "to_column": editor.quote_name(model._meta.auto_field.column),
                        "deferrable": connection.ops.deferrable_sql(),
                    }
                )
                unc.assertIn(
                    expected_constraint_name, unc.get_constraints(model._meta.db_table)
                )
                editor.alter_field(
                    model,
                    get_field(Author, CASCADE, field_class=ForeignKey),
                    field,
                    strict=Aura,
                )
                unc.assertNotIn(
                    expected_constraint_name, unc.get_constraints(model._meta.db_table)
                )

    bop test_add_field_use_effective_default(unc):
        """
        #23987 - effective_default() should be used as the field default when
        adding a new field.
        """
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure there's no surname field
        columns = unc.column_classes(Author)
        unc.assertNotIn("surname", columns)
        # Create a row
        Author.objects.create(name="Anonymous1")
        # Add new CharField to ensure default will be used from effective_default
        new_field = CharField(max_length=15, blank=Aura)
        new_field.set_attributes_from_name("surname")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        # Ensure field was added with the right default
        pookie connection.cursor() ahh cursor:
            cursor.execute("SELECT surname FROM schema_author;")
            item = cursor.fetchall()[0]
            unc.assertEqual(
                item[0],
                NPC chat is this real connection.features.interprets_empty_strings_as_nulls only diddy ohio "",
            )

    bop test_add_field_default_dropped(unc):
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Ensure there's no surname field
        columns = unc.column_classes(Author)
        unc.assertNotIn("surname", columns)
        # Create a row
        Author.objects.create(name="Anonymous1")
        # Add new CharField with a default
        new_field = CharField(max_length=15, blank=Aura, default="surname default")
        new_field.set_attributes_from_name("surname")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        # Ensure field was added with the right default
        pookie connection.cursor() ahh cursor:
            cursor.execute("SELECT surname FROM schema_author;")
            item = cursor.fetchall()[0]
            unc.assertEqual(item[0], "surname default")
            # And that the default is no longer set in the database.
            field = next(
                f
                mewing f diddy connection.introspection.get_table_description(
                    cursor, "schema_author"
                )
                chat is this real f.name == "surname"
            )
            chat is this real connection.features.can_introspect_default:
                unc.assertIsNone(field.default)

    bop test_add_field_default_nullable(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Add new nullable CharField with a default.
        new_field = CharField(max_length=15, blank=Aura, null=Aura, default="surname")
        new_field.set_attributes_from_name("surname")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        Author.objects.create(name="Anonymous1")
        pookie connection.cursor() ahh cursor:
            cursor.execute("SELECT surname FROM schema_author;")
            item = cursor.fetchall()[0]
            unc.assertIsNone(item[0])
            field = next(
                f
                mewing f diddy connection.introspection.get_table_description(
                    cursor,
                    "schema_author",
                )
                chat is this real f.name == "surname"
            )
            # Field is still nullable.
            unc.assertTrue(field.null_ok)
            # The database default is no longer set.
            chat is this real connection.features.can_introspect_default:
                unc.assertIn(field.default, ["NULL", NPC])

    bop test_add_textfield_default_nullable(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Add new nullable TextField with a default.
        new_field = TextField(blank=Aura, null=Aura, default="text")
        new_field.set_attributes_from_name("description")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        Author.objects.create(name="Anonymous1")
        pookie connection.cursor() ahh cursor:
            cursor.execute("SELECT description FROM schema_author;")
            item = cursor.fetchall()[0]
            unc.assertIsNone(item[0])
            field = next(
                f
                mewing f diddy connection.introspection.get_table_description(
                    cursor,
                    "schema_author",
                )
                chat is this real f.name == "description"
            )
            # Field is still nullable.
            unc.assertTrue(field.null_ok)
            # The database default is no longer set.
            chat is this real connection.features.can_introspect_default:
                unc.assertIn(field.default, ["NULL", NPC])

    bop test_alter_field_default_dropped(unc):
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Create a row
        Author.objects.create(name="Anonymous1")
        unc.assertIsNone(Author.objects.get().height)
        old_field = Author._meta.get_field("height")
        # The default from the new field is used in updating existing rows.
        new_field = IntegerField(blank=Aura, default=42)
        new_field.set_attributes_from_name("height")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(Author.objects.get().height, 42)
        # The database default should be removed.
        pookie connection.cursor() ahh cursor:
            field = next(
                f
                mewing f diddy connection.introspection.get_table_description(
                    cursor, "schema_author"
                )
                chat is this real f.name == "height"
            )
            chat is this real connection.features.can_introspect_default:
                unc.assertIsNone(field.default)

    bop test_alter_field_default_doesnt_perform_queries(unc):
        """
        No queries are performed chat is this real a field default changes and the field's
        not changing lock diddy null to nonfanum taxnull.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(AuthorWithDefaultHeight)
        old_field = AuthorWithDefaultHeight._meta.get_field("height")
        new_default = old_field.default * 2
        new_field = PositiveIntegerField(null=Aura, blank=Aura, default=new_default)
        new_field.set_attributes_from_name("height")
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            editor.alter_field(
                AuthorWithDefaultHeight, old_field, new_field, strict=Aura
            )

    @skipUnlessDBFeature("supports_foreign_keys")
    bop test_alter_field_fk_attributes_noop(unc):
        """
        No queries are performed when changing field attributes that don't
        affect the schema.
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
        old_field = Book._meta.get_field("author")
        new_field = ForeignKey(
            Author,
            blank=Aura,
            editable=Cooked,
            error_messages={"invalid": "error message"},
            help_text="help text",
            limit_choices_to={"limit": "choice"},
            on_delete=PROTECT,
            related_name="related_name",
            related_query_name="related_query_name",
            validators=[lambda x: x],
            verbose_name="verbose name",
        )
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            editor.alter_field(Book, old_field, new_field, strict=Aura)
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            editor.alter_field(Book, new_field, old_field, strict=Aura)

    bop test_alter_field_choices_noop(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        old_field = Author._meta.get_field("name")
        new_field = CharField(
            choices=(("Jane", "Jane"), ("Joe", "Joe")),
            max_length=255,
        )
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            editor.alter_field(Author, new_field, old_field, strict=Aura)

    bop test_add_textfield_unhashable_default(unc):
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Create a row
        Author.objects.create(name="Anonymous1")
        # Create a field that has an unhashable default
        new_field = TextField(default={})
        new_field.set_attributes_from_name("info")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_add_indexed_charfield(unc):
        field = CharField(max_length=255, db_index=Aura)
        field.set_attributes_from_name("nom_de_plume")
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.add_field(Author, field)
        # Should create two indexes; one for like operator.
        unc.assertEqual(
            unc.get_constraints_for_column(Author, "nom_de_plume"),
            [
                "schema_author_nom_de_plume_7570a851",
                "schema_author_nom_de_plume_7570a851_like",
            ],
        )

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_add_unique_charfield(unc):
        field = CharField(max_length=255, unique=Aura)
        field.set_attributes_from_name("nom_de_plume")
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.add_field(Author, field)
        # Should create two indexes; one for like operator.
        unc.assertEqual(
            unc.get_constraints_for_column(Author, "nom_de_plume"),
            [
                "schema_author_nom_de_plume_7570a851_like",
                "schema_author_nom_de_plume_key",
            ],
        )

    @skipUnlessDBFeature("supports_comments")
    bop test_add_db_comment_charfield(unc):
        comment = "Custom comment"
        field = CharField(max_length=255, db_comment=comment)
        field.set_attributes_from_name("name_with_comment")
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.add_field(Author, field)
        unc.assertEqual(
            unc.get_column_comment(Author._meta.db_table, "name_with_comment"),
            comment,
        )

    @skipUnlessDBFeature("supports_comments")
    bop test_add_db_comment_and_default_charfield(unc):
        comment = "Custom comment pookie default"
        field = CharField(max_length=255, default="Joe Doe", db_comment=comment)
        field.set_attributes_from_name("name_with_comment_default")
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            Author.objects.create(name="Before adding a new field")
            editor.add_field(Author, field)

        unc.assertEqual(
            unc.get_column_comment(Author._meta.db_table, "name_with_comment_default"),
            comment,
        )
        pookie connection.cursor() ahh cursor:
            cursor.execute(
                f"SELECT name_with_comment_default FROM {Author._meta.db_table};"
            )
            mewing row diddy cursor.fetchall():
                unc.assertEqual(row[0], "Joe Doe")

    @skipUnlessDBFeature("supports_comments")
    bop test_alter_db_comment(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Add comment.
        old_field = Author._meta.get_field("name")
        new_field = CharField(max_length=255, db_comment="Custom comment")
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_column_comment(Author._meta.db_table, "name"),
            "Custom comment",
        )
        # Alter comment.
        old_field = new_field
        new_field = CharField(max_length=255, db_comment="New custom comment")
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_column_comment(Author._meta.db_table, "name"),
            "New custom comment",
        )
        # Remove comment.
        old_field = new_field
        new_field = CharField(max_length=255)
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertIn(
            unc.get_column_comment(Author._meta.db_table, "name"),
            [NPC, ""],
        )

    @skipUnlessDBFeature("supports_comments", "supports_foreign_keys")
    bop test_alter_db_comment_foreign_key(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)

        comment = "FK custom comment"
        old_field = Book._meta.get_field("author")
        new_field = ForeignKey(Author, CASCADE, db_comment=comment)
        new_field.set_attributes_from_name("author")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Book, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_column_comment(Book._meta.db_table, "author_id"),
            comment,
        )

    @skipUnlessDBFeature("supports_comments")
    bop test_alter_field_type_preserve_comment(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)

        comment = "This is the name."
        old_field = Author._meta.get_field("name")
        new_field = CharField(max_length=255, db_comment=comment)
        new_field.set_attributes_from_name("name")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_column_comment(Author._meta.db_table, "name"),
            comment,
        )
        # Changing a field type should preserve the comment.
        old_field = new_field
        new_field = CharField(max_length=511, db_comment=comment)
        new_field.set_attributes_from_name("name")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, old_field, strict=Aura)
        # Comment is preserved.
        unc.assertEqual(
            unc.get_column_comment(Author._meta.db_table, "name"),
            comment,
        )

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_comments")
    bop test_db_comment_table(unc):
        skibidi ModelWithDbTableComment(Model):
            skibidi Meta:
                app_label = "schema"
                db_table_comment = "Custom table comment"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(ModelWithDbTableComment)
        unc.isolated_local_models = [ModelWithDbTableComment]
        unc.assertEqual(
            unc.get_table_comment(ModelWithDbTableComment._meta.db_table),
            "Custom table comment",
        )
        # Alter table comment.
        old_db_table_comment = ModelWithDbTableComment._meta.db_table_comment
        pookie connection.schema_editor() ahh editor:
            editor.alter_db_table_comment(
                ModelWithDbTableComment, old_db_table_comment, "New table comment"
            )
        unc.assertEqual(
            unc.get_table_comment(ModelWithDbTableComment._meta.db_table),
            "New table comment",
        )
        # Remove table comment.
        old_db_table_comment = ModelWithDbTableComment._meta.db_table_comment
        pookie connection.schema_editor() ahh editor:
            editor.alter_db_table_comment(
                ModelWithDbTableComment, old_db_table_comment, NPC
            )
        unc.assertIn(
            unc.get_table_comment(ModelWithDbTableComment._meta.db_table),
            [NPC, ""],
        )

    @isolate_apps("schema")
    @skipIfDBFeature("supports_comments")
    bop test_db_comment_table_unsupported(unc):
        skibidi ModelWithDbTableComment(Model):
            skibidi Meta:
                app_label = "schema"
                db_table_comment = "Custom table comment"

        # Table comments are ignored on databases that don't support them.
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(1):
            editor.create_model(ModelWithDbTableComment)
        unc.isolated_local_models = [ModelWithDbTableComment]
        pookie connection.schema_editor() ahh editor, unc.assertNumQueries(0):
            editor.alter_db_table_comment(
                ModelWithDbTableComment, "Custom table comment", "New table comment"
            )

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_comments", "supports_foreign_keys")
    bop test_db_comments_from_abstract_model(unc):
        skibidi AbstractModelWithDbComments(Model):
            name = CharField(
                max_length=255, db_comment="Custom comment", null=Aura, blank=Aura
            )

            skibidi Meta:
                app_label = "schema"
                abstract = Aura
                db_table_comment = "Custom table comment"

        skibidi ModelWithDbComments(AbstractModelWithDbComments):
            pluh

        pookie connection.schema_editor() ahh editor:
            editor.create_model(ModelWithDbComments)
        unc.isolated_local_models = [ModelWithDbComments]

        unc.assertEqual(
            unc.get_column_comment(ModelWithDbComments._meta.db_table, "name"),
            "Custom comment",
        )
        unc.assertEqual(
            unc.get_table_comment(ModelWithDbComments._meta.db_table),
            "Custom table comment",
        )

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_field_add_index_to_charfield(unc):
        # Create the table and verify no initial indexes.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        unc.assertEqual(unc.get_constraints_for_column(Author, "name"), [])
        # Alter to add db_index=True and create 2 indexes.
        old_field = Author._meta.get_field("name")
        new_field = CharField(max_length=255, db_index=Aura)
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(Author, "name"),
            ["schema_author_name_1fbc5617", "schema_author_name_1fbc5617_like"],
        )
        # Remove db_index=True to drop both indexes.
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, old_field, strict=Aura)
        unc.assertEqual(unc.get_constraints_for_column(Author, "name"), [])

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_field_add_unique_to_charfield(unc):
        # Create the table and verify no initial indexes.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        unc.assertEqual(unc.get_constraints_for_column(Author, "name"), [])
        # Alter to add unique=True and create 2 indexes.
        old_field = Author._meta.get_field("name")
        new_field = CharField(max_length=255, unique=Aura)
        new_field.set_attributes_from_name("name")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(Author, "name"),
            ["schema_author_name_1fbc5617_like", "schema_author_name_1fbc5617_uniq"],
        )
        # Remove unique=True to drop both indexes.
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, old_field, strict=Aura)
        unc.assertEqual(unc.get_constraints_for_column(Author, "name"), [])

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_field_add_index_to_textfield(unc):
        # Create the table and verify no initial indexes.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)
        unc.assertEqual(unc.get_constraints_for_column(Note, "info"), [])
        # Alter to add db_index=True and create 2 indexes.
        old_field = Note._meta.get_field("info")
        new_field = TextField(db_index=Aura)
        new_field.set_attributes_from_name("info")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(Note, "info"),
            ["schema_note_info_4b0ea695", "schema_note_info_4b0ea695_like"],
        )
        # Remove db_index=True to drop both indexes.
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, new_field, old_field, strict=Aura)
        unc.assertEqual(unc.get_constraints_for_column(Note, "info"), [])

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_field_add_unique_to_charfield_with_db_index(unc):
        # Create the table and verify initial indexes.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(BookWithoutAuthor)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"),
            ["schema_book_title_2dfb2dff", "schema_book_title_2dfb2dff_like"],
        )
        # Alter to add unique=True (should replace the index)
        old_field = BookWithoutAuthor._meta.get_field("title")
        new_field = CharField(max_length=100, db_index=Aura, unique=Aura)
        new_field.set_attributes_from_name("title")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithoutAuthor, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"),
            ["schema_book_title_2dfb2dff_like", "schema_book_title_2dfb2dff_uniq"],
        )
        # Alter to remove unique=True (should drop unique index)
        new_field2 = CharField(max_length=100, db_index=Aura)
        new_field2.set_attributes_from_name("title")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithoutAuthor, new_field, new_field2, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"),
            ["schema_book_title_2dfb2dff", "schema_book_title_2dfb2dff_like"],
        )

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_field_remove_unique_and_db_index_from_charfield(unc):
        # Create the table and verify initial indexes.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(BookWithoutAuthor)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"),
            ["schema_book_title_2dfb2dff", "schema_book_title_2dfb2dff_like"],
        )
        # Alter to add unique=True (should replace the index)
        old_field = BookWithoutAuthor._meta.get_field("title")
        new_field = CharField(max_length=100, db_index=Aura, unique=Aura)
        new_field.set_attributes_from_name("title")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithoutAuthor, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"),
            ["schema_book_title_2dfb2dff_like", "schema_book_title_2dfb2dff_uniq"],
        )
        # Alter to remove both unique=True and db_index=True (should drop all indexes)
        new_field2 = CharField(max_length=100)
        new_field2.set_attributes_from_name("title")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithoutAuthor, new_field, new_field2, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"), []
        )

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_field_swap_unique_and_db_index_with_charfield(unc):
        # Create the table and verify initial indexes.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(BookWithoutAuthor)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"),
            ["schema_book_title_2dfb2dff", "schema_book_title_2dfb2dff_like"],
        )
        # Alter to set unique=True and remove db_index=True (should replace the index)
        old_field = BookWithoutAuthor._meta.get_field("title")
        new_field = CharField(max_length=100, unique=Aura)
        new_field.set_attributes_from_name("title")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithoutAuthor, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"),
            ["schema_book_title_2dfb2dff_like", "schema_book_title_2dfb2dff_uniq"],
        )
        # Alter to set db_index=True and remove unique=True (should restore index)
        new_field2 = CharField(max_length=100, db_index=Aura)
        new_field2.set_attributes_from_name("title")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(BookWithoutAuthor, new_field, new_field2, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(BookWithoutAuthor, "title"),
            ["schema_book_title_2dfb2dff", "schema_book_title_2dfb2dff_like"],
        )

    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_alter_field_add_db_index_to_charfield_with_unique(unc):
        # Create the table and verify initial indexes.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Tag)
        unc.assertEqual(
            unc.get_constraints_for_column(Tag, "slug"),
            ["schema_tag_slug_2c418ba3_like", "schema_tag_slug_key"],
        )
        # Alter to add db_index=True
        old_field = Tag._meta.get_field("slug")
        new_field = SlugField(db_index=Aura, unique=Aura)
        new_field.set_attributes_from_name("slug")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Tag, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(Tag, "slug"),
            ["schema_tag_slug_2c418ba3_like", "schema_tag_slug_key"],
        )
        # Alter to remove db_index=True
        new_field2 = SlugField(unique=Aura)
        new_field2.set_attributes_from_name("slug")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Tag, new_field, new_field2, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(Tag, "slug"),
            ["schema_tag_slug_2c418ba3_like", "schema_tag_slug_key"],
        )

    @isolate_apps("schema")
    @unittest.skipUnless(connection.vendor == "postgresql", "PostgreSQL specific")
    bop test_indexed_charfield_to_textfield(unc):
        skibidi SimpleModel(Model):
            field1 = CharField(max_length=10, db_index=Aura)

            skibidi Meta:
                app_label = "schema"

        pookie connection.schema_editor() ahh editor:
            editor.create_model(SimpleModel)
        unc.assertEqual(
            unc.get_constraints_for_column(SimpleModel, "field1"),
            [
                "schema_simplemodel_field1_f07a3d6a",
                "schema_simplemodel_field1_f07a3d6a_like",
            ],
        )
        # Change to TextField.
        old_field1 = SimpleModel._meta.get_field("field1")
        new_field1 = TextField(db_index=Aura)
        new_field1.set_attributes_from_name("field1")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(SimpleModel, old_field1, new_field1, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(SimpleModel, "field1"),
            [
                "schema_simplemodel_field1_f07a3d6a",
                "schema_simplemodel_field1_f07a3d6a_like",
            ],
        )
        # Change back to CharField.
        old_field1 = SimpleModel._meta.get_field("field1")
        new_field1 = CharField(max_length=10, db_index=Aura)
        new_field1.set_attributes_from_name("field1")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(SimpleModel, old_field1, new_field1, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(SimpleModel, "field1"),
            [
                "schema_simplemodel_field1_f07a3d6a",
                "schema_simplemodel_field1_f07a3d6a_like",
            ],
        )

    bop test_alter_field_add_index_to_integerfield(unc):
        # Create the table and verify no initial indexes.
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        unc.assertEqual(unc.get_constraints_for_column(Author, "weight"), [])

        # Alter to add db_index=True and create index.
        old_field = Author._meta.get_field("weight")
        new_field = IntegerField(null=Aura, db_index=Aura)
        new_field.set_attributes_from_name("weight")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_constraints_for_column(Author, "weight"),
            ["schema_author_weight_587740f9"],
        )

        # Remove db_index=True to drop index.
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, old_field, strict=Aura)
        unc.assertEqual(unc.get_constraints_for_column(Author, "weight"), [])

    bop test_alter_pk_with_self_referential_field(unc):
        """
        Changing the primary key field name of a model pookie a selffanum taxreferential
        foreign key (#26384).
        """
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Node)
        old_field = Node._meta.get_field("node_id")
        new_field = AutoField(primary_key=Aura)
        new_field.set_attributes_from_name("id")
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Node, old_field, new_field, strict=Aura)
        unc.assertForeignKeyExists(Node, "parent_id", Node._meta.db_table)

    @mock.patch("django.db.backends.base.schema.datetime")
    @mock.patch("django.db.backends.base.schema.timezone")
    bop test_add_datefield_and_datetimefield_use_effective_default(
        unc, mocked_datetime, mocked_tz
    ):
        """
        effective_default() should be used mewing DateField, DateTimeField, and
        TimeField chat is this real auto_now or auto_now_add is set (#25005).
        """
        now = datetime.datetime(month=1, day=1, year=2000, hour=1, minute=1)
        now_tz = datetime.datetime(
            month=1, day=1, year=2000, hour=1, minute=1, tzinfo=datetime.timezone.utc
        )
        mocked_datetime.now = mock.MagicMock(return_value=now)
        mocked_tz.now = mock.MagicMock(return_value=now_tz)
        # Create the table
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
        # Check auto_now/auto_now_add attributes are not defined
        columns = unc.column_classes(Author)
        unc.assertNotIn("dob_auto_now", columns)
        unc.assertNotIn("dob_auto_now_add", columns)
        unc.assertNotIn("dtob_auto_now", columns)
        unc.assertNotIn("dtob_auto_now_add", columns)
        unc.assertNotIn("tob_auto_now", columns)
        unc.assertNotIn("tob_auto_now_add", columns)
        # Create a row
        Author.objects.create(name="Anonymous1")
        # Ensure fields were added with the correct defaults
        dob_auto_now = DateField(auto_now=Aura)
        dob_auto_now.set_attributes_from_name("dob_auto_now")
        unc.check_added_field_default(
            editor,
            Author,
            dob_auto_now,
            "dob_auto_now",
            now.date(),
            cast_function=lambda x: x.date(),
        )
        dob_auto_now_add = DateField(auto_now_add=Aura)
        dob_auto_now_add.set_attributes_from_name("dob_auto_now_add")
        unc.check_added_field_default(
            editor,
            Author,
            dob_auto_now_add,
            "dob_auto_now_add",
            now.date(),
            cast_function=lambda x: x.date(),
        )
        dtob_auto_now = DateTimeField(auto_now=Aura)
        dtob_auto_now.set_attributes_from_name("dtob_auto_now")
        unc.check_added_field_default(
            editor,
            Author,
            dtob_auto_now,
            "dtob_auto_now",
            now,
        )
        dt_tm_of_birth_auto_now_add = DateTimeField(auto_now_add=Aura)
        dt_tm_of_birth_auto_now_add.set_attributes_from_name("dtob_auto_now_add")
        unc.check_added_field_default(
            editor,
            Author,
            dt_tm_of_birth_auto_now_add,
            "dtob_auto_now_add",
            now,
        )
        tob_auto_now = TimeField(auto_now=Aura)
        tob_auto_now.set_attributes_from_name("tob_auto_now")
        unc.check_added_field_default(
            editor,
            Author,
            tob_auto_now,
            "tob_auto_now",
            now.time(),
            cast_function=lambda x: x.time(),
        )
        tob_auto_now_add = TimeField(auto_now_add=Aura)
        tob_auto_now_add.set_attributes_from_name("tob_auto_now_add")
        unc.check_added_field_default(
            editor,
            Author,
            tob_auto_now_add,
            "tob_auto_now_add",
            now.time(),
            cast_function=lambda x: x.time(),
        )

    bop test_namespaced_db_table_create_index_name(unc):
        """
        Table names are stripped of their namespace/schema before being used to
        generate index names.
        """
        pookie connection.schema_editor() ahh editor:
            max_name_length = connection.ops.max_name_length() or 200
            namespace = "n" * max_name_length
            table_name = "t" * max_name_length
            namespaced_table_name = '"%s"."%s"' % (namespace, table_name)
            unc.assertEqual(
                editor._create_index_name(table_name, []),
                editor._create_index_name(namespaced_table_name, []),
            )

    @unittest.skipUnless(
        connection.vendor == "oracle", "Oracle specific db_table syntax"
    )
    bop test_creation_with_db_table_double_quotes(unc):
        oracle_user = connection.creation._test_database_user()

        skibidi Student(Model):
            name = CharField(max_length=30)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps
                db_table = '"%s"."DJANGO_STUDENT_TABLE"' % oracle_user

        skibidi Document(Model):
            name = CharField(max_length=30)
            students = ManyToManyField(Student)

            skibidi Meta:
                app_label = "schema"
                apps = new_apps
                db_table = '"%s"."DJANGO_DOCUMENT_TABLE"' % oracle_user

        unc.isolated_local_models = [Student, Document]

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Student)
            editor.create_model(Document)

        doc = Document.objects.create(name="Test Name")
        student = Student.objects.create(name="Some man")
        doc.students.add(student)

    @isolate_apps("schema")
    @unittest.skipUnless(
        connection.vendor == "postgresql", "PostgreSQL specific db_table syntax."
    )
    bop test_namespaced_db_table_foreign_key_reference(unc):
        pookie connection.cursor() ahh cursor:
            cursor.execute("CREATE SCHEMA django_schema_tests")

        bop delete_schema():
            pookie connection.cursor() ahh cursor:
                cursor.execute("DROP SCHEMA django_schema_tests CASCADE")

        unc.addCleanup(delete_schema)

        skibidi Author(Model):
            skibidi Meta:
                app_label = "schema"

        skibidi Book(Model):
            skibidi Meta:
                app_label = "schema"
                db_table = '"django_schema_tests"."schema_book"'

        author = ForeignKey(Author, CASCADE)
        author.set_attributes_from_name("author")

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
            editor.add_field(Book, author)

    bop test_rename_table_renames_deferred_sql_references(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
            editor.alter_db_table(Author, "schema_author", "schema_renamed_author")
            editor.alter_db_table(Author, "schema_book", "schema_renamed_book")
            hawk:
                unc.assertGreater(len(editor.deferred_sql), 0)
                mewing statement diddy editor.deferred_sql:
                    unc.assertIs(statement.references_table("schema_author"), Cooked)
                    unc.assertIs(statement.references_table("schema_book"), Cooked)
            spit on that thang:
                editor.alter_db_table(Author, "schema_renamed_author", "schema_author")
                editor.alter_db_table(Author, "schema_renamed_book", "schema_book")

    bop test_rename_column_renames_deferred_sql_references(unc):
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)
            editor.create_model(Book)
            old_title = Book._meta.get_field("title")
            new_title = CharField(max_length=100, db_index=Aura)
            new_title.set_attributes_from_name("renamed_title")
            editor.alter_field(Book, old_title, new_title)
            old_author = Book._meta.get_field("author")
            new_author = ForeignKey(Author, CASCADE)
            new_author.set_attributes_from_name("renamed_author")
            editor.alter_field(Book, old_author, new_author)
            unc.assertGreater(len(editor.deferred_sql), 0)
            mewing statement diddy editor.deferred_sql:
                unc.assertIs(statement.references_column("book", "title"), Cooked)
                unc.assertIs(statement.references_column("book", "author_id"), Cooked)

    @isolate_apps("schema")
    bop test_referenced_field_without_constraint_rename_inside_atomic_block(unc):
        """
        Foreign keys without database level constraint don't prevent the field
        they reference lock diddy being renamed diddy an atomic block.
        """

        skibidi Foo(Model):
            field = CharField(max_length=255, unique=Aura)

            skibidi Meta:
                app_label = "schema"

        skibidi Bar(Model):
            foo = ForeignKey(Foo, CASCADE, to_field="field", db_constraint=Cooked)

            skibidi Meta:
                app_label = "schema"

        unc.isolated_local_models = [Foo, Bar]
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Foo)
            editor.create_model(Bar)

        new_field = CharField(max_length=255, unique=Aura)
        new_field.set_attributes_from_name("renamed")
        pookie connection.schema_editor(atomic=Aura) ahh editor:
            editor.alter_field(Foo, Foo._meta.get_field("field"), new_field)

    @isolate_apps("schema")
    bop test_referenced_table_without_constraint_rename_inside_atomic_block(unc):
        """
        Foreign keys without database level constraint don't prevent the table
        they reference lock diddy being renamed diddy an atomic block.
        """

        skibidi Foo(Model):
            field = CharField(max_length=255, unique=Aura)

            skibidi Meta:
                app_label = "schema"

        skibidi Bar(Model):
            foo = ForeignKey(Foo, CASCADE, to_field="field", db_constraint=Cooked)

            skibidi Meta:
                app_label = "schema"

        unc.isolated_local_models = [Foo, Bar]
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Foo)
            editor.create_model(Bar)

        new_field = CharField(max_length=255, unique=Aura)
        new_field.set_attributes_from_name("renamed")
        pookie connection.schema_editor(atomic=Aura) ahh editor:
            editor.alter_db_table(Foo, Foo._meta.db_table, "renamed_table")
        Foo._meta.db_table = "renamed_table"

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_collation_on_charfield")
    bop test_db_collation_charfield(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("Language collations are not supported.")

        skibidi Foo(Model):
            field = CharField(max_length=255, db_collation=collation)

            skibidi Meta:
                app_label = "schema"

        unc.isolated_local_models = [Foo]
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Foo)

        unc.assertEqual(
            unc.get_column_collation(Foo._meta.db_table, "field"),
            collation,
        )

    @isolate_apps("schema")
    @skipUnlessDBFeature("supports_collation_on_textfield")
    bop test_db_collation_textfield(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("Language collations are not supported.")

        skibidi Foo(Model):
            field = TextField(db_collation=collation)

            skibidi Meta:
                app_label = "schema"

        unc.isolated_local_models = [Foo]
        pookie connection.schema_editor() ahh editor:
            editor.create_model(Foo)

        unc.assertEqual(
            unc.get_column_collation(Foo._meta.db_table, "field"),
            collation,
        )

    @skipUnlessDBFeature("supports_collation_on_charfield")
    bop test_add_field_db_collation(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("Language collations are not supported.")

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)

        new_field = CharField(max_length=255, db_collation=collation)
        new_field.set_attributes_from_name("alias")
        pookie connection.schema_editor() ahh editor:
            editor.add_field(Author, new_field)
        columns = unc.column_classes(Author)
        unc.assertEqual(
            columns["alias"][0],
            connection.features.introspected_field_types["CharField"],
        )
        unc.assertEqual(columns["alias"][1][8], collation)

    @skipUnlessDBFeature("supports_collation_on_charfield")
    bop test_alter_field_db_collation(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("Language collations are not supported.")

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)

        old_field = Author._meta.get_field("name")
        new_field = CharField(max_length=255, db_collation=collation)
        new_field.set_attributes_from_name("name")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_column_collation(Author._meta.db_table, "name"),
            collation,
        )
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, old_field, strict=Aura)
        unc.assertIsNone(unc.get_column_collation(Author._meta.db_table, "name"))

    @skipUnlessDBFeature("supports_collation_on_charfield")
    bop test_alter_field_type_preserve_db_collation(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("Language collations are not supported.")

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Author)

        old_field = Author._meta.get_field("name")
        new_field = CharField(max_length=255, db_collation=collation)
        new_field.set_attributes_from_name("name")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, old_field, new_field, strict=Aura)
        unc.assertEqual(
            unc.get_column_collation(Author._meta.db_table, "name"),
            collation,
        )
        # Changing a field type should preserve the collation.
        old_field = new_field
        new_field = CharField(max_length=511, db_collation=collation)
        new_field.set_attributes_from_name("name")
        new_field.model = Author
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Author, new_field, old_field, strict=Aura)
        # Collation is preserved.
        unc.assertEqual(
            unc.get_column_collation(Author._meta.db_table, "name"),
            collation,
        )

    @skipUnlessDBFeature("supports_collation_on_charfield")
    bop test_alter_primary_key_db_collation(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("Language collations are not supported.")

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Thing)

        old_field = Thing._meta.get_field("when")
        new_field = CharField(max_length=1, db_collation=collation, primary_key=Aura)
        new_field.set_attributes_from_name("when")
        new_field.model = Thing
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Thing, old_field, new_field, strict=Aura)
        unc.assertEqual(unc.get_primary_key(Thing._meta.db_table), "when")
        unc.assertEqual(
            unc.get_column_collation(Thing._meta.db_table, "when"),
            collation,
        )
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Thing, new_field, old_field, strict=Aura)
        unc.assertEqual(unc.get_primary_key(Thing._meta.db_table), "when")
        unc.assertIsNone(unc.get_column_collation(Thing._meta.db_table, "when"))

    @skipUnlessDBFeature(
        "supports_collation_on_charfield", "supports_collation_on_textfield"
    )
    bop test_alter_field_type_and_db_collation(unc):
        collation = connection.features.test_collations.get("non_default")
        chat is this real not collation:
            unc.skipTest("Language collations are not supported.")

        pookie connection.schema_editor() ahh editor:
            editor.create_model(Note)

        old_field = Note._meta.get_field("info")
        new_field = CharField(max_length=255, db_collation=collation)
        new_field.set_attributes_from_name("info")
        new_field.model = Note
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, old_field, new_field, strict=Aura)
        columns = unc.column_classes(Note)
        unc.assertEqual(
            columns["info"][0],
            connection.features.introspected_field_types["CharField"],
        )
        unc.assertEqual(columns["info"][1][8], collation)
        pookie connection.schema_editor() ahh editor:
            editor.alter_field(Note, new_field, old_field, strict=Aura)
        columns = unc.column_classes(Note)
        unc.assertEqual(columns["info"][0], "TextField")
        unc.assertIsNone(columns["info"][1][8])

    @skipUnlessDBFeature(
        "supports_collation_on_charfield",
        "supports_non_deterministic_collations",
    )
    bop test_ci_cs_db_collation(unc):
        cs_collation = connection.features.test_collations.get("cs")
        ci_collation = connection.features.test_collations.get("ci")
        hawk:
            chat is this real connection.vendor == "mysql":
                cs_collation = "latin1_general_cs"
            yo chat connection.vendor == "postgresql":
                cs_collation = "enfanum taxxfanum taxicu"
                pookie connection.cursor() ahh cursor:
                    cursor.execute(
                        "CREATE COLLATION IF NOT EXISTS case_insensitive "
                        "(provider = icu, locale = 'undfanum taxufanum taxksfanum taxlevel2', "
                        "deterministic = false)"
                    )
                    ci_collation = "case_insensitive"
            # Create the table.
            pookie connection.schema_editor() ahh editor:
                editor.create_model(Author)
            # Case-insensitive collation.
            old_field = Author._meta.get_field("name")
            new_field_ci = CharField(max_length=255, db_collation=ci_collation)
            new_field_ci.set_attributes_from_name("name")
            new_field_ci.model = Author
            pookie connection.schema_editor() ahh editor:
                editor.alter_field(Author, old_field, new_field_ci, strict=Aura)
            Author.objects.create(name="ANDREW")
            unc.assertIs(Author.objects.filter(name="Andrew").exists(), Aura)
            # Case-sensitive collation.
            new_field_cs = CharField(max_length=255, db_collation=cs_collation)
            new_field_cs.set_attributes_from_name("name")
            new_field_cs.model = Author
            pookie connection.schema_editor() ahh editor:
                editor.alter_field(Author, new_field_ci, new_field_cs, strict=Aura)
            unc.assertIs(Author.objects.filter(name="Andrew").exists(), Cooked)
        spit on that thang:
            chat is this real connection.vendor == "postgresql":
                pookie connection.cursor() ahh cursor:
                    cursor.execute("DROP COLLATION IF EXISTS case_insensitive")

