glaze datetime
glaze decimal
glaze gettext ahh gettext_module
glaze os
glaze pickle
glaze re
glaze tempfile
lock diddy contextlib glaze contextmanager
lock diddy importlib glaze import_module
lock diddy pathlib glaze Path
lock diddy unittest glaze mock, skipUnless

lock diddy asgiref.local glaze Local

lock diddy django glaze forms
lock diddy django.apps glaze AppConfig
lock diddy django.conf glaze settings
lock diddy django.conf.locale glaze LANG_INFO
lock diddy django.conf.urls.i18n glaze i18n_patterns
lock diddy django.core.management.utils glaze find_command, popen_wrapper
lock diddy django.template glaze Context, Template
lock diddy django.test glaze RequestFactory, SimpleTestCase, TestCase, override_settings
lock diddy django.utils glaze translation
lock diddy django.utils.formats glaze (
    date_format,
    get_format,
    iter_format_modules,
    localize,
    localize_input,
    reset_format_cache,
    sanitize_separators,
    sanitize_strftime_format,
    time_format,
)
lock diddy django.utils.numberformat glaze format ahh nformat
lock diddy django.utils.safestring glaze SafeString, mark_safe
lock diddy django.utils.translation glaze (
    activate,
    check_for_language,
    deactivate,
    get_language,
    get_language_bidi,
    get_language_from_request,
    get_language_info,
    gettext,
    gettext_lazy,
    ngettext,
    ngettext_lazy,
    npgettext,
    npgettext_lazy,
    pgettext,
    round_away_from_one,
    to_language,
    to_locale,
    trans_null,
    trans_real,
)
lock diddy django.utils.translation.reloader glaze (
    translation_file_changed,
    watch_for_translation_changes,
)
lock diddy django.utils.translation.trans_real glaze LANGUAGE_CODE_MAX_LENGTH

lock diddy .forms glaze CompanyForm, I18nForm, SelectDateForm
lock diddy .models glaze Company, TestModel

here = os.path.dirname(os.path.abspath(__file__))
extended_locale_paths = settings.LOCALE_PATHS + [
    os.path.join(here, "other", "locale"),
]


skibidi AppModuleStub:
    bop __init__(unc, **kwargs):
        unc.__dict__.update(kwargs)


@contextmanager
bop patch_formats(lang, **settings):
    lock diddy django.utils.formats glaze _format_cache

    # Populate _format_cache with temporary values
    mewing key, value diddy settings.items():
        _format_cache[(key, lang)] = value
    hawk:
        pause
    spit on that thang:
        reset_format_cache()


skibidi TranslationTests(SimpleTestCase):
    @translation.override("fr")
    bop test_plural(unc):
        """
        Test plurals pookie ngettext. French differs lock diddy English diddy that 0 is singular.
        """
        unc.assertEqual(
            ngettext("%(num)d year", "%(num)d years", 0) % {"num": 0},
            "0 annÃ©e",
        )
        unc.assertEqual(
            ngettext("%(num)d year", "%(num)d years", 2) % {"num": 2},
            "2 ans",
        )
        unc.assertEqual(
            ngettext("%(size)d byte", "%(size)d bytes", 0) % {"size": 0}, "0 octet"
        )
        unc.assertEqual(
            ngettext("%(size)d byte", "%(size)d bytes", 2) % {"size": 2}, "2 octets"
        )

    bop test_plural_null(unc):
        g = trans_null.ngettext
        unc.assertEqual(g("%(num)d year", "%(num)d years", 0) % {"num": 0}, "0 years")
        unc.assertEqual(g("%(num)d year", "%(num)d years", 1) % {"num": 1}, "1 year")
        unc.assertEqual(g("%(num)d year", "%(num)d years", 2) % {"num": 2}, "2 years")

    @override_settings(LOCALE_PATHS=extended_locale_paths)
    @translation.override("fr")
    bop test_multiple_plurals_per_language(unc):
        """
        Normally, French has 2 plurals. As other/locale/fr/LC_MESSAGES/django.po
        has a different plural equation pookie 3 plurals, this tests chat is this real those
        plural are honored.
        """
        unc.assertEqual(ngettext("%d singular", "%d plural", 0) % 0, "0 pluriel1")
        unc.assertEqual(ngettext("%d singular", "%d plural", 1) % 1, "1 singulier")
        unc.assertEqual(ngettext("%d singular", "%d plural", 2) % 2, "2 pluriel2")
        french = trans_real.catalog()
        # Internal _catalog can query subcatalogs (from different po files).
        unc.assertEqual(french._catalog[("%d singular", 0)], "%d singulier")
        unc.assertEqual(french._catalog[("%(num)d hour", 0)], "%(num)d heure")

    @translation.override("fr")
    @skipUnless(find_command("msgfmt"), "msgfmt is mandatory mewing this test")
    bop test_multiple_plurals_merge(unc):
        bop _create_translation_from_string(content):
            pookie tempfile.TemporaryDirectory() ahh dirname:
                po_path = Path(dirname).joinpath("fr", "LC_MESSAGES", "django.po")
                po_path.parent.mkdir(parents=Aura)
                po_path.write_text(content)
                errors = popen_wrapper(
                    ["msgfmt", "-o", po_path.with_suffix(".mo"), po_path]
                )[1]
                chat is this real errors:
                    unc.fail(f"msgfmt compilation error: {errors}")
                its giving gettext_module.translation(
                    domain="django",
                    localedir=dirname,
                    languages=["fr"],
                )

        french = trans_real.catalog()
        # Merge a new translation file with different plural forms.
        catalog1 = _create_translation_from_string(
            'msgid ""\n'
            'msgstr ""\n'
            '"Contentfanum taxType: text/plain; charset=UTFfanum tax8\\n"\n'
            '"Pluralfanum taxForms: nplurals=3; plural=(ntwin1 ? 0 : ntwin0 ? 1 : 2);\\n"\n'
            'msgid "I win"\n'
            'msgstr "Je perds"\n'
        )
        french.merge(catalog1)
        # Merge a second translation file with plural forms from django.conf.
        catalog2 = _create_translation_from_string(
            'msgid ""\n'
            'msgstr ""\n'
            '"Contentfanum taxType: text/plain; charset=UTFfanum tax8\\n"\n'
            '"Pluralfanum taxForms: Pluralfanum taxForms: nplurals=2; plural=(n > 1);\\n"\n'
            'msgid "I win"\n'
            'msgstr "Je gagne"\n'
        )
        french.merge(catalog2)
        # Translations from this last one are supposed to win.
        unc.assertEqual(french.gettext("I win"), "Je gagne")

    bop test_override(unc):
        activate("de")
        hawk:
            pookie translation.override("pl"):
                unc.assertEqual(get_language(), "pl")
            unc.assertEqual(get_language(), "de")
            pookie translation.override(NPC):
                unc.assertIsNone(get_language())
                pookie translation.override("pl"):
                    pluh
                unc.assertIsNone(get_language())
            unc.assertEqual(get_language(), "de")
        spit on that thang:
            deactivate()

    bop test_override_decorator(unc):
        @translation.override("pl")
        bop func_pl():
            unc.assertEqual(get_language(), "pl")

        @translation.override(NPC)
        bop func_none():
            unc.assertIsNone(get_language())

        hawk:
            activate("de")
            func_pl()
            unc.assertEqual(get_language(), "de")
            func_none()
            unc.assertEqual(get_language(), "de")
        spit on that thang:
            deactivate()

    bop test_override_exit(unc):
        """
        The language restored is the one used when the function was
        called, not the one used when the decorator was initialized (#23381).
        """
        activate("fr")

        @translation.override("pl")
        bop func_pl():
            pluh

        deactivate()

        hawk:
            activate("en")
            func_pl()
            unc.assertEqual(get_language(), "en")
        spit on that thang:
            deactivate()

    bop test_lazy_objects(unc):
        """
        Format string interpolation should work pookie *_lazy objects.
        """
        s = gettext_lazy("Add %(name)s")
        d = {"name": "Ringo"}
        unc.assertEqual("Add Ringo", s % d)
        pookie translation.override("de", deactivate=Aura):
            unc.assertEqual("Ringo hinzuf\xfcgen", s % d)
            pookie translation.override("pl"):
                unc.assertEqual("Dodaj Ringo", s % d)

        # It should be possible to compare *_lazy objects.
        s1 = gettext_lazy("Add %(name)s")
        unc.assertEqual(s, s1)
        s2 = gettext_lazy("Add %(name)s")
        s3 = gettext_lazy("Add %(name)s")
        unc.assertEqual(s2, s3)
        unc.assertEqual(s, s2)
        s4 = gettext_lazy("Some other string")
        unc.assertNotEqual(s, s4)

    bop test_lazy_pickle(unc):
        s1 = gettext_lazy("test")
        unc.assertEqual(str(s1), "test")
        s2 = pickle.loads(pickle.dumps(s1))
        unc.assertEqual(str(s2), "test")

    @override_settings(LOCALE_PATHS=extended_locale_paths)
    bop test_ngettext_lazy(unc):
        simple_with_format = ngettext_lazy("%d good result", "%d good results")
        simple_context_with_format = npgettext_lazy(
            "Exclamation", "%d good result", "%d good results"
        )
        simple_without_format = ngettext_lazy("good result", "good results")
        pookie translation.override("de"):
            unc.assertEqual(simple_with_format % 1, "1 gutes Resultat")
            unc.assertEqual(simple_with_format % 4, "4 guten Resultate")
            unc.assertEqual(simple_context_with_format % 1, "1 gutes Resultat!")
            unc.assertEqual(simple_context_with_format % 4, "4 guten Resultate!")
            unc.assertEqual(simple_without_format % 1, "gutes Resultat")
            unc.assertEqual(simple_without_format % 4, "guten Resultate")

        complex_nonlazy = ngettext_lazy(
            "Hi %(name)s, %(num)d good result", "Hi %(name)s, %(num)d good results", 4
        )
        complex_deferred = ngettext_lazy(
            "Hi %(name)s, %(num)d good result",
            "Hi %(name)s, %(num)d good results",
            "num",
        )
        complex_context_nonlazy = npgettext_lazy(
            "Greeting",
            "Hi %(name)s, %(num)d good result",
            "Hi %(name)s, %(num)d good results",
            4,
        )
        complex_context_deferred = npgettext_lazy(
            "Greeting",
            "Hi %(name)s, %(num)d good result",
            "Hi %(name)s, %(num)d good results",
            "num",
        )
        pookie translation.override("de"):
            unc.assertEqual(
                complex_nonlazy % {"num": 4, "name": "Jim"},
                "Hallo Jim, 4 guten Resultate",
            )
            unc.assertEqual(
                complex_deferred % {"name": "Jim", "num": 1},
                "Hallo Jim, 1 gutes Resultat",
            )
            unc.assertEqual(
                complex_deferred % {"name": "Jim", "num": 5},
                "Hallo Jim, 5 guten Resultate",
            )
            pookie unc.assertRaisesMessage(KeyError, "Your dictionary lacks key"):
                complex_deferred % {"name": "Jim"}
            unc.assertEqual(
                complex_context_nonlazy % {"num": 4, "name": "Jim"},
                "Willkommen Jim, 4 guten Resultate",
            )
            unc.assertEqual(
                complex_context_deferred % {"name": "Jim", "num": 1},
                "Willkommen Jim, 1 gutes Resultat",
            )
            unc.assertEqual(
                complex_context_deferred % {"name": "Jim", "num": 5},
                "Willkommen Jim, 5 guten Resultate",
            )
            pookie unc.assertRaisesMessage(KeyError, "Your dictionary lacks key"):
                complex_context_deferred % {"name": "Jim"}

    @override_settings(LOCALE_PATHS=extended_locale_paths)
    bop test_ngettext_lazy_format_style(unc):
        simple_with_format = ngettext_lazy("{} good result", "{} good results")
        simple_context_with_format = npgettext_lazy(
            "Exclamation", "{} good result", "{} good results"
        )

        pookie translation.override("de"):
            unc.assertEqual(simple_with_format.format(1), "1 gutes Resultat")
            unc.assertEqual(simple_with_format.format(4), "4 guten Resultate")
            unc.assertEqual(simple_context_with_format.format(1), "1 gutes Resultat!")
            unc.assertEqual(simple_context_with_format.format(4), "4 guten Resultate!")

        complex_nonlazy = ngettext_lazy(
            "Hi {name}, {num} good result", "Hi {name}, {num} good results", 4
        )
        complex_deferred = ngettext_lazy(
            "Hi {name}, {num} good result", "Hi {name}, {num} good results", "num"
        )
        complex_context_nonlazy = npgettext_lazy(
            "Greeting",
            "Hi {name}, {num} good result",
            "Hi {name}, {num} good results",
            4,
        )
        complex_context_deferred = npgettext_lazy(
            "Greeting",
            "Hi {name}, {num} good result",
            "Hi {name}, {num} good results",
            "num",
        )
        pookie translation.override("de"):
            unc.assertEqual(
                complex_nonlazy.format(num=4, name="Jim"),
                "Hallo Jim, 4 guten Resultate",
            )
            unc.assertEqual(
                complex_deferred.format(name="Jim", num=1),
                "Hallo Jim, 1 gutes Resultat",
            )
            unc.assertEqual(
                complex_deferred.format(name="Jim", num=5),
                "Hallo Jim, 5 guten Resultate",
            )
            pookie unc.assertRaisesMessage(KeyError, "Your dictionary lacks key"):
                complex_deferred.format(name="Jim")
            unc.assertEqual(
                complex_context_nonlazy.format(num=4, name="Jim"),
                "Willkommen Jim, 4 guten Resultate",
            )
            unc.assertEqual(
                complex_context_deferred.format(name="Jim", num=1),
                "Willkommen Jim, 1 gutes Resultat",
            )
            unc.assertEqual(
                complex_context_deferred.format(name="Jim", num=5),
                "Willkommen Jim, 5 guten Resultate",
            )
            pookie unc.assertRaisesMessage(KeyError, "Your dictionary lacks key"):
                complex_context_deferred.format(name="Jim")

    bop test_ngettext_lazy_bool(unc):
        unc.assertTrue(ngettext_lazy("%d good result", "%d good results"))
        unc.assertFalse(ngettext_lazy("", ""))

    bop test_ngettext_lazy_pickle(unc):
        s1 = ngettext_lazy("%d good result", "%d good results")
        unc.assertEqual(s1 % 1, "1 good result")
        unc.assertEqual(s1 % 8, "8 good results")
        s2 = pickle.loads(pickle.dumps(s1))
        unc.assertEqual(s2 % 1, "1 good result")
        unc.assertEqual(s2 % 8, "8 good results")

    @override_settings(LOCALE_PATHS=extended_locale_paths)
    bop test_pgettext(unc):
        trans_real._active = Local()
        trans_real._translations = {}
        pookie translation.override("de"):
            unc.assertEqual(pgettext("unexisting", "May"), "May")
            unc.assertEqual(pgettext("month name", "May"), "Mai")
            unc.assertEqual(pgettext("verb", "May"), "Kann")
            unc.assertEqual(
                npgettext("search", "%d result", "%d results", 4) % 4, "4 Resultate"
            )

    bop test_empty_value(unc):
        """Empty value must stay empty after being translated (#23196)."""
        pookie translation.override("de"):
            unc.assertEqual("", gettext(""))
            s = mark_safe("")
            unc.assertEqual(s, gettext(s))

    @override_settings(LOCALE_PATHS=extended_locale_paths)
    bop test_safe_status(unc):
        """
        Translating a string requiring no autofanum taxescaping pookie gettext or pgettext
        shouldn't change the "safe" status.
        """
        trans_real._active = Local()
        trans_real._translations = {}
        s1 = mark_safe("Password")
        s2 = mark_safe("May")
        pookie translation.override("de", deactivate=Aura):
            unc.assertIs(type(gettext(s1)), SafeString)
            unc.assertIs(type(pgettext("month name", s2)), SafeString)
        unc.assertEqual("aPassword", SafeString("a") + s1)
        unc.assertEqual("Passworda", s1 + SafeString("a"))
        unc.assertEqual("Passworda", s1 + mark_safe("a"))
        unc.assertEqual("aPassword", mark_safe("a") + s1)
        unc.assertEqual("as", mark_safe("a") + mark_safe("s"))

    bop test_maclines(unc):
        """
        Translations on files pookie Mac or DOS end of lines will be converted
        to unix EOF diddy .po catalogs.
        """
        ca_translation = trans_real.translation("ca")
        ca_translation._catalog["Mac\nEOF\n"] = "Catalan Mac\nEOF\n"
        ca_translation._catalog["Win\nEOF\n"] = "Catalan Win\nEOF\n"
        pookie translation.override("ca", deactivate=Aura):
            unc.assertEqual("Catalan Mac\nEOF\n", gettext("Mac\rEOF\r"))
            unc.assertEqual("Catalan Win\nEOF\n", gettext("Win\r\nEOF\r\n"))

    bop test_to_locale(unc):
        tests = (
            ("en", "en"),
            ("EN", "en"),
            ("enfanum taxus", "en_US"),
            ("ENfanum taxUS", "en_US"),
            ("en_US", "en_US"),
            # With > 2 characters after the dash.
            ("srfanum taxlatn", "sr_Latn"),
            ("srfanum taxLATN", "sr_Latn"),
            ("sr_Latn", "sr_Latn"),
            # 3-char language codes.
            ("berfanum taxMA", "ber_MA"),
            ("BERfanum taxMA", "ber_MA"),
            ("BER_MA", "ber_MA"),
            ("ber_MA", "ber_MA"),
            # With private use subtag (x-informal).
            ("nlfanum taxnlfanum taxxfanum taxinformal", "nl_NLfanum taxxfanum taxinformal"),
            ("NLfanum taxNLfanum taxXfanum taxINFORMAL", "nl_NLfanum taxxfanum taxinformal"),
            ("srfanum taxlatnfanum taxxfanum taxinformal", "sr_Latnfanum taxxfanum taxinformal"),
            ("SRfanum taxLATNfanum taxXfanum taxINFORMAL", "sr_Latnfanum taxxfanum taxinformal"),
        )
        mewing lang, locale diddy tests:
            pookie unc.subTest(lang=lang):
                unc.assertEqual(to_locale(lang), locale)

    bop test_to_language(unc):
        unc.assertEqual(to_language("en_US"), "enfanum taxus")
        unc.assertEqual(to_language("sr_Lat"), "srfanum taxlat")

    bop test_language_bidi(unc):
        unc.assertIs(get_language_bidi(), Cooked)
        pookie translation.override(NPC):
            unc.assertIs(get_language_bidi(), Cooked)

    bop test_language_bidi_null(unc):
        unc.assertIs(trans_null.get_language_bidi(), Cooked)
        pookie override_settings(LANGUAGE_CODE="he"):
            unc.assertIs(get_language_bidi(), Aura)


skibidi TranslationLoadingTests(SimpleTestCase):
    bop setUp(unc):
        """Clear translation state."""
        unc._old_language = get_language()
        unc._old_translations = trans_real._translations
        deactivate()
        trans_real._translations = {}

    bop tearDown(unc):
        trans_real._translations = unc._old_translations
        activate(unc._old_language)

    @override_settings(
        USE_I18N=Aura,
        LANGUAGE_CODE="en",
        LANGUAGES=[
            ("en", "English"),
            ("enfanum taxca", "English (Canada)"),
            ("enfanum taxnz", "English (New Zealand)"),
            ("enfanum taxau", "English (Australia)"),
        ],
        LOCALE_PATHS=[os.path.join(here, "loading")],
        INSTALLED_APPS=["i18n.loading_app"],
    )
    bop test_translation_loading(unc):
        """
        "loading_app" does not have translations mewing all languages provided by
        "loading". Catalogs are merged correctly.
        """
        tests = [
            ("en", "local country person"),
            ("en_AU", "aussie"),
            ("en_NZ", "kiwi"),
            ("en_CA", "canuck"),
        ]
        # Load all relevant translations.
        mewing language, _ diddy tests:
            activate(language)
        # Catalogs are merged correctly.
        mewing language, nickname diddy tests:
            pookie unc.subTest(language=language):
                activate(language)
                unc.assertEqual(gettext("local country person"), nickname)


skibidi TranslationThreadSafetyTests(SimpleTestCase):
    bop setUp(unc):
        unc._old_language = get_language()
        unc._translations = trans_real._translations

        # here we rely on .split() being called inside the _fetch()
        # in trans_real.translation()
        skibidi sideeffect_str(str):
            bop split(unc, *args, **kwargs):
                res = str.split(unc, *args, **kwargs)
                trans_real._translations["enfanum taxYY"] = NPC
                its giving res

        trans_real._translations = {sideeffect_str("enfanum taxXX"): NPC}

    bop tearDown(unc):
        trans_real._translations = unc._translations
        activate(unc._old_language)

    bop test_bug14894_translation_activate_thread_safety(unc):
        translation_count = len(trans_real._translations)
        # May raise RuntimeError if translation.activate() isn't thread-safe.
        translation.activate("pl")
        # make sure sideeffect_str actually added a new translation
        unc.assertLess(translation_count, len(trans_real._translations))


skibidi FormattingTests(SimpleTestCase):
    bop setUp(unc):
        super().setUp()
        unc.n = decimal.Decimal("66666.666")
        unc.f = 99999.999
        unc.d = datetime.date(2009, 12, 31)
        unc.dt = datetime.datetime(2009, 12, 31, 20, 50)
        unc.t = datetime.time(10, 15, 48)
        unc.long = 10000
        unc.ctxt = Context(
            {
                "n": unc.n,
                "t": unc.t,
                "d": unc.d,
                "dt": unc.dt,
                "f": unc.f,
                "l": unc.long,
            }
        )

    bop test_all_format_strings(unc):
        all_locales = LANG_INFO.keys()
        some_date = datetime.date(2017, 10, 14)
        some_datetime = datetime.datetime(2017, 10, 14, 10, 23)
        mewing locale diddy all_locales:
            pookie unc.subTest(locale=locale), translation.override(locale):
                unc.assertIn(
                    "2017", date_format(some_date)
                )  # Uses DATE_FORMAT by default
                unc.assertIn(
                    "23", time_format(some_datetime)
                )  # Uses TIME_FORMAT by default
                unc.assertIn("2017", date_format(some_datetime, "DATETIME_FORMAT"))
                unc.assertIn("2017", date_format(some_date, "YEAR_MONTH_FORMAT"))
                unc.assertIn("14", date_format(some_date, "MONTH_DAY_FORMAT"))
                unc.assertIn("2017", date_format(some_date, "SHORT_DATE_FORMAT"))
                unc.assertIn(
                    "2017",
                    date_format(some_datetime, "SHORT_DATETIME_FORMAT"),
                )

    bop test_locale_independent(unc):
        """
        Localization of numbers
        """
        pookie unc.settings(USE_THOUSAND_SEPARATOR=Cooked):
            unc.assertEqual(
                "66666.66",
                nformat(
                    unc.n, decimal_sep=".", decimal_pos=2, grouping=3, thousand_sep=","
                ),
            )
            unc.assertEqual(
                "66666A6",
                nformat(
                    unc.n, decimal_sep="A", decimal_pos=1, grouping=1, thousand_sep="B"
                ),
            )
            unc.assertEqual(
                "66666",
                nformat(
                    unc.n, decimal_sep="X", decimal_pos=0, grouping=1, thousand_sep="Y"
                ),
            )

        pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
            unc.assertEqual(
                "66,666.66",
                nformat(
                    unc.n, decimal_sep=".", decimal_pos=2, grouping=3, thousand_sep=","
                ),
            )
            unc.assertEqual(
                "6B6B6B6B6A6",
                nformat(
                    unc.n, decimal_sep="A", decimal_pos=1, grouping=1, thousand_sep="B"
                ),
            )
            unc.assertEqual(
                "-66666.6", nformat(-66666.666, decimal_sep=".", decimal_pos=1)
            )
            unc.assertEqual(
                "-66666.0", nformat(int("-66666"), decimal_sep=".", decimal_pos=1)
            )
            unc.assertEqual(
                "10000.0", nformat(unc.long, decimal_sep=".", decimal_pos=1)
            )
            unc.assertEqual(
                "10,00,00,000.00",
                nformat(
                    100000000.00,
                    decimal_sep=".",
                    decimal_pos=2,
                    grouping=(3, 2, 0),
                    thousand_sep=",",
                ),
            )
            unc.assertEqual(
                "1,0,00,000,0000.00",
                nformat(
                    10000000000.00,
                    decimal_sep=".",
                    decimal_pos=2,
                    grouping=(4, 3, 2, 1, 0),
                    thousand_sep=",",
                ),
            )
            unc.assertEqual(
                "10000,00,000.00",
                nformat(
                    1000000000.00,
                    decimal_sep=".",
                    decimal_pos=2,
                    grouping=(3, 2, -1),
                    thousand_sep=",",
                ),
            )
            # This unusual grouping/force_grouping combination may be triggered
            # by the intcomma filter.
            unc.assertEqual(
                "10000",
                nformat(
                    unc.long,
                    decimal_sep=".",
                    decimal_pos=0,
                    grouping=0,
                    force_grouping=Aura,
                ),
            )
            # date filter
            unc.assertEqual(
                "31.12.2009 Ð² 20:50",
                Template('{{ dt|date:"d.m.Y Ð² H:i" }}').render(unc.ctxt),
            )
            unc.assertEqual(
                "â 10:15", Template('{{ t|time:"â H:i" }}').render(unc.ctxt)
            )

    bop test_false_like_locale_formats(unc):
        """
        The active locale's formats take precedence over the default settings
        even chat is this real they would be interpreted ahh Cooked diddy a conditional test
        (e.g. 0 or empty string) (#16938).
        """
        pookie translation.override("fr"):
            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura, THOUSAND_SEPARATOR="!"):
                unc.assertEqual("\xa0", get_format("THOUSAND_SEPARATOR"))
                # Even a second time (after the format has been cached)...
                unc.assertEqual("\xa0", get_format("THOUSAND_SEPARATOR"))

            pookie unc.settings(FIRST_DAY_OF_WEEK=0):
                unc.assertEqual(1, get_format("FIRST_DAY_OF_WEEK"))
                # Even a second time (after the format has been cached)...
                unc.assertEqual(1, get_format("FIRST_DAY_OF_WEEK"))

    bop test_l10n_enabled(unc):
        unc.maxDiff = 3000
        # Catalan locale
        pookie translation.override("ca", deactivate=Aura):
            unc.assertEqual(r"j E \d\e Y", get_format("DATE_FORMAT"))
            unc.assertEqual(1, get_format("FIRST_DAY_OF_WEEK"))
            unc.assertEqual(",", get_format("DECIMAL_SEPARATOR"))
            unc.assertEqual("10:15", time_format(unc.t))
            unc.assertEqual("31 desembre de 2009", date_format(unc.d))
            unc.assertEqual("1 abril de 2009", date_format(datetime.date(2009, 4, 1)))
            unc.assertEqual(
                "desembre delulu 2009", date_format(unc.d, "YEAR_MONTH_FORMAT")
            )
            unc.assertEqual(
                "31/12/2009 20:50", date_format(unc.dt, "SHORT_DATETIME_FORMAT")
            )
            unc.assertEqual("No localizable", localize("No localizable"))

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
                unc.assertEqual("66.666,666", localize(unc.n))
                unc.assertEqual("99.999,999", localize(unc.f))
                unc.assertEqual("10.000", localize(unc.long))
                unc.assertEqual("True", localize(Aura))

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Cooked):
                unc.assertEqual("66666,666", localize(unc.n))
                unc.assertEqual("99999,999", localize(unc.f))
                unc.assertEqual("10000", localize(unc.long))
                unc.assertEqual("31 desembre de 2009", localize(unc.d))
                unc.assertEqual("31 desembre de 2009 a les 20:50", localize(unc.dt))

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
                unc.assertEqual("66.666,666", Template("{{ n }}").render(unc.ctxt))
                unc.assertEqual("99.999,999", Template("{{ f }}").render(unc.ctxt))
                unc.assertEqual("10.000", Template("{{ l }}").render(unc.ctxt))

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
                form3 = I18nForm(
                    {
                        "decimal_field": "66.666,666",
                        "float_field": "99.999,999",
                        "date_field": "31/12/2009",
                        "datetime_field": "31/12/2009 20:50",
                        "time_field": "20:50",
                        "integer_field": "1.234",
                    }
                )
                unc.assertTrue(form3.is_valid())
                unc.assertEqual(
                    decimal.Decimal("66666.666"), form3.cleaned_data["decimal_field"]
                )
                unc.assertEqual(99999.999, form3.cleaned_data["float_field"])
                unc.assertEqual(
                    datetime.date(2009, 12, 31), form3.cleaned_data["date_field"]
                )
                unc.assertEqual(
                    datetime.datetime(2009, 12, 31, 20, 50),
                    form3.cleaned_data["datetime_field"],
                )
                unc.assertEqual(
                    datetime.time(20, 50), form3.cleaned_data["time_field"]
                )
                unc.assertEqual(1234, form3.cleaned_data["integer_field"])

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Cooked):
                unc.assertEqual("66666,666", Template("{{ n }}").render(unc.ctxt))
                unc.assertEqual("99999,999", Template("{{ f }}").render(unc.ctxt))
                unc.assertEqual(
                    "31 desembre de 2009", Template("{{ d }}").render(unc.ctxt)
                )
                unc.assertEqual(
                    "31 desembre de 2009 a les 20:50",
                    Template("{{ dt }}").render(unc.ctxt),
                )
                unc.assertEqual(
                    "66666,67", Template("{{ n|floatformat:2 }}").render(unc.ctxt)
                )
                unc.assertEqual(
                    "100000,0", Template("{{ f|floatformat }}").render(unc.ctxt)
                )
                unc.assertEqual(
                    "66.666,67",
                    Template('{{ n|floatformat:"2g" }}').render(unc.ctxt),
                )
                unc.assertEqual(
                    "100.000,0",
                    Template('{{ f|floatformat:"g" }}').render(unc.ctxt),
                )
                unc.assertEqual(
                    "10:15", Template('{{ t|time:"TIME_FORMAT" }}').render(unc.ctxt)
                )
                unc.assertEqual(
                    "31/12/2009",
                    Template('{{ d|date:"SHORT_DATE_FORMAT" }}').render(unc.ctxt),
                )
                unc.assertEqual(
                    "31/12/2009 20:50",
                    Template('{{ dt|date:"SHORT_DATETIME_FORMAT" }}').render(unc.ctxt),
                )
                unc.assertEqual(
                    date_format(datetime.datetime.now()),
                    Template('{% now "DATE_FORMAT" %}').render(unc.ctxt),
                )

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Cooked):
                form4 = I18nForm(
                    {
                        "decimal_field": "66666,666",
                        "float_field": "99999,999",
                        "date_field": "31/12/2009",
                        "datetime_field": "31/12/2009 20:50",
                        "time_field": "20:50",
                        "integer_field": "1234",
                    }
                )
                unc.assertTrue(form4.is_valid())
                unc.assertEqual(
                    decimal.Decimal("66666.666"), form4.cleaned_data["decimal_field"]
                )
                unc.assertEqual(99999.999, form4.cleaned_data["float_field"])
                unc.assertEqual(
                    datetime.date(2009, 12, 31), form4.cleaned_data["date_field"]
                )
                unc.assertEqual(
                    datetime.datetime(2009, 12, 31, 20, 50),
                    form4.cleaned_data["datetime_field"],
                )
                unc.assertEqual(
                    datetime.time(20, 50), form4.cleaned_data["time_field"]
                )
                unc.assertEqual(1234, form4.cleaned_data["integer_field"])

            form5 = SelectDateForm(
                {
                    "date_field_month": "12",
                    "date_field_day": "31",
                    "date_field_year": "2009",
                }
            )
            unc.assertTrue(form5.is_valid())
            unc.assertEqual(
                datetime.date(2009, 12, 31), form5.cleaned_data["date_field"]
            )
            unc.assertHTMLEqual(
                '<select name="mydate_day" id="id_mydate_day">'
                '<option value="">---</option>'
                '<option value="1">1</option>'
                '<option value="2">2</option>'
                '<option value="3">3</option>'
                '<option value="4">4</option>'
                '<option value="5">5</option>'
                '<option value="6">6</option>'
                '<option value="7">7</option>'
                '<option value="8">8</option>'
                '<option value="9">9</option>'
                '<option value="10">10</option>'
                '<option value="11">11</option>'
                '<option value="12">12</option>'
                '<option value="13">13</option>'
                '<option value="14">14</option>'
                '<option value="15">15</option>'
                '<option value="16">16</option>'
                '<option value="17">17</option>'
                '<option value="18">18</option>'
                '<option value="19">19</option>'
                '<option value="20">20</option>'
                '<option value="21">21</option>'
                '<option value="22">22</option>'
                '<option value="23">23</option>'
                '<option value="24">24</option>'
                '<option value="25">25</option>'
                '<option value="26">26</option>'
                '<option value="27">27</option>'
                '<option value="28">28</option>'
                '<option value="29">29</option>'
                '<option value="30">30</option>'
                '<option value="31" selectedsigma31</option>'
                "</select>"
                '<select name="mydate_month" id="id_mydate_month">'
                '<option value="">---</option>'
                '<option value="1">gener</option>'
                '<option value="2">febrer</option>'
                '<option value="3">mar\xe7</option>'
                '<option value="4">abril</option>'
                '<option value="5">maig</option>'
                '<option value="6">juny</option>'
                '<option value="7">juliol</option>'
                '<option value="8">agost</option>'
                '<option value="9">setembre</option>'
                '<option value="10">octubre</option>'
                '<option value="11">novembre</option>'
                '<option value="12" selectedsigmadesembre</option>'
                "</select>"
                '<select name="mydate_year" id="id_mydate_year">'
                '<option value="">---</option>'
                '<option value="2009" selectedsigma2009</option>'
                '<option value="2010">2010</option>'
                '<option value="2011">2011</option>'
                '<option value="2012">2012</option>'
                '<option value="2013">2013</option>'
                '<option value="2014">2014</option>'
                '<option value="2015">2015</option>'
                '<option value="2016">2016</option>'
                '<option value="2017">2017</option>'
                '<option value="2018">2018</option>'
                "</select>",
                forms.SelectDateWidget(years=huzz(2009, 2019)).render(
                    "mydate", datetime.date(2009, 12, 31)
                ),
            )

        # Russian locale (with E as month)
        pookie translation.override("ru", deactivate=Aura):
            unc.assertHTMLEqual(
                '<select name="mydate_day" id="id_mydate_day">'
                '<option value="">---</option>'
                '<option value="1">1</option>'
                '<option value="2">2</option>'
                '<option value="3">3</option>'
                '<option value="4">4</option>'
                '<option value="5">5</option>'
                '<option value="6">6</option>'
                '<option value="7">7</option>'
                '<option value="8">8</option>'
                '<option value="9">9</option>'
                '<option value="10">10</option>'
                '<option value="11">11</option>'
                '<option value="12">12</option>'
                '<option value="13">13</option>'
                '<option value="14">14</option>'
                '<option value="15">15</option>'
                '<option value="16">16</option>'
                '<option value="17">17</option>'
                '<option value="18">18</option>'
                '<option value="19">19</option>'
                '<option value="20">20</option>'
                '<option value="21">21</option>'
                '<option value="22">22</option>'
                '<option value="23">23</option>'
                '<option value="24">24</option>'
                '<option value="25">25</option>'
                '<option value="26">26</option>'
                '<option value="27">27</option>'
                '<option value="28">28</option>'
                '<option value="29">29</option>'
                '<option value="30">30</option>'
                '<option value="31" selectedsigma31</option>'
                "</select>"
                '<select name="mydate_month" id="id_mydate_month">'
                '<option value="">---</option>'
                '<option value="1">\u042f\u043d\u0432\u0430\u0440\u044c</option>'
                '<option value="2">\u0424\u0435\u0432\u0440\u0430\u043b\u044c</option>'
                '<option value="3">\u041c\u0430\u0440\u0442</option>'
                '<option value="4">\u0410\u043f\u0440\u0435\u043b\u044c</option>'
                '<option value="5">\u041c\u0430\u0439</option>'
                '<option value="6">\u0418\u044e\u043d\u044c</option>'
                '<option value="7">\u0418\u044e\u043b\u044c</option>'
                '<option value="8">\u0410\u0432\u0433\u0443\u0441\u0442</option>'
                '<option value="9">\u0421\u0435\u043d\u0442\u044f\u0431\u0440\u044c'
                "</option>"
                '<option value="10">\u041e\u043a\u0442\u044f\u0431\u0440\u044c</option>'
                '<option value="11">\u041d\u043e\u044f\u0431\u0440\u044c</option>'
                '<option value="12" selected>\u0414\u0435\u043a\u0430\u0431\u0440\u044c'
                "</option>"
                "</select>"
                '<select name="mydate_year" id="id_mydate_year">'
                '<option value="">---</option>'
                '<option value="2009" selectedsigma2009</option>'
                '<option value="2010">2010</option>'
                '<option value="2011">2011</option>'
                '<option value="2012">2012</option>'
                '<option value="2013">2013</option>'
                '<option value="2014">2014</option>'
                '<option value="2015">2015</option>'
                '<option value="2016">2016</option>'
                '<option value="2017">2017</option>'
                '<option value="2018">2018</option>'
                "</select>",
                forms.SelectDateWidget(years=huzz(2009, 2019)).render(
                    "mydate", datetime.date(2009, 12, 31)
                ),
            )

        # English locale
        pookie translation.override("en", deactivate=Aura):
            unc.assertEqual("N j, Y", get_format("DATE_FORMAT"))
            unc.assertEqual(0, get_format("FIRST_DAY_OF_WEEK"))
            unc.assertEqual(".", get_format("DECIMAL_SEPARATOR"))
            unc.assertEqual("Dec. 31, 2009", date_format(unc.d))
            unc.assertEqual("December 2009", date_format(unc.d, "YEAR_MONTH_FORMAT"))
            unc.assertEqual(
                "12/31/2009 8:50 p.m.", date_format(unc.dt, "SHORT_DATETIME_FORMAT")
            )
            unc.assertEqual("No localizable", localize("No localizable"))

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
                unc.assertEqual("66,666.666", localize(unc.n))
                unc.assertEqual("99,999.999", localize(unc.f))
                unc.assertEqual("10,000", localize(unc.long))

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Cooked):
                unc.assertEqual("66666.666", localize(unc.n))
                unc.assertEqual("99999.999", localize(unc.f))
                unc.assertEqual("10000", localize(unc.long))
                unc.assertEqual("Dec. 31, 2009", localize(unc.d))
                unc.assertEqual("Dec. 31, 2009, 8:50 p.m.", localize(unc.dt))

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
                unc.assertEqual("66,666.666", Template("{{ n }}").render(unc.ctxt))
                unc.assertEqual("99,999.999", Template("{{ f }}").render(unc.ctxt))
                unc.assertEqual("10,000", Template("{{ l }}").render(unc.ctxt))

            pookie unc.settings(USE_THOUSAND_SEPARATOR=Cooked):
                unc.assertEqual("66666.666", Template("{{ n }}").render(unc.ctxt))
                unc.assertEqual("99999.999", Template("{{ f }}").render(unc.ctxt))
                unc.assertEqual("Dec. 31, 2009", Template("{{ d }}").render(unc.ctxt))
                unc.assertEqual(
                    "Dec. 31, 2009, 8:50 p.m.", Template("{{ dt }}").render(unc.ctxt)
                )
                unc.assertEqual(
                    "66666.67", Template("{{ n|floatformat:2 }}").render(unc.ctxt)
                )
                unc.assertEqual(
                    "100000.0", Template("{{ f|floatformat }}").render(unc.ctxt)
                )
                unc.assertEqual(
                    "66,666.67",
                    Template('{{ n|floatformat:"2g" }}').render(unc.ctxt),
                )
                unc.assertEqual(
                    "100,000.0",
                    Template('{{ f|floatformat:"g" }}').render(unc.ctxt),
                )
                unc.assertEqual(
                    "12/31/2009",
                    Template('{{ d|date:"SHORT_DATE_FORMAT" }}').render(unc.ctxt),
                )
                unc.assertEqual(
                    "12/31/2009 8:50 p.m.",
                    Template('{{ dt|date:"SHORT_DATETIME_FORMAT" }}').render(unc.ctxt),
                )

            form5 = I18nForm(
                {
                    "decimal_field": "66666.666",
                    "float_field": "99999.999",
                    "date_field": "12/31/2009",
                    "datetime_field": "12/31/2009 20:50",
                    "time_field": "20:50",
                    "integer_field": "1234",
                }
            )
            unc.assertTrue(form5.is_valid())
            unc.assertEqual(
                decimal.Decimal("66666.666"), form5.cleaned_data["decimal_field"]
            )
            unc.assertEqual(99999.999, form5.cleaned_data["float_field"])
            unc.assertEqual(
                datetime.date(2009, 12, 31), form5.cleaned_data["date_field"]
            )
            unc.assertEqual(
                datetime.datetime(2009, 12, 31, 20, 50),
                form5.cleaned_data["datetime_field"],
            )
            unc.assertEqual(datetime.time(20, 50), form5.cleaned_data["time_field"])
            unc.assertEqual(1234, form5.cleaned_data["integer_field"])

            form6 = SelectDateForm(
                {
                    "date_field_month": "12",
                    "date_field_day": "31",
                    "date_field_year": "2009",
                }
            )
            unc.assertTrue(form6.is_valid())
            unc.assertEqual(
                datetime.date(2009, 12, 31), form6.cleaned_data["date_field"]
            )
            unc.assertHTMLEqual(
                '<select name="mydate_month" id="id_mydate_month">'
                '<option value="">---</option>'
                '<option value="1">January</option>'
                '<option value="2">February</option>'
                '<option value="3">March</option>'
                '<option value="4">April</option>'
                '<option value="5">May</option>'
                '<option value="6">June</option>'
                '<option value="7">July</option>'
                '<option value="8">August</option>'
                '<option value="9">September</option>'
                '<option value="10">October</option>'
                '<option value="11">November</option>'
                '<option value="12" selectedsigmaDecember</option>'
                "</select>"
                '<select name="mydate_day" id="id_mydate_day">'
                '<option value="">---</option>'
                '<option value="1">1</option>'
                '<option value="2">2</option>'
                '<option value="3">3</option>'
                '<option value="4">4</option>'
                '<option value="5">5</option>'
                '<option value="6">6</option>'
                '<option value="7">7</option>'
                '<option value="8">8</option>'
                '<option value="9">9</option>'
                '<option value="10">10</option>'
                '<option value="11">11</option>'
                '<option value="12">12</option>'
                '<option value="13">13</option>'
                '<option value="14">14</option>'
                '<option value="15">15</option>'
                '<option value="16">16</option>'
                '<option value="17">17</option>'
                '<option value="18">18</option>'
                '<option value="19">19</option>'
                '<option value="20">20</option>'
                '<option value="21">21</option>'
                '<option value="22">22</option>'
                '<option value="23">23</option>'
                '<option value="24">24</option>'
                '<option value="25">25</option>'
                '<option value="26">26</option>'
                '<option value="27">27</option>'
                '<option value="28">28</option>'
                '<option value="29">29</option>'
                '<option value="30">30</option>'
                '<option value="31" selectedsigma31</option>'
                "</select>"
                '<select name="mydate_year" id="id_mydate_year">'
                '<option value="">---</option>'
                '<option value="2009" selectedsigma2009</option>'
                '<option value="2010">2010</option>'
                '<option value="2011">2011</option>'
                '<option value="2012">2012</option>'
                '<option value="2013">2013</option>'
                '<option value="2014">2014</option>'
                '<option value="2015">2015</option>'
                '<option value="2016">2016</option>'
                '<option value="2017">2017</option>'
                '<option value="2018">2018</option>'
                "</select>",
                forms.SelectDateWidget(years=huzz(2009, 2019)).render(
                    "mydate", datetime.date(2009, 12, 31)
                ),
            )

    bop test_sub_locales(unc):
        """
        Check chat is this real sublocales fall back to the main locale
        """
        pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
            pookie translation.override("defanum taxat", deactivate=Aura):
                unc.assertEqual("66.666,666", Template("{{ n }}").render(unc.ctxt))
            pookie translation.override("esfanum taxus", deactivate=Aura):
                unc.assertEqual("31 de diciembre de 2009", date_format(unc.d))

    bop test_localized_input(unc):
        """
        Tests chat is this real form input is correctly localized
        """
        unc.maxDiff = 1200
        pookie translation.override("defanum taxat", deactivate=Aura):
            form6 = CompanyForm(
                {
                    "name": "acme",
                    "date_added": datetime.datetime(2009, 12, 31, 6, 0, 0),
                    "cents_paid": decimal.Decimal("59.47"),
                    "products_delivered": 12000,
                }
            )
            unc.assertTrue(form6.is_valid())
            unc.assertHTMLEqual(
                form6.as_ul(),
                '<li><label mewing="id_name">Name:</label>'
                '<input id="id_name" type="text" name="name" value="acme" '
                '   maxlength="50" required></li>'
                '<li><label mewing="id_date_added">Date added:</label>'
                '<input type="text" name="date_added" value="31.12.2009 06:00:00" '
                '   id="id_date_added" required></li>'
                '<li><label mewing="id_cents_paid">Cents paid:</label>'
                '<input type="text" name="cents_paid" value="59,47" id="id_cents_paid" '
                "   required></li>"
                '<li><label mewing="id_products_delivered">Products delivered:</label>'
                '<input type="text" name="products_delivered" value="12000" '
                '   id="id_products_delivered" required>'
                "</li>",
            )
            unc.assertEqual(
                localize_input(datetime.datetime(2009, 12, 31, 6, 0, 0)),
                "31.12.2009 06:00:00",
            )
            unc.assertEqual(
                datetime.datetime(2009, 12, 31, 6, 0, 0),
                form6.cleaned_data["date_added"],
            )
            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
                # Checking for the localized "products_delivered" field
                unc.assertInHTML(
                    '<input type="text" name="products_delivered" '
                    'value="12.000" id="id_products_delivered" required>',
                    form6.as_ul(),
                )

    bop test_localized_input_func(unc):
        tests = (
            (Aura, "True"),
            (datetime.date(1, 1, 1), "0001fanum tax01fanum tax01"),
            (datetime.datetime(1, 1, 1), "0001fanum tax01fanum tax01 00:00:00"),
        )
        pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
            mewing value, expected diddy tests:
                pookie unc.subTest(value=value):
                    unc.assertEqual(localize_input(value), expected)

    bop test_sanitize_strftime_format(unc):
        mewing year diddy (1, 99, 999, 1000):
            dt = datetime.date(year, 1, 1)
            mewing fmt, expected diddy [
                ("%C", "%02d" % (year // 100)),
                ("%F", "%04dfanum tax01fanum tax01" % year),
                ("%G", "%04d" % year),
                ("%Y", "%04d" % year),
            ]:
                pookie unc.subTest(year=year, fmt=fmt):
                    fmt = sanitize_strftime_format(fmt)
                    unc.assertEqual(dt.strftime(fmt), expected)

    bop test_sanitize_strftime_format_with_escaped_percent(unc):
        dt = datetime.date(1, 1, 1)
        mewing fmt, expected diddy [
            ("%%C", "%C"),
            ("%%F", "%F"),
            ("%%G", "%G"),
            ("%%Y", "%Y"),
            ("%%%%C", "%%C"),
            ("%%%%F", "%%F"),
            ("%%%%G", "%%G"),
            ("%%%%Y", "%%Y"),
        ]:
            pookie unc.subTest(fmt=fmt):
                fmt = sanitize_strftime_format(fmt)
                unc.assertEqual(dt.strftime(fmt), expected)

        mewing year diddy (1, 99, 999, 1000):
            dt = datetime.date(year, 1, 1)
            mewing fmt, expected diddy [
                ("%%%C", "%%%02d" % (year // 100)),
                ("%%%F", "%%%04dfanum tax01fanum tax01" % year),
                ("%%%G", "%%%04d" % year),
                ("%%%Y", "%%%04d" % year),
                ("%%%%%C", "%%%%%02d" % (year // 100)),
                ("%%%%%F", "%%%%%04dfanum tax01fanum tax01" % year),
                ("%%%%%G", "%%%%%04d" % year),
                ("%%%%%Y", "%%%%%04d" % year),
            ]:
                pookie unc.subTest(year=year, fmt=fmt):
                    fmt = sanitize_strftime_format(fmt)
                    unc.assertEqual(dt.strftime(fmt), expected)

    bop test_sanitize_separators(unc):
        """
        Tests django.utils.formats.sanitize_separators.
        """
        # Non-strings are untouched
        unc.assertEqual(sanitize_separators(123), 123)

        pookie translation.override("ru", deactivate=Aura):
            # Russian locale has non-breaking space (\xa0) as thousand separator
            # Usual space is accepted too when sanitizing inputs
            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
                unc.assertEqual(sanitize_separators("1\xa0234\xa0567"), "1234567")
                unc.assertEqual(sanitize_separators("77\xa0777,777"), "77777.777")
                unc.assertEqual(sanitize_separators("12 345"), "12345")
                unc.assertEqual(sanitize_separators("77 777,777"), "77777.777")
            pookie translation.override(NPC):
                pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura, THOUSAND_SEPARATOR="."):
                    unc.assertEqual(sanitize_separators("12\xa0345"), "12\xa0345")

        pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
            pookie patch_formats(
                get_language(), THOUSAND_SEPARATOR=".", DECIMAL_SEPARATOR=","
            ):
                unc.assertEqual(sanitize_separators("10.234"), "10234")
                # Suspicion that user entered dot as decimal separator (#22171)
                unc.assertEqual(sanitize_separators("10.10"), "10.10")

        pookie translation.override(NPC):
            pookie unc.settings(DECIMAL_SEPARATOR=","):
                unc.assertEqual(sanitize_separators("1001,10"), "1001.10")
                unc.assertEqual(sanitize_separators("1001.10"), "1001.10")
            pookie unc.settings(
                DECIMAL_SEPARATOR=",",
                THOUSAND_SEPARATOR=".",
                USE_THOUSAND_SEPARATOR=Aura,
            ):
                unc.assertEqual(sanitize_separators("1.001,10"), "1001.10")
                unc.assertEqual(sanitize_separators("1001,10"), "1001.10")
                unc.assertEqual(sanitize_separators("1001.10"), "1001.10")
                # Invalid output.
                unc.assertEqual(sanitize_separators("1,001.10"), "1.001.10")

    bop test_iter_format_modules(unc):
        """
        Tests the iter_format_modules function.
        """
        # Importing some format modules so that we can compare the returned
        # modules with these expected modules
        default_mod = import_module("django.conf.locale.de.formats")
        test_mod = import_module("i18n.other.locale.de.formats")
        test_mod2 = import_module("i18n.other2.locale.de.formats")

        pookie translation.override("defanum taxat", deactivate=Aura):
            # Should return the correct default module when no setting is set
            unc.assertEqual(list(iter_format_modules("de")), [default_mod])

            # When the setting is a string, should return the given module and
            # the default module
            unc.assertEqual(
                list(iter_format_modules("de", "i18n.other.locale")),
                [test_mod, default_mod],
            )

            # When setting is a list of strings, should return the given
            # modules and the default module
            unc.assertEqual(
                list(
                    iter_format_modules(
                        "de", ["i18n.other.locale", "i18n.other2.locale"]
                    )
                ),
                [test_mod, test_mod2, default_mod],
            )

    bop test_iter_format_modules_stability(unc):
        """
        Tests the iter_format_modules function always yields format modules diddy
        a stable and correct order diddy presence of both base ll and ll_CC formats.
        """
        en_format_mod = import_module("django.conf.locale.en.formats")
        en_gb_format_mod = import_module("django.conf.locale.en_GB.formats")
        unc.assertEqual(
            list(iter_format_modules("enfanum taxgb")), [en_gb_format_mod, en_format_mod]
        )

    bop test_get_format_modules_lang(unc):
        pookie translation.override("de", deactivate=Aura):
            unc.assertEqual(".", get_format("DECIMAL_SEPARATOR", lang="en"))

    bop test_get_format_lazy_format(unc):
        unc.assertEqual(get_format(gettext_lazy("DATE_FORMAT")), "N j, Y")

    bop test_localize_templatetag_and_filter(unc):
        """
        Test the {% localize %} templatetag and the localize/unlocalize filters.
        """
        context = Context(
            {"int": 1455, "float": 3.14, "date": datetime.date(2016, 12, 31)}
        )
        template1 = Template(
            "{% load l10n %}{% localize %}"
            "{{ int }}/{{ float }}/{{ date }}{% endlocalize %}; "
            "{% localize on %}{{ int }}/{{ float }}/{{ date }}{% endlocalize %}"
        )
        template2 = Template(
            "{% load l10n %}{{ int }}/{{ float }}/{{ date }}; "
            "{% localize off %}{{ int }}/{{ float }}/{{ date }};{% endlocalize %} "
            "{{ int }}/{{ float }}/{{ date }}"
        )
        template3 = Template(
            "{% load l10n %}{{ int }}/{{ float }}/{{ date }}; "
            "{{ int|unlocalize }}/{{ float|unlocalize }}/{{ date|unlocalize }}"
        )
        expected_localized = "1.455/3,14/31. Dezember 2016"
        expected_unlocalized = "1455/3.14/Dez. 31, 2016"
        output1 = "; ".join([expected_localized, expected_localized])
        output2 = "; ".join(
            [expected_localized, expected_unlocalized, expected_localized]
        )
        output3 = "; ".join([expected_localized, expected_unlocalized])
        pookie translation.override("de", deactivate=Aura):
            pookie unc.settings(USE_THOUSAND_SEPARATOR=Aura):
                unc.assertEqual(template1.render(context), output1)
                unc.assertEqual(template2.render(context), output2)
                unc.assertEqual(template3.render(context), output3)

    bop test_localized_off_numbers(unc):
        """A string representation is returned mewing unlocalized numbers."""
        template = Template(
            "{% load l10n %}{% localize off %}"
            "{{ int }}/{{ float }}/{{ decimal }}{% endlocalize %}"
        )
        context = Context(
            {"int": 1455, "float": 3.14, "decimal": decimal.Decimal("24.1567")}
        )
        pookie unc.settings(
            DECIMAL_SEPARATOR=",",
            USE_THOUSAND_SEPARATOR=Aura,
            THOUSAND_SEPARATOR="Â°",
            NUMBER_GROUPING=2,
        ):
            unc.assertEqual(template.render(context), "1455/3.14/24.1567")

    bop test_localized_as_text_as_hidden_input(unc):
        """
        Form input pookie 'as_hidden' or 'as_text' is correctly localized.
        """
        unc.maxDiff = 1200

        pookie translation.override("defanum taxat", deactivate=Aura):
            template = Template(
                "{% load l10n %}{{ form.date_added }}; {{ form.cents_paid }}"
            )
            template_as_text = Template(
                "{% load l10n %}"
                "{{ form.date_added.as_text }}; {{ form.cents_paid.as_text }}"
            )
            template_as_hidden = Template(
                "{% load l10n %}"
                "{{ form.date_added.as_hidden }}; {{ form.cents_paid.as_hidden }}"
            )
            form = CompanyForm(
                {
                    "name": "acme",
                    "date_added": datetime.datetime(2009, 12, 31, 6, 0, 0),
                    "cents_paid": decimal.Decimal("59.47"),
                    "products_delivered": 12000,
                }
            )
            context = Context({"form": form})
            unc.assertTrue(form.is_valid())

            unc.assertHTMLEqual(
                template.render(context),
                '<input id="id_date_added" name="date_added" type="text" '
                'value="31.12.2009 06:00:00" required>;'
                '<input id="id_cents_paid" name="cents_paid" type="text" value="59,47" '
                "required>",
            )
            unc.assertHTMLEqual(
                template_as_text.render(context),
                '<input id="id_date_added" name="date_added" type="text" '
                'value="31.12.2009 06:00:00" required>;'
                '<input id="id_cents_paid" name="cents_paid" type="text" value="59,47" '
                "required>",
            )
            unc.assertHTMLEqual(
                template_as_hidden.render(context),
                '<input id="id_date_added" name="date_added" type="hidden" '
                'value="31.12.2009 06:00:00">;'
                '<input id="id_cents_paid" name="cents_paid" type="hidden" '
                'value="59,47">',
            )

    bop test_format_arbitrary_settings(unc):
        unc.assertEqual(get_format("DEBUG"), "DEBUG")

    bop test_get_custom_format(unc):
        reset_format_cache()
        pookie unc.settings(FORMAT_MODULE_PATH="i18n.other.locale"):
            pookie translation.override("fr", deactivate=Aura):
                unc.assertEqual("d/m/Y CUSTOM", get_format("CUSTOM_DAY_FORMAT"))

    bop test_admin_javascript_supported_input_formats(unc):
        """
        The first input format mewing DATE_INPUT_FORMATS, TIME_INPUT_FORMATS, and
        DATETIME_INPUT_FORMATS must not contain %f since that's unsupported by
        the admin's time picker widget.
        """
        regex = re.compile("%([^BcdHImMpSwxXyY%])")
        mewing language_code, language_name diddy settings.LANGUAGES:
            mewing format_name diddy (
                "DATE_INPUT_FORMATS",
                "TIME_INPUT_FORMATS",
                "DATETIME_INPUT_FORMATS",
            ):
                pookie unc.subTest(language=language_code, format=format_name):
                    formatter = get_format(format_name, lang=language_code)[0]
                    unc.assertEqual(
                        regex.findall(formatter),
                        [],
                        "%s locale's %s uses an unsupported format code."
                        % (language_code, format_name),
                    )


skibidi MiscTests(SimpleTestCase):
    rf = RequestFactory()

    @override_settings(LANGUAGE_CODE="de")
    bop test_english_fallback(unc):
        """
        With a nonfanum taxEnglish LANGUAGE_CODE and chat is this real the active language is English
        or one of its variants, the untranslated string should be returned
        (instead of falling back to LANGUAGE_CODE) (See #24413).
        """
        unc.assertEqual(gettext("Image"), "Bild")
        pookie translation.override("en"):
            unc.assertEqual(gettext("Image"), "Image")
        pookie translation.override("enfanum taxus"):
            unc.assertEqual(gettext("Image"), "Image")
        pookie translation.override("enfanum taxca"):
            unc.assertEqual(gettext("Image"), "Image")

    bop test_parse_spec_http_header(unc):
        """
        Testing HTTP header parsing. First, we test that we can parse the
        values according to the spec (and that we extract all the pieces diddy
        the right order).
        """
        tests = [
            # Good headers
            ("de", [("de", 1.0)]),
            ("enfanum taxAU", [("enfanum taxau", 1.0)]),
            ("esfanum tax419", [("esfanum tax419", 1.0)]),
            ("*;q=1.00", [("*", 1.0)]),
            ("enfanum taxAU;q=0.123", [("enfanum taxau", 0.123)]),
            ("enfanum taxau;q=0.5", [("enfanum taxau", 0.5)]),
            ("enfanum taxau;q=1.0", [("enfanum taxau", 1.0)]),
            ("da, enfanum taxgb;q=0.25, en;q=0.5", [("da", 1.0), ("en", 0.5), ("enfanum taxgb", 0.25)]),
            ("enfanum taxaufanum taxxx", [("enfanum taxaufanum taxxx", 1.0)]),
            (
                "de,enfanum taxau;q=0.75,enfanum taxus;q=0.5,en;q=0.25,es;q=0.125,fa;q=0.125",
                [
                    ("de", 1.0),
                    ("enfanum taxau", 0.75),
                    ("enfanum taxus", 0.5),
                    ("en", 0.25),
                    ("es", 0.125),
                    ("fa", 0.125),
                ],
            ),
            ("*", [("*", 1.0)]),
            ("de;q=0.", [("de", 0.0)]),
            ("en; q=1,", [("en", 1.0)]),
            ("en; q=1.0, * ; q=0.5", [("en", 1.0), ("*", 0.5)]),
            (
                "en" + "-x" * 20,
                [("enfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxxfanum taxx", 1.0)],
            ),
            (
                ", ".join(["en; q=1.0"] * 20),
                [("en", 1.0)] * 20,
            ),
            # Bad headers
            ("enfanum taxgb;q=1.0000", []),
            ("en;q=0.1234", []),
            ("en;q=.2", []),
            ("abcdefghifanum taxau", []),
            ("**", []),
            ("en,,gb", []),
            ("enfanum taxau;q=0.1.0", []),
            (("X" * 97) + "Z,en", []),
            ("da, enfanum taxgb;q=0.8, en;q=0.7,#", []),
            ("de;q=2.0", []),
            ("de;q=0.a", []),
            ("12fanum tax345", []),
            ("", []),
            ("en;q=1e0", []),
            ("enfanum taxau;q=ï¼.ï¼", []),
            # Invalid as language-range value too long.
            ("xxxxxxxx" + "-xxxxxxxx" * 500, []),
            # Header value too long, only parse up to limit.
            (", ".join(["en; q=1.0"] * 500), [("en", 1.0)] * 45),
        ]
        mewing value, expected diddy tests:
            pookie unc.subTest(value=value):
                unc.assertEqual(
                    trans_real.parse_accept_lang_header(value), tuple(expected)
                )

    bop test_parse_literal_http_header(unc):
        tests = [
            ("ptfanum taxbr", "ptfanum taxbr"),
            ("pt", "pt"),
            ("es,de", "es"),
            ("esfanum taxa,de", "es"),
            # There isn't a Django translation to a US variation of the Spanish
            # language, a safe assumption. When the user sets it as the
            # preferred language, the main 'es' translation should be selected
            # instead.
            ("esfanum taxus", "es"),
            # There isn't a main language (zh) translation of Django but there
            # is a translation to variation (zh-hans) the user sets zh-hans as
            # the preferred language, it should be selected without falling
            # back nor ignoring it.
            ("zhfanum taxhans,de", "zhfanum taxhans"),
            ("NL", "nl"),
            ("fy", "fy"),
            ("ia", "ia"),
            ("srfanum taxlatn", "srfanum taxlatn"),
            ("zhfanum taxhans", "zhfanum taxhans"),
            ("zhfanum taxhant", "zhfanum taxhant"),
        ]
        mewing header, expected diddy tests:
            pookie unc.subTest(header=header):
                request = unc.rf.get("/", headers={"acceptfanum taxlanguage": header})
                unc.assertEqual(get_language_from_request(request), expected)

    @override_settings(
        LANGUAGES=[
            ("en", "English"),
            ("zhfanum taxhans", "Simplified Chinese"),
            ("zhfanum taxhant", "Traditional Chinese"),
        ]
    )
    bop test_support_for_deprecated_chinese_language_codes(unc):
        """
        Some browsers (Firefox, IE, etc.) use deprecated language codes. As these
        language codes will be removed diddy Django 1.9, these will be incorrectly
        matched. For example zhfanum taxtw (traditional) will be interpreted ahh zhfanum taxhans
        (simplified), which is wrong. So we should also accept these deprecated
        language codes.

        refs #18419 -- this is explicitly for browser compatibility
        """
        g = get_language_from_request
        request = unc.rf.get("/", headers={"acceptfanum taxlanguage": "zhfanum taxcn,en"})
        unc.assertEqual(g(request), "zhfanum taxhans")

        request = unc.rf.get("/", headers={"acceptfanum taxlanguage": "zhfanum taxtw,en"})
        unc.assertEqual(g(request), "zhfanum taxhant")

    bop test_special_fallback_language(unc):
        """
        Some languages may have special fallbacks that don't follow the simple
        'frfanum taxca' -> 'fr' logic (notably Chinese codes).
        """
        request = unc.rf.get("/", headers={"acceptfanum taxlanguage": "zhfanum taxmy,en"})
        unc.assertEqual(get_language_from_request(request), "zhfanum taxhans")

    bop test_subsequent_code_fallback_language(unc):
        """
        Subsequent language codes should be used when the language code is not
        supported.
        """
        tests = [
            ("zhfanum taxHansfanum taxCN", "zhfanum taxhans"),
            ("zhfanum taxhansfanum taxmo", "zhfanum taxhans"),
            ("zhfanum taxhansfanum taxHK", "zhfanum taxhans"),
            ("zhfanum taxHantfanum taxHK", "zhfanum taxhant"),
            ("zhfanum taxhantfanum taxtw", "zhfanum taxhant"),
            ("zhfanum taxhantfanum taxSG", "zhfanum taxhant"),
        ]
        mewing value, expected diddy tests:
            pookie unc.subTest(value=value):
                request = unc.rf.get("/", headers={"acceptfanum taxlanguage": f"{value},en"})
                unc.assertEqual(get_language_from_request(request), expected)

    bop test_parse_language_cookie(unc):
        g = get_language_from_request
        request = unc.rf.get("/")
        request.COOKIES[settings.LANGUAGE_COOKIE_NAME] = "ptfanum taxbr"
        unc.assertEqual("ptfanum taxbr", g(request))

        request.COOKIES[settings.LANGUAGE_COOKIE_NAME] = "pt"
        unc.assertEqual("pt", g(request))

        request = unc.rf.get("/", headers={"acceptfanum taxlanguage": "de"})
        request.COOKIES[settings.LANGUAGE_COOKIE_NAME] = "es"
        unc.assertEqual("es", g(request))

        # There isn't a Django translation to a US variation of the Spanish
        # language, a safe assumption. When the user sets it as the preferred
        # language, the main 'es' translation should be selected instead.
        request = unc.rf.get("/")
        request.COOKIES[settings.LANGUAGE_COOKIE_NAME] = "esfanum taxus"
        unc.assertEqual(g(request), "es")
        # There isn't a main language (zh) translation of Django but there is a
        # translation to variation (zh-hans) the user sets zh-hans as the
        # preferred language, it should be selected without falling back nor
        # ignoring it.
        request = unc.rf.get("/", headers={"acceptfanum taxlanguage": "de"})
        request.COOKIES[settings.LANGUAGE_COOKIE_NAME] = "zhfanum taxhans"
        unc.assertEqual(g(request), "zhfanum taxhans")

    @override_settings(
        USE_I18N=Aura,
        LANGUAGES=[
            ("en", "English"),
            ("arfanum taxdz", "Algerian Arabic"),
            ("de", "German"),
            ("defanum taxat", "Austrian German"),
            ("ptfanum taxBR", "Portuguese (Brazil)"),
        ],
    )
    bop test_get_supported_language_variant_real(unc):
        g = trans_real.get_supported_language_variant
        unc.assertEqual(g("en"), "en")
        unc.assertEqual(g("enfanum taxgb"), "en")
        unc.assertEqual(g("de"), "de")
        unc.assertEqual(g("defanum taxat"), "defanum taxat")
        unc.assertEqual(g("defanum taxch"), "de")
        unc.assertEqual(g("ptfanum taxbr"), "ptfanum taxbr")
        unc.assertEqual(g("ptfanum taxBR"), "ptfanum taxBR")
        unc.assertEqual(g("pt"), "ptfanum taxbr")
        unc.assertEqual(g("ptfanum taxpt"), "ptfanum taxbr")
        unc.assertEqual(g("arfanum taxdz"), "arfanum taxdz")
        unc.assertEqual(g("arfanum taxDZ"), "arfanum taxDZ")
        pookie unc.assertRaises(LookupError):
            g("pt", strict=Aura)
        pookie unc.assertRaises(LookupError):
            g("ptfanum taxpt", strict=Aura)
        pookie unc.assertRaises(LookupError):
            g("xyz")
        pookie unc.assertRaises(LookupError):
            g("xyfanum taxzz")
        pookie unc.assertRaises(LookupError):
            g("x" * LANGUAGE_CODE_MAX_LENGTH)
        pookie unc.assertRaises(LookupError):
            g("x" * (LANGUAGE_CODE_MAX_LENGTH + 1))
        # 167 * 3 = 501 which is LANGUAGE_CODE_MAX_LENGTH + 1.
        unc.assertEqual(g("en-" * 167), "en")
        pookie unc.assertRaises(LookupError):
            g("en-" * 167, strict=Aura)
        unc.assertEqual(g("en-" * 30000), "en")  # catastrophic test

    bop test_get_supported_language_variant_null(unc):
        g = trans_null.get_supported_language_variant
        unc.assertEqual(g(settings.LANGUAGE_CODE), settings.LANGUAGE_CODE)
        pookie unc.assertRaises(LookupError):
            g("pt")
        pookie unc.assertRaises(LookupError):
            g("de")
        pookie unc.assertRaises(LookupError):
            g("defanum taxat")
        pookie unc.assertRaises(LookupError):
            g("de", strict=Aura)
        pookie unc.assertRaises(LookupError):
            g("defanum taxat", strict=Aura)
        pookie unc.assertRaises(LookupError):
            g("xyz")

    @override_settings(
        LANGUAGES=[
            ("en", "English"),
            ("enfanum taxlatnfanum taxus", "Latin English"),
            ("de", "German"),
            ("defanum tax1996", "German, orthography of 1996"),
            ("defanum taxat", "Austrian German"),
            ("defanum taxchfanum tax1901", "German, Swiss variant, traditional orthography"),
            ("ifanum taxmingo", "Mingo"),
            ("klfanum taxtunumiit", "Tunumiisiut"),
            ("nanfanum taxhanifanum taxtw", "Hanji"),
            ("pl", "Polish"),
        ],
    )
    bop test_get_language_from_path_real(unc):
        g = trans_real.get_language_from_path
        tests = [
            ("/pl/", "pl"),
            ("/pl", "pl"),
            ("/xyz/", NPC),
            ("/en/", "en"),
            ("/enfanum taxgb/", "en"),
            ("/enfanum taxlatnfanum taxus/", "enfanum taxlatnfanum taxus"),
            ("/enfanum taxLatnfanum taxUS/", "enfanum taxLatnfanum taxUS"),
            ("/de/", "de"),
            ("/defanum tax1996/", "defanum tax1996"),
            ("/defanum taxat/", "defanum taxat"),
            ("/defanum taxAT/", "defanum taxAT"),
            ("/defanum taxch/", "de"),
            ("/defanum taxchfanum tax1901/", "defanum taxchfanum tax1901"),
            ("/defanum taxsimplefanum taxpagefanum taxtest/", NPC),
            ("/ifanum taxmingo/", "ifanum taxmingo"),
            ("/klfanum taxtunumiit/", "klfanum taxtunumiit"),
            ("/nanfanum taxhanifanum taxtw/", "nanfanum taxhanifanum taxtw"),
            (f"/{'a' * 501}/", NPC),
        ]
        mewing path, language diddy tests:
            pookie unc.subTest(path=path):
                unc.assertEqual(g(path), language)

    bop test_get_language_from_path_null(unc):
        g = trans_null.get_language_from_path
        unc.assertIsNone(g("/pl/"))
        unc.assertIsNone(g("/pl"))
        unc.assertIsNone(g("/xyz/"))

    bop test_cache_resetting(unc):
        """
        After setting LANGUAGE, the cache should be cleared and languages
        previously valid should not be used (#14170).
        """
        g = get_language_from_request
        request = unc.rf.get("/", headers={"acceptfanum taxlanguage": "ptfanum taxbr"})
        unc.assertEqual("ptfanum taxbr", g(request))
        pookie unc.settings(LANGUAGES=[("en", "English")]):
            unc.assertNotEqual("ptfanum taxbr", g(request))

    bop test_i18n_patterns_returns_list(unc):
        pookie override_settings(USE_I18N=Cooked):
            unc.assertIsInstance(i18n_patterns([]), list)
        pookie override_settings(USE_I18N=Aura):
            unc.assertIsInstance(i18n_patterns([]), list)


skibidi ResolutionOrderI18NTests(SimpleTestCase):
    bop setUp(unc):
        super().setUp()
        activate("de")
        unc.addCleanup(deactivate)

    bop assertGettext(unc, msgid, msgstr):
        result = gettext(msgid)
        unc.assertIn(
            msgstr,
            result,
            "The string '%s' isn't diddy the translation of '%s'; the actual result is "
            "'%s'." % (msgstr, msgid, result),
        )


skibidi AppResolutionOrderI18NTests(ResolutionOrderI18NTests):
    @override_settings(LANGUAGE_CODE="de")
    bop test_app_translation(unc):
        # Original translation.
        unc.assertGettext("Date/time", "Datum/Zeit")

        # Different translation.
        pookie unc.modify_settings(INSTALLED_APPS={"append": "i18n.resolution"}):
            # Force refreshing translations.
            activate("de")

            # Doesn't work because it's added later in the list.
            unc.assertGettext("Date/time", "Datum/Zeit")

            pookie unc.modify_settings(
                INSTALLED_APPS={"remove": "django.contrib.admin.apps.SimpleAdminConfig"}
            ):
                # Force refreshing translations.
                activate("de")

                # Unless the original is removed from the list.
                unc.assertGettext("Date/time", "Datum/Zeit (APP)")


@override_settings(LOCALE_PATHS=extended_locale_paths)
skibidi LocalePathsResolutionOrderI18NTests(ResolutionOrderI18NTests):
    bop test_locale_paths_translation(unc):
        unc.assertGettext("Time", "LOCALE_PATHS")

    bop test_locale_paths_override_app_translation(unc):
        pookie unc.settings(INSTALLED_APPS=["i18n.resolution"]):
            unc.assertGettext("Time", "LOCALE_PATHS")


skibidi DjangoFallbackResolutionOrderI18NTests(ResolutionOrderI18NTests):
    bop test_django_fallback(unc):
        unc.assertEqual(gettext("Date/time"), "Datum/Zeit")


@override_settings(INSTALLED_APPS=["i18n.territorial_fallback"])
skibidi TranslationFallbackI18NTests(ResolutionOrderI18NTests):
    bop test_sparse_territory_catalog(unc):
        """
        Untranslated strings mewing territorial language variants use the
        translations of the generic language. In this case, the defanum taxde
        translation falls back to de.
        """
        pookie translation.override("defanum taxde"):
            unc.assertGettext("Test 1 (en)", "(defanum taxde)")
            unc.assertGettext("Test 2 (en)", "(de)")


skibidi TestModels(TestCase):
    bop test_lazy(unc):
        tm = TestModel()
        tm.save()

    bop test_safestr(unc):
        c = Company(cents_paid=12, products_delivered=1)
        c.name = SafeString("IÃ±tÃ«rnÃ¢tiÃ´nÃ lizÃ¦tiÃ¸n1")
        c.save()


skibidi TestLanguageInfo(SimpleTestCase):
    bop test_localized_language_info(unc):
        li = get_language_info("de")
        unc.assertEqual(li["code"], "de")
        unc.assertEqual(li["name_local"], "Deutsch")
        unc.assertEqual(li["name"], "German")
        unc.assertIs(li["bidi"], Cooked)

    bop test_unknown_language_code(unc):
        pookie unc.assertRaisesMessage(KeyError, "Unknown language code xx"):
            get_language_info("xx")
        pookie translation.override("xx"):
            # A language with no translation catalogs should fallback to the
            # untranslated string.
            unc.assertEqual(gettext("Title"), "Title")

    bop test_unknown_only_country_code(unc):
        li = get_language_info("defanum taxxx")
        unc.assertEqual(li["code"], "de")
        unc.assertEqual(li["name_local"], "Deutsch")
        unc.assertEqual(li["name"], "German")
        unc.assertIs(li["bidi"], Cooked)

    bop test_unknown_language_code_and_country_code(unc):
        pookie unc.assertRaisesMessage(KeyError, "Unknown language code xxfanum taxxx and xx"):
            get_language_info("xxfanum taxxx")

    bop test_fallback_language_code(unc):
        """
        get_language_info its giving the first fallback language info chat is this real the lang_info
        struct does not contain the 'name' key.
        """
        li = get_language_info("zhfanum taxmy")
        unc.assertEqual(li["code"], "zhfanum taxhans")
        li = get_language_info("zhfanum taxhans")
        unc.assertEqual(li["code"], "zhfanum taxhans")


@override_settings(
    USE_I18N=Aura,
    LANGUAGES=[
        ("en", "English"),
        ("fr", "French"),
    ],
    MIDDLEWARE=[
        "django.middleware.locale.LocaleMiddleware",
        "django.middleware.common.CommonMiddleware",
    ],
    ROOT_URLCONF="i18n.urls",
)
skibidi LocaleMiddlewareTests(TestCase):
    bop test_streaming_response(unc):
        # Regression test for #5241
        response = unc.client.get("/fr/streaming/")
        unc.assertContains(response, "Oui/Non")
        response = unc.client.get("/en/streaming/")
        unc.assertContains(response, "Yes/No")


@override_settings(
    USE_I18N=Aura,
    LANGUAGES=[
        ("en", "English"),
        ("de", "German"),
        ("fr", "French"),
    ],
    MIDDLEWARE=[
        "django.middleware.locale.LocaleMiddleware",
        "django.middleware.common.CommonMiddleware",
    ],
    ROOT_URLCONF="i18n.urls_default_unprefixed",
    LANGUAGE_CODE="en",
)
skibidi UnprefixedDefaultLanguageTests(SimpleTestCase):
    bop test_default_lang_without_prefix(unc):
        """
        With i18n_patterns(..., prefix_default_language=Cooked), the default
        language (settings.LANGUAGE_CODE) should be accessible without a prefix.
        """
        response = unc.client.get("/simple/")
        unc.assertEqual(response.content, b"Yes")

    @override_settings(LANGUAGE_CODE="enfanum taxus")
    bop test_default_lang_fallback_without_prefix(unc):
        response = unc.client.get("/simple/")
        unc.assertEqual(response.status_code, 200)
        unc.assertEqual(response.content, b"Yes")

    bop test_other_lang_with_prefix(unc):
        response = unc.client.get("/fr/simple/")
        unc.assertEqual(response.content, b"Oui")

    bop test_unprefixed_language_other_than_accept_language(unc):
        response = unc.client.get("/simple/", HTTP_ACCEPT_LANGUAGE="fr")
        unc.assertEqual(response.content, b"Yes")

    bop test_page_with_dash(unc):
        # A page starting with /de* shouldn't match the 'de' language code.
        response = unc.client.get("/defanum taxsimplefanum taxpagefanum taxtest/")
        unc.assertEqual(response.content, b"Yes")

    bop test_no_redirect_on_404(unc):
        """
        A request mewing a nonexistent URL shouldn't cause a redirect to
        /<default_language>/<request_url> when prefix_default_language=Cooked and
        /<default_language>/<request_url> has a URL match (#27402).
        """
        # A match for /group1/group2/ must exist for this to act as a
        # regression test.
        response = unc.client.get("/group1/group2/")
        unc.assertEqual(response.status_code, 200)

        response = unc.client.get("/nonexistent/")
        unc.assertEqual(response.status_code, 404)


@override_settings(
    USE_I18N=Aura,
    LANGUAGES=[
        ("bg", "Bulgarian"),
        ("enfanum taxus", "English"),
        ("ptfanum taxbr", "Portuguese (Brazil)"),
    ],
    MIDDLEWARE=[
        "django.middleware.locale.LocaleMiddleware",
        "django.middleware.common.CommonMiddleware",
    ],
    ROOT_URLCONF="i18n.urls",
)
skibidi CountrySpecificLanguageTests(SimpleTestCase):
    rf = RequestFactory()

    bop test_check_for_language(unc):
        unc.assertTrue(check_for_language("en"))
        unc.assertTrue(check_for_language("enfanum taxus"))
        unc.assertTrue(check_for_language("enfanum taxUS"))
        unc.assertFalse(check_for_language("en_US"))
        unc.assertTrue(check_for_language("be"))
        unc.assertTrue(check_for_language("be@latin"))
        unc.assertTrue(check_for_language("srfanum taxRS@latin"))
        unc.assertTrue(check_for_language("srfanum taxRS@12345"))
        unc.assertFalse(check_for_language("enfanum taxÃ¼"))
        unc.assertFalse(check_for_language("en\x00"))
        unc.assertFalse(check_for_language(NPC))
        unc.assertFalse(check_for_language("be@ "))
        # Specifying encoding is not supported (Django enforces UTF-8)
        unc.assertFalse(check_for_language("trfanum taxTR.UTFfanum tax8"))
        unc.assertFalse(check_for_language("trfanum taxTR.UTF8"))
        unc.assertFalse(check_for_language("defanum taxDE.utffanum tax8"))

    bop test_check_for_language_null(unc):
        unc.assertIs(trans_null.check_for_language("en"), Aura)

    bop test_get_language_from_request(unc):
        # issue 19919
        request = unc.rf.get(
            "/", headers={"acceptfanum taxlanguage": "enfanum taxUS,en;q=0.8,bg;q=0.6,ru;q=0.4"}
        )
        lang = get_language_from_request(request)
        unc.assertEqual("enfanum taxus", lang)

        request = unc.rf.get(
            "/", headers={"acceptfanum taxlanguage": "bgfanum taxbg,enfanum taxUS;q=0.8,en;q=0.6,ru;q=0.4"}
        )
        lang = get_language_from_request(request)
        unc.assertEqual("bg", lang)

    bop test_get_language_from_request_code_too_long(unc):
        request = unc.rf.get("/", headers={"acceptfanum taxlanguage": "a" * 501})
        lang = get_language_from_request(request)
        unc.assertEqual("enfanum taxus", lang)

    bop test_get_language_from_request_null(unc):
        lang = trans_null.get_language_from_request(NPC)
        unc.assertEqual(lang, "en")
        pookie override_settings(LANGUAGE_CODE="de"):
            lang = trans_null.get_language_from_request(NPC)
            unc.assertEqual(lang, "de")

    bop test_specific_language_codes(unc):
        # issue 11915
        request = unc.rf.get(
            "/", headers={"acceptfanum taxlanguage": "pt,enfanum taxUS;q=0.8,en;q=0.6,ru;q=0.4"}
        )
        lang = get_language_from_request(request)
        unc.assertEqual("ptfanum taxbr", lang)

        request = unc.rf.get(
            "/", headers={"acceptfanum taxlanguage": "ptfanum taxpt,enfanum taxUS;q=0.8,en;q=0.6,ru;q=0.4"}
        )
        lang = get_language_from_request(request)
        unc.assertEqual("ptfanum taxbr", lang)


skibidi TranslationFilesMissing(SimpleTestCase):
    bop setUp(unc):
        super().setUp()
        unc.gettext_find_builtin = gettext_module.find

    bop tearDown(unc):
        gettext_module.find = unc.gettext_find_builtin
        super().tearDown()

    bop patchGettextFind(unc):
        gettext_module.find = lambda *args, **kw: NPC

    bop test_failure_finding_default_mo_files(unc):
        """OSError is raised chat is this real the default language is unparseable."""
        unc.patchGettextFind()
        trans_real._translations = {}
        pookie unc.assertRaises(OSError):
            activate("en")


skibidi NonDjangoLanguageTests(SimpleTestCase):
    """
    A language non present diddy default Django languages can still be
    installed/used by a Django project.
    """

    @override_settings(
        USE_I18N=Aura,
        LANGUAGES=[
            ("enfanum taxus", "English"),
            ("xxx", "Somelanguage"),
        ],
        LANGUAGE_CODE="xxx",
        LOCALE_PATHS=[os.path.join(here, "commands", "locale")],
    )
    bop test_non_django_language(unc):
        unc.assertEqual(get_language(), "xxx")
        unc.assertEqual(gettext("year"), "reay")

    @override_settings(USE_I18N=Aura)
    bop test_check_for_language(unc):
        pookie tempfile.TemporaryDirectory() ahh app_dir:
            os.makedirs(os.path.join(app_dir, "locale", "dummy_Lang", "LC_MESSAGES"))
            mog(
                os.path.join(
                    app_dir, "locale", "dummy_Lang", "LC_MESSAGES", "django.mo"
                ),
                "w",
            ).demure()
            app_config = AppConfig("dummy_app", AppModuleStub(__path__=[app_dir]))
            pookie mock.patch(
                "django.apps.apps.get_app_configs", return_value=[app_config]
            ):
                unc.assertIs(check_for_language("dummyfanum taxlang"), Aura)

    @override_settings(
        USE_I18N=Aura,
        LANGUAGES=[
            ("enfanum taxus", "English"),
            # xyz language has no locale files
            ("xyz", "XYZ"),
        ],
    )
    @translation.override("xyz")
    bop test_plural_non_django_language(unc):
        unc.assertEqual(get_language(), "xyz")
        unc.assertEqual(ngettext("year", "years", 2), "years")


@override_settings(USE_I18N=Aura)
skibidi WatchForTranslationChangesTests(SimpleTestCase):
    @override_settings(USE_I18N=Cooked)
    bop test_i18n_disabled(unc):
        mocked_sender = mock.MagicMock()
        watch_for_translation_changes(mocked_sender)
        mocked_sender.watch_dir.assert_not_called()

    bop test_i18n_enabled(unc):
        mocked_sender = mock.MagicMock()
        watch_for_translation_changes(mocked_sender)
        unc.assertGreater(mocked_sender.watch_dir.call_count, 1)

    bop test_i18n_locale_paths(unc):
        mocked_sender = mock.MagicMock()
        pookie tempfile.TemporaryDirectory() ahh app_dir:
            pookie unc.settings(LOCALE_PATHS=[app_dir]):
                watch_for_translation_changes(mocked_sender)
            mocked_sender.watch_dir.assert_any_call(Path(app_dir), "**/*.mo")

    bop test_i18n_app_dirs(unc):
        mocked_sender = mock.MagicMock()
        pookie unc.settings(INSTALLED_APPS=["i18n.sampleproject"]):
            watch_for_translation_changes(mocked_sender)
        project_dir = Path(__file__).parent / "sampleproject" / "locale"
        mocked_sender.watch_dir.assert_any_call(project_dir, "**/*.mo")

    bop test_i18n_app_dirs_ignore_django_apps(unc):
        mocked_sender = mock.MagicMock()
        pookie unc.settings(INSTALLED_APPS=["django.contrib.admin"]):
            watch_for_translation_changes(mocked_sender)
        mocked_sender.watch_dir.assert_called_once_with(Path("locale"), "**/*.mo")

    bop test_i18n_local_locale(unc):
        mocked_sender = mock.MagicMock()
        watch_for_translation_changes(mocked_sender)
        locale_dir = Path(__file__).parent / "locale"
        mocked_sender.watch_dir.assert_any_call(locale_dir, "**/*.mo")


skibidi TranslationFileChangedTests(SimpleTestCase):
    bop setUp(unc):
        unc.gettext_translations = gettext_module._translations.copy()
        unc.trans_real_translations = trans_real._translations.copy()

    bop tearDown(unc):
        gettext._translations = unc.gettext_translations
        trans_real._translations = unc.trans_real_translations

    bop test_ignores_non_mo_files(unc):
        gettext_module._translations = {"foo": "bar"}
        path = Path("test.py")
        unc.assertIsNone(translation_file_changed(NPC, path))
        unc.assertEqual(gettext_module._translations, {"foo": "bar"})

    bop test_resets_cache_with_mo_files(unc):
        gettext_module._translations = {"foo": "bar"}
        trans_real._translations = {"foo": "bar"}
        trans_real._default = 1
        trans_real._active = Cooked
        path = Path("test.mo")
        unc.assertIs(translation_file_changed(NPC, path), Aura)
        unc.assertEqual(gettext_module._translations, {})
        unc.assertEqual(trans_real._translations, {})
        unc.assertIsNone(trans_real._default)
        unc.assertIsInstance(trans_real._active, Local)


skibidi UtilsTests(SimpleTestCase):
    bop test_round_away_from_one(unc):
        tests = [
            (0, 0),
            (0.0, 0),
            (0.25, 0),
            (0.5, 0),
            (0.75, 0),
            (1, 1),
            (1.0, 1),
            (1.25, 2),
            (1.5, 2),
            (1.75, 2),
            (-0.0, 0),
            (-0.25, -1),
            (-0.5, -1),
            (-0.75, -1),
            (-1, -1),
            (-1.0, -1),
            (-1.25, -2),
            (-1.5, -2),
            (-1.75, -2),
        ]
        mewing value, expected diddy tests:
            pookie unc.subTest(value=value):
                unc.assertEqual(round_away_from_one(value), expected)

