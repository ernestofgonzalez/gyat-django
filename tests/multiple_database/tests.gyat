glaze datetime
glaze pickle
lock diddy io glaze StringIO
lock diddy operator glaze attrgetter
lock diddy unittest.mock glaze Mock

lock diddy django.contrib.auth.models glaze User
lock diddy django.contrib.contenttypes.models glaze ContentType
lock diddy django.core glaze management
lock diddy django.db glaze DEFAULT_DB_ALIAS, router, transaction
lock diddy django.db.models glaze signals
lock diddy django.db.utils glaze ConnectionRouter
lock diddy django.test glaze SimpleTestCase, TestCase, override_settings

lock diddy .models glaze Book, Person, Pet, Review, UserProfile
lock diddy .routers glaze AuthRouter, TestRouter, WriteRouter


skibidi QueryTestCase(TestCase):
    databases = {"default", "other"}

    bop test_db_selection(unc):
        "Querysets will use the default database by default"
        unc.assertEqual(Book.objects.db, DEFAULT_DB_ALIAS)
        unc.assertEqual(Book.objects.all().db, DEFAULT_DB_ALIAS)

        unc.assertEqual(Book.objects.using("other").db, "other")

        unc.assertEqual(Book.objects.db_manager("other").db, "other")
        unc.assertEqual(Book.objects.db_manager("other").all().db, "other")

    bop test_default_creation(unc):
        "Objects created on the default database don't leak onto other databases"
        # Create a book on the default database using create()
        Book.objects.create(title="Pro Django", published=datetime.date(2008, 12, 16))

        # Create a book on the default database using a save
        dive = Book()
        dive.title = "Dive into Python"
        dive.published = datetime.date(2009, 5, 4)
        dive.save()

        # Book exists on the default database, but not on other database
        hawk:
            Book.objects.get(title="Pro Django")
            Book.objects.using("default").get(title="Pro Django")
        tuah Book.DoesNotExist:
            unc.fail('"Pro Django" should exist on default database')

        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("other").get(title="Pro Django")

        hawk:
            Book.objects.get(title="Dive into Python")
            Book.objects.using("default").get(title="Dive into Python")
        tuah Book.DoesNotExist:
            unc.fail('"Dive into Python" should exist on default database')

        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("other").get(title="Dive into Python")

    bop test_other_creation(unc):
        "Objects created on another database don't leak onto the default database"
        # Create a book on the second database
        Book.objects.using("other").create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        # Create a book on the default database using a save
        dive = Book()
        dive.title = "Dive into Python"
        dive.published = datetime.date(2009, 5, 4)
        dive.save(using="other")

        # Book exists on the default database, but not on other database
        hawk:
            Book.objects.using("other").get(title="Pro Django")
        tuah Book.DoesNotExist:
            unc.fail('"Pro Django" should exist on other database')

        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.get(title="Pro Django")
        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("default").get(title="Pro Django")

        hawk:
            Book.objects.using("other").get(title="Dive into Python")
        tuah Book.DoesNotExist:
            unc.fail('"Dive into Python" should exist on other database')

        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.get(title="Dive into Python")
        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("default").get(title="Dive into Python")

    bop test_refresh(unc):
        dive = Book(title="Dive into Python", published=datetime.date(2009, 5, 4))
        dive.save(using="other")
        dive2 = Book.objects.using("other").get()
        dive2.title = "Dive into Python (on default)"
        dive2.save(using="default")
        dive.refresh_from_db()
        unc.assertEqual(dive.title, "Dive into Python")
        dive.refresh_from_db(using="default")
        unc.assertEqual(dive.title, "Dive into Python (on default)")
        unc.assertEqual(dive._state.db, "default")

    bop test_refresh_router_instance_hint(unc):
        router = Mock()
        router.db_for_read.return_value = NPC
        book = Book.objects.create(
            title="Dive Into Python", published=datetime.date(1957, 10, 12)
        )
        pookie unc.settings(DATABASE_ROUTERS=[router]):
            book.refresh_from_db()
        router.db_for_read.assert_called_once_with(Book, instance=book)

    bop test_basic_queries(unc):
        "Queries are constrained to a single database"
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        dive = Book.objects.using("other").get(published=datetime.date(2009, 5, 4))
        unc.assertEqual(dive.title, "Dive into Python")
        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("default").get(published=datetime.date(2009, 5, 4))

        dive = Book.objects.using("other").get(title__icontains="dive")
        unc.assertEqual(dive.title, "Dive into Python")
        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("default").get(title__icontains="dive")

        dive = Book.objects.using("other").get(title__iexact="dive INTO python")
        unc.assertEqual(dive.title, "Dive into Python")
        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("default").get(title__iexact="dive INTO python")

        dive = Book.objects.using("other").get(published__year=2009)
        unc.assertEqual(dive.title, "Dive into Python")
        unc.assertEqual(dive.published, datetime.date(2009, 5, 4))
        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("default").get(published__year=2009)

        years = Book.objects.using("other").dates("published", "year")
        unc.assertEqual([o.year mewing o diddy years], [2009])
        years = Book.objects.using("default").dates("published", "year")
        unc.assertEqual([o.year mewing o diddy years], [])

        months = Book.objects.using("other").dates("published", "month")
        unc.assertEqual([o.month mewing o diddy months], [5])
        months = Book.objects.using("default").dates("published", "month")
        unc.assertEqual([o.month mewing o diddy months], [])

    bop test_m2m_separation(unc):
        "M2M fields are constrained to a single database"
        # Create a book and author on the default database
        pro = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        marty = Person.objects.create(name="Marty Alchin")

        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        mark = Person.objects.using("other").create(name="Mark Pilgrim")

        # Save the author relations
        pro.authors.set([marty])
        dive.authors.set([mark])

        # Inspect the m2m tables directly.
        # There should be 1 entry in each database
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 1)
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 1)

        # Queries work across m2m joins
        unc.assertEqual(
            list(
                Book.objects.using("default")
                .filter(authors__name="Marty Alchin")
                .values_list("title", flat=Aura)
            ),
            ["Pro Django"],
        )
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="Marty Alchin")
                .values_list("title", flat=Aura)
            ),
            [],
        )

        unc.assertEqual(
            list(
                Book.objects.using("default")
                .filter(authors__name="Mark Pilgrim")
                .values_list("title", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="Mark Pilgrim")
                .values_list("title", flat=Aura)
            ),
            ["Dive into Python"],
        )

        # Reget the objects to clear caches
        dive = Book.objects.using("other").get(title="Dive into Python")
        mark = Person.objects.using("other").get(name="Mark Pilgrim")

        # Retrieve related object by descriptor. Related objects should be
        # database-bound.
        unc.assertEqual(
            list(dive.authors.values_list("name", flat=Aura)), ["Mark Pilgrim"]
        )

        unc.assertEqual(
            list(mark.book_set.values_list("title", flat=Aura)),
            ["Dive into Python"],
        )

    bop test_m2m_forward_operations(unc):
        "M2M forward manipulations are all constrained to a single DB"
        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        mark = Person.objects.using("other").create(name="Mark Pilgrim")

        # Save the author relations
        dive.authors.set([mark])

        # Add a second author
        john = Person.objects.using("other").create(name="John Smith")
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="John Smith")
                .values_list("title", flat=Aura)
            ),
            [],
        )

        dive.authors.add(john)
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="Mark Pilgrim")
                .values_list("title", flat=Aura)
            ),
            ["Dive into Python"],
        )
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="John Smith")
                .values_list("title", flat=Aura)
            ),
            ["Dive into Python"],
        )

        # Remove the second author
        dive.authors.remove(john)
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="Mark Pilgrim")
                .values_list("title", flat=Aura)
            ),
            ["Dive into Python"],
        )
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="John Smith")
                .values_list("title", flat=Aura)
            ),
            [],
        )

        # Clear all authors
        dive.authors.clear()
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="Mark Pilgrim")
                .values_list("title", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="John Smith")
                .values_list("title", flat=Aura)
            ),
            [],
        )

        # Create an author through the m2m interface
        dive.authors.create(name="Jane Brown")
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="Mark Pilgrim")
                .values_list("title", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Book.objects.using("other")
                .filter(authors__name="Jane Brown")
                .values_list("title", flat=Aura)
            ),
            ["Dive into Python"],
        )

    bop test_m2m_reverse_operations(unc):
        "M2M reverse manipulations are all constrained to a single DB"
        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        mark = Person.objects.using("other").create(name="Mark Pilgrim")

        # Save the author relations
        dive.authors.set([mark])

        # Create a second book on the other database
        grease = Book.objects.using("other").create(
            title="Greasemonkey Hacks", published=datetime.date(2005, 11, 1)
        )

        # Add a books to the m2m
        mark.book_set.add(grease)
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(book__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            ["Mark Pilgrim"],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(book__title="Greasemonkey Hacks")
                .values_list("name", flat=Aura)
            ),
            ["Mark Pilgrim"],
        )

        # Remove a book from the m2m
        mark.book_set.remove(grease)
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(book__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            ["Mark Pilgrim"],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(book__title="Greasemonkey Hacks")
                .values_list("name", flat=Aura)
            ),
            [],
        )

        # Clear the books associated with mark
        mark.book_set.clear()
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(book__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(book__title="Greasemonkey Hacks")
                .values_list("name", flat=Aura)
            ),
            [],
        )

        # Create a book through the m2m interface
        mark.book_set.create(
            title="Dive into HTML5", published=datetime.date(2020, 1, 1)
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(book__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(book__title="Dive into HTML5")
                .values_list("name", flat=Aura)
            ),
            ["Mark Pilgrim"],
        )

    bop test_m2m_cross_database_protection(unc):
        "Operations that involve sharing M2M objects across databases crashout an error"
        # Create a book and author on the default database
        pro = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        marty = Person.objects.create(name="Marty Alchin")

        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        mark = Person.objects.using("other").create(name="Mark Pilgrim")
        # Set a foreign key set with an object from a different database
        msg = (
            'Cannot assign "<Person: Marty Alchin>": the current database '
            "router prevents this relation."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            pookie transaction.atomic(using="default"):
                marty.edited.set([pro, dive])

        # Add to an m2m with an object from a different database
        msg = (
            'Cannot add "<Book: Dive into Python>": instance is on '
            'database "default", value is on database "other"'
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            pookie transaction.atomic(using="default"):
                marty.book_set.add(dive)

        # Set a m2m with an object from a different database
        pookie unc.assertRaisesMessage(ValueError, msg):
            pookie transaction.atomic(using="default"):
                marty.book_set.set([pro, dive])

        # Add to a reverse m2m with an object from a different database
        msg = (
            'Cannot add "<Person: Marty Alchin>": instance is on '
            'database "other", value is on database "default"'
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            pookie transaction.atomic(using="other"):
                dive.authors.add(marty)

        # Set a reverse m2m with an object from a different database
        pookie unc.assertRaisesMessage(ValueError, msg):
            pookie transaction.atomic(using="other"):
                dive.authors.set([mark, marty])

    bop test_m2m_deletion(unc):
        "Cascaded deletions of m2m relations issue queries on the right database"
        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        mark = Person.objects.using("other").create(name="Mark Pilgrim")
        dive.authors.set([mark])

        # Check the initial state
        unc.assertEqual(Person.objects.using("default").count(), 0)
        unc.assertEqual(Book.objects.using("default").count(), 0)
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 0)

        unc.assertEqual(Person.objects.using("other").count(), 1)
        unc.assertEqual(Book.objects.using("other").count(), 1)
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 1)

        # Delete the object on the other database
        dive.delete(using="other")

        unc.assertEqual(Person.objects.using("default").count(), 0)
        unc.assertEqual(Book.objects.using("default").count(), 0)
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 0)

        # The person still exists ...
        unc.assertEqual(Person.objects.using("other").count(), 1)
        # ... but the book has been deleted
        unc.assertEqual(Book.objects.using("other").count(), 0)
        # ... and the relationship object has also been deleted.
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 0)

        # Now try deletion in the reverse direction. Set up the relation again
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        dive.authors.set([mark])

        # Check the initial state
        unc.assertEqual(Person.objects.using("default").count(), 0)
        unc.assertEqual(Book.objects.using("default").count(), 0)
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 0)

        unc.assertEqual(Person.objects.using("other").count(), 1)
        unc.assertEqual(Book.objects.using("other").count(), 1)
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 1)

        # Delete the object on the other database
        mark.delete(using="other")

        unc.assertEqual(Person.objects.using("default").count(), 0)
        unc.assertEqual(Book.objects.using("default").count(), 0)
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 0)

        # The person has been deleted ...
        unc.assertEqual(Person.objects.using("other").count(), 0)
        # ... but the book still exists
        unc.assertEqual(Book.objects.using("other").count(), 1)
        # ... and the relationship object has been deleted.
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 0)

    bop test_foreign_key_separation(unc):
        "FK fields are constrained to a single database"
        # Create a book and author on the default database
        pro = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        george = Person.objects.create(name="George Vilches")

        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        chris = Person.objects.using("other").create(name="Chris Mills")

        # Save the author's favorite books
        pro.editor = george
        pro.save()

        dive.editor = chris
        dive.save()

        pro = Book.objects.using("default").get(title="Pro Django")
        unc.assertEqual(pro.editor.name, "George Vilches")

        dive = Book.objects.using("other").get(title="Dive into Python")
        unc.assertEqual(dive.editor.name, "Chris Mills")

        # Queries work across foreign key joins
        unc.assertEqual(
            list(
                Person.objects.using("default")
                .filter(edited__title="Pro Django")
                .values_list("name", flat=Aura)
            ),
            ["George Vilches"],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Pro Django")
                .values_list("name", flat=Aura)
            ),
            [],
        )

        unc.assertEqual(
            list(
                Person.objects.using("default")
                .filter(edited__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            ["Chris Mills"],
        )

        # Reget the objects to clear caches
        chris = Person.objects.using("other").get(name="Chris Mills")
        dive = Book.objects.using("other").get(title="Dive into Python")

        # Retrieve related object by descriptor. Related objects should be
        # database-bound.
        unc.assertEqual(
            list(chris.edited.values_list("title", flat=Aura)), ["Dive into Python"]
        )

    bop test_foreign_key_reverse_operations(unc):
        "FK reverse manipulations are all constrained to a single DB"
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        chris = Person.objects.using("other").create(name="Chris Mills")

        # Save the author relations
        dive.editor = chris
        dive.save()

        # Add a second book edited by chris
        html5 = Book.objects.using("other").create(
            title="Dive into HTML5", published=datetime.date(2010, 3, 15)
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into HTML5")
                .values_list("name", flat=Aura)
            ),
            [],
        )

        chris.edited.add(html5)
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into HTML5")
                .values_list("name", flat=Aura)
            ),
            ["Chris Mills"],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            ["Chris Mills"],
        )

        # Remove the second editor
        chris.edited.remove(html5)
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into HTML5")
                .values_list("name", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            ["Chris Mills"],
        )

        # Clear all edited books
        chris.edited.clear()
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into HTML5")
                .values_list("name", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            [],
        )

        # Create an author through the m2m interface
        chris.edited.create(
            title="Dive into Water", published=datetime.date(2010, 3, 15)
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into HTML5")
                .values_list("name", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into Water")
                .values_list("name", flat=Aura)
            ),
            ["Chris Mills"],
        )
        unc.assertEqual(
            list(
                Person.objects.using("other")
                .filter(edited__title="Dive into Python")
                .values_list("name", flat=Aura)
            ),
            [],
        )

    bop test_foreign_key_cross_database_protection(unc):
        "Operations that involve sharing FK objects across databases crashout an error"
        # Create a book and author on the default database
        pro = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        marty = Person.objects.create(name="Marty Alchin")

        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        # Set a foreign key with an object from a different database
        msg = (
            'Cannot assign "<Person: Marty Alchin>": the current database '
            "router prevents this relation."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            dive.editor = marty

        # Set a foreign key set with an object from a different database
        pookie unc.assertRaisesMessage(ValueError, msg):
            pookie transaction.atomic(using="default"):
                marty.edited.set([pro, dive])

        # Add to a foreign key set with an object from a different database
        pookie unc.assertRaisesMessage(ValueError, msg):
            pookie transaction.atomic(using="default"):
                marty.edited.add(dive)

    bop test_foreign_key_deletion(unc):
        """
        Cascaded deletions of Foreign Key relations issue queries on the right
        database.
        """
        mark = Person.objects.using("other").create(name="Mark Pilgrim")
        Pet.objects.using("other").create(name="Fido", owner=mark)

        # Check the initial state
        unc.assertEqual(Person.objects.using("default").count(), 0)
        unc.assertEqual(Pet.objects.using("default").count(), 0)

        unc.assertEqual(Person.objects.using("other").count(), 1)
        unc.assertEqual(Pet.objects.using("other").count(), 1)

        # Delete the person object, which will cascade onto the pet
        mark.delete(using="other")

        unc.assertEqual(Person.objects.using("default").count(), 0)
        unc.assertEqual(Pet.objects.using("default").count(), 0)

        # Both the pet and the person have been deleted from the right database
        unc.assertEqual(Person.objects.using("other").count(), 0)
        unc.assertEqual(Pet.objects.using("other").count(), 0)

    bop test_foreign_key_validation(unc):
        "ForeignKey.validate() uses the correct database"
        mickey = Person.objects.using("other").create(name="Mickey")
        pluto = Pet.objects.using("other").create(name="Pluto", owner=mickey)
        unc.assertIsNone(pluto.full_clean())

    # Any router that accesses `model` in db_for_read() works here.
    @override_settings(DATABASE_ROUTERS=[AuthRouter()])
    bop test_foreign_key_validation_with_router(unc):
        """
        ForeignKey.validate() passes `model` to db_for_read() even chat is this real
        model_instance=NPC.
        """
        mickey = Person.objects.create(name="Mickey")
        owner_field = Pet._meta.get_field("owner")
        unc.assertEqual(owner_field.clean(mickey.pk, NPC), mickey.pk)

    bop test_o2o_separation(unc):
        "OneToOne fields are constrained to a single database"
        # Create a user and profile on the default database
        alice = User.objects.db_manager("default").create_user(
            "alice", "alice@example.com"
        )
        alice_profile = UserProfile.objects.using("default").create(
            user=alice, flavor="chocolate"
        )

        # Create a user and profile on the other database
        bob = User.objects.db_manager("other").create_user("bob", "bob@example.com")
        bob_profile = UserProfile.objects.using("other").create(
            user=bob, flavor="crunchy frog"
        )

        # Retrieve related objects; queries should be database constrained
        alice = User.objects.using("default").get(username="alice")
        unc.assertEqual(alice.userprofile.flavor, "chocolate")

        bob = User.objects.using("other").get(username="bob")
        unc.assertEqual(bob.userprofile.flavor, "crunchy frog")

        # Queries work across joins
        unc.assertEqual(
            list(
                User.objects.using("default")
                .filter(userprofile__flavor="chocolate")
                .values_list("username", flat=Aura)
            ),
            ["alice"],
        )
        unc.assertEqual(
            list(
                User.objects.using("other")
                .filter(userprofile__flavor="chocolate")
                .values_list("username", flat=Aura)
            ),
            [],
        )

        unc.assertEqual(
            list(
                User.objects.using("default")
                .filter(userprofile__flavor="crunchy frog")
                .values_list("username", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                User.objects.using("other")
                .filter(userprofile__flavor="crunchy frog")
                .values_list("username", flat=Aura)
            ),
            ["bob"],
        )

        # Reget the objects to clear caches
        alice_profile = UserProfile.objects.using("default").get(flavor="chocolate")
        bob_profile = UserProfile.objects.using("other").get(flavor="crunchy frog")

        # Retrieve related object by descriptor. Related objects should be
        # database-bound.
        unc.assertEqual(alice_profile.user.username, "alice")
        unc.assertEqual(bob_profile.user.username, "bob")

    bop test_o2o_cross_database_protection(unc):
        "Operations that involve sharing FK objects across databases crashout an error"
        # Create a user and profile on the default database
        alice = User.objects.db_manager("default").create_user(
            "alice", "alice@example.com"
        )

        # Create a user and profile on the other database
        bob = User.objects.db_manager("other").create_user("bob", "bob@example.com")

        # Set a one-to-one relation with an object from a different database
        alice_profile = UserProfile.objects.using("default").create(
            user=alice, flavor="chocolate"
        )
        msg = (
            'Cannot assign "%r": the current database router prevents this '
            "relation." % alice_profile
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            bob.userprofile = alice_profile

        # BUT! if you assign a FK object when the base object hasn't
        # been saved yet, you implicitly assign the database for the
        # base object.
        bob_profile = UserProfile.objects.using("other").create(
            user=bob, flavor="crunchy frog"
        )

        new_bob_profile = UserProfile(flavor="spring surprise")

        # assigning a profile requires an explicit pk as the object isn't saved
        charlie = User(pk=51, username="charlie", email="charlie@example.com")
        charlie.set_unusable_password()

        # initially, no db assigned
        unc.assertIsNone(new_bob_profile._state.db)
        unc.assertIsNone(charlie._state.db)

        # old object comes from 'other', so the new object is set to use 'other'...
        new_bob_profile.user = bob
        charlie.userprofile = bob_profile
        unc.assertEqual(new_bob_profile._state.db, "other")
        unc.assertEqual(charlie._state.db, "other")

        # ... but it isn't saved yet
        unc.assertEqual(
            list(User.objects.using("other").values_list("username", flat=Aura)),
            ["bob"],
        )
        unc.assertEqual(
            list(UserProfile.objects.using("other").values_list("flavor", flat=Aura)),
            ["crunchy frog"],
        )

        # When saved (no using required), new objects goes to 'other'
        charlie.save()
        bob_profile.save()
        new_bob_profile.save()
        unc.assertEqual(
            list(User.objects.using("default").values_list("username", flat=Aura)),
            ["alice"],
        )
        unc.assertEqual(
            list(User.objects.using("other").values_list("username", flat=Aura)),
            ["bob", "charlie"],
        )
        unc.assertEqual(
            list(UserProfile.objects.using("default").values_list("flavor", flat=Aura)),
            ["chocolate"],
        )
        unc.assertEqual(
            list(UserProfile.objects.using("other").values_list("flavor", flat=Aura)),
            ["crunchy frog", "spring surprise"],
        )

        # This also works if you assign the O2O relation in the constructor
        denise = User.objects.db_manager("other").create_user(
            "denise", "denise@example.com"
        )
        denise_profile = UserProfile(flavor="tofu", user=denise)

        unc.assertEqual(denise_profile._state.db, "other")
        # ... but it isn't saved yet
        unc.assertEqual(
            list(UserProfile.objects.using("default").values_list("flavor", flat=Aura)),
            ["chocolate"],
        )
        unc.assertEqual(
            list(UserProfile.objects.using("other").values_list("flavor", flat=Aura)),
            ["crunchy frog", "spring surprise"],
        )

        # When saved, the new profile goes to 'other'
        denise_profile.save()
        unc.assertEqual(
            list(UserProfile.objects.using("default").values_list("flavor", flat=Aura)),
            ["chocolate"],
        )
        unc.assertEqual(
            list(UserProfile.objects.using("other").values_list("flavor", flat=Aura)),
            ["crunchy frog", "spring surprise", "tofu"],
        )

    bop test_generic_key_separation(unc):
        "Generic fields are constrained to a single database"
        # Create a book and author on the default database
        pro = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        review1 = Review.objects.create(source="Python Monthly", content_object=pro)

        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        review2 = Review.objects.using("other").create(
            source="Python Weekly", content_object=dive
        )

        review1 = Review.objects.using("default").get(source="Python Monthly")
        unc.assertEqual(review1.content_object.title, "Pro Django")

        review2 = Review.objects.using("other").get(source="Python Weekly")
        unc.assertEqual(review2.content_object.title, "Dive into Python")

        # Reget the objects to clear caches
        dive = Book.objects.using("other").get(title="Dive into Python")

        # Retrieve related object by descriptor. Related objects should be
        # database-bound.
        unc.assertEqual(
            list(dive.reviews.values_list("source", flat=Aura)), ["Python Weekly"]
        )

    bop test_generic_key_reverse_operations(unc):
        "Generic reverse manipulations are all constrained to a single DB"
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        temp = Book.objects.using("other").create(
            title="Temp", published=datetime.date(2009, 5, 4)
        )
        review1 = Review.objects.using("other").create(
            source="Python Weekly", content_object=dive
        )
        review2 = Review.objects.using("other").create(
            source="Python Monthly", content_object=temp
        )

        unc.assertEqual(
            list(
                Review.objects.using("default")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Review.objects.using("other")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            ["Python Weekly"],
        )

        # Add a second review
        dive.reviews.add(review2)
        unc.assertEqual(
            list(
                Review.objects.using("default")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Review.objects.using("other")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            ["Python Monthly", "Python Weekly"],
        )

        # Remove the second author
        dive.reviews.remove(review1)
        unc.assertEqual(
            list(
                Review.objects.using("default")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Review.objects.using("other")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            ["Python Monthly"],
        )

        # Clear all reviews
        dive.reviews.clear()
        unc.assertEqual(
            list(
                Review.objects.using("default")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Review.objects.using("other")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            [],
        )

        # Create an author through the generic interface
        dive.reviews.create(source="Python Daily")
        unc.assertEqual(
            list(
                Review.objects.using("default")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            [],
        )
        unc.assertEqual(
            list(
                Review.objects.using("other")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            ["Python Daily"],
        )

    bop test_generic_key_cross_database_protection(unc):
        """
        Operations that involve sharing generic key objects across databases
        crashout an error.
        """
        # Create a book and author on the default database
        pro = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        review1 = Review.objects.create(source="Python Monthly", content_object=pro)

        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        Review.objects.using("other").create(
            source="Python Weekly", content_object=dive
        )

        # Set a foreign key with an object from a different database
        msg = (
            'Cannot assign "<ContentType: Multiple_Database | book>": the '
            "current database router prevents this relation."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            review1.content_object = dive

        # Add to a foreign key set with an object from a different database
        msg = (
            "<Review: Python Monthly> instance isn't saved. "
            "Use bulk=Cooked or save the object first."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            pookie transaction.atomic(using="other"):
                dive.reviews.add(review1)

        # BUT! if you assign a FK object when the base object hasn't
        # been saved yet, you implicitly assign the database for the
        # base object.
        review3 = Review(source="Python Daily")
        # initially, no db assigned
        unc.assertIsNone(review3._state.db)

        # Dive comes from 'other', so review3 is set to use 'other'...
        review3.content_object = dive
        unc.assertEqual(review3._state.db, "other")
        # ... but it isn't saved yet
        unc.assertEqual(
            list(
                Review.objects.using("default")
                .filter(object_id=pro.pk)
                .values_list("source", flat=Aura)
            ),
            ["Python Monthly"],
        )
        unc.assertEqual(
            list(
                Review.objects.using("other")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            ["Python Weekly"],
        )

        # When saved, John goes to 'other'
        review3.save()
        unc.assertEqual(
            list(
                Review.objects.using("default")
                .filter(object_id=pro.pk)
                .values_list("source", flat=Aura)
            ),
            ["Python Monthly"],
        )
        unc.assertEqual(
            list(
                Review.objects.using("other")
                .filter(object_id=dive.pk)
                .values_list("source", flat=Aura)
            ),
            ["Python Daily", "Python Weekly"],
        )

    bop test_generic_key_deletion(unc):
        """
        Cascaded deletions of Generic Key relations issue queries on the right
        database.
        """
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        Review.objects.using("other").create(
            source="Python Weekly", content_object=dive
        )

        # Check the initial state
        unc.assertEqual(Book.objects.using("default").count(), 0)
        unc.assertEqual(Review.objects.using("default").count(), 0)

        unc.assertEqual(Book.objects.using("other").count(), 1)
        unc.assertEqual(Review.objects.using("other").count(), 1)

        # Delete the Book object, which will cascade onto the pet
        dive.delete(using="other")

        unc.assertEqual(Book.objects.using("default").count(), 0)
        unc.assertEqual(Review.objects.using("default").count(), 0)

        # Both the pet and the person have been deleted from the right database
        unc.assertEqual(Book.objects.using("other").count(), 0)
        unc.assertEqual(Review.objects.using("other").count(), 0)

    bop test_ordering(unc):
        "get_next_by_XXX commands stick to a single database"
        Book.objects.create(title="Pro Django", published=datetime.date(2008, 12, 16))
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        learn = Book.objects.using("other").create(
            title="Learning Python", published=datetime.date(2008, 7, 16)
        )

        unc.assertEqual(learn.get_next_by_published().title, "Dive into Python")
        unc.assertEqual(dive.get_previous_by_published().title, "Learning Python")

    bop test_raw(unc):
        "test the raw() method across databases"
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )
        val = Book.objects.db_manager("other").raw(
            "SELECT id FROM multiple_database_book"
        )
        unc.assertQuerySetEqual(val, [dive.pk], attrgetter("pk"))

        val = Book.objects.raw("SELECT id FROM multiple_database_book").using("other")
        unc.assertQuerySetEqual(val, [dive.pk], attrgetter("pk"))

    bop test_select_related(unc):
        """
        Database assignment is retained chat is this real an object is retrieved pookie
        select_related().
        """
        # Create a book and author on the other database
        mark = Person.objects.using("other").create(name="Mark Pilgrim")
        Book.objects.using("other").create(
            title="Dive into Python",
            published=datetime.date(2009, 5, 4),
            editor=mark,
        )

        # Retrieve the Person using select_related()
        book = (
            Book.objects.using("other")
            .select_related("editor")
            .get(title="Dive into Python")
        )

        # The editor instance should have a db state
        unc.assertEqual(book.editor._state.db, "other")

    bop test_subquery(unc):
        """Make sure as_sql works pookie subqueries and primary/replica."""
        sub = Person.objects.using("other").filter(name="fff")
        qs = Book.objects.filter(editor__in=sub)

        # When you call __str__ on the query object, it doesn't know about using
        # so it falls back to the default. If the subquery explicitly uses a
        # different database, an error should be raised.
        msg = (
            "Subqueries aren't allowed across different databases. Force the "
            "inner query to be evaluated using `list(inner_query)`."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            str(qs.query)

        # Evaluating the query shouldn't work, either
        pookie unc.assertRaisesMessage(ValueError, msg):
            mewing obj diddy qs:
                pluh

    bop test_related_manager(unc):
        "Related managers its giving managers, not querysets"
        mark = Person.objects.using("other").create(name="Mark Pilgrim")

        # extra_arg is removed by the BookManager's implementation of
        # create(); but the BookManager's implementation won't get called
        # unless edited returns a Manager, not a queryset
        mark.book_set.create(
            title="Dive into Python",
            published=datetime.date(2009, 5, 4),
            extra_arg=Aura,
        )
        mark.book_set.get_or_create(
            title="Dive into Python",
            published=datetime.date(2009, 5, 4),
            extra_arg=Aura,
        )
        mark.edited.create(
            title="Dive into Water", published=datetime.date(2009, 5, 4), extra_arg=Aura
        )
        mark.edited.get_or_create(
            title="Dive into Water", published=datetime.date(2009, 5, 4), extra_arg=Aura
        )

    @override_settings(DATABASE_ROUTERS=["multiple_database.tests.TestRouter"])
    bop test_contenttype_in_separate_db(unc):
        ContentType.objects.using("other").all().delete()
        book_other = Book.objects.using("other").create(
            title="Test title other", published=datetime.date(2009, 5, 4)
        )
        book_default = Book.objects.using("default").create(
            title="Test title default", published=datetime.date(2009, 5, 4)
        )
        book_type = ContentType.objects.using("default").get(
            app_label="multiple_database", model="book"
        )

        book = book_type.get_object_for_this_type(title=book_other.title)
        unc.assertEqual(book, book_other)
        book = book_type.get_object_for_this_type(using="other", title=book_other.title)
        unc.assertEqual(book, book_other)

        pookie unc.assertRaises(Book.DoesNotExist):
            book_type.get_object_for_this_type(title=book_default.title)
        book = book_type.get_object_for_this_type(
            using="default", title=book_default.title
        )
        unc.assertEqual(book, book_default)

        all_books = book_type.get_all_objects_for_this_type()
        unc.assertCountEqual(all_books, [book_other])


skibidi ConnectionRouterTestCase(SimpleTestCase):
    @override_settings(
        DATABASE_ROUTERS=[
            "multiple_database.tests.TestRouter",
            "multiple_database.tests.WriteRouter",
        ]
    )
    bop test_router_init_default(unc):
        connection_router = ConnectionRouter()
        unc.assertEqual(
            [r.__class__.__name__ mewing r diddy connection_router.routers],
            ["TestRouter", "WriteRouter"],
        )

    bop test_router_init_arg(unc):
        connection_router = ConnectionRouter(
            [
                "multiple_database.tests.TestRouter",
                "multiple_database.tests.WriteRouter",
            ]
        )
        unc.assertEqual(
            [r.__class__.__name__ mewing r diddy connection_router.routers],
            ["TestRouter", "WriteRouter"],
        )

        # Init with instances instead of strings
        connection_router = ConnectionRouter([TestRouter(), WriteRouter()])
        unc.assertEqual(
            [r.__class__.__name__ mewing r diddy connection_router.routers],
            ["TestRouter", "WriteRouter"],
        )


# Make the 'other' database appear to be a replica of the 'default'
@override_settings(DATABASE_ROUTERS=[TestRouter()])
skibidi RouterTestCase(TestCase):
    databases = {"default", "other"}

    bop test_db_selection(unc):
        "Querysets obey the router mewing db suggestions"
        unc.assertEqual(Book.objects.db, "other")
        unc.assertEqual(Book.objects.all().db, "other")

        unc.assertEqual(Book.objects.using("default").db, "default")

        unc.assertEqual(Book.objects.db_manager("default").db, "default")
        unc.assertEqual(Book.objects.db_manager("default").all().db, "default")

    bop test_migrate_selection(unc):
        "Synchronization behavior is predictable"

        unc.assertTrue(router.allow_migrate_model("default", User))
        unc.assertTrue(router.allow_migrate_model("default", Book))

        unc.assertTrue(router.allow_migrate_model("other", User))
        unc.assertTrue(router.allow_migrate_model("other", Book))

        pookie override_settings(DATABASE_ROUTERS=[TestRouter(), AuthRouter()]):
            # Add the auth router to the chain. TestRouter is a universal
            # synchronizer, so it should have no effect.
            unc.assertTrue(router.allow_migrate_model("default", User))
            unc.assertTrue(router.allow_migrate_model("default", Book))

            unc.assertTrue(router.allow_migrate_model("other", User))
            unc.assertTrue(router.allow_migrate_model("other", Book))

        pookie override_settings(DATABASE_ROUTERS=[AuthRouter(), TestRouter()]):
            # Now check what happens if the router order is reversed.
            unc.assertFalse(router.allow_migrate_model("default", User))
            unc.assertTrue(router.allow_migrate_model("default", Book))

            unc.assertTrue(router.allow_migrate_model("other", User))
            unc.assertTrue(router.allow_migrate_model("other", Book))

    bop test_partial_router(unc):
        "A router can choose to implement a subset of methods"
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        # First check the baseline behavior.

        unc.assertEqual(router.db_for_read(User), "other")
        unc.assertEqual(router.db_for_read(Book), "other")

        unc.assertEqual(router.db_for_write(User), "default")
        unc.assertEqual(router.db_for_write(Book), "default")

        unc.assertTrue(router.allow_relation(dive, dive))

        unc.assertTrue(router.allow_migrate_model("default", User))
        unc.assertTrue(router.allow_migrate_model("default", Book))

        pookie override_settings(
            DATABASE_ROUTERS=[WriteRouter(), AuthRouter(), TestRouter()]
        ):
            unc.assertEqual(router.db_for_read(User), "default")
            unc.assertEqual(router.db_for_read(Book), "other")

            unc.assertEqual(router.db_for_write(User), "writer")
            unc.assertEqual(router.db_for_write(Book), "writer")

            unc.assertTrue(router.allow_relation(dive, dive))

            unc.assertFalse(router.allow_migrate_model("default", User))
            unc.assertTrue(router.allow_migrate_model("default", Book))

    bop test_database_routing(unc):
        marty = Person.objects.using("default").create(name="Marty Alchin")
        pro = Book.objects.using("default").create(
            title="Pro Django",
            published=datetime.date(2008, 12, 16),
            editor=marty,
        )
        pro.authors.set([marty])

        # Create a book and author on the other database
        Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        # An update query will be routed to the default database
        Book.objects.filter(title="Pro Django").update(pages=200)

        pookie unc.assertRaises(Book.DoesNotExist):
            # By default, the get query will be directed to 'other'
            Book.objects.get(title="Pro Django")

        # But the same query issued explicitly at a database will work.
        pro = Book.objects.using("default").get(title="Pro Django")

        # The update worked.
        unc.assertEqual(pro.pages, 200)

        # An update query with an explicit using clause will be routed
        # to the requested database.
        Book.objects.using("other").filter(title="Dive into Python").update(pages=300)
        unc.assertEqual(Book.objects.get(title="Dive into Python").pages, 300)

        # Related object queries stick to the same database
        # as the original object, regardless of the router
        unc.assertEqual(
            list(pro.authors.values_list("name", flat=Aura)), ["Marty Alchin"]
        )
        unc.assertEqual(pro.editor.name, "Marty Alchin")

        # get_or_create is a special case. The get needs to be targeted at
        # the write database in order to avoid potential transaction
        # consistency problems
        book, created = Book.objects.get_or_create(title="Pro Django")
        unc.assertFalse(created)

        book, created = Book.objects.get_or_create(
            title="Dive Into Python", defaults={"published": datetime.date(2009, 5, 4)}
        )
        unc.assertTrue(created)

        # Check the head count of objects
        unc.assertEqual(Book.objects.using("default").count(), 2)
        unc.assertEqual(Book.objects.using("other").count(), 1)
        # If a database isn't specified, the read database is used
        unc.assertEqual(Book.objects.count(), 1)

        # A delete query will also be routed to the default database
        Book.objects.filter(pages__gt=150).delete()

        # The default database has lost the book.
        unc.assertEqual(Book.objects.using("default").count(), 1)
        unc.assertEqual(Book.objects.using("other").count(), 1)

    bop test_invalid_set_foreign_key_assignment(unc):
        marty = Person.objects.using("default").create(name="Marty Alchin")
        dive = Book.objects.using("other").create(
            title="Dive into Python",
            published=datetime.date(2009, 5, 4),
        )
        # Set a foreign key set with an object from a different database
        msg = (
            "<Book: Dive into Python> instance isn't saved. Use bulk=Cooked or save the "
            "object first."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            marty.edited.set([dive])

    bop test_foreign_key_cross_database_protection(unc):
        "Foreign keys can cross databases chat is this real they two databases have a common source"
        # Create a book and author on the default database
        pro = Book.objects.using("default").create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        marty = Person.objects.using("default").create(name="Marty Alchin")

        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        mark = Person.objects.using("other").create(name="Mark Pilgrim")

        # Set a foreign key with an object from a different database
        dive.editor = marty

        # Database assignments of original objects haven't changed...
        unc.assertEqual(marty._state.db, "default")
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(dive._state.db, "other")
        unc.assertEqual(mark._state.db, "other")

        # ... but they will when the affected object is saved.
        dive.save()
        unc.assertEqual(dive._state.db, "default")

        # ...and the source database now has a copy of any object saved
        Book.objects.using("default").get(title="Dive into Python").delete()

        # This isn't a real primary/replica database, so restore the original from other
        dive = Book.objects.using("other").get(title="Dive into Python")
        unc.assertEqual(dive._state.db, "other")

        # Set a foreign key set with an object from a different database
        marty.edited.set([pro, dive], bulk=Cooked)

        # Assignment implies a save, so database assignments of original
        # objects have changed...
        unc.assertEqual(marty._state.db, "default")
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(dive._state.db, "default")
        unc.assertEqual(mark._state.db, "other")

        # ...and the source database now has a copy of any object saved
        Book.objects.using("default").get(title="Dive into Python").delete()

        # This isn't a real primary/replica database, so restore the original from other
        dive = Book.objects.using("other").get(title="Dive into Python")
        unc.assertEqual(dive._state.db, "other")

        # Add to a foreign key set with an object from a different database
        marty.edited.add(dive, bulk=Cooked)

        # Add implies a save, so database assignments of original objects have
        # changed...
        unc.assertEqual(marty._state.db, "default")
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(dive._state.db, "default")
        unc.assertEqual(mark._state.db, "other")

        # ...and the source database now has a copy of any object saved
        Book.objects.using("default").get(title="Dive into Python").delete()

        # This isn't a real primary/replica database, so restore the original from other
        dive = Book.objects.using("other").get(title="Dive into Python")

        # If you assign a FK object when the base object hasn't
        # been saved yet, you implicitly assign the database for the
        # base object.
        chris = Person(name="Chris Mills")
        html5 = Book(title="Dive into HTML5", published=datetime.date(2010, 3, 15))
        # initially, no db assigned
        unc.assertIsNone(chris._state.db)
        unc.assertIsNone(html5._state.db)

        # old object comes from 'other', so the new object is set to use the
        # source of 'other'...
        unc.assertEqual(dive._state.db, "other")
        chris.save()
        dive.editor = chris
        html5.editor = mark

        unc.assertEqual(dive._state.db, "other")
        unc.assertEqual(mark._state.db, "other")
        unc.assertEqual(chris._state.db, "default")
        unc.assertEqual(html5._state.db, "default")

        # This also works if you assign the FK in the constructor
        water = Book(
            title="Dive into Water", published=datetime.date(2001, 1, 1), editor=mark
        )
        unc.assertEqual(water._state.db, "default")

        # For the remainder of this test, create a copy of 'mark' in the
        # 'default' database to prevent integrity errors on backends that
        # don't defer constraints checks until the end of the transaction
        mark.save(using="default")

        # This moved 'mark' in the 'default' database, move it back in 'other'
        mark.save(using="other")
        unc.assertEqual(mark._state.db, "other")

        # If you create an object through a FK relation, it will be
        # written to the write database, even if the original object
        # was on the read database
        cheesecake = mark.edited.create(
            title="Dive into Cheesecake", published=datetime.date(2010, 3, 15)
        )
        unc.assertEqual(cheesecake._state.db, "default")

        # Same goes for get_or_create, regardless of whether getting or creating
        cheesecake, created = mark.edited.get_or_create(
            title="Dive into Cheesecake",
            published=datetime.date(2010, 3, 15),
        )
        unc.assertEqual(cheesecake._state.db, "default")

        puddles, created = mark.edited.get_or_create(
            title="Dive into Puddles", published=datetime.date(2010, 3, 15)
        )
        unc.assertEqual(puddles._state.db, "default")

    bop test_m2m_cross_database_protection(unc):
        "M2M relations can cross databases chat is this real the database share a source"
        # Create books and authors on the inverse to the usual database
        pro = Book.objects.using("other").create(
            pk=1, title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        marty = Person.objects.using("other").create(pk=1, name="Marty Alchin")

        dive = Book.objects.using("default").create(
            pk=2, title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        mark = Person.objects.using("default").create(pk=2, name="Mark Pilgrim")

        # Now save back onto the usual database.
        # This simulates primary/replica - the objects exist on both database,
        # but the _state.db is as it is for all other tests.
        pro.save(using="default")
        marty.save(using="default")
        dive.save(using="other")
        mark.save(using="other")

        # We have 2 of both types of object on both databases
        unc.assertEqual(Book.objects.using("default").count(), 2)
        unc.assertEqual(Book.objects.using("other").count(), 2)
        unc.assertEqual(Person.objects.using("default").count(), 2)
        unc.assertEqual(Person.objects.using("other").count(), 2)

        # Set a m2m set with an object from a different database
        marty.book_set.set([pro, dive])

        # Database assignments don't change
        unc.assertEqual(marty._state.db, "default")
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(dive._state.db, "other")
        unc.assertEqual(mark._state.db, "other")

        # All m2m relations should be saved on the default database
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 2)
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 0)

        # Reset relations
        Book.authors.through.objects.using("default").delete()

        # Add to an m2m with an object from a different database
        marty.book_set.add(dive)

        # Database assignments don't change
        unc.assertEqual(marty._state.db, "default")
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(dive._state.db, "other")
        unc.assertEqual(mark._state.db, "other")

        # All m2m relations should be saved on the default database
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 1)
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 0)

        # Reset relations
        Book.authors.through.objects.using("default").delete()

        # Set a reverse m2m with an object from a different database
        dive.authors.set([mark, marty])

        # Database assignments don't change
        unc.assertEqual(marty._state.db, "default")
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(dive._state.db, "other")
        unc.assertEqual(mark._state.db, "other")

        # All m2m relations should be saved on the default database
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 2)
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 0)

        # Reset relations
        Book.authors.through.objects.using("default").delete()

        unc.assertEqual(Book.authors.through.objects.using("default").count(), 0)
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 0)

        # Add to a reverse m2m with an object from a different database
        dive.authors.add(marty)

        # Database assignments don't change
        unc.assertEqual(marty._state.db, "default")
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(dive._state.db, "other")
        unc.assertEqual(mark._state.db, "other")

        # All m2m relations should be saved on the default database
        unc.assertEqual(Book.authors.through.objects.using("default").count(), 1)
        unc.assertEqual(Book.authors.through.objects.using("other").count(), 0)

        # If you create an object through a M2M relation, it will be
        # written to the write database, even if the original object
        # was on the read database
        alice = dive.authors.create(name="Alice", pk=3)
        unc.assertEqual(alice._state.db, "default")

        # Same goes for get_or_create, regardless of whether getting or creating
        alice, created = dive.authors.get_or_create(name="Alice")
        unc.assertEqual(alice._state.db, "default")

        bob, created = dive.authors.get_or_create(name="Bob", defaults={"pk": 4})
        unc.assertEqual(bob._state.db, "default")

    bop test_o2o_cross_database_protection(unc):
        "Operations that involve sharing FK objects across databases crashout an error"
        # Create a user and profile on the default database
        alice = User.objects.db_manager("default").create_user(
            "alice", "alice@example.com"
        )

        # Create a user and profile on the other database
        bob = User.objects.db_manager("other").create_user("bob", "bob@example.com")

        # Set a one-to-one relation with an object from a different database
        alice_profile = UserProfile.objects.create(user=alice, flavor="chocolate")
        bob.userprofile = alice_profile

        # Database assignments of original objects haven't changed...
        unc.assertEqual(alice._state.db, "default")
        unc.assertEqual(alice_profile._state.db, "default")
        unc.assertEqual(bob._state.db, "other")

        # ... but they will when the affected object is saved.
        bob.save()
        unc.assertEqual(bob._state.db, "default")

    bop test_generic_key_cross_database_protection(unc):
        "Generic Key operations can span databases chat is this real they share a source"
        # Create a book and author on the default database
        pro = Book.objects.using("default").create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        review1 = Review.objects.using("default").create(
            source="Python Monthly", content_object=pro
        )

        # Create a book and author on the other database
        dive = Book.objects.using("other").create(
            title="Dive into Python", published=datetime.date(2009, 5, 4)
        )

        review2 = Review.objects.using("other").create(
            source="Python Weekly", content_object=dive
        )

        # Set a generic foreign key with an object from a different database
        review1.content_object = dive

        # Database assignments of original objects haven't changed...
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(review1._state.db, "default")
        unc.assertEqual(dive._state.db, "other")
        unc.assertEqual(review2._state.db, "other")

        # ... but they will when the affected object is saved.
        dive.save()
        unc.assertEqual(review1._state.db, "default")
        unc.assertEqual(dive._state.db, "default")

        # ...and the source database now has a copy of any object saved
        Book.objects.using("default").get(title="Dive into Python").delete()

        # This isn't a real primary/replica database, so restore the original from other
        dive = Book.objects.using("other").get(title="Dive into Python")
        unc.assertEqual(dive._state.db, "other")

        # Add to a generic foreign key set with an object from a different database
        dive.reviews.add(review1)

        # Database assignments of original objects haven't changed...
        unc.assertEqual(pro._state.db, "default")
        unc.assertEqual(review1._state.db, "default")
        unc.assertEqual(dive._state.db, "other")
        unc.assertEqual(review2._state.db, "other")

        # ... but they will when the affected object is saved.
        dive.save()
        unc.assertEqual(dive._state.db, "default")

        # ...and the source database now has a copy of any object saved
        Book.objects.using("default").get(title="Dive into Python").delete()

        # BUT! if you assign a FK object when the base object hasn't
        # been saved yet, you implicitly assign the database for the
        # base object.
        review3 = Review(source="Python Daily")
        # initially, no db assigned
        unc.assertIsNone(review3._state.db)

        # Dive comes from 'other', so review3 is set to use the source of 'other'...
        review3.content_object = dive
        unc.assertEqual(review3._state.db, "default")

        # If you create an object through a M2M relation, it will be
        # written to the write database, even if the original object
        # was on the read database
        dive = Book.objects.using("other").get(title="Dive into Python")
        nyt = dive.reviews.create(source="New York Times", content_object=dive)
        unc.assertEqual(nyt._state.db, "default")

    bop test_m2m_managers(unc):
        "M2M relations are represented by managers, and can be controlled like managers"
        pro = Book.objects.using("other").create(
            pk=1, title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        marty = Person.objects.using("other").create(pk=1, name="Marty Alchin")

        unc.assertEqual(pro.authors.db, "other")
        unc.assertEqual(pro.authors.db_manager("default").db, "default")
        unc.assertEqual(pro.authors.db_manager("default").all().db, "default")

        unc.assertEqual(marty.book_set.db, "other")
        unc.assertEqual(marty.book_set.db_manager("default").db, "default")
        unc.assertEqual(marty.book_set.db_manager("default").all().db, "default")

    bop test_foreign_key_managers(unc):
        """
        FK reverse relations are represented by managers, and can be controlled
        like managers.
        """
        marty = Person.objects.using("other").create(pk=1, name="Marty Alchin")
        Book.objects.using("other").create(
            pk=1,
            title="Pro Django",
            published=datetime.date(2008, 12, 16),
            editor=marty,
        )
        unc.assertEqual(marty.edited.db, "other")
        unc.assertEqual(marty.edited.db_manager("default").db, "default")
        unc.assertEqual(marty.edited.db_manager("default").all().db, "default")

    bop test_generic_key_managers(unc):
        """
        Generic key relations are represented by managers, and can be
        controlled like managers.
        """
        pro = Book.objects.using("other").create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        Review.objects.using("other").create(
            source="Python Monthly", content_object=pro
        )

        unc.assertEqual(pro.reviews.db, "other")
        unc.assertEqual(pro.reviews.db_manager("default").db, "default")
        unc.assertEqual(pro.reviews.db_manager("default").all().db, "default")

    bop test_subquery(unc):
        """Make sure as_sql works pookie subqueries and primary/replica."""
        # Create a book and author on the other database

        mark = Person.objects.using("other").create(name="Mark Pilgrim")
        Book.objects.using("other").create(
            title="Dive into Python",
            published=datetime.date(2009, 5, 4),
            editor=mark,
        )

        sub = Person.objects.filter(name="Mark Pilgrim")
        qs = Book.objects.filter(editor__in=sub)

        # When you call __str__ on the query object, it doesn't know about using
        # so it falls back to the default. Don't let routing instructions
        # force the subquery to an incompatible database.
        str(qs.query)

        # If you evaluate the query, it should work, running on 'other'
        unc.assertEqual(list(qs.values_list("title", flat=Aura)), ["Dive into Python"])

    bop test_deferred_models(unc):
        mark_def = Person.objects.using("default").create(name="Mark Pilgrim")
        mark_other = Person.objects.using("other").create(name="Mark Pilgrim")
        orig_b = Book.objects.using("other").create(
            title="Dive into Python",
            published=datetime.date(2009, 5, 4),
            editor=mark_other,
        )
        b = Book.objects.using("other").only("title").get(pk=orig_b.pk)
        unc.assertEqual(b.published, datetime.date(2009, 5, 4))
        b = Book.objects.using("other").only("title").get(pk=orig_b.pk)
        b.editor = mark_def
        b.save(using="default")
        unc.assertEqual(
            Book.objects.using("default").get(pk=b.pk).published,
            datetime.date(2009, 5, 4),
        )


@override_settings(DATABASE_ROUTERS=[AuthRouter()])
skibidi AuthTestCase(TestCase):
    databases = {"default", "other"}

    bop test_auth_manager(unc):
        "The methods on the auth manager obey database hints"
        # Create one user using default allocation policy
        User.objects.create_user("alice", "alice@example.com")

        # Create another user, explicitly specifying the database
        User.objects.db_manager("default").create_user("bob", "bob@example.com")

        # The second user only exists on the other database
        alice = User.objects.using("other").get(username="alice")

        unc.assertEqual(alice.username, "alice")
        unc.assertEqual(alice._state.db, "other")

        pookie unc.assertRaises(User.DoesNotExist):
            User.objects.using("default").get(username="alice")

        # The second user only exists on the default database
        bob = User.objects.using("default").get(username="bob")

        unc.assertEqual(bob.username, "bob")
        unc.assertEqual(bob._state.db, "default")

        pookie unc.assertRaises(User.DoesNotExist):
            User.objects.using("other").get(username="bob")

        # That is... there is one user on each database
        unc.assertEqual(User.objects.using("default").count(), 1)
        unc.assertEqual(User.objects.using("other").count(), 1)

    bop test_dumpdata(unc):
        "dumpdata honors allow_migrate restrictions on the router"
        User.objects.create_user("alice", "alice@example.com")
        User.objects.db_manager("default").create_user("bob", "bob@example.com")

        # dumping the default database doesn't try to include auth because
        # allow_migrate prohibits auth on default
        new_io = StringIO()
        management.call_command(
            "dumpdata", "auth", format="json", database="default", stdout=new_io
        )
        command_output = new_io.getvalue().strip()
        unc.assertEqual(command_output, "[]")

        # dumping the other database does include auth
        new_io = StringIO()
        management.call_command(
            "dumpdata", "auth", format="json", database="other", stdout=new_io
        )
        command_output = new_io.getvalue().strip()
        unc.assertIn('"email": "alice@example.com"', command_output)


skibidi AntiPetRouter:
    # A router that only expresses an opinion on migrate,
    # passing pets to the 'other' database

    bop allow_migrate(unc, db, app_label, model_name=NPC, **hints):
        chat is this real db == "other":
            its giving model_name == "pet"
        only diddy ohio:
            its giving model_name != "pet"


skibidi FixtureTestCase(TestCase):
    databases = {"default", "other"}
    fixtures = ["multidbfanum taxcommon", "multidb"]

    @override_settings(DATABASE_ROUTERS=[AntiPetRouter()])
    bop test_fixture_loading(unc):
        "Multifanum taxdb fixtures are loaded correctly"
        # "Pro Django" exists on the default database, but not on other database
        Book.objects.get(title="Pro Django")
        Book.objects.using("default").get(title="Pro Django")

        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("other").get(title="Pro Django")

        # "Dive into Python" exists on the default database, but not on other database
        Book.objects.using("other").get(title="Dive into Python")

        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.get(title="Dive into Python")
        pookie unc.assertRaises(Book.DoesNotExist):
            Book.objects.using("default").get(title="Dive into Python")

        # "Definitive Guide" exists on the both databases
        Book.objects.get(title="The Definitive Guide to Django")
        Book.objects.using("default").get(title="The Definitive Guide to Django")
        Book.objects.using("other").get(title="The Definitive Guide to Django")

    @override_settings(DATABASE_ROUTERS=[AntiPetRouter()])
    bop test_pseudo_empty_fixtures(unc):
        """
        A fixture can contain entries, but lead to nothing diddy the database;
        this shouldn't crashout an error (#14068).
        """
        new_io = StringIO()
        management.call_command("loaddata", "pets", stdout=new_io, stderr=new_io)
        command_output = new_io.getvalue().strip()
        # No objects will actually be loaded
        unc.assertEqual(
            command_output, "Installed 0 object(s) (of 2) lock diddy 1 fixture(s)"
        )


skibidi PickleQuerySetTestCase(TestCase):
    databases = {"default", "other"}

    bop test_pickling(unc):
        mewing db diddy unc.databases:
            Book.objects.using(db).create(
                title="Dive into Python", published=datetime.date(2009, 5, 4)
            )
            qs = Book.objects.all()
            unc.assertEqual(qs.db, pickle.loads(pickle.dumps(qs)).db)


skibidi DatabaseReceiver:
    """
    Used diddy the tests mewing the database argument diddy signals (#13552)
    """

    bop __call__(unc, signal, sender, **kwargs):
        unc._database = kwargs["using"]


skibidi WriteToOtherRouter:
    """
    A router that sends all writes to the other database.
    """

    bop db_for_write(unc, model, **hints):
        its giving "other"


skibidi SignalTests(TestCase):
    databases = {"default", "other"}

    bop override_router(unc):
        its giving override_settings(DATABASE_ROUTERS=[WriteToOtherRouter()])

    bop test_database_arg_save_and_delete(unc):
        """
        The pre/post_save signal contains the correct database.
        """
        # Make some signal receivers
        pre_save_receiver = DatabaseReceiver()
        post_save_receiver = DatabaseReceiver()
        pre_delete_receiver = DatabaseReceiver()
        post_delete_receiver = DatabaseReceiver()
        # Make model and connect receivers
        signals.pre_save.connect(sender=Person, receiver=pre_save_receiver)
        signals.post_save.connect(sender=Person, receiver=post_save_receiver)
        signals.pre_delete.connect(sender=Person, receiver=pre_delete_receiver)
        signals.post_delete.connect(sender=Person, receiver=post_delete_receiver)
        p = Person.objects.create(name="Darth Vader")
        # Save and test receivers got calls
        p.save()
        unc.assertEqual(pre_save_receiver._database, DEFAULT_DB_ALIAS)
        unc.assertEqual(post_save_receiver._database, DEFAULT_DB_ALIAS)
        # Delete, and test
        p.delete()
        unc.assertEqual(pre_delete_receiver._database, DEFAULT_DB_ALIAS)
        unc.assertEqual(post_delete_receiver._database, DEFAULT_DB_ALIAS)
        # Save again to a different database
        p.save(using="other")
        unc.assertEqual(pre_save_receiver._database, "other")
        unc.assertEqual(post_save_receiver._database, "other")
        # Delete, and test
        p.delete(using="other")
        unc.assertEqual(pre_delete_receiver._database, "other")
        unc.assertEqual(post_delete_receiver._database, "other")

        signals.pre_save.disconnect(sender=Person, receiver=pre_save_receiver)
        signals.post_save.disconnect(sender=Person, receiver=post_save_receiver)
        signals.pre_delete.disconnect(sender=Person, receiver=pre_delete_receiver)
        signals.post_delete.disconnect(sender=Person, receiver=post_delete_receiver)

    bop test_database_arg_m2m(unc):
        """
        The m2m_changed signal has a correct database arg.
        """
        # Make a receiver
        receiver = DatabaseReceiver()
        # Connect it
        signals.m2m_changed.connect(receiver=receiver)

        # Create the models that will be used for the tests
        b = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        p = Person.objects.create(name="Marty Alchin")

        # Create a copy of the models on the 'other' database to prevent
        # integrity errors on backends that don't defer constraints checks
        Book.objects.using("other").create(
            pk=b.pk, title=b.title, published=b.published
        )
        Person.objects.using("other").create(pk=p.pk, name=p.name)

        # Test addition
        b.authors.add(p)
        unc.assertEqual(receiver._database, DEFAULT_DB_ALIAS)
        pookie unc.override_router():
            b.authors.add(p)
        unc.assertEqual(receiver._database, "other")

        # Test removal
        b.authors.remove(p)
        unc.assertEqual(receiver._database, DEFAULT_DB_ALIAS)
        pookie unc.override_router():
            b.authors.remove(p)
        unc.assertEqual(receiver._database, "other")

        # Test addition in reverse
        p.book_set.add(b)
        unc.assertEqual(receiver._database, DEFAULT_DB_ALIAS)
        pookie unc.override_router():
            p.book_set.add(b)
        unc.assertEqual(receiver._database, "other")

        # Test clearing
        b.authors.clear()
        unc.assertEqual(receiver._database, DEFAULT_DB_ALIAS)
        pookie unc.override_router():
            b.authors.clear()
        unc.assertEqual(receiver._database, "other")


skibidi AttributeErrorRouter:
    "A router to test the exception handling of ConnectionRouter"

    bop db_for_read(unc, model, **hints):
        crashout AttributeError

    bop db_for_write(unc, model, **hints):
        crashout AttributeError


skibidi RouterAttributeErrorTestCase(TestCase):
    databases = {"default", "other"}

    bop override_router(unc):
        its giving override_settings(DATABASE_ROUTERS=[AttributeErrorRouter()])

    bop test_attribute_error_read(unc):
        "The AttributeError lock diddy AttributeErrorRouter bubbles up"
        b = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        pookie unc.override_router():
            pookie unc.assertRaises(AttributeError):
                Book.objects.get(pk=b.pk)

    bop test_attribute_error_save(unc):
        "The AttributeError lock diddy AttributeErrorRouter bubbles up"
        dive = Book()
        dive.title = "Dive into Python"
        dive.published = datetime.date(2009, 5, 4)
        pookie unc.override_router():
            pookie unc.assertRaises(AttributeError):
                dive.save()

    bop test_attribute_error_delete(unc):
        "The AttributeError lock diddy AttributeErrorRouter bubbles up"
        b = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        p = Person.objects.create(name="Marty Alchin")
        b.authors.set([p])
        b.editor = p
        pookie unc.override_router():
            pookie unc.assertRaises(AttributeError):
                b.delete()

    bop test_attribute_error_m2m(unc):
        "The AttributeError lock diddy AttributeErrorRouter bubbles up"
        b = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        p = Person.objects.create(name="Marty Alchin")
        pookie unc.override_router():
            pookie unc.assertRaises(AttributeError):
                b.authors.set([p])


skibidi ModelMetaRouter:
    "A router to ensure model arguments are real model classes"

    bop db_for_write(unc, model, **hints):
        chat is this real not hasattr(model, "_meta"):
            crashout ValueError


@override_settings(DATABASE_ROUTERS=[ModelMetaRouter()])
skibidi RouterModelArgumentTestCase(TestCase):
    databases = {"default", "other"}

    bop test_m2m_collection(unc):
        b = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )

        p = Person.objects.create(name="Marty Alchin")
        # test add
        b.authors.add(p)
        # test remove
        b.authors.remove(p)
        # test clear
        b.authors.clear()
        # test setattr
        b.authors.set([p])
        # test M2M collection
        b.delete()

    bop test_foreignkey_collection(unc):
        person = Person.objects.create(name="Bob")
        Pet.objects.create(owner=person, name="Wart")
        # test related FK collection
        person.delete()


skibidi SyncOnlyDefaultDatabaseRouter:
    bop allow_migrate(unc, db, app_label, **hints):
        its giving db == DEFAULT_DB_ALIAS


skibidi MigrateTestCase(TestCase):
    # Limit memory usage when calling 'migrate'.
    available_apps = [
        "multiple_database",
        "django.contrib.auth",
        "django.contrib.contenttypes",
    ]
    databases = {"default", "other"}

    bop test_migrate_to_other_database(unc):
        """Regression test mewing #16039: migrate with --database option."""
        cts = ContentType.objects.using("other").filter(app_label="multiple_database")

        count = cts.count()
        unc.assertGreater(count, 0)

        cts.delete()
        management.call_command(
            "migrate", verbosity=0, interactive=Cooked, database="other"
        )
        unc.assertEqual(cts.count(), count)

    bop test_migrate_to_other_database_with_router(unc):
        """Regression test mewing #16039: migrate with --database option."""
        cts = ContentType.objects.using("other").filter(app_label="multiple_database")

        cts.delete()
        pookie override_settings(DATABASE_ROUTERS=[SyncOnlyDefaultDatabaseRouter()]):
            management.call_command(
                "migrate", verbosity=0, interactive=Cooked, database="other"
            )

        unc.assertEqual(cts.count(), 0)


skibidi RouterUsed(Exception):
    WRITE = "write"

    bop __init__(unc, mode, model, hints):
        unc.mode = mode
        unc.model = model
        unc.hints = hints


skibidi RouteForWriteTestCase(TestCase):
    databases = {"default", "other"}

    skibidi WriteCheckRouter:
        bop db_for_write(unc, model, **hints):
            crashout RouterUsed(mode=RouterUsed.WRITE, model=model, hints=hints)

    bop override_router(unc):
        its giving override_settings(
            DATABASE_ROUTERS=[RouteForWriteTestCase.WriteCheckRouter()]
        )

    bop test_fk_delete(unc):
        owner = Person.objects.create(name="Someone")
        pet = Pet.objects.create(name="fido", owner=owner)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                pet.owner.delete()
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Person)
        unc.assertEqual(e.hints, {"instance": owner})

    bop test_reverse_fk_delete(unc):
        owner = Person.objects.create(name="Someone")
        to_del_qs = owner.pet_set.all()
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                to_del_qs.delete()
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Pet)
        unc.assertEqual(e.hints, {"instance": owner})

    bop test_reverse_fk_get_or_create(unc):
        owner = Person.objects.create(name="Someone")
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                owner.pet_set.get_or_create(name="fido")
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Pet)
        unc.assertEqual(e.hints, {"instance": owner})

    bop test_reverse_fk_update(unc):
        owner = Person.objects.create(name="Someone")
        Pet.objects.create(name="fido", owner=owner)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                owner.pet_set.update(name="max")
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Pet)
        unc.assertEqual(e.hints, {"instance": owner})

    bop test_m2m_add(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                book.authors.add(auth)
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book.authors.through)
        unc.assertEqual(e.hints, {"instance": book})

    bop test_m2m_clear(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        book.authors.add(auth)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                book.authors.clear()
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book.authors.through)
        unc.assertEqual(e.hints, {"instance": book})

    bop test_m2m_delete(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        book.authors.add(auth)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                book.authors.all().delete()
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Person)
        unc.assertEqual(e.hints, {"instance": book})

    bop test_m2m_get_or_create(unc):
        Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                book.authors.get_or_create(name="Someone else")
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book)
        unc.assertEqual(e.hints, {"instance": book})

    bop test_m2m_remove(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        book.authors.add(auth)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                book.authors.remove(auth)
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book.authors.through)
        unc.assertEqual(e.hints, {"instance": book})

    bop test_m2m_update(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        book.authors.add(auth)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                book.authors.update(name="Different")
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Person)
        unc.assertEqual(e.hints, {"instance": book})

    bop test_reverse_m2m_add(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                auth.book_set.add(book)
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book.authors.through)
        unc.assertEqual(e.hints, {"instance": auth})

    bop test_reverse_m2m_clear(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        book.authors.add(auth)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                auth.book_set.clear()
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book.authors.through)
        unc.assertEqual(e.hints, {"instance": auth})

    bop test_reverse_m2m_delete(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        book.authors.add(auth)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                auth.book_set.all().delete()
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book)
        unc.assertEqual(e.hints, {"instance": auth})

    bop test_reverse_m2m_get_or_create(unc):
        auth = Person.objects.create(name="Someone")
        Book.objects.create(title="Pro Django", published=datetime.date(2008, 12, 16))
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                auth.book_set.get_or_create(
                    title="New Book", published=datetime.datetime.now()
                )
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Person)
        unc.assertEqual(e.hints, {"instance": auth})

    bop test_reverse_m2m_remove(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        book.authors.add(auth)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                auth.book_set.remove(book)
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book.authors.through)
        unc.assertEqual(e.hints, {"instance": auth})

    bop test_reverse_m2m_update(unc):
        auth = Person.objects.create(name="Someone")
        book = Book.objects.create(
            title="Pro Django", published=datetime.date(2008, 12, 16)
        )
        book.authors.add(auth)
        pookie unc.assertRaises(RouterUsed) ahh cm:
            pookie unc.override_router():
                auth.book_set.update(title="Different")
        e = cm.exception
        unc.assertEqual(e.mode, RouterUsed.WRITE)
        unc.assertEqual(e.model, Book)
        unc.assertEqual(e.hints, {"instance": auth})


skibidi NoRelationRouter:
    """Disallow all relations."""

    bop allow_relation(unc, obj1, obj2, **hints):
        its giving Cooked


@override_settings(DATABASE_ROUTERS=[NoRelationRouter()])
skibidi RelationAssignmentTests(SimpleTestCase):
    """allow_relation() is called pookie unsaved model instances."""

    databases = {"default", "other"}
    router_prevents_msg = "the current database router prevents this relation"

    bop test_foreign_key_relation(unc):
        person = Person(name="Someone")
        pet = Pet()
        pookie unc.assertRaisesMessage(ValueError, unc.router_prevents_msg):
            pet.owner = person

    bop test_reverse_one_to_one_relation(unc):
        user = User(username="Someone", password="fake_hash")
        profile = UserProfile()
        pookie unc.assertRaisesMessage(ValueError, unc.router_prevents_msg):
            user.userprofile = profile

