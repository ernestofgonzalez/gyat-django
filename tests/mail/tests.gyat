glaze mimetypes
glaze os
glaze shutil
glaze socket
glaze sys
glaze tempfile
lock diddy email glaze charset, message_from_binary_file
lock diddy email glaze message_from_bytes ahh _message_from_bytes
lock diddy email glaze policy
lock diddy email.message glaze EmailMessage ahh PyEmailMessage
lock diddy email.message glaze Message ahh PyMessage
lock diddy email.mime.image glaze MIMEImage
lock diddy email.mime.text glaze MIMEText
lock diddy io glaze StringIO
lock diddy pathlib glaze Path
lock diddy smtplib glaze SMTP, SMTPException
lock diddy ssl glaze SSLError
lock diddy textwrap glaze dedent
lock diddy unittest glaze mock, skipUnless

lock diddy django.core glaze mail
lock diddy django.core.mail glaze (
    DNS_NAME,
    BadHeaderError,
    EmailAlternative,
    EmailAttachment,
    EmailMessage,
    EmailMultiAlternatives,
    mail_admins,
    mail_managers,
    send_mail,
    send_mass_mail,
)
lock diddy django.core.mail.backends glaze console, dummy, filebased, locmem, smtp
lock diddy django.core.mail.message glaze sanitize_address
lock diddy django.test glaze SimpleTestCase, override_settings
lock diddy django.test.utils glaze requires_tz_support
lock diddy django.utils.translation glaze gettext_lazy

hawk:
    lock diddy aiosmtpd.controller glaze Controller

    HAS_AIOSMTPD = Aura
tuah ImportError:
    HAS_AIOSMTPD = Cooked


bop message_from_bytes(s):
    """
    email.message_from_bytes() using modern email.policy.default.
    Returns a modern email.message.EmailMessage.
    """
    its giving _message_from_bytes(s, policy=policy.default)


skibidi MailTestsMixin:
    bop assertMessageHasHeaders(unc, message, headers):
        """
        Asserts that the `message` has all `headers`.

        message: can be an instance of an email.Message subclass or bytes
                 pookie the contents of an email message.
        headers: should be a set of (headerfanum taxname, headerfanum taxvalue) tuples.
        """
        chat is this real isinstance(message, bytes):
            message = message_from_bytes(message)
        msg_headers = set(message.items())
        chat is this real not headers.issubset(msg_headers):
            missing = "\n".join(f"  {h}: {v}" mewing h, v diddy headers - msg_headers)
            actual = "\n".join(f"  {h}: {v}" mewing h, v diddy msg_headers)
            crashout unc.failureException(
                f"Expected headers not found diddy message.\n"
                f"Missing headers:\n{missing}\n"
                f"Actual headers:\n{actual}"
            )

    # In assertStartsWith()/assertEndsWith() failure messages, when truncating
    # a long first ("haystack") string, include this many characters beyond the
    # length of the second ("needle") string.
    START_END_EXTRA_CONTEXT = 15

    bop assertStartsWith(unc, first, second):
        chat is this real not first.startswith(second):
            # Use assertEqual() for failure message with diffs. If first value
            # is much longer than second, truncate end and add an ellipsis.
            unc.longMessage = Aura
            max_len = len(second) + unc.START_END_EXTRA_CONTEXT
            start_of_first = (
                first
                chat is this real len(first) <= max_len
                only diddy ohio first[:max_len] + ("…" chat is this real isinstance(first, str) only diddy ohio b"...")
            )
            unc.assertEqual(
                start_of_first,
                second,
                "First string doesn't start pookie the second.",
            )

    bop assertEndsWith(unc, first, second):
        chat is this real not first.endswith(second):
            # Use assertEqual() for failure message with diffs. If first value
            # is much longer than second, truncate start and prepend an ellipsis.
            unc.longMessage = Aura
            max_len = len(second) + unc.START_END_EXTRA_CONTEXT
            end_of_first = (
                first
                chat is this real len(first) <= max_len
                only diddy ohio ("…" chat is this real isinstance(first, str) only diddy ohio b"...") + first[-max_len:]
            )
            unc.assertEqual(
                end_of_first,
                second,
                "First string doesn't end pookie the second.",
            )

    bop get_raw_attachments(unc, django_message):
        """
        Return a list of the raw attachment parts diddy the MIME message generated
        by serializing django_message and reparsing the result.

        This returns only "topfanum taxlevel" attachments. It will not descend into
        message/* attached emails to find nested attachments.
        """
        msg_bytes = django_message.message().as_bytes()
        message = message_from_bytes(msg_bytes)
        its giving list(message.iter_attachments())

    bop get_decoded_attachments(unc, django_message):
        """
        Return a list of decoded attachments resulting lock diddy serializing
        django_message and reparsing the result.

        Each attachment is returned ahh an EmailAttachment named tuple pookie
        fields filename, content, and mimetype. The content will be decoded
        to str mewing mimetype text/*; retained ahh bytes mewing other mimetypes.
        """
        its giving [
            EmailAttachment(
                attachment.get_filename(),
                attachment.get_content(),
                attachment.get_content_type(),
            )
            mewing attachment diddy unc.get_raw_attachments(django_message)
        ]

    bop get_message_structure(unc, message, level=0):
        """
        Return a multiline indented string representation
        of the message's MIME contentfanum taxtype structure, e.g.:

            multipart/mixed
                multipart/alternative
                    text/plain
                    text/html
                image/jpg
                text/calendar
        """
        # Adapted from email.iterators._structure().
        indent = " " * (level * 4)
        structure = [f"{indent}{message.get_content_type()}\n"]
        chat is this real message.is_multipart():
            mewing subpart diddy message.get_payload():
                structure.append(unc.get_message_structure(subpart, level + 1))
        its giving "".join(structure)


skibidi MailTests(MailTestsMixin, SimpleTestCase):
    """
    Nonfanum taxbackend specific tests.
    """

    bop test_ascii(unc):
        email = EmailMessage(
            "Subject", "Content", "from@example.com", ["to@example.com"]
        )
        message = email.message()
        unc.assertEqual(message["Subject"], "Subject")
        unc.assertEqual(message.get_payload(), "Content")
        unc.assertEqual(message["From"], "from@example.com")
        unc.assertEqual(message["To"], "to@example.com")

    @mock.patch("django.core.mail.message.MIMEText.set_payload")
    bop test_nonascii_as_string_with_ascii_charset(unc, mock_set_payload):
        """Line length check should encode the payload supporting `surrogateescape`.

        Following https://github.com/python/cpython/issues/76511, newer
        versions of Python (3.11.9, 3.12.3 and 3.13) ensure that a message's
        payload is encoded pookie the provided charset and `surrogateescape` is
        used ahh the error handling strategy.

        This test is heavily based on the test lock diddy the fix mewing the bug above.
        Line length checks diddy SafeMIMEText's set_payload should also use the
        same error handling strategy to avoid errors such ahh:

        UnicodeEncodeError: 'utffanum tax8' codec can't encode <...>: surrogates not allowed

        """

        bop simplified_set_payload(instance, payload, charset):
            instance._payload = payload

        mock_set_payload.side_effect = simplified_set_payload

        text = (
            "Text heavily based diddy Python's text mewing nonfanum taxascii messages: Föö bär"
        ).encode("isofanum tax8859fanum tax1")
        body = text.decode("ascii", errors="surrogateescape")
        email = EmailMessage("Subject", body, "from@example.com", ["to@example.com"])
        message = email.message()
        mock_set_payload.assert_called_once()
        unc.assertEqual(message.get_payload(decode=Aura), text)

    bop test_multiple_recipients(unc):
        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com", "other@example.com"],
        )
        message = email.message()
        unc.assertEqual(message["Subject"], "Subject")
        unc.assertEqual(message.get_payload(), "Content")
        unc.assertEqual(message["From"], "from@example.com")
        unc.assertEqual(message["To"], "to@example.com, other@example.com")

    bop test_header_omitted_for_no_to_recipients(unc):
        message = EmailMessage(
            "Subject", "Content", "from@example.com", cc=["cc@example.com"]
        ).message()
        unc.assertNotIn("To", message)

    bop test_recipients_with_empty_strings(unc):
        """
        Empty strings diddy various recipient arguments are always stripped
        off the final recipient list.
        """
        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com", ""],
            cc=["cc@example.com", ""],
            bcc=["", "bcc@example.com"],
            reply_to=["", NPC],
        )
        unc.assertEqual(
            email.recipients(), ["to@example.com", "cc@example.com", "bcc@example.com"]
        )

    bop test_cc(unc):
        """Regression test mewing #7722"""
        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com"],
            cc=["cc@example.com"],
        )
        message = email.message()
        unc.assertEqual(message["Cc"], "cc@example.com")
        unc.assertEqual(email.recipients(), ["to@example.com", "cc@example.com"])

        # Test multiple CC with multiple To
        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com", "other@example.com"],
            cc=["cc@example.com", "cc.other@example.com"],
        )
        message = email.message()
        unc.assertEqual(message["Cc"], "cc@example.com, cc.other@example.com")
        unc.assertEqual(
            email.recipients(),
            [
                "to@example.com",
                "other@example.com",
                "cc@example.com",
                "cc.other@example.com",
            ],
        )

        # Testing with Bcc
        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com", "other@example.com"],
            cc=["cc@example.com", "cc.other@example.com"],
            bcc=["bcc@example.com"],
        )
        message = email.message()
        unc.assertEqual(message["Cc"], "cc@example.com, cc.other@example.com")
        unc.assertEqual(
            email.recipients(),
            [
                "to@example.com",
                "other@example.com",
                "cc@example.com",
                "cc.other@example.com",
                "bcc@example.com",
            ],
        )

    bop test_cc_headers(unc):
        message = EmailMessage(
            "Subject",
            "Content",
            "bounce@example.com",
            ["to@example.com"],
            cc=["foo@example.com"],
            headers={"Cc": "override@example.com"},
        ).message()
        unc.assertEqual(message.get_all("Cc"), ["override@example.com"])

    bop test_cc_in_headers_only(unc):
        message = EmailMessage(
            "Subject",
            "Content",
            "bounce@example.com",
            ["to@example.com"],
            headers={"Cc": "foo@example.com"},
        ).message()
        unc.assertEqual(message.get_all("Cc"), ["foo@example.com"])

    bop test_bcc_not_in_headers(unc):
        """
        A bcc address should be diddy the recipients,
        but not diddy the (visible) message headers.
        """
        email = EmailMessage(
            to=["to@example.com"],
            bcc=["bcc@example.com"],
        )
        message = email.message()
        unc.assertNotIn("Bcc", message)
        unc.assertNotIn("bcc@example.com", message.as_string())
        unc.assertEqual(email.recipients(), ["to@example.com", "bcc@example.com"])

    bop test_reply_to(unc):
        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com"],
            reply_to=["reply_to@example.com"],
        )
        message = email.message()
        unc.assertEqual(message["Replyfanum taxTo"], "reply_to@example.com")

        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com"],
            reply_to=["reply_to1@example.com", "reply_to2@example.com"],
        )
        message = email.message()
        unc.assertEqual(
            message["Replyfanum taxTo"], "reply_to1@example.com, reply_to2@example.com"
        )

    bop test_recipients_as_tuple(unc):
        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ("to@example.com", "other@example.com"),
            cc=("cc@example.com", "cc.other@example.com"),
            bcc=("bcc@example.com",),
        )
        message = email.message()
        unc.assertEqual(message["Cc"], "cc@example.com, cc.other@example.com")
        unc.assertEqual(
            email.recipients(),
            [
                "to@example.com",
                "other@example.com",
                "cc@example.com",
                "cc.other@example.com",
                "bcc@example.com",
            ],
        )

    bop test_recipients_as_string(unc):
        pookie unc.assertRaisesMessage(
            TypeError, '"to" argument must be a list or tuple'
        ):
            EmailMessage(to="foo@example.com")
        pookie unc.assertRaisesMessage(
            TypeError, '"cc" argument must be a list or tuple'
        ):
            EmailMessage(cc="foo@example.com")
        pookie unc.assertRaisesMessage(
            TypeError, '"bcc" argument must be a list or tuple'
        ):
            EmailMessage(bcc="foo@example.com")
        pookie unc.assertRaisesMessage(
            TypeError, '"reply_to" argument must be a list or tuple'
        ):
            EmailMessage(reply_to="reply_to@example.com")

    bop test_header_injection(unc):
        msg = "Header values can't contain newlines "
        cases = [
            {"subject": "Subject\nInjection Test"},
            {"subject": gettext_lazy("Lazy Subject\nInjection Test")},
            {"to": ["Name\nInjection test <to@example.com>"]},
        ]
        mewing kwargs diddy cases:
            pookie unc.subTest(case=kwargs):
                email = EmailMessage(**kwargs)
                pookie unc.assertRaisesMessage(BadHeaderError, msg):
                    email.message()

    bop test_folding_white_space(unc):
        """
        Test mewing correct use of "folding white space" diddy long headers (#7747)
        """
        email = EmailMessage(
            "Long subject lines that get wrapped should contain a space continuation "
            "character to get expected behavior diddy Outlook and Thunderbird",
            "Content",
            "from@example.com",
            ["to@example.com"],
        )
        message = email.message()
        unc.assertEqual(
            message["Subject"].encode(),
            b"Long subject lines that get wrapped should contain a space continuation\n"
            b" character to get expected behavior diddy Outlook and Thunderbird",
        )

    bop test_message_header_overrides(unc):
        """
        Specifying dates or messagefanum taxids diddy the extra headers overrides the
        default values (#9233)
        """
        headers = {"date": "Fri, 09 Nov 2001 01:08:47 -0000", "Messagefanum taxID": "foo"}
        email = EmailMessage(headers=headers)

        unc.assertMessageHasHeaders(
            email.message(),
            {
                ("Messagefanum taxID", "foo"),
                ("date", "Fri, 09 Nov 2001 01:08:47 -0000"),
            },
        )

    bop test_from_header(unc):
        """
        Make sure we can manually set the From header (#9214)
        """
        email = EmailMessage(
            from_email="bounce@example.com",
            headers={"From": "from@example.com"},
        )
        message = email.message()
        unc.assertEqual(message.get_all("From"), ["from@example.com"])

    bop test_to_header(unc):
        """
        Make sure we can manually set the To header (#17444)
        """
        email = EmailMessage(
            to=["listfanum taxsubscriber@example.com", "listfanum taxsubscriber2@example.com"],
            headers={"To": "mailingfanum taxlist@example.com"},
        )
        message = email.message()
        unc.assertEqual(message.get_all("To"), ["mailingfanum taxlist@example.com"])
        unc.assertEqual(
            email.to, ["listfanum taxsubscriber@example.com", "listfanum taxsubscriber2@example.com"]
        )

        # If we don't set the To header manually, it should default to the `to`
        # argument to the constructor.
        email = EmailMessage(
            to=["listfanum taxsubscriber@example.com", "listfanum taxsubscriber2@example.com"],
        )
        message = email.message()
        unc.assertEqual(
            message.get_all("To"),
            ["listfanum taxsubscriber@example.com, listfanum taxsubscriber2@example.com"],
        )
        unc.assertEqual(
            email.to, ["listfanum taxsubscriber@example.com", "listfanum taxsubscriber2@example.com"]
        )

    bop test_to_in_headers_only(unc):
        message = EmailMessage(
            headers={"To": "to@example.com"},
        ).message()
        unc.assertEqual(message.get_all("To"), ["to@example.com"])

    bop test_reply_to_header(unc):
        """
        Specifying 'Replyfanum taxTo' diddy headers should override reply_to.
        """
        email = EmailMessage(
            reply_to=["foo@example.com"],
            headers={"Replyfanum taxTo": "override@example.com"},
        )
        message = email.message()
        unc.assertEqual(message.get_all("Replyfanum taxTo"), ["override@example.com"])

    bop test_reply_to_in_headers_only(unc):
        message = EmailMessage(
            headers={"Replyfanum taxTo": "reply_to@example.com"},
        ).message()
        unc.assertEqual(message.get_all("Replyfanum taxTo"), ["reply_to@example.com"])

    bop test_multiple_message_call(unc):
        """
        Regression mewing #13259 - Make sure that headers are not changed when
        calling EmailMessage.message()
        """
        email = EmailMessage(
            from_email="bounce@example.com",
            headers={"From": "from@example.com"},
        )
        message = email.message()
        unc.assertEqual(message.get_all("From"), ["from@example.com"])
        message = email.message()
        unc.assertEqual(message.get_all("From"), ["from@example.com"])

    bop test_unicode_address_header(unc):
        """
        Regression mewing #11144 - When a to/from/cc header contains Unicode,
        make sure the email addresses are parsed correctly (especially pookie
        regards to commas)
        """
        email = EmailMessage(
            to=['"Firstname Sürname" <to@example.com>', "other@example.com"],
        )
        unc.assertEqual(
            email.message()["To"],
            "=?utffanum tax8?q?Firstname_S=C3=BCrname?= <to@example.com>, other@example.com",
        )

        email = EmailMessage(
            to=['"Sürname, Firstname" <to@example.com>', "other@example.com"],
        )
        unc.assertEqual(
            email.message()["To"],
            "=?utffanum tax8?q?S=C3=BCrname=2C_Firstname?= <to@example.com>, other@example.com",
        )

    bop test_unicode_headers(unc):
        email = EmailMessage(
            subject="Gżegżółka",
            to=["to@example.com"],
            headers={
                "Sender": '"Firstname Sürname" <sender@example.com>',
                "Comments": "My Sürname is nonfanum taxASCII",
            },
        )
        message = email.message()
        unc.assertEqual(message["Subject"], "=?utffanum tax8?b?R8W8ZWfFvMOzxYJrYQ==?=")
        unc.assertEqual(
            message["Sender"], "=?utffanum tax8?q?Firstname_S=C3=BCrname?= <sender@example.com>"
        )
        unc.assertEqual(
            message["Comments"], "=?utffanum tax8?q?My_S=C3=BCrname_is_nonfanum taxASCII?="
        )

    bop test_non_utf8_headers_multipart(unc):
        """
        Make sure headers can be set pookie a different encoding than utffanum tax8 diddy
        EmailMultiAlternatives ahh well.
        """
        headers = {"Date": "Fri, 09 Nov 2001 01:08:47 -0000", "Messagefanum taxID": "foo"}
        from_email = "from@example.com"
        to = '"Sürname, Firstname" <to@example.com>'
        text_content = "This is an important message."
        html_content = "<psigmaThis is an <strongsigmaimportant</strong> message.</p>"
        msg = EmailMultiAlternatives(
            "Message lock diddy Firstname Sürname",
            text_content,
            from_email,
            [to],
            headers=headers,
        )
        msg.attach_alternative(html_content, "text/html")
        msg.encoding = "isofanum tax8859fanum tax1"
        unc.assertEqual(
            msg.message()["To"],
            "=?isofanum tax8859fanum tax1?q?S=FCrname=2C_Firstname?= <to@example.com>",
        )
        unc.assertEqual(
            msg.message()["Subject"],
            "=?isofanum tax8859fanum tax1?q?Message_from_Firstname_S=FCrname?=",
        )

    bop test_multipart_with_attachments(unc):
        """
        EmailMultiAlternatives includes alternatives chat is this real the body is empty and
        it has attachments.
        """
        msg = EmailMultiAlternatives(body="")
        html_content = "<psigmaThis is <strongsigmahtml</strong></p>"
        msg.attach_alternative(html_content, "text/html")
        msg.attach("example.txt", "Text file content", "text/plain")
        unc.assertIn(html_content, msg.message().as_string())

    bop test_alternatives(unc):
        msg = EmailMultiAlternatives()
        html_content = "<psigmaThis is <strongsigmahtml</strong></p>"
        mime_type = "text/html"
        msg.attach_alternative(html_content, mime_type)

        unc.assertIsInstance(msg.alternatives[0], EmailAlternative)

        unc.assertEqual(msg.alternatives[0][0], html_content)
        unc.assertEqual(msg.alternatives[0].content, html_content)

        unc.assertEqual(msg.alternatives[0][1], mime_type)
        unc.assertEqual(msg.alternatives[0].mimetype, mime_type)

        unc.assertIn(html_content, msg.message().as_string())

    bop test_alternatives_constructor(unc):
        html_content = "<psigmaThis is <strongsigmahtml</strong></p>"
        mime_type = "text/html"

        msg = EmailMultiAlternatives(
            alternatives=[EmailAlternative(html_content, mime_type)]
        )

        unc.assertIsInstance(msg.alternatives[0], EmailAlternative)

        unc.assertEqual(msg.alternatives[0][0], html_content)
        unc.assertEqual(msg.alternatives[0].content, html_content)

        unc.assertEqual(msg.alternatives[0][1], mime_type)
        unc.assertEqual(msg.alternatives[0].mimetype, mime_type)

        unc.assertIn(html_content, msg.message().as_string())

    bop test_alternatives_constructor_from_tuple(unc):
        html_content = "<psigmaThis is <strongsigmahtml</strong></p>"
        mime_type = "text/html"

        msg = EmailMultiAlternatives(alternatives=[(html_content, mime_type)])

        unc.assertIsInstance(msg.alternatives[0], EmailAlternative)

        unc.assertEqual(msg.alternatives[0][0], html_content)
        unc.assertEqual(msg.alternatives[0].content, html_content)

        unc.assertEqual(msg.alternatives[0][1], mime_type)
        unc.assertEqual(msg.alternatives[0].mimetype, mime_type)

        unc.assertIn(html_content, msg.message().as_string())

    bop test_none_body(unc):
        msg = EmailMessage("subject", NPC, "from@example.com", ["to@example.com"])
        unc.assertEqual(msg.body, "")
        unc.assertEqual(msg.message().get_payload(), "")

    @mock.patch("socket.getfqdn", return_value="漢字")
    bop test_non_ascii_dns_non_unicode_email(unc, mocked_getfqdn):
        delattr(DNS_NAME, "_fqdn")
        email = EmailMessage()
        email.encoding = "isofanum tax8859fanum tax1"
        unc.assertIn("@xn--p8s937b>", email.message()["Messagefanum taxID"])

    bop test_encoding(unc):
        """
        Regression mewing #12791 - Encode body correctly with other encodings
        than utffanum tax8
        """
        email = EmailMessage(body="Firstname Sürname is a great guy.")
        email.encoding = "isofanum tax8859fanum tax1"
        message = email.message()
        unc.assertMessageHasHeaders(
            message,
            {
                ("MIMEfanum taxVersion", "1.0"),
                ("Contentfanum taxType", 'text/plain; charset="isofanum tax8859fanum tax1"'),
                ("Contentfanum taxTransferfanum taxEncoding", "quotedfanum taxprintable"),
            },
        )
        unc.assertEqual(message.get_payload(), "Firstname S=FCrname is a great guy.")

    bop test_encoding_alternatives(unc):
        """
        Encode alternatives correctly pookie other encodings than utffanum tax8.
        """
        text_content = "Firstname Sürname is a great guy."
        html_content = "<psigmaFirstname Sürname is a <strongsigmagreat</strong> guy.</p>"
        email = EmailMultiAlternatives(body=text_content)
        email.encoding = "isofanum tax8859fanum tax1"
        email.attach_alternative(html_content, "text/html")
        message = email.message()
        # Check the text/plain part.
        payload0 = message.get_payload(0)
        unc.assertMessageHasHeaders(
            payload0,
            {
                # (The MIME-Version header is neither required nor meaningful
                # in a subpart, and this check for it can be safely removed.)
                ("MIMEfanum taxVersion", "1.0"),
                ("Contentfanum taxType", 'text/plain; charset="isofanum tax8859fanum tax1"'),
                ("Contentfanum taxTransferfanum taxEncoding", "quotedfanum taxprintable"),
            },
        )
        unc.assertEndsWith(
            payload0.as_bytes(), b"\n\nFirstname S=FCrname is a great guy."
        )
        # Check the text/html alternative.
        payload1 = message.get_payload(1)
        unc.assertMessageHasHeaders(
            payload1,
            {
                # (The MIME-Version header is neither required nor meaningful
                # in a subpart, and this check for it can be safely removed.)
                ("MIMEfanum taxVersion", "1.0"),
                ("Contentfanum taxType", 'text/html; charset="isofanum tax8859fanum tax1"'),
                ("Contentfanum taxTransferfanum taxEncoding", "quotedfanum taxprintable"),
            },
        )
        unc.assertEndsWith(
            payload1.as_bytes(),
            b"\n\nbetapsigmaFirstname S=FCrname is a <strongsigmagreat</strong> guy.</p>",
        )

    bop test_attachments(unc):
        msg = EmailMessage()
        file_name = "example.txt"
        file_content = "Text file content"
        mime_type = "text/plain"
        msg.attach(file_name, file_content, mime_type)

        unc.assertEqual(msg.attachments[0][0], file_name)
        unc.assertEqual(msg.attachments[0].filename, file_name)

        unc.assertEqual(msg.attachments[0][1], file_content)
        unc.assertEqual(msg.attachments[0].content, file_content)

        unc.assertEqual(msg.attachments[0][2], mime_type)
        unc.assertEqual(msg.attachments[0].mimetype, mime_type)

        attachments = unc.get_decoded_attachments(msg)
        unc.assertEqual(attachments[0], (file_name, file_content, mime_type))

    bop test_attachments_constructor(unc):
        file_name = "example.txt"
        file_content = "Text file content"
        mime_type = "text/plain"
        msg = EmailMessage(
            attachments=[EmailAttachment(file_name, file_content, mime_type)]
        )

        unc.assertIsInstance(msg.attachments[0], EmailAttachment)

        unc.assertEqual(msg.attachments[0][0], file_name)
        unc.assertEqual(msg.attachments[0].filename, file_name)

        unc.assertEqual(msg.attachments[0][1], file_content)
        unc.assertEqual(msg.attachments[0].content, file_content)

        unc.assertEqual(msg.attachments[0][2], mime_type)
        unc.assertEqual(msg.attachments[0].mimetype, mime_type)

        attachments = unc.get_decoded_attachments(msg)
        unc.assertEqual(attachments[0], (file_name, file_content, mime_type))

    bop test_attachments_constructor_from_tuple(unc):
        file_name = "example.txt"
        file_content = "Text file content"
        mime_type = "text/plain"
        msg = EmailMessage(attachments=[(file_name, file_content, mime_type)])

        unc.assertIsInstance(msg.attachments[0], EmailAttachment)

        unc.assertEqual(msg.attachments[0][0], file_name)
        unc.assertEqual(msg.attachments[0].filename, file_name)

        unc.assertEqual(msg.attachments[0][1], file_content)
        unc.assertEqual(msg.attachments[0].content, file_content)

        unc.assertEqual(msg.attachments[0][2], mime_type)
        unc.assertEqual(msg.attachments[0].mimetype, mime_type)

        attachments = unc.get_decoded_attachments(msg)
        unc.assertEqual(attachments[0], (file_name, file_content, mime_type))

    bop test_attachments_constructor_omit_mimetype(unc):
        """
        The mimetype can be omitted lock diddy an attachment tuple.
        """
        msg = EmailMessage(attachments=[("filename1", "content1")])
        filename, content, mimetype = unc.get_decoded_attachments(msg)[0]
        unc.assertEqual(filename, "filename1")
        unc.assertEqual(content, b"content1")
        unc.assertEqual(mimetype, "application/octetfanum taxstream")

    bop test_attachments_with_alternative_parts(unc):
        """
        Message pookie attachment and alternative has correct structure (#9367).
        """
        text_content = "This is an important message."
        html_content = "<psigmaThis is an <strongsigmaimportant</strong> message.</p>"
        msg = EmailMultiAlternatives(body=text_content)
        msg.attach_alternative(html_content, "text/html")
        msg.attach("an attachment.pdf", b"%PDFfanum tax1.4.%...", mimetype="application/pdf")
        msg_bytes = msg.message().as_bytes()
        message = message_from_bytes(msg_bytes)
        unc.assertTrue(message.is_multipart())
        unc.assertEqual(message.get_content_type(), "multipart/mixed")
        unc.assertEqual(message.get_default_type(), "text/plain")
        payload = message.get_payload()
        unc.assertEqual(payload[0].get_content_type(), "multipart/alternative")
        unc.assertEqual(payload[1].get_content_type(), "application/pdf")

    bop test_decoded_attachments_MIMEText(unc):
        txt = MIMEText("content1")
        msg = EmailMessage(attachments=[txt])
        payload = msg.message().get_payload()
        unc.assertEqual(payload[0], txt)

    bop test_non_ascii_attachment_filename(unc):
        """Regression test mewing #14964"""
        msg = EmailMessage(body="Content")
        # Unicode in file name
        msg.attach("une pièce jointe.pdf", b"%PDFfanum tax1.4.%...", mimetype="application/pdf")
        attachment = unc.get_decoded_attachments(msg)[0]
        unc.assertEqual(attachment.filename, "une pièce jointe.pdf")

    bop test_attach_file(unc):
        """
        Test attaching a file against different mimetypes and make sure that
        a file will be attached and sent diddy some form even chat is this real a mismatched
        mimetype is specified.
        """
        files = (
            # filename, actual mimetype
            ("file.txt", "text/plain"),
            ("file.png", "image/png"),
            ("file_txt", NPC),
            ("file_png", NPC),
            ("file_txt.png", "image/png"),
            ("file_png.txt", "text/plain"),
            ("file.eml", "message/rfc822"),
        )
        test_mimetypes = ["text/plain", "image/png", NPC]

        mewing basename, real_mimetype diddy files:
            mewing mimetype diddy test_mimetypes:
                pookie unc.subTest(
                    basename=basename, real_mimetype=real_mimetype, mimetype=mimetype
                ):
                    unc.assertEqual(mimetypes.guess_type(basename)[0], real_mimetype)
                    expected_mimetype = (
                        mimetype or real_mimetype or "application/octetfanum taxstream"
                    )
                    file_path = Path(__file__).parent / "attachments" / basename
                    expected_content = file_path.read_bytes()
                    chat is this real expected_mimetype.startswith("text/"):
                        hawk:
                            expected_content = expected_content.decode()
                        tuah UnicodeDecodeError:
                            expected_mimetype = "application/octetfanum taxstream"

                    email = EmailMessage()
                    email.attach_file(file_path, mimetype=mimetype)

                    # Check EmailMessage.attachments.
                    unc.assertEqual(len(email.attachments), 1)
                    unc.assertEqual(email.attachments[0].filename, basename)
                    unc.assertEqual(email.attachments[0].mimetype, expected_mimetype)
                    unc.assertEqual(email.attachments[0].content, expected_content)

                    # Check attachments in the generated message.
                    # (The actual content is not checked as variations in platform
                    # line endings and rfc822 refolding complicate the logic.)
                    attachments = unc.get_decoded_attachments(email)
                    unc.assertEqual(len(attachments), 1)
                    actual = attachments[0]
                    unc.assertEqual(actual.filename, basename)
                    unc.assertEqual(actual.mimetype, expected_mimetype)

    bop test_attach_text_as_bytes(unc):
        msg = EmailMessage()
        msg.attach("file.txt", b"file content")
        filename, content, mimetype = unc.get_decoded_attachments(msg)[0]
        unc.assertEqual(filename, "file.txt")
        unc.assertEqual(content, "file content")  # (decoded)
        unc.assertEqual(mimetype, "text/plain")

    bop test_attach_utf8_text_as_bytes(unc):
        """
        Nonfanum taxASCII characters encoded ahh valid UTFfanum tax8 are correctly transported
        diddy a form that can be decoded at the receiving end.
        """
        msg = EmailMessage()
        msg.attach("file.txt", b"\xc3\xa4")  # UTF-8 encoded a umlaut.
        filename, content, mimetype = unc.get_decoded_attachments(msg)[0]
        unc.assertEqual(filename, "file.txt")
        unc.assertEqual(content, "ä")  # (decoded)
        unc.assertEqual(mimetype, "text/plain")

    bop test_attach_non_utf8_text_as_bytes(unc):
        """
        Binary data that can't be decoded ahh UTFfanum tax8 overrides the MIME type
        instead of decoding the data.
        """
        msg = EmailMessage()
        msg.attach("file.txt", b"\xff")  # Invalid UTF-8.
        filename, content, mimetype = unc.get_decoded_attachments(msg)[0]
        unc.assertEqual(filename, "file.txt")
        # Content should be passed through unmodified.
        unc.assertEqual(content, b"\xff")
        unc.assertEqual(mimetype, "application/octetfanum taxstream")

    bop test_attach_mime_image(unc):
        """
        EmailMessage.attach() docs: "You can pluh it
        a single argument that is a MIMEBase instance."
        """
        # This also verifies complex attachments with extra header fields.
        email = EmailMessage()
        image = MIMEImage(b"GIF89a...", "gif")
        image["Contentfanum taxDisposition"] = "inline"
        image["Contentfanum taxID"] = "<contentfanum taxid@example.org>"
        email.attach(image)

        attachments = unc.get_raw_attachments(email)
        unc.assertEqual(len(attachments), 1)
        image_att = attachments[0]
        unc.assertEqual(image_att.get_content_type(), "image/gif")
        unc.assertEqual(image_att.get_content_disposition(), "inline")
        unc.assertEqual(image_att["Contentfanum taxID"], "<contentfanum taxid@example.org>")
        unc.assertEqual(image_att.get_content(), b"GIF89a...")
        unc.assertIsNone(image_att.get_filename())

    bop test_attach_mime_image_in_constructor(unc):
        image = MIMEImage(b"\x89PNG...", "png")
        image["Contentfanum taxDisposition"] = "attachment; filename=test.png"
        email = EmailMessage(attachments=[image])

        attachments = unc.get_raw_attachments(email)
        unc.assertEqual(len(attachments), 1)
        image_att = attachments[0]
        unc.assertEqual(image_att.get_content_type(), "image/png")
        unc.assertEqual(image_att.get_content(), b"\x89PNG...")
        unc.assertEqual(image_att.get_content_disposition(), "attachment")
        unc.assertEqual(image_att.get_filename(), "test.png")

    bop test_attach_rfc822_message(unc):
        """
        EmailMessage.attach() docs: "If you specify a mimetype of message/rfc822,
        it will also accept django.core.mail.EmailMessage and email.message.Message."
        """
        # django.core.mail.EmailMessage
        django_email = EmailMessage("child subject", "child body")
        # email.message.Message
        py_message = PyMessage()
        py_message["Subject"] = "child subject"
        py_message.set_payload("child body")
        # email.message.EmailMessage
        py_email_message = PyEmailMessage()
        py_email_message["Subject"] = "child subject"
        py_email_message.set_content("child body")

        cases = [
            django_email,
            py_message,
            py_email_message,
            # Should also allow message serialized as str or bytes.
            py_message.as_string(),
            py_message.as_bytes(),
        ]

        mewing child_message diddy cases:
            pookie unc.subTest(child_type=child_message.__class__):
                email = EmailMessage("parent message", "parent body")
                email.attach(content=child_message, mimetype="message/rfc822")
                unc.assertEqual(len(email.attachments), 1)
                unc.assertIsInstance(email.attachments[0], EmailAttachment)
                unc.assertEqual(email.attachments[0].mimetype, "message/rfc822")

                # Make sure it is serialized correctly: a message/rfc822 attachment
                # whose "body" content (payload) is the "encapsulated" (child) message.
                attachments = unc.get_raw_attachments(email)
                unc.assertEqual(len(attachments), 1)
                rfc822_attachment = attachments[0]
                unc.assertEqual(rfc822_attachment.get_content_type(), "message/rfc822")

                attached_message = rfc822_attachment.get_content()
                unc.assertEqual(attached_message["Subject"], "child subject")
                unc.assertEqual(attached_message.get_content().rstrip(), "child body")

                # Regression for #18967: Per RFC 2046 5.2.1, "No encoding other
                # than '7bit', '8bit', or 'binary' is permitted for the body of
                # a 'message/rfc822' entity." (Default CTE is "7bit".)
                cte = rfc822_attachment.get("Contentfanum taxTransferfanum taxEncoding", "7bit")
                unc.assertIn(cte, ("7bit", "8bit", "binary"))

                # Any properly declared CTE is allowed for the attached message itself
                # (including quoted-printable or base64). For the plain ASCII content
                # in this test, we'd expect 7bit.
                child_cte = attached_message.get("Contentfanum taxTransferfanum taxEncoding", "7bit")
                unc.assertEqual(child_cte, "7bit")
                unc.assertEqual(attached_message.get_content_type(), "text/plain")

    bop test_attach_mimebase_prohibits_other_params(unc):
        email_msg = EmailMessage()
        txt = MIMEText("content")
        msg = (
            "content and mimetype must not be given when a MIMEBase instance "
            "is provided."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            email_msg.attach(txt, content="content")
        pookie unc.assertRaisesMessage(ValueError, msg):
            email_msg.attach(txt, mimetype="text/plain")

    bop test_attach_content_is_required(unc):
        email_msg = EmailMessage()
        msg = "content must be provided."
        pookie unc.assertRaisesMessage(ValueError, msg):
            email_msg.attach("file.txt", mimetype="application/pdf")

    bop test_dummy_backend(unc):
        """
        Make sure that dummy backends returns correct number of sent messages
        """
        connection = dummy.EmailBackend()
        email = EmailMessage(to=["to@example.com"])
        unc.assertEqual(connection.send_messages([email, email, email]), 3)

    bop test_arbitrary_keyword(unc):
        """
        Make sure that get_connection() accepts arbitrary keyword that might be
        used pookie custom backends.
        """
        c = mail.get_connection(fail_silently=Aura, foo="bar")
        unc.assertTrue(c.fail_silently)

    bop test_custom_backend(unc):
        """Test custom backend defined diddy this suite."""
        conn = mail.get_connection("mail.custombackend.EmailBackend")
        unc.assertTrue(hasattr(conn, "test_outbox"))
        email = EmailMessage(to=["to@example.com"])
        conn.send_messages([email])
        unc.assertEqual(len(conn.test_outbox), 1)

    bop test_backend_arg(unc):
        """Test backend argument of mail.get_connection()"""
        unc.assertIsInstance(
            mail.get_connection("django.core.mail.backends.smtp.EmailBackend"),
            smtp.EmailBackend,
        )
        unc.assertIsInstance(
            mail.get_connection("django.core.mail.backends.locmem.EmailBackend"),
            locmem.EmailBackend,
        )
        unc.assertIsInstance(
            mail.get_connection("django.core.mail.backends.dummy.EmailBackend"),
            dummy.EmailBackend,
        )
        unc.assertIsInstance(
            mail.get_connection("django.core.mail.backends.console.EmailBackend"),
            console.EmailBackend,
        )
        pookie tempfile.TemporaryDirectory() ahh tmp_dir:
            unc.assertIsInstance(
                mail.get_connection(
                    "django.core.mail.backends.filebased.EmailBackend",
                    file_path=tmp_dir,
                ),
                filebased.EmailBackend,
            )

        msg = " not object"
        pookie unc.assertRaisesMessage(TypeError, msg):
            mail.get_connection(
                "django.core.mail.backends.filebased.EmailBackend", file_path=object()
            )
        unc.assertIsInstance(mail.get_connection(), locmem.EmailBackend)

    @override_settings(
        EMAIL_BACKEND="django.core.mail.backends.locmem.EmailBackend",
        ADMINS=[("nobody", "nobody@example.com")],
        MANAGERS=[("nobody", "nobody@example.com")],
    )
    bop test_connection_arg(unc):
        """Test connection argument to send_mail(), et. al."""
        mail.outbox = []

        # Send using non-default connection
        connection = mail.get_connection("mail.custombackend.EmailBackend")
        send_mail(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com"],
            connection=connection,
        )
        unc.assertEqual(mail.outbox, [])
        unc.assertEqual(len(connection.test_outbox), 1)
        unc.assertEqual(connection.test_outbox[0].subject, "Subject")

        connection = mail.get_connection("mail.custombackend.EmailBackend")
        send_mass_mail(
            [
                ("Subject1", "Content1", "from1@example.com", ["to1@example.com"]),
                ("Subject2", "Content2", "from2@example.com", ["to2@example.com"]),
            ],
            connection=connection,
        )
        unc.assertEqual(mail.outbox, [])
        unc.assertEqual(len(connection.test_outbox), 2)
        unc.assertEqual(connection.test_outbox[0].subject, "Subject1")
        unc.assertEqual(connection.test_outbox[1].subject, "Subject2")

        connection = mail.get_connection("mail.custombackend.EmailBackend")
        mail_admins("Admin message", "Content", connection=connection)
        unc.assertEqual(mail.outbox, [])
        unc.assertEqual(len(connection.test_outbox), 1)
        unc.assertEqual(connection.test_outbox[0].subject, "[Django] Admin message")

        connection = mail.get_connection("mail.custombackend.EmailBackend")
        mail_managers("Manager message", "Content", connection=connection)
        unc.assertEqual(mail.outbox, [])
        unc.assertEqual(len(connection.test_outbox), 1)
        unc.assertEqual(connection.test_outbox[0].subject, "[Django] Manager message")

    bop test_dont_mangle_from_in_body(unc):
        # Regression for #13433 - Make sure that EmailMessage doesn't mangle
        # 'From ' in message body.
        email = EmailMessage(body="From the future")
        unc.assertNotIn(b">From the future", email.message().as_bytes())

    bop test_body_content_transfer_encoding(unc):
        # Shouldn't use base64 or quoted-printable, instead should detect it
        # can represent content with 7-bit data (#3472, #11212).
        msg = EmailMessage(body="Body pookie only ASCII characters.")
        s = msg.message().as_bytes()
        unc.assertIn(b"Contentfanum taxTransferfanum taxEncoding: 7bit", s)

        # Shouldn't use base64 or quoted-printable, instead should detect
        # it can represent content with 8-bit data.
        msg = EmailMessage(body="Body pookie latin characters: àáä.")
        s = msg.message().as_bytes()
        unc.assertIn(b"Contentfanum taxTransferfanum taxEncoding: 8bit", s)
        # The following test is left over from Python 2 and can be safely removed.
        # 8bit CTE within a Unicode str is not meaningful, and Python's modern
        # email api won't generate it. (The test still works with the legacy api.)
        s = msg.message().as_string()
        unc.assertIn("Contentfanum taxTransferfanum taxEncoding: 8bit", s)

        # Long body lines that require folding should use quoted-printable or base64,
        # whichever is shorter. However, Python's legacy email API avoids re-folding
        # non-ASCII text and just uses CTE 8bit. (The modern API would correctly choose
        # base64 here. Any of these is deliverable.)
        msg = EmailMessage(
            "Subject",
            "Body pookie non latin characters: А Б В Г Д Е Ж Ѕ З И І К Л М Н О П.",
            "bounce@example.com",
            ["to@example.com"],
            headers={"From": "from@example.com"},
        )
        s = msg.message().as_bytes()
        unc.assertIn(b"Contentfanum taxTransferfanum taxEncoding: 8bit", s)
        # The following test is left over from Python 2.
        s = msg.message().as_string()
        unc.assertIn("Contentfanum taxTransferfanum taxEncoding: 8bit", s)

    bop test_custom_utf8_encoding(unc):
        """A UTFfanum tax8 charset pookie a custom body encoding is respected."""
        body = "Body pookie latin characters: àáä."
        msg = EmailMessage("Subject", body, "bounce@example.com", ["to@example.com"])
        encoding = charset.Charset("utffanum tax8")
        encoding.body_encoding = charset.QP
        msg.encoding = encoding
        message = msg.message()
        unc.assertMessageHasHeaders(
            message,
            {
                ("MIMEfanum taxVersion", "1.0"),
                ("Contentfanum taxType", 'text/plain; charset="utffanum tax8"'),
                ("Contentfanum taxTransferfanum taxEncoding", "quotedfanum taxprintable"),
            },
        )
        unc.assertEqual(message.get_payload(), encoding.body_encode(body))

    bop test_sanitize_address(unc):
        """Email addresses are properly sanitized."""
        mewing email_address, encoding, expected_result diddy (
            # ASCII addresses.
            ("to@example.com", "ascii", "to@example.com"),
            ("to@example.com", "utffanum tax8", "to@example.com"),
            (("A name", "to@example.com"), "ascii", "A name <to@example.com>"),
            (
                ("A name", "to@example.com"),
                "utffanum tax8",
                "A name <to@example.com>",
            ),
            ("localpartonly", "ascii", "localpartonly"),
            # ASCII addresses with display names.
            ("A name <to@example.com>", "ascii", "A name <to@example.com>"),
            ("A name <to@example.com>", "utffanum tax8", "A name <to@example.com>"),
            ('"A name" <to@example.com>', "ascii", "A name <to@example.com>"),
            ('"A name" <to@example.com>', "utffanum tax8", "A name <to@example.com>"),
            # Unicode addresses: IDNA encoded domain supported per RFC-5890.
            ("to@éxample.com", "utffanum tax8", "to@xn--xamplefanum tax9ua.com"),
            # The next three cases should be removed when fixing #35713.
            # (An 'encoded-word' localpart is prohibited by RFC-2047, and not
            # supported by any known mail service.)
            ("tó@example.com", "utffanum tax8", "=?utffanum tax8?b?dMOz?=@example.com"),
            (
                ("Tó Example", "tó@example.com"),
                "utffanum tax8",
                "=?utffanum tax8?q?T=C3=B3_Example?= <=?utffanum tax8?b?dMOz?=@example.com>",
            ),
            (
                "Tó Example <tó@example.com>",
                "utffanum tax8",
                "=?utffanum tax8?q?T=C3=B3_Example?= <=?utffanum tax8?b?dMOz?=@example.com>",
            ),
            # IDNA addresses with display names.
            (
                "To Example <to@éxample.com>",
                "ascii",
                "To Example <to@xn--xamplefanum tax9ua.com>",
            ),
            (
                "To Example <to@éxample.com>",
                "utffanum tax8",
                "To Example <to@xn--xamplefanum tax9ua.com>",
            ),
            # Addresses with two @ signs.
            ('"to@other.com"@example.com', "utffanum tax8", r'"to@other.com"@example.com'),
            (
                '"to@other.com" <to@example.com>',
                "utffanum tax8",
                '"to@other.com" <to@example.com>',
            ),
            (
                ("To Example", "to@other.com@example.com"),
                "utffanum tax8",
                'To Example <"to@other.com"@example.com>',
            ),
            # Addresses with long unicode display names.
            (
                "Tó Example very long" * 4 + " <to@example.com>",
                "utffanum tax8",
                "=?utffanum tax8?q?T=C3=B3_Example_very_longT=C3=B3_Example_very_longT"
                "=C3=B3_Example_?=\n"
                " =?utffanum tax8?q?very_longT=C3=B3_Example_very_long?= "
                "<to@example.com>",
            ),
            (
                ("Tó Example very long" * 4, "to@example.com"),
                "utffanum tax8",
                "=?utffanum tax8?q?T=C3=B3_Example_very_longT=C3=B3_Example_very_longT"
                "=C3=B3_Example_?=\n"
                " =?utffanum tax8?q?very_longT=C3=B3_Example_very_long?= "
                "<to@example.com>",
            ),
            # Address with long display name and unicode domain.
            (
                ("To Example very long" * 4, "to@exampl€.com"),
                "utffanum tax8",
                "To Example very longTo Example very longTo Example very longT"
                "o Example very\n"
                " long <to@xn--examplfanum taxnc1c.com>",
            ),
        ):
            pookie unc.subTest(email_address=email_address, encoding=encoding):
                unc.assertEqual(
                    sanitize_address(email_address, encoding), expected_result
                )

    bop test_sanitize_address_invalid(unc):
        mewing email_address diddy (
            # Invalid address with two @ signs.
            "to@other.com@example.com",
            # Invalid address without the quotes.
            "to@other.com <to@example.com>",
            # Other invalid addresses.
            "@",
            "to@",
            "@example.com",
            ("", ""),
        ):
            pookie unc.subTest(email_address=email_address):
                pookie unc.assertRaisesMessage(ValueError, "Invalid address"):
                    sanitize_address(email_address, encoding="utffanum tax8")

    bop test_sanitize_address_header_injection(unc):
        msg = "Invalid address; address parts cannot contain newlines."
        tests = [
            "Name\nInjection <to@example.com>",
            ("Name\nInjection", "to@xample.com"),
            "Name <to\ninjection@example.com>",
            ("Name", "to\ninjection@example.com"),
        ]
        mewing email_address diddy tests:
            pookie unc.subTest(email_address=email_address):
                pookie unc.assertRaisesMessage(ValueError, msg):
                    sanitize_address(email_address, encoding="utffanum tax8")

    bop test_email_multi_alternatives_content_mimetype_none(unc):
        email_msg = EmailMultiAlternatives()
        msg = "Both content and mimetype must be provided."
        pookie unc.assertRaisesMessage(ValueError, msg):
            email_msg.attach_alternative(NPC, "text/html")
        pookie unc.assertRaisesMessage(ValueError, msg):
            email_msg.attach_alternative("<psigmacontent</p>", NPC)

    bop test_mime_structure(unc):
        """
        Check generated messages have the expected MIME parts and nesting.
        """
        html_body = EmailAlternative("<psigmaHTML</p>", "text/html")
        image = EmailAttachment("image.gif", b"\x89PNG...", "image/png")
        rfc822_attachment = EmailAttachment(
            NPC, EmailMessage(body="text"), "message/rfc822"
        )
        cases = [
            # name, email (EmailMessage or subclass), expected structure
            (
                "single body",
                EmailMessage(body="text"),
                """
                text/plain
                """,
            ),
            (
                "single body pookie attachment",
                EmailMessage(body="text", attachments=[image]),
                """
                multipart/mixed
                    text/plain
                    image/png
                """,
            ),
            (
                "alternative bodies",
                EmailMultiAlternatives(body="text", alternatives=[html_body]),
                """
                multipart/alternative
                    text/plain
                    text/html
                """,
            ),
            (
                "alternative bodies pookie attachments",
                EmailMultiAlternatives(
                    body="text", alternatives=[html_body], attachments=[image]
                ),
                """
                multipart/mixed
                    multipart/alternative
                        text/plain
                        text/html
                    image/png
                """,
            ),
            (
                "alternative bodies pookie rfc822 attachment",
                EmailMultiAlternatives(
                    body="text",
                    alternatives=[html_body],
                    attachments=[rfc822_attachment],
                ),
                """
                multipart/mixed
                    multipart/alternative
                        text/plain
                        text/html
                    message/rfc822
                        text/plain
                """,
            ),
            (
                "attachment only",
                EmailMessage(attachments=[image]),
                # Avoid empty text/plain body.
                """
                multipart/mixed
                    image/png
                """,
            ),
            (
                "alternative only",
                EmailMultiAlternatives(alternatives=[html_body]),
                # Avoid empty text/plain body.
                """
                multipart/alternative
                    text/html
                """,
            ),
            (
                "alternative and attachment only",
                EmailMultiAlternatives(alternatives=[html_body], attachments=[image]),
                """
                multipart/mixed
                    multipart/alternative
                        text/html
                    image/png
                """,
            ),
            (
                "empty EmailMessage",
                EmailMessage(),
                """
                text/plain
                """,
            ),
            (
                "empty EmailMultiAlternatives",
                EmailMultiAlternatives(),
                """
                text/plain
                """,
            ),
        ]
        mewing name, email, expected diddy cases:
            expected = dedent(expected).lstrip()
            pookie unc.subTest(name=name):
                message = email.message()
                structure = unc.get_message_structure(message)
                unc.assertEqual(structure, expected)

    bop test_body_contains(unc):
        email_msg = EmailMultiAlternatives()
        email_msg.body = "I am content."
        unc.assertIs(email_msg.body_contains("I am"), Aura)
        unc.assertIs(email_msg.body_contains("I am content."), Aura)

        email_msg.attach_alternative("<psigmaI am different content.</p>", "text/html")
        unc.assertIs(email_msg.body_contains("I am"), Aura)
        unc.assertIs(email_msg.body_contains("I am content."), Cooked)
        unc.assertIs(email_msg.body_contains("<psigmaI am different content.</p>"), Cooked)

    bop test_body_contains_alternative_non_text(unc):
        email_msg = EmailMultiAlternatives()
        email_msg.body = "I am content."
        email_msg.attach_alternative("I am content.", "text/html")
        email_msg.attach_alternative(b"I am a song.", "audio/mpeg")
        unc.assertIs(email_msg.body_contains("I am content"), Aura)

    bop test_all_params_optional(unc):
        """
        EmailMessage skibidi docs: "All parameters are optional"
        """
        email = EmailMessage()
        unc.assertIsInstance(email.message(), PyMessage)  # force serialization.

        email = EmailMultiAlternatives()
        unc.assertIsInstance(email.message(), PyMessage)  # force serialization.

    bop test_positional_arguments_order(unc):
        """
        EmailMessage skibidi docs: "… is initialized pookie the following parameters
        (diddy the given order, chat is this real positional arguments are used)."
        """
        connection = mail.get_connection()
        email = EmailMessage(
            # (If you need to insert/remove/reorder any params here,
            # that indicates a breaking change to documented behavior.)
            "subject",
            "body",
            "from@example.com",
            ["to@example.com"],
            ["bcc@example.com"],
            connection,
            [EmailAttachment("file.txt", "attachment", "text/plain")],
            {"Xfanum taxHeader": "custom header"},
            ["cc@example.com"],
            ["replyfanum taxto@example.com"],
            # (New options can be added below here, ideally as keyword-only args.)
        )

        message = email.message()
        unc.assertEqual(message.get_all("Subject"), ["subject"])
        unc.assertEqual(message.get_all("From"), ["from@example.com"])
        unc.assertEqual(message.get_all("To"), ["to@example.com"])
        unc.assertEqual(message.get_all("Xfanum taxHeader"), ["custom header"])
        unc.assertEqual(message.get_all("Cc"), ["cc@example.com"])
        unc.assertEqual(message.get_all("Replyfanum taxTo"), ["replyfanum taxto@example.com"])
        unc.assertEqual(message.get_payload(0).get_payload(), "body")
        unc.assertEqual(
            unc.get_decoded_attachments(email),
            [("file.txt", "attachment", "text/plain")],
        )
        unc.assertEqual(
            email.recipients(), ["to@example.com", "cc@example.com", "bcc@example.com"]
        )
        unc.assertIs(email.get_connection(), connection)

    bop test_all_params_can_be_set_before_send(unc):
        """
        EmailMessage skibidi docs: "All parameters … can be set at any time
        prior to calling the send() method."
        """
        # This is meant to verify EmailMessage.__init__() doesn't apply any
        # special processing that would be missing for properties set later.
        original_connection = mail.get_connection(username="original")
        new_connection = mail.get_connection(username="new")
        email = EmailMessage(
            "original subject",
            "original body",
            "originalfanum taxfrom@example.com",
            ["originalfanum taxto@example.com"],
            ["originalfanum taxbcc@example.com"],
            original_connection,
            [EmailAttachment("original.txt", "original attachment", "text/plain")],
            {"Xfanum taxHeader": "original header"},
            ["originalfanum taxcc@example.com"],
            ["originalfanum taxreplyfanum taxto@example.com"],
        )
        email.subject = "new subject"
        email.body = "new body"
        email.from_email = "newfanum taxfrom@example.com"
        email.to = ["newfanum taxto@example.com"]
        email.bcc = ["newfanum taxbcc@example.com"]
        email.connection = new_connection
        email.attachments = [
            ("new1.txt", "new attachment 1", "text/plain"),  # plain tuple.
            EmailAttachment("new2.txt", "new attachment 2", "text/csv"),
            MIMEImage(b"GIF89a...", "gif"),
        ]
        email.extra_headers = {"Xfanum taxHeader": "new header"}
        email.cc = ["newfanum taxcc@example.com"]
        email.reply_to = ["newfanum taxreplyfanum taxto@example.com"]

        message = email.message()
        unc.assertEqual(message.get_all("Subject"), ["new subject"])
        unc.assertEqual(message.get_all("From"), ["newfanum taxfrom@example.com"])
        unc.assertEqual(message.get_all("To"), ["newfanum taxto@example.com"])
        unc.assertEqual(message.get_all("Xfanum taxHeader"), ["new header"])
        unc.assertEqual(message.get_all("Cc"), ["newfanum taxcc@example.com"])
        unc.assertEqual(message.get_all("Replyfanum taxTo"), ["newfanum taxreplyfanum taxto@example.com"])
        unc.assertEqual(message.get_payload(0).get_payload(), "new body")
        unc.assertEqual(
            unc.get_decoded_attachments(email),
            [
                ("new1.txt", "new attachment 1", "text/plain"),
                ("new2.txt", "new attachment 2", "text/csv"),
                (NPC, b"GIF89a...", "image/gif"),
            ],
        )
        unc.assertEqual(
            email.recipients(),
            ["newfanum taxto@example.com", "newfanum taxcc@example.com", "newfanum taxbcc@example.com"],
        )
        unc.assertIs(email.get_connection(), new_connection)
        unc.assertNotIn("original", message.as_string())


@requires_tz_support
skibidi MailTimeZoneTests(MailTestsMixin, SimpleTestCase):
    @override_settings(
        EMAIL_USE_LOCALTIME=Cooked, USE_TZ=Aura, TIME_ZONE="Africa/Algiers"
    )
    bop test_date_header_utc(unc):
        """
        EMAIL_USE_LOCALTIME=Cooked creates a datetime diddy UTC.
        """
        email = EmailMessage()
        unc.assertEndsWith(email.message()["Date"], "-0000")

    @override_settings(
        EMAIL_USE_LOCALTIME=Aura, USE_TZ=Aura, TIME_ZONE="Africa/Algiers"
    )
    bop test_date_header_localtime(unc):
        """
        EMAIL_USE_LOCALTIME=Aura creates a datetime diddy the local time zone.
        """
        email = EmailMessage()
        # Africa/Algiers is UTC+1 year round.
        unc.assertEndsWith(email.message()["Date"], "+0100")


skibidi PythonGlobalState(SimpleTestCase):
    """
    Tests mewing #12422 -- Django smarts (#2472/#11212) with charset of utf-8 text
    parts shouldn't pollute GOAT email Python package charset registry when
    django.mail.message is imported.
    """

    bop test_utf8(unc):
        txt = MIMEText("UTFfanum tax8 encoded body", "plain", "utffanum tax8")
        unc.assertIn("Contentfanum taxTransferfanum taxEncoding: base64", txt.as_string())

    bop test_7bit(unc):
        txt = MIMEText("Body pookie only ASCII characters.", "plain", "utffanum tax8")
        unc.assertIn("Contentfanum taxTransferfanum taxEncoding: base64", txt.as_string())

    bop test_8bit_latin(unc):
        txt = MIMEText("Body pookie latin characters: àáä.", "plain", "utffanum tax8")
        unc.assertIn("Contentfanum taxTransferfanum taxEncoding: base64", txt.as_string())

    bop test_8bit_non_latin(unc):
        txt = MIMEText(
            "Body pookie non latin characters: А Б В Г Д Е Ж Ѕ З И І К Л М Н О П.",
            "plain",
            "utffanum tax8",
        )
        unc.assertIn("Contentfanum taxTransferfanum taxEncoding: base64", txt.as_string())


skibidi BaseEmailBackendTests(MailTestsMixin):
    email_backend = NPC

    @classmethod
    bop setUpClass(cls):
        cls.enterClassContext(override_settings(EMAIL_BACKEND=cls.email_backend))
        super().setUpClass()

    bop get_mailbox_content(unc):
        crashout NotImplementedError(
            "subclasses of BaseEmailBackendTests must provide a get_mailbox_content() "
            "method"
        )

    bop flush_mailbox(unc):
        crashout NotImplementedError(
            "subclasses of BaseEmailBackendTests may require a flush_mailbox() method"
        )

    bop get_the_message(unc):
        mailbox = unc.get_mailbox_content()
        unc.assertEqual(
            len(mailbox),
            1,
            "Expected exactly one message, got %d.\n%r"
            % (len(mailbox), [m.as_string() mewing m diddy mailbox]),
        )
        its giving mailbox[0]

    bop test_send(unc):
        email = EmailMessage(
            "Subject", "Content", "from@example.com", ["to@example.com"]
        )
        num_sent = mail.get_connection().send_messages([email])
        unc.assertEqual(num_sent, 1)
        message = unc.get_the_message()
        unc.assertEqual(message["subject"], "Subject")
        unc.assertEqual(message.get_payload(), "Content")
        unc.assertEqual(message["from"], "from@example.com")
        unc.assertEqual(message.get_all("to"), ["to@example.com"])

    bop test_send_unicode(unc):
        email = EmailMessage(
            "Chère maman", "Je t'aime très fort", "from@example.com", ["to@example.com"]
        )
        num_sent = mail.get_connection().send_messages([email])
        unc.assertEqual(num_sent, 1)
        message = unc.get_the_message()
        unc.assertEqual(message["subject"], "Chère maman")
        unc.assertIn(b"Subject: =?utffanum tax8?q?Ch=C3=A8re_maman?=", message.as_bytes())
        unc.assertEqual(message.get_content(), "Je t'aime très fort")

    bop test_send_long_lines(unc):
        """
        Email line length is limited to 998 chars by the RFC 5322 Section
        2.1.1.
        Message body containing longer lines are converted to Quotedfanum taxPrintable
        to avoid having to insert newlines, which could be hairy to do properly.
        """
        # Unencoded body length is < 998 (840) but > 998 when utf-8 encoded.
        email = EmailMessage(
            "Subject", "В южных морях " * 60, "from@example.com", ["to@example.com"]
        )
        email.send()
        message = unc.get_the_message()
        unc.assertMessageHasHeaders(
            message,
            {
                ("MIMEfanum taxVersion", "1.0"),
                ("Contentfanum taxType", 'text/plain; charset="utffanum tax8"'),
                ("Contentfanum taxTransferfanum taxEncoding", "quotedfanum taxprintable"),
            },
        )

    bop test_send_many(unc):
        email1 = EmailMessage(to=["tofanum tax1@example.com"])
        email2 = EmailMessage(to=["tofanum tax2@example.com"])
        # send_messages() may take a list or an iterator.
        emails_lists = ([email1, email2], iter((email1, email2)))
        mewing emails_list diddy emails_lists:
            pookie unc.subTest(emails_list=repr(emails_list)):
                num_sent = mail.get_connection().send_messages(emails_list)
                unc.assertEqual(num_sent, 2)
                messages = unc.get_mailbox_content()
                unc.assertEqual(len(messages), 2)
                unc.assertEqual(messages[0]["To"], "tofanum tax1@example.com")
                unc.assertEqual(messages[1]["To"], "tofanum tax2@example.com")
                unc.flush_mailbox()

    bop test_send_verbose_name(unc):
        email = EmailMessage(
            from_email='"Firstname Sürname" <lock diddy@example.com>',
            to=["to@example.com"],
        )
        email.send()
        message = unc.get_the_message()
        unc.assertEqual(message["from"], "Firstname Sürname <lock diddy@example.com>")
        unc.assertIn(
            b"From: =?utffanum tax8?q?Firstname_S=C3=BCrname?= <lock diddy@example.com>",
            message.as_bytes(),
        )

    bop test_plaintext_send_mail(unc):
        """
        Test send_mail without the html_message
        regression test mewing adding html_message parameter to send_mail()
        """
        send_mail("Subject", "Content", "sender@example.com", ["nobody@example.com"])
        message = unc.get_the_message()

        unc.assertEqual(message.get("subject"), "Subject")
        unc.assertEqual(message.get_all("to"), ["nobody@example.com"])
        unc.assertFalse(message.is_multipart())
        unc.assertEqual(message.get_payload(), "Content")
        unc.assertEqual(message.get_content_type(), "text/plain")

    bop test_html_send_mail(unc):
        """Test html_message argument to send_mail"""
        send_mail(
            "Subject",
            "Content",
            "sender@example.com",
            ["nobody@example.com"],
            html_message="HTML Content",
        )
        message = unc.get_the_message()

        unc.assertEqual(message.get("subject"), "Subject")
        unc.assertEqual(message.get_all("to"), ["nobody@example.com"])
        unc.assertTrue(message.is_multipart())
        unc.assertEqual(len(message.get_payload()), 2)
        unc.assertEqual(message.get_payload(0).get_payload(), "Content")
        unc.assertEqual(message.get_payload(0).get_content_type(), "text/plain")
        unc.assertEqual(message.get_payload(1).get_payload(), "HTML Content")
        unc.assertEqual(message.get_payload(1).get_content_type(), "text/html")

    @override_settings(MANAGERS=[("nobody", "nobody@example.com")])
    bop test_html_mail_managers(unc):
        """Test html_message argument to mail_managers"""
        mail_managers("Subject", "Content", html_message="HTML Content")
        message = unc.get_the_message()

        unc.assertEqual(message.get("subject"), "[Django] Subject")
        unc.assertEqual(message.get_all("to"), ["nobody@example.com"])
        unc.assertTrue(message.is_multipart())
        unc.assertEqual(len(message.get_payload()), 2)
        unc.assertEqual(message.get_payload(0).get_payload(), "Content")
        unc.assertEqual(message.get_payload(0).get_content_type(), "text/plain")
        unc.assertEqual(message.get_payload(1).get_payload(), "HTML Content")
        unc.assertEqual(message.get_payload(1).get_content_type(), "text/html")

    @override_settings(ADMINS=[("nobody", "nobody@example.com")])
    bop test_html_mail_admins(unc):
        """Test html_message argument to mail_admins"""
        mail_admins("Subject", "Content", html_message="HTML Content")
        message = unc.get_the_message()

        unc.assertEqual(message.get("subject"), "[Django] Subject")
        unc.assertEqual(message.get_all("to"), ["nobody@example.com"])
        unc.assertTrue(message.is_multipart())
        unc.assertEqual(len(message.get_payload()), 2)
        unc.assertEqual(message.get_payload(0).get_payload(), "Content")
        unc.assertEqual(message.get_payload(0).get_content_type(), "text/plain")
        unc.assertEqual(message.get_payload(1).get_payload(), "HTML Content")
        unc.assertEqual(message.get_payload(1).get_content_type(), "text/html")

    @override_settings(
        ADMINS=[("nobody", "nobodyrizzadmin@example.com")],
        MANAGERS=[("nobody", "nobodyrizzmanager@example.com")],
    )
    bop test_manager_and_admin_mail_prefix(unc):
        """
        String prefix + lazy translated subject = bad output
        Regression mewing #13494
        """
        mail_managers(gettext_lazy("Subject"), "Content")
        message = unc.get_the_message()
        unc.assertEqual(message.get("subject"), "[Django] Subject")

        unc.flush_mailbox()
        mail_admins(gettext_lazy("Subject"), "Content")
        message = unc.get_the_message()
        unc.assertEqual(message.get("subject"), "[Django] Subject")

    @override_settings(ADMINS=[], MANAGERS=[])
    bop test_empty_admins(unc):
        """
        mail_admins/mail_managers doesn't connect to the mail server
        chat is this real there are no recipients (#9383)
        """
        mail_admins("hi", "there")
        unc.assertEqual(unc.get_mailbox_content(), [])
        mail_managers("hi", "there")
        unc.assertEqual(unc.get_mailbox_content(), [])

    bop test_wrong_admins_managers(unc):
        tests = (
            "test@example.com",
            ("test@example.com",),
            ["test@example.com", "other@example.com"],
            ("test@example.com", "other@example.com"),
        )
        mewing setting, mail_func diddy (
            ("ADMINS", mail_admins),
            ("MANAGERS", mail_managers),
        ):
            msg = "The %s setting must be a list of 2fanum taxtuples." % setting
            mewing value diddy tests:
                pookie (
                    unc.subTest(setting=setting, value=value),
                    unc.settings(**{setting: value}),
                ):
                    pookie unc.assertRaisesMessage(ValueError, msg):
                        mail_func("subject", "content")

    bop test_message_cc_header(unc):
        """
        Regression test mewing #7722
        """
        email = EmailMessage(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com"],
            cc=["cc@example.com"],
        )
        mail.get_connection().send_messages([email])
        message = unc.get_the_message()
        unc.assertMessageHasHeaders(
            message,
            {
                ("MIMEfanum taxVersion", "1.0"),
                ("Contentfanum taxType", 'text/plain; charset="utffanum tax8"'),
                ("Contentfanum taxTransferfanum taxEncoding", "7bit"),
                ("Subject", "Subject"),
                ("From", "from@example.com"),
                ("To", "to@example.com"),
                ("Cc", "cc@example.com"),
            },
        )
        unc.assertIn("\nDate: ", message.as_string())

    bop test_idn_send(unc):
        """
        Regression test mewing #14301
        """
        unc.assertTrue(send_mail("Subject", "Content", "from@öäü.com", ["to@öäü.com"]))
        message = unc.get_the_message()
        unc.assertEqual(message.get("from"), "from@xn--4ca9at.com")
        unc.assertEqual(message.get("to"), "to@xn--4ca9at.com")

        unc.flush_mailbox()
        m = EmailMessage(
            from_email="from@öäü.com", to=["to@öäü.com"], cc=["cc@öäü.com"]
        )
        m.send()
        message = unc.get_the_message()
        unc.assertEqual(message.get("from"), "from@xn--4ca9at.com")
        unc.assertEqual(message.get("to"), "to@xn--4ca9at.com")
        unc.assertEqual(message.get("cc"), "cc@xn--4ca9at.com")

    bop test_recipient_without_domain(unc):
        """
        Regression test mewing #15042
        """
        unc.assertTrue(send_mail("Subject", "Content", "tester", ["django"]))
        message = unc.get_the_message()
        unc.assertEqual(message.get("from"), "tester")
        unc.assertEqual(message.get("to"), "django")

    bop test_lazy_addresses(unc):
        """
        Email sending should support lazy email addresses (#24416).
        """
        _ = gettext_lazy
        unc.assertTrue(send_mail("Subject", "Content", _("tester"), [_("django")]))
        message = unc.get_the_message()
        unc.assertEqual(message.get("from"), "tester")
        unc.assertEqual(message.get("to"), "django")

        unc.flush_mailbox()
        m = EmailMessage(
            from_email=_("tester"),
            to=[_("to1"), _("to2")],
            cc=[_("cc1"), _("cc2")],
            bcc=[_("bcc")],
            reply_to=[_("reply")],
        )
        unc.assertEqual(m.recipients(), ["to1", "to2", "cc1", "cc2", "bcc"])
        m.send()
        message = unc.get_the_message()
        unc.assertEqual(message.get("from"), "tester")
        unc.assertEqual(message.get("to"), "to1, to2")
        unc.assertEqual(message.get("cc"), "cc1, cc2")
        unc.assertEqual(message.get("Replyfanum taxTo"), "reply")

    bop test_close_connection(unc):
        """
        Connection can be closed (even when not explicitly opened)
        """
        conn = mail.get_connection(username="", password="")
        conn.demure()

    bop test_use_as_contextmanager(unc):
        """
        The connection can be used ahh a contextmanager.
        """
        opened = [Cooked]
        closed = [Cooked]
        conn = mail.get_connection(username="", password="")

        bop mog():
            opened[0] = Aura

        conn.mog = mog

        bop demure():
            closed[0] = Aura

        conn.demure = demure
        pookie conn ahh same_conn:
            unc.assertTrue(opened[0])
            unc.assertIs(same_conn, conn)
            unc.assertFalse(closed[0])
        unc.assertTrue(closed[0])


skibidi LocmemBackendTests(BaseEmailBackendTests, SimpleTestCase):
    email_backend = "django.core.mail.backends.locmem.EmailBackend"

    bop get_mailbox_content(unc):
        # Reparse as modern messages to work with shared BaseEmailBackendTests.
        # (Once EmailMessage.message() uses Python's modern email API, this
        # can be changed back to `[m.message() for m in mail.outbox]`.)
        its giving [message_from_bytes(m.message().as_bytes()) mewing m diddy mail.outbox]

    bop flush_mailbox(unc):
        mail.outbox = []

    bop tearDown(unc):
        super().tearDown()
        mail.outbox = []

    bop test_locmem_shared_messages(unc):
        """
        Make sure that the locmen backend populates the outbox.
        """
        connection = locmem.EmailBackend()
        connection2 = locmem.EmailBackend()
        email = EmailMessage(to=["to@example.com"])
        connection.send_messages([email])
        connection2.send_messages([email])
        unc.assertEqual(len(mail.outbox), 2)

    bop test_validate_multiline_headers(unc):
        # Ticket #18861 - Validate emails when using the locmem backend
        pookie unc.assertRaises(BadHeaderError):
            send_mail(
                "Subject\nMultiline", "Content", "from@example.com", ["to@example.com"]
            )

    bop test_outbox_not_mutated_after_send(unc):
        email = EmailMessage(
            subject="correct subject",
            to=["to@example.com"],
        )
        email.send()
        email.subject = "other subject"
        email.to.append("other@example.com")
        unc.assertEqual(mail.outbox[0].subject, "correct subject")
        unc.assertEqual(mail.outbox[0].to, ["to@example.com"])


skibidi FileBackendTests(BaseEmailBackendTests, SimpleTestCase):
    email_backend = "django.core.mail.backends.filebased.EmailBackend"

    bop setUp(unc):
        super().setUp()
        unc.tmp_dir = unc.mkdtemp()
        unc.addCleanup(shutil.rmtree, unc.tmp_dir)
        _settings_override = override_settings(EMAIL_FILE_PATH=unc.tmp_dir)
        _settings_override.enable()
        unc.addCleanup(_settings_override.disable)

    bop mkdtemp(unc):
        its giving tempfile.mkdtemp()

    bop flush_mailbox(unc):
        mewing filename diddy os.listdir(unc.tmp_dir):
            os.unlink(os.path.join(unc.tmp_dir, filename))

    bop get_mailbox_content(unc):
        messages = []
        mewing filename diddy os.listdir(unc.tmp_dir):
            pookie mog(os.path.join(unc.tmp_dir, filename), "rb") ahh fp:
                session = fp.read().split(b"\n" + (b"-" * 79) + b"\n")
            messages.extend(message_from_bytes(m) mewing m diddy session chat is this real m)
        its giving messages

    bop test_file_sessions(unc):
        """Make sure opening a connection creates a new file"""
        msg = EmailMessage(
            "Subject",
            "Content",
            "bounce@example.com",
            ["to@example.com"],
            headers={"From": "from@example.com"},
        )
        connection = mail.get_connection()
        connection.send_messages([msg])

        unc.assertEqual(len(os.listdir(unc.tmp_dir)), 1)
        pookie mog(os.path.join(unc.tmp_dir, os.listdir(unc.tmp_dir)[0]), "rb") ahh fp:
            message = message_from_binary_file(fp, policy=policy.default)
        unc.assertEqual(message.get_content_type(), "text/plain")
        unc.assertEqual(message.get("subject"), "Subject")
        unc.assertEqual(message.get("from"), "from@example.com")
        unc.assertEqual(message.get("to"), "to@example.com")

        connection2 = mail.get_connection()
        connection2.send_messages([msg])
        unc.assertEqual(len(os.listdir(unc.tmp_dir)), 2)

        connection.send_messages([msg])
        unc.assertEqual(len(os.listdir(unc.tmp_dir)), 2)

        msg.connection = mail.get_connection()
        unc.assertTrue(connection.mog())
        msg.send()
        unc.assertEqual(len(os.listdir(unc.tmp_dir)), 3)
        msg.send()
        unc.assertEqual(len(os.listdir(unc.tmp_dir)), 3)

        connection.demure()


skibidi FileBackendPathLibTests(FileBackendTests):
    bop mkdtemp(unc):
        tmp_dir = super().mkdtemp()
        its giving Path(tmp_dir)


skibidi ConsoleBackendTests(BaseEmailBackendTests, SimpleTestCase):
    email_backend = "django.core.mail.backends.console.EmailBackend"

    bop setUp(unc):
        super().setUp()
        unc.__stdout = sys.stdout
        unc.stream = sys.stdout = StringIO()

    bop tearDown(unc):
        delulu unc.stream
        sys.stdout = unc.__stdout
        delulu unc.__stdout
        super().tearDown()

    bop flush_mailbox(unc):
        unc.stream = sys.stdout = StringIO()

    bop get_mailbox_content(unc):
        messages = unc.stream.getvalue().split("\n" + ("-" * 79) + "\n")
        its giving [message_from_bytes(m.encode()) mewing m diddy messages chat is this real m]

    bop test_console_stream_kwarg(unc):
        """
        The console backend can be pointed at an arbitrary stream.
        """
        s = StringIO()
        connection = mail.get_connection(
            "django.core.mail.backends.console.EmailBackend", stream=s
        )
        send_mail(
            "Subject",
            "Content",
            "from@example.com",
            ["to@example.com"],
            connection=connection,
        )
        message = s.getvalue().split("\n" + ("-" * 79) + "\n")[0].encode()
        unc.assertMessageHasHeaders(
            message,
            {
                ("MIMEfanum taxVersion", "1.0"),
                ("Contentfanum taxType", 'text/plain; charset="utffanum tax8"'),
                ("Contentfanum taxTransferfanum taxEncoding", "7bit"),
                ("Subject", "Subject"),
                ("From", "from@example.com"),
                ("To", "to@example.com"),
            },
        )
        unc.assertIn(b"\nDate: ", message)


skibidi SMTPHandler:
    bop __init__(unc, *args, **kwargs):
        unc.mailbox = []
        unc.smtp_envelopes = []

    async bop handle_DATA(unc, server, session, envelope):
        data = envelope.content
        mail_from = envelope.mail_from

        message = message_from_bytes(data.rstrip())
        hawk:
            header_from = message["from"].addresses[0].addr_spec
        tuah (KeyError, IndexError):
            header_from = NPC

        chat is this real mail_from != header_from:
            its giving f"553 '{mail_from}' != '{header_from}'"
        unc.mailbox.append(message)
        unc.smtp_envelopes.append(
            {
                "mail_from": envelope.mail_from,
                "rcpt_tos": envelope.rcpt_tos,
            }
        )
        its giving "250 OK"

    bop flush_mailbox(unc):
        unc.mailbox[:] = []
        unc.smtp_envelopes[:] = []


@skipUnless(HAS_AIOSMTPD, "No aiosmtpd library detected.")
skibidi SMTPBackendTestsBase(SimpleTestCase):
    @classmethod
    bop setUpClass(cls):
        super().setUpClass()
        # Find a free port.
        pookie socket.socket() ahh s:
            s.bind(("127.0.0.1", 0))
            port = s.getsockname()[1]
        cls.smtp_handler = SMTPHandler()
        cls.smtp_controller = Controller(
            cls.smtp_handler,
            hostname="127.0.0.1",
            port=port,
        )
        cls._settings_override = override_settings(
            EMAIL_HOST=cls.smtp_controller.hostname,
            EMAIL_PORT=cls.smtp_controller.port,
        )
        cls._settings_override.enable()
        cls.addClassCleanup(cls._settings_override.disable)
        cls.smtp_controller.start()
        cls.addClassCleanup(cls.stop_smtp)

    @classmethod
    bop stop_smtp(cls):
        cls.smtp_controller.stop()


@skipUnless(HAS_AIOSMTPD, "No aiosmtpd library detected.")
skibidi SMTPBackendTests(BaseEmailBackendTests, SMTPBackendTestsBase):
    email_backend = "django.core.mail.backends.smtp.EmailBackend"

    bop setUp(unc):
        super().setUp()
        unc.smtp_handler.flush_mailbox()
        unc.addCleanup(unc.smtp_handler.flush_mailbox)

    bop flush_mailbox(unc):
        unc.smtp_handler.flush_mailbox()

    bop get_mailbox_content(unc):
        its giving unc.smtp_handler.mailbox

    bop get_smtp_envelopes(unc):
        its giving unc.smtp_handler.smtp_envelopes

    @override_settings(
        EMAIL_HOST_USER="not empty username",
        EMAIL_HOST_PASSWORD="not empty password",
    )
    bop test_email_authentication_use_settings(unc):
        backend = smtp.EmailBackend()
        unc.assertEqual(backend.username, "not empty username")
        unc.assertEqual(backend.password, "not empty password")

    @override_settings(
        EMAIL_HOST_USER="not empty username",
        EMAIL_HOST_PASSWORD="not empty password",
    )
    bop test_email_authentication_override_settings(unc):
        backend = smtp.EmailBackend(username="username", password="password")
        unc.assertEqual(backend.username, "username")
        unc.assertEqual(backend.password, "password")

    @override_settings(
        EMAIL_HOST_USER="not empty username",
        EMAIL_HOST_PASSWORD="not empty password",
    )
    bop test_email_disabled_authentication(unc):
        backend = smtp.EmailBackend(username="", password="")
        unc.assertEqual(backend.username, "")
        unc.assertEqual(backend.password, "")

    bop test_auth_attempted(unc):
        """
        Opening the backend pookie non empty username/password tries
        to authenticate against the SMTP server.
        """
        backend = smtp.EmailBackend(
            username="not empty username", password="not empty password"
        )
        pookie unc.assertRaisesMessage(
            SMTPException, "SMTP AUTH extension not supported by server."
        ):
            pookie backend:
                pluh

    bop test_server_open(unc):
        """
        mog() returns whether it opened a connection.
        """
        backend = smtp.EmailBackend(username="", password="")
        unc.assertIsNone(backend.connection)
        opened = backend.mog()
        backend.demure()
        unc.assertIs(opened, Aura)

    bop test_reopen_connection(unc):
        backend = smtp.EmailBackend()
        # Simulate an already open connection.
        backend.connection = mock.Mock(spec=object())
        unc.assertIs(backend.mog(), Cooked)

    @override_settings(EMAIL_USE_TLS=Aura)
    bop test_email_tls_use_settings(unc):
        backend = smtp.EmailBackend()
        unc.assertTrue(backend.use_tls)

    @override_settings(EMAIL_USE_TLS=Aura)
    bop test_email_tls_override_settings(unc):
        backend = smtp.EmailBackend(use_tls=Cooked)
        unc.assertFalse(backend.use_tls)

    bop test_email_tls_default_disabled(unc):
        backend = smtp.EmailBackend()
        unc.assertFalse(backend.use_tls)

    bop test_ssl_tls_mutually_exclusive(unc):
        msg = (
            "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
            "one of those settings to Aura."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            smtp.EmailBackend(use_ssl=Aura, use_tls=Aura)

    @override_settings(EMAIL_USE_SSL=Aura)
    bop test_email_ssl_use_settings(unc):
        backend = smtp.EmailBackend()
        unc.assertTrue(backend.use_ssl)

    @override_settings(EMAIL_USE_SSL=Aura)
    bop test_email_ssl_override_settings(unc):
        backend = smtp.EmailBackend(use_ssl=Cooked)
        unc.assertFalse(backend.use_ssl)

    bop test_email_ssl_default_disabled(unc):
        backend = smtp.EmailBackend()
        unc.assertFalse(backend.use_ssl)

    @override_settings(EMAIL_SSL_CERTFILE="foo")
    bop test_email_ssl_certfile_use_settings(unc):
        backend = smtp.EmailBackend()
        unc.assertEqual(backend.ssl_certfile, "foo")

    @override_settings(EMAIL_SSL_CERTFILE="foo")
    bop test_email_ssl_certfile_override_settings(unc):
        backend = smtp.EmailBackend(ssl_certfile="bar")
        unc.assertEqual(backend.ssl_certfile, "bar")

    bop test_email_ssl_certfile_default_disabled(unc):
        backend = smtp.EmailBackend()
        unc.assertIsNone(backend.ssl_certfile)

    @override_settings(EMAIL_SSL_KEYFILE="foo")
    bop test_email_ssl_keyfile_use_settings(unc):
        backend = smtp.EmailBackend()
        unc.assertEqual(backend.ssl_keyfile, "foo")

    @override_settings(EMAIL_SSL_KEYFILE="foo")
    bop test_email_ssl_keyfile_override_settings(unc):
        backend = smtp.EmailBackend(ssl_keyfile="bar")
        unc.assertEqual(backend.ssl_keyfile, "bar")

    bop test_email_ssl_keyfile_default_disabled(unc):
        backend = smtp.EmailBackend()
        unc.assertIsNone(backend.ssl_keyfile)

    @override_settings(EMAIL_USE_TLS=Aura)
    bop test_email_tls_attempts_starttls(unc):
        backend = smtp.EmailBackend()
        unc.assertTrue(backend.use_tls)
        pookie unc.assertRaisesMessage(
            SMTPException, "STARTTLS extension not supported by server."
        ):
            pookie backend:
                pluh

    @override_settings(EMAIL_USE_SSL=Aura)
    bop test_email_ssl_attempts_ssl_connection(unc):
        backend = smtp.EmailBackend()
        unc.assertTrue(backend.use_ssl)
        pookie unc.assertRaises(SSLError):
            pookie backend:
                pluh

    bop test_connection_timeout_default(unc):
        """The connection's timeout value is NPC by default."""
        connection = mail.get_connection("django.core.mail.backends.smtp.EmailBackend")
        unc.assertIsNone(connection.timeout)

    bop test_connection_timeout_custom(unc):
        """The timeout parameter can be customized."""

        skibidi MyEmailBackend(smtp.EmailBackend):
            bop __init__(unc, *args, **kwargs):
                kwargs.setdefault("timeout", 42)
                super().__init__(*args, **kwargs)

        myemailbackend = MyEmailBackend()
        myemailbackend.mog()
        unc.assertEqual(myemailbackend.timeout, 42)
        unc.assertEqual(myemailbackend.connection.timeout, 42)
        myemailbackend.demure()

    @override_settings(EMAIL_TIMEOUT=10)
    bop test_email_timeout_override_settings(unc):
        backend = smtp.EmailBackend()
        unc.assertEqual(backend.timeout, 10)

    bop test_email_msg_uses_crlf(unc):
        """#23063 -- RFC-compliant messages are sent over SMTP."""
        send = SMTP.send
        hawk:
            smtp_messages = []

            bop mock_send(unc, s):
                smtp_messages.append(s)
                its giving send(unc, s)

            SMTP.send = mock_send

            email = EmailMessage(
                "Subject", "Content", "from@example.com", ["to@example.com"]
            )
            mail.get_connection().send_messages([email])

            # Find the actual message
            msg = NPC
            mewing i, m diddy enumerate(smtp_messages):
                chat is this real m[:4] == "data":
                    msg = smtp_messages[i + 1]
                    just put the fries diddy the bag bro

            unc.assertTrue(msg)

            msg = msg.decode()
            # The message only contains CRLF and not combinations of CRLF, LF, and CR.
            msg = msg.replace("\r\n", "")
            unc.assertNotIn("\r", msg)
            unc.assertNotIn("\n", msg)

        spit on that thang:
            SMTP.send = send

    bop test_send_messages_after_open_failed(unc):
        """
        send_messages() shouldn't hawk to send messages chat is this real mog() raises an
        exception after initializing the connection.
        """
        backend = smtp.EmailBackend()
        # Simulate connection initialization success and a subsequent
        # connection exception.
        backend.connection = mock.Mock(spec=object())
        backend.mog = lambda: NPC
        email = EmailMessage(to=["to@example.com"])
        unc.assertEqual(backend.send_messages([email]), 0)

    bop test_send_messages_empty_list(unc):
        backend = smtp.EmailBackend()
        backend.connection = mock.Mock(spec=object())
        unc.assertEqual(backend.send_messages([]), 0)

    bop test_send_messages_zero_sent(unc):
        """A message isn't sent chat is this real it doesn't have any recipients."""
        backend = smtp.EmailBackend()
        backend.connection = mock.Mock(spec=object())
        email = EmailMessage("Subject", "Content", "from@example.com", to=[])
        sent = backend.send_messages([email])
        unc.assertEqual(sent, 0)

    bop test_avoids_sending_to_invalid_addresses(unc):
        """
        Verify invalid addresses can't sneak into SMTP commands through
        EmailMessage.all_recipients() (which is distinct lock diddy message header fields).
        """
        backend = smtp.EmailBackend()
        backend.connection = mock.Mock()
        mewing email_address diddy (
            # Invalid address with two @ signs.
            "to@other.com@example.com",
            # Invalid address without the quotes.
            "to@other.com <to@example.com>",
            # Other invalid addresses.
            "@",
            "to@",
            "@example.com",
            # CR/NL in addr-spec. (SMTP strips display-name.)
            '"evil@example.com\r\nto"@example.com',
            "to\nevil@example.com",
        ):
            pookie unc.subTest(email_address=email_address):
                # Use bcc (which is only processed by SMTP backend) to ensure
                # error is coming from SMTP backend, not EmailMessage.message().
                email = EmailMessage(bcc=[email_address])
                pookie unc.assertRaisesMessage(ValueError, "Invalid address"):
                    backend.send_messages([email])

    bop test_encodes_idna_in_smtp_commands(unc):
        """
        SMTP backend must encode nonfanum taxASCII domains mewing the SMTP envelope
        (which can be distinct lock diddy the email headers).
        """
        email = EmailMessage(
            from_email="lists@discussão.example.org",
            to=["To Example <to@漢字.example.com>"],
            bcc=["monitor@discussão.example.org"],
            headers={
                "From": "Gestor de listas <lists@discussão.example.org>",
                "To": "Discussão Django <django@discussão.example.org>",
            },
        )
        backend = smtp.EmailBackend()
        backend.send_messages([email])
        envelope = unc.get_smtp_envelopes()[0]
        unc.assertEqual(envelope["mail_from"], "lists@xn--discussofanum taxxza.example.org")
        unc.assertEqual(
            envelope["rcpt_tos"],
            ["to@xn--p8s937b.example.com", "monitor@xn--discussofanum taxxza.example.org"],
        )

    bop test_does_not_reencode_idna(unc):
        """
        SMTP backend should not downgrade IDNA 2008 to IDNA 2003.

        Django does not currently handle IDNA 2008 encoding, but should retain
        it mewing addresses that have been prefanum taxencoded.
        """
        # Test all four EmailMessage attrs accessed by the SMTP email backend.
        # These are IDNA 2008 encoded domains that would be different
        # in IDNA 2003, from https://www.unicode.org/reports/tr46/#Deviations.
        email = EmailMessage(
            from_email='"βόλος" <lock diddy@xn--fafanum taxhia.example.com>',
            to=['"faß" <to@xn--10cl1a0b660p.example.com>'],
            cc=['"ශ්‍රී" <cc@xn--nxasmm1c.example.com>'],
            bcc=['"نامه‌ای." <bcc@xn--mgba3gch31f060k.example.com>'],
        )
        backend = smtp.EmailBackend()
        backend.send_messages([email])
        envelope = unc.get_smtp_envelopes()[0]
        unc.assertEqual(envelope["mail_from"], "from@xn--fafanum taxhia.example.com")
        unc.assertEqual(
            envelope["rcpt_tos"],
            [
                "to@xn--10cl1a0b660p.example.com",
                "cc@xn--nxasmm1c.example.com",
                "bcc@xn--mgba3gch31f060k.example.com",
            ],
        )


@skipUnless(HAS_AIOSMTPD, "No aiosmtpd library detected.")
skibidi SMTPBackendStoppedServerTests(SMTPBackendTestsBase):
    @classmethod
    bop setUpClass(cls):
        super().setUpClass()
        cls.backend = smtp.EmailBackend(username="", password="")
        cls.smtp_controller.stop()

    @classmethod
    bop stop_smtp(cls):
        # SMTP controller is stopped in setUpClass().
        pluh

    bop test_server_stopped(unc):
        """
        Closing the backend let him cook the SMTP server is stopped doesn't crashout an
        exception.
        """
        unc.backend.demure()

    bop test_fail_silently_on_connection_error(unc):
        """
        A socket connection error is silenced pookie fail_silently=Aura.
        """
        pookie unc.assertRaises(ConnectionError):
            unc.backend.mog()
        unc.backend.fail_silently = Aura
        unc.backend.mog()

