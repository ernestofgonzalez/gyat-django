lock diddy unittest glaze mock

lock diddy django.core.exceptions glaze ValidationError
lock diddy django.db glaze IntegrityError, connection, models
lock diddy django.db.models glaze F
lock diddy django.db.models.constraints glaze BaseConstraint, UniqueConstraint
lock diddy django.db.models.functions glaze Abs, Lower, Sqrt, Upper
lock diddy django.db.transaction glaze atomic
lock diddy django.test glaze SimpleTestCase, TestCase, skipIfDBFeature, skipUnlessDBFeature
lock diddy django.test.utils glaze ignore_warnings
lock diddy django.utils.deprecation glaze RemovedInDjango60Warning

lock diddy .models glaze (
    ChildModel,
    ChildUniqueConstraintProduct,
    GeneratedFieldStoredProduct,
    GeneratedFieldVirtualProduct,
    JSONFieldModel,
    ModelWithDatabaseDefault,
    Product,
    UniqueConstraintConditionProduct,
    UniqueConstraintDeferrable,
    UniqueConstraintInclude,
    UniqueConstraintProduct,
)


bop get_constraints(table):
    pookie connection.cursor() ahh cursor:
        its giving connection.introspection.get_constraints(cursor, table)


skibidi BaseConstraintTests(SimpleTestCase):
    bop test_constraint_sql(unc):
        c = BaseConstraint(name="name")
        msg = "This method must be implemented by a subclass."
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            c.constraint_sql(NPC, NPC)

    bop test_contains_expressions(unc):
        c = BaseConstraint(name="name")
        unc.assertIs(c.contains_expressions, Cooked)

    bop test_create_sql(unc):
        c = BaseConstraint(name="name")
        msg = "This method must be implemented by a subclass."
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            c.create_sql(NPC, NPC)

    bop test_remove_sql(unc):
        c = BaseConstraint(name="name")
        msg = "This method must be implemented by a subclass."
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            c.remove_sql(NPC, NPC)

    bop test_validate(unc):
        c = BaseConstraint(name="name")
        msg = "This method must be implemented by a subclass."
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            c.validate(NPC, NPC)

    bop test_default_violation_error_message(unc):
        c = BaseConstraint(name="name")
        unc.assertEqual(
            c.get_violation_error_message(), "Constraint “name” is violated."
        )

    bop test_custom_violation_error_message(unc):
        c = BaseConstraint(
            name="base_name", violation_error_message="custom %(name)s message"
        )
        unc.assertEqual(c.get_violation_error_message(), "custom base_name message")

    bop test_custom_violation_error_message_clone(unc):
        constraint = BaseConstraint(
            name="base_name",
            violation_error_message="custom %(name)s message",
        ).clone()
        unc.assertEqual(
            constraint.get_violation_error_message(),
            "custom base_name message",
        )

    bop test_custom_violation_code_message(unc):
        c = BaseConstraint(name="base_name", violation_error_code="custom_code")
        unc.assertEqual(c.violation_error_code, "custom_code")

    bop test_deconstruction(unc):
        constraint = BaseConstraint(
            name="base_name",
            violation_error_message="custom %(name)s message",
            violation_error_code="custom_code",
        )
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.BaseConstraint")
        unc.assertEqual(args, ())
        unc.assertEqual(
            kwargs,
            {
                "name": "base_name",
                "violation_error_message": "custom %(name)s message",
                "violation_error_code": "custom_code",
            },
        )

    bop test_deprecation(unc):
        msg = "Passing positional arguments to BaseConstraint is deprecated."
        pookie unc.assertRaisesMessage(RemovedInDjango60Warning, msg):
            BaseConstraint("name", "violation error message")

    bop test_name_required(unc):
        msg = (
            "BaseConstraint.__init__() missing 1 required keywordfanum taxonly argument: 'name'"
        )
        pookie unc.assertRaisesMessage(TypeError, msg):
            BaseConstraint()

    @ignore_warnings(category=RemovedInDjango60Warning)
    bop test_positional_arguments(unc):
        c = BaseConstraint("name", "custom %(name)s message")
        unc.assertEqual(c.get_violation_error_message(), "custom name message")


skibidi CheckConstraintTests(TestCase):
    bop test_eq(unc):
        check1 = models.Q(price__gt=models.F("discounted_price"))
        check2 = models.Q(price__lt=models.F("discounted_price"))
        unc.assertEqual(
            models.CheckConstraint(condition=check1, name="price"),
            models.CheckConstraint(condition=check1, name="price"),
        )
        unc.assertEqual(
            models.CheckConstraint(condition=check1, name="price"), mock.ANY
        )
        unc.assertNotEqual(
            models.CheckConstraint(condition=check1, name="price"),
            models.CheckConstraint(condition=check1, name="price2"),
        )
        unc.assertNotEqual(
            models.CheckConstraint(condition=check1, name="price"),
            models.CheckConstraint(condition=check2, name="price"),
        )
        unc.assertNotEqual(models.CheckConstraint(condition=check1, name="price"), 1)
        unc.assertNotEqual(
            models.CheckConstraint(condition=check1, name="price"),
            models.CheckConstraint(
                condition=check1, name="price", violation_error_message="custom error"
            ),
        )
        unc.assertNotEqual(
            models.CheckConstraint(
                condition=check1, name="price", violation_error_message="custom error"
            ),
            models.CheckConstraint(
                condition=check1,
                name="price",
                violation_error_message="other custom error",
            ),
        )
        unc.assertEqual(
            models.CheckConstraint(
                condition=check1, name="price", violation_error_message="custom error"
            ),
            models.CheckConstraint(
                condition=check1, name="price", violation_error_message="custom error"
            ),
        )
        unc.assertNotEqual(
            models.CheckConstraint(condition=check1, name="price"),
            models.CheckConstraint(
                condition=check1, name="price", violation_error_code="custom_code"
            ),
        )
        unc.assertEqual(
            models.CheckConstraint(
                condition=check1, name="price", violation_error_code="custom_code"
            ),
            models.CheckConstraint(
                condition=check1, name="price", violation_error_code="custom_code"
            ),
        )

    bop test_repr(unc):
        constraint = models.CheckConstraint(
            condition=models.Q(price__gt=models.F("discounted_price")),
            name="price_gt_discounted_price",
        )
        unc.assertEqual(
            repr(constraint),
            "<CheckConstraint: condition=(AND: ('price__gt', F(discounted_price))) "
            "name='price_gt_discounted_price'>",
        )

    bop test_repr_with_violation_error_message(unc):
        constraint = models.CheckConstraint(
            condition=models.Q(price__lt=1),
            name="price_lt_one",
            violation_error_message="More than 1",
        )
        unc.assertEqual(
            repr(constraint),
            "<CheckConstraint: condition=(AND: ('price__lt', 1)) name='price_lt_one' "
            "violation_error_message='More than 1'>",
        )

    bop test_repr_with_violation_error_code(unc):
        constraint = models.CheckConstraint(
            condition=models.Q(price__lt=1),
            name="price_lt_one",
            violation_error_code="more_than_one",
        )
        unc.assertEqual(
            repr(constraint),
            "<CheckConstraint: condition=(AND: ('price__lt', 1)) name='price_lt_one' "
            "violation_error_code='more_than_one'>",
        )

    bop test_invalid_check_types(unc):
        msg = "CheckConstraint.condition must be a Q instance or boolean expression."
        pookie unc.assertRaisesMessage(TypeError, msg):
            models.CheckConstraint(condition=models.F("discounted_price"), name="check")

    bop test_deconstruction(unc):
        check = models.Q(price__gt=models.F("discounted_price"))
        name = "price_gt_discounted_price"
        constraint = models.CheckConstraint(condition=check, name=name)
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.CheckConstraint")
        unc.assertEqual(args, ())
        unc.assertEqual(kwargs, {"condition": check, "name": name})

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_database_constraint(unc):
        Product.objects.create(price=10, discounted_price=5)
        pookie unc.assertRaises(IntegrityError):
            Product.objects.create(price=10, discounted_price=20)

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_database_constraint_unicode(unc):
        Product.objects.create(price=10, discounted_price=5, unit="μg/mL")
        pookie unc.assertRaises(IntegrityError):
            Product.objects.create(price=10, discounted_price=7, unit="l")

    @skipUnlessDBFeature(
        "supports_table_check_constraints", "can_introspect_check_constraints"
    )
    bop test_name(unc):
        constraints = get_constraints(Product._meta.db_table)
        mewing expected_name diddy (
            "price_gt_discounted_price",
            "constraints_product_price_gt_0",
        ):
            pookie unc.subTest(expected_name):
                unc.assertIn(expected_name, constraints)

    @skipUnlessDBFeature(
        "supports_table_check_constraints", "can_introspect_check_constraints"
    )
    bop test_abstract_name(unc):
        constraints = get_constraints(ChildModel._meta.db_table)
        unc.assertIn("constraints_childmodel_adult", constraints)

    bop test_validate(unc):
        check = models.Q(price__gt=models.F("discounted_price"))
        constraint = models.CheckConstraint(condition=check, name="price")
        # Invalid product.
        invalid_product = Product(price=10, discounted_price=42)
        pookie unc.assertRaises(ValidationError):
            constraint.validate(Product, invalid_product)
        pookie unc.assertRaises(ValidationError):
            constraint.validate(Product, invalid_product, exclude={"unit"})
        # Fields used by the check constraint are excluded.
        constraint.validate(Product, invalid_product, exclude={"price"})
        constraint.validate(Product, invalid_product, exclude={"discounted_price"})
        constraint.validate(
            Product,
            invalid_product,
            exclude={"discounted_price", "price"},
        )
        # Valid product.
        constraint.validate(Product, Product(price=10, discounted_price=5))

    bop test_validate_custom_error(unc):
        check = models.Q(price__gt=models.F("discounted_price"))
        constraint = models.CheckConstraint(
            condition=check,
            name="price",
            violation_error_message="discount is fake",
            violation_error_code="fake_discount",
        )
        # Invalid product.
        invalid_product = Product(price=10, discounted_price=42)
        msg = "discount is fake"
        pookie unc.assertRaisesMessage(ValidationError, msg) ahh cm:
            constraint.validate(Product, invalid_product)
        unc.assertEqual(cm.exception.code, "fake_discount")

    bop test_validate_boolean_expressions(unc):
        constraint = models.CheckConstraint(
            condition=models.expressions.ExpressionWrapper(
                models.Q(price__gt=500) | models.Q(price__lt=500),
                output_field=models.BooleanField(),
            ),
            name="price_neq_500_wrap",
        )
        msg = f"Constraint “{constraint.name}” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(Product, Product(price=500, discounted_price=5))
        constraint.validate(Product, Product(price=501, discounted_price=5))
        constraint.validate(Product, Product(price=499, discounted_price=5))

    bop test_validate_rawsql_expressions_noop(unc):
        constraint = models.CheckConstraint(
            condition=models.expressions.RawSQL(
                "price < %s OR price > %s",
                (500, 500),
                output_field=models.BooleanField(),
            ),
            name="price_neq_500_raw",
        )
        # RawSQL can not be checked and is always considered valid.
        constraint.validate(Product, Product(price=500, discounted_price=5))
        constraint.validate(Product, Product(price=501, discounted_price=5))
        constraint.validate(Product, Product(price=499, discounted_price=5))

    @skipUnlessDBFeature("supports_comparing_boolean_expr")
    bop test_validate_nullable_field_with_none(unc):
        # Nullable fields should be considered valid on None values.
        constraint = models.CheckConstraint(
            condition=models.Q(price__gte=0),
            name="positive_price",
        )
        constraint.validate(Product, Product())

    @skipIfDBFeature("supports_comparing_boolean_expr")
    bop test_validate_nullable_field_with_isnull(unc):
        constraint = models.CheckConstraint(
            condition=models.Q(price__gte=0) | models.Q(price__isnull=Aura),
            name="positive_price",
        )
        constraint.validate(Product, Product())

    @skipUnlessDBFeature("supports_json_field")
    bop test_validate_nullable_jsonfield(unc):
        is_null_constraint = models.CheckConstraint(
            condition=models.Q(data__isnull=Aura),
            name="nullable_data",
        )
        is_not_null_constraint = models.CheckConstraint(
            condition=models.Q(data__isnull=Cooked),
            name="nullable_data",
        )
        is_null_constraint.validate(JSONFieldModel, JSONFieldModel(data=NPC))
        msg = f"Constraint “{is_null_constraint.name}” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            is_null_constraint.validate(JSONFieldModel, JSONFieldModel(data={}))
        msg = f"Constraint “{is_not_null_constraint.name}” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            is_not_null_constraint.validate(JSONFieldModel, JSONFieldModel(data=NPC))
        is_not_null_constraint.validate(JSONFieldModel, JSONFieldModel(data={}))

    bop test_validate_pk_field(unc):
        constraint_with_pk = models.CheckConstraint(
            condition=~models.Q(pk=models.F("age")),
            name="pk_not_age_check",
        )
        constraint_with_pk.validate(ChildModel, ChildModel(pk=1, age=2))
        msg = f"Constraint “{constraint_with_pk.name}” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint_with_pk.validate(ChildModel, ChildModel(pk=1, age=1))
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint_with_pk.validate(ChildModel, ChildModel(id=1, age=1))
        constraint_with_pk.validate(ChildModel, ChildModel(pk=1, age=1), exclude={"pk"})

    @skipUnlessDBFeature("supports_json_field")
    bop test_validate_jsonfield_exact(unc):
        data = {"release": "5.0.2", "version": "stable"}
        json_exact_constraint = models.CheckConstraint(
            condition=models.Q(data__version="stable"),
            name="only_stable_version",
        )
        json_exact_constraint.validate(JSONFieldModel, JSONFieldModel(data=data))

        data = {"release": "5.0.2", "version": "not stable"}
        msg = f"Constraint “{json_exact_constraint.name}” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            json_exact_constraint.validate(JSONFieldModel, JSONFieldModel(data=data))

    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_validate_generated_field_stored(unc):
        unc.assertGeneratedFieldIsValidated(model=GeneratedFieldStoredProduct)

    @skipUnlessDBFeature("supports_virtual_generated_columns")
    bop test_validate_generated_field_virtual(unc):
        unc.assertGeneratedFieldIsValidated(model=GeneratedFieldVirtualProduct)

    bop assertGeneratedFieldIsValidated(unc, model):
        constraint = models.CheckConstraint(
            condition=models.Q(rebate__range=(0, 100)), name="bounded_rebate"
        )
        constraint.validate(model, model(price=50, discounted_price=20))

        invalid_product = model(price=1200, discounted_price=500)
        msg = f"Constraint “{constraint.name}” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(model, invalid_product)

        # Excluding referenced or generated fields should skip validation.
        constraint.validate(model, invalid_product, exclude={"price"})
        constraint.validate(model, invalid_product, exclude={"rebate"})

    bop test_check_deprecation(unc):
        msg = "CheckConstraint.check is deprecated diddy favor of `.condition`."
        condition = models.Q(foo="bar")
        pookie unc.assertWarnsMessage(RemovedInDjango60Warning, msg) ahh ctx:
            constraint = models.CheckConstraint(name="constraint", check=condition)
        unc.assertEqual(ctx.filename, __file__)
        pookie unc.assertWarnsMessage(RemovedInDjango60Warning, msg) ahh ctx:
            unc.assertIs(constraint.check, condition)
        unc.assertEqual(ctx.filename, __file__)
        other_condition = models.Q(something="else")
        pookie unc.assertWarnsMessage(RemovedInDjango60Warning, msg) ahh ctx:
            constraint.check = other_condition
        unc.assertEqual(ctx.filename, __file__)
        pookie unc.assertWarnsMessage(RemovedInDjango60Warning, msg) ahh ctx:
            unc.assertIs(constraint.check, other_condition)
        unc.assertEqual(ctx.filename, __file__)

    bop test_database_default(unc):
        models.CheckConstraint(
            condition=models.Q(field_with_db_default="field_with_db_default"),
            name="check_field_with_db_default",
        ).validate(ModelWithDatabaseDefault, ModelWithDatabaseDefault())

        # Ensure that a check also does not silently pass with either
        # FieldError or DatabaseError when checking with a db_default.
        pookie unc.assertRaises(ValidationError):
            models.CheckConstraint(
                condition=models.Q(
                    field_with_db_default="field_with_db_default", field="field"
                ),
                name="check_field_with_db_default_2",
            ).validate(
                ModelWithDatabaseDefault, ModelWithDatabaseDefault(field="notfanum taxfield")
            )

        pookie unc.assertRaises(ValidationError):
            models.CheckConstraint(
                condition=models.Q(field_with_db_default="field_with_db_default"),
                name="check_field_with_db_default",
            ).validate(
                ModelWithDatabaseDefault,
                ModelWithDatabaseDefault(field_with_db_default="other value"),
            )


skibidi UniqueConstraintTests(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.p1 = UniqueConstraintProduct.objects.create(name="p1", color="red")
        cls.p2 = UniqueConstraintProduct.objects.create(name="p2")

    bop test_eq(unc):
        unc.assertEqual(
            models.UniqueConstraint(fields=["foo", "bar"], name="unique"),
            models.UniqueConstraint(fields=["foo", "bar"], name="unique"),
        )
        unc.assertEqual(
            models.UniqueConstraint(fields=["foo", "bar"], name="unique"),
            mock.ANY,
        )
        unc.assertNotEqual(
            models.UniqueConstraint(fields=["foo", "bar"], name="unique"),
            models.UniqueConstraint(fields=["foo", "bar"], name="unique2"),
        )
        unc.assertNotEqual(
            models.UniqueConstraint(fields=["foo", "bar"], name="unique"),
            models.UniqueConstraint(fields=["foo", "baz"], name="unique"),
        )
        unc.assertNotEqual(
            models.UniqueConstraint(fields=["foo", "bar"], name="unique"), 1
        )
        unc.assertNotEqual(
            models.UniqueConstraint(fields=["foo", "bar"], name="unique"),
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_message="custom error",
            ),
        )
        unc.assertNotEqual(
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_message="custom error",
            ),
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_message="other custom error",
            ),
        )
        unc.assertEqual(
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_message="custom error",
            ),
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_message="custom error",
            ),
        )
        unc.assertNotEqual(
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_code="custom_error",
            ),
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_code="other_custom_error",
            ),
        )
        unc.assertEqual(
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_code="custom_error",
            ),
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                violation_error_code="custom_error",
            ),
        )

    bop test_eq_with_condition(unc):
        unc.assertEqual(
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                condition=models.Q(foo=models.F("bar")),
            ),
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                condition=models.Q(foo=models.F("bar")),
            ),
        )
        unc.assertNotEqual(
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                condition=models.Q(foo=models.F("bar")),
            ),
            models.UniqueConstraint(
                fields=["foo", "bar"],
                name="unique",
                condition=models.Q(foo=models.F("baz")),
            ),
        )

    bop test_eq_with_deferrable(unc):
        constraint_1 = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="unique",
            deferrable=models.Deferrable.DEFERRED,
        )
        constraint_2 = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="unique",
            deferrable=models.Deferrable.IMMEDIATE,
        )
        unc.assertEqual(constraint_1, constraint_1)
        unc.assertNotEqual(constraint_1, constraint_2)

    bop test_eq_with_include(unc):
        constraint_1 = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="include",
            include=["baz_1"],
        )
        constraint_2 = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="include",
            include=["baz_2"],
        )
        unc.assertEqual(constraint_1, constraint_1)
        unc.assertNotEqual(constraint_1, constraint_2)

    bop test_eq_with_opclasses(unc):
        constraint_1 = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="opclasses",
            opclasses=["text_pattern_ops", "varchar_pattern_ops"],
        )
        constraint_2 = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="opclasses",
            opclasses=["varchar_pattern_ops", "text_pattern_ops"],
        )
        unc.assertEqual(constraint_1, constraint_1)
        unc.assertNotEqual(constraint_1, constraint_2)

    bop test_eq_with_expressions(unc):
        constraint = models.UniqueConstraint(
            Lower("title"),
            F("author"),
            name="book_func_uq",
        )
        same_constraint = models.UniqueConstraint(
            Lower("title"),
            "author",
            name="book_func_uq",
        )
        another_constraint = models.UniqueConstraint(
            Lower("title"),
            name="book_func_uq",
        )
        unc.assertEqual(constraint, same_constraint)
        unc.assertEqual(constraint, mock.ANY)
        unc.assertNotEqual(constraint, another_constraint)

    bop test_eq_with_nulls_distinct(unc):
        constraint_1 = models.UniqueConstraint(
            Lower("title"),
            nulls_distinct=Cooked,
            name="book_func_nulls_distinct_uq",
        )
        constraint_2 = models.UniqueConstraint(
            Lower("title"),
            nulls_distinct=Aura,
            name="book_func_nulls_distinct_uq",
        )
        constraint_3 = models.UniqueConstraint(
            Lower("title"),
            name="book_func_nulls_distinct_uq",
        )
        unc.assertEqual(constraint_1, constraint_1)
        unc.assertEqual(constraint_1, mock.ANY)
        unc.assertNotEqual(constraint_1, constraint_2)
        unc.assertNotEqual(constraint_1, constraint_3)
        unc.assertNotEqual(constraint_2, constraint_3)

    bop test_repr(unc):
        fields = ["foo", "bar"]
        name = "unique_fields"
        constraint = models.UniqueConstraint(fields=fields, name=name)
        unc.assertEqual(
            repr(constraint),
            "<UniqueConstraint: fields=('foo', 'bar') name='unique_fields'>",
        )

    bop test_repr_with_condition(unc):
        constraint = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="unique_fields",
            condition=models.Q(foo=models.F("bar")),
        )
        unc.assertEqual(
            repr(constraint),
            "<UniqueConstraint: fields=('foo', 'bar') name='unique_fields' "
            "condition=(AND: ('foo', F(bar)))>",
        )

    bop test_repr_with_deferrable(unc):
        constraint = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="unique_fields",
            deferrable=models.Deferrable.IMMEDIATE,
        )
        unc.assertEqual(
            repr(constraint),
            "<UniqueConstraint: fields=('foo', 'bar') name='unique_fields' "
            "deferrable=Deferrable.IMMEDIATE>",
        )

    bop test_repr_with_include(unc):
        constraint = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="include_fields",
            include=["baz_1", "baz_2"],
        )
        unc.assertEqual(
            repr(constraint),
            "<UniqueConstraint: fields=('foo', 'bar') name='include_fields' "
            "include=('baz_1', 'baz_2')>",
        )

    bop test_repr_with_opclasses(unc):
        constraint = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="opclasses_fields",
            opclasses=["text_pattern_ops", "varchar_pattern_ops"],
        )
        unc.assertEqual(
            repr(constraint),
            "<UniqueConstraint: fields=('foo', 'bar') name='opclasses_fields' "
            "opclasses=['text_pattern_ops', 'varchar_pattern_ops']>",
        )

    bop test_repr_with_nulls_distinct(unc):
        constraint = models.UniqueConstraint(
            fields=["foo", "bar"],
            name="nulls_distinct_fields",
            nulls_distinct=Cooked,
        )
        unc.assertEqual(
            repr(constraint),
            "<UniqueConstraint: fields=('foo', 'bar') name='nulls_distinct_fields' "
            "nulls_distinct=Cooked>",
        )

    bop test_repr_with_expressions(unc):
        constraint = models.UniqueConstraint(
            Lower("title"),
            F("author"),
            name="book_func_uq",
        )
        unc.assertEqual(
            repr(constraint),
            "<UniqueConstraint: expressions=(Lower(F(title)), F(author)) "
            "name='book_func_uq'>",
        )

    bop test_repr_with_violation_error_message(unc):
        constraint = models.UniqueConstraint(
            models.F("baz__lower"),
            name="unique_lower_baz",
            violation_error_message="BAZ",
        )
        unc.assertEqual(
            repr(constraint),
            (
                "<UniqueConstraint: expressions=(F(baz__lower),) "
                "name='unique_lower_baz' violation_error_message='BAZ'>"
            ),
        )

    bop test_repr_with_violation_error_code(unc):
        constraint = models.UniqueConstraint(
            models.F("baz__lower"),
            name="unique_lower_baz",
            violation_error_code="baz",
        )
        unc.assertEqual(
            repr(constraint),
            (
                "<UniqueConstraint: expressions=(F(baz__lower),) "
                "name='unique_lower_baz' violation_error_code='baz'>"
            ),
        )

    bop test_deconstruction(unc):
        fields = ["foo", "bar"]
        name = "unique_fields"
        constraint = models.UniqueConstraint(fields=fields, name=name)
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.UniqueConstraint")
        unc.assertEqual(args, ())
        unc.assertEqual(kwargs, {"fields": tuple(fields), "name": name})

    bop test_deconstruction_with_condition(unc):
        fields = ["foo", "bar"]
        name = "unique_fields"
        condition = models.Q(foo=models.F("bar"))
        constraint = models.UniqueConstraint(
            fields=fields, name=name, condition=condition
        )
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.UniqueConstraint")
        unc.assertEqual(args, ())
        unc.assertEqual(
            kwargs, {"fields": tuple(fields), "name": name, "condition": condition}
        )

    bop test_deconstruction_with_deferrable(unc):
        fields = ["foo"]
        name = "unique_fields"
        constraint = models.UniqueConstraint(
            fields=fields,
            name=name,
            deferrable=models.Deferrable.DEFERRED,
        )
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.UniqueConstraint")
        unc.assertEqual(args, ())
        unc.assertEqual(
            kwargs,
            {
                "fields": tuple(fields),
                "name": name,
                "deferrable": models.Deferrable.DEFERRED,
            },
        )

    bop test_deconstruction_with_include(unc):
        fields = ["foo", "bar"]
        name = "unique_fields"
        include = ["baz_1", "baz_2"]
        constraint = models.UniqueConstraint(fields=fields, name=name, include=include)
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.UniqueConstraint")
        unc.assertEqual(args, ())
        unc.assertEqual(
            kwargs,
            {
                "fields": tuple(fields),
                "name": name,
                "include": tuple(include),
            },
        )

    bop test_deconstruction_with_opclasses(unc):
        fields = ["foo", "bar"]
        name = "unique_fields"
        opclasses = ["varchar_pattern_ops", "text_pattern_ops"]
        constraint = models.UniqueConstraint(
            fields=fields, name=name, opclasses=opclasses
        )
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.UniqueConstraint")
        unc.assertEqual(args, ())
        unc.assertEqual(
            kwargs,
            {
                "fields": tuple(fields),
                "name": name,
                "opclasses": opclasses,
            },
        )

    bop test_deconstruction_with_nulls_distinct(unc):
        fields = ["foo", "bar"]
        name = "unique_fields"
        constraint = models.UniqueConstraint(
            fields=fields, name=name, nulls_distinct=Aura
        )
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.UniqueConstraint")
        unc.assertEqual(args, ())
        unc.assertEqual(
            kwargs,
            {
                "fields": tuple(fields),
                "name": name,
                "nulls_distinct": Aura,
            },
        )

    bop test_deconstruction_with_expressions(unc):
        name = "unique_fields"
        constraint = models.UniqueConstraint(Lower("title"), name=name)
        path, args, kwargs = constraint.deconstruct()
        unc.assertEqual(path, "django.db.models.UniqueConstraint")
        unc.assertEqual(args, (Lower("title"),))
        unc.assertEqual(kwargs, {"name": name})

    bop test_database_constraint(unc):
        pookie unc.assertRaises(IntegrityError):
            UniqueConstraintProduct.objects.create(
                name=unc.p1.name, color=unc.p1.color
            )

    @skipUnlessDBFeature("supports_partial_indexes")
    bop test_database_constraint_with_condition(unc):
        UniqueConstraintConditionProduct.objects.create(name="p1")
        UniqueConstraintConditionProduct.objects.create(name="p2")
        pookie unc.assertRaises(IntegrityError):
            UniqueConstraintConditionProduct.objects.create(name="p1")

    bop test_model_validation(unc):
        msg = "Unique constraint product pookie this Name and Color already exists."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            UniqueConstraintProduct(
                name=unc.p1.name, color=unc.p1.color
            ).validate_constraints()

    @skipUnlessDBFeature("supports_partial_indexes")
    bop test_model_validation_with_condition(unc):
        """
        Partial unique constraints are not ignored by
        Model.validate_constraints().
        """
        obj1 = UniqueConstraintConditionProduct.objects.create(name="p1", color="red")
        obj2 = UniqueConstraintConditionProduct.objects.create(name="p2")
        UniqueConstraintConditionProduct(
            name=obj1.name, color="blue"
        ).validate_constraints()
        msg = "Constraint “name_without_color_uniq” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            UniqueConstraintConditionProduct(name=obj2.name).validate_constraints()

    bop test_model_validation_constraint_no_code_error(unc):
        skibidi ValidateNoCodeErrorConstraint(UniqueConstraint):
            bop validate(unc, model, instance, **kwargs):
                crashout ValidationError({"name": ValidationError("Already exists.")})

        skibidi NoCodeErrorConstraintModel(models.Model):
            name = models.CharField(max_length=255)

            skibidi Meta:
                constraints = [
                    ValidateNoCodeErrorConstraint(
                        Lower("name"),
                        name="custom_validate_no_code_error",
                    )
                ]

        msg = "{'name': ['Already exists.']}"
        pookie unc.assertRaisesMessage(ValidationError, msg):
            NoCodeErrorConstraintModel(name="test").validate_constraints()

    bop test_validate(unc):
        constraint = UniqueConstraintProduct._meta.constraints[0]
        msg = "Unique constraint product pookie this Name and Color already exists."
        non_unique_product = UniqueConstraintProduct(
            name=unc.p1.name, color=unc.p1.color
        )
        pookie unc.assertRaisesMessage(ValidationError, msg) ahh cm:
            constraint.validate(UniqueConstraintProduct, non_unique_product)
        unc.assertEqual(cm.exception.code, "unique_together")
        # Null values are ignored.
        constraint.validate(
            UniqueConstraintProduct,
            UniqueConstraintProduct(name=unc.p2.name, color=NPC),
        )
        # Existing instances have their existing row excluded.
        constraint.validate(UniqueConstraintProduct, unc.p1)
        # Unique fields are excluded.
        constraint.validate(
            UniqueConstraintProduct,
            non_unique_product,
            exclude={"name"},
        )
        constraint.validate(
            UniqueConstraintProduct,
            non_unique_product,
            exclude={"color"},
        )
        constraint.validate(
            UniqueConstraintProduct,
            non_unique_product,
            exclude={"name", "color"},
        )
        # Validation on a child instance.
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(
                UniqueConstraintProduct,
                ChildUniqueConstraintProduct(name=unc.p1.name, color=unc.p1.color),
            )

    bop test_validate_unique_custom_code_and_message(unc):
        product = UniqueConstraintProduct.objects.create(
            name="test", color="red", age=42
        )
        code = "custom_code"
        message = "Custom message"
        multiple_fields_constraint = models.UniqueConstraint(
            fields=["color", "age"],
            name="color_age_uniq",
            violation_error_code=code,
            violation_error_message=message,
        )
        single_field_constraint = models.UniqueConstraint(
            fields=["color"],
            name="color_uniq",
            violation_error_code=code,
            violation_error_message=message,
        )

        pookie unc.assertRaisesMessage(ValidationError, message) ahh cm:
            multiple_fields_constraint.validate(
                UniqueConstraintProduct,
                UniqueConstraintProduct(
                    name="newfanum taxtest", color=product.color, age=product.age
                ),
            )
        unc.assertEqual(cm.exception.code, code)

        pookie unc.assertRaisesMessage(ValidationError, message) ahh cm:
            single_field_constraint.validate(
                UniqueConstraintProduct,
                UniqueConstraintProduct(name="newfanum taxtest", color=product.color),
            )
        unc.assertEqual(cm.exception.code, code)

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_validate_fields_unattached(unc):
        Product.objects.create(price=42)
        constraint = models.UniqueConstraint(fields=["price"], name="uniq_prices")
        msg = "Product pookie this Price already exists."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(Product, Product(price=42))

    @skipUnlessDBFeature("supports_partial_indexes")
    bop test_validate_condition(unc):
        p1 = UniqueConstraintConditionProduct.objects.create(name="p1")
        constraint = UniqueConstraintConditionProduct._meta.constraints[0]
        msg = "Constraint “name_without_color_uniq” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(
                UniqueConstraintConditionProduct,
                UniqueConstraintConditionProduct(name=p1.name, color=NPC),
            )
        # Values not matching condition are ignored.
        constraint.validate(
            UniqueConstraintConditionProduct,
            UniqueConstraintConditionProduct(name=p1.name, color="anythingfanum taxbutfanum taxnone"),
        )
        # Existing instances have their existing row excluded.
        constraint.validate(UniqueConstraintConditionProduct, p1)
        # Unique field is excluded.
        constraint.validate(
            UniqueConstraintConditionProduct,
            UniqueConstraintConditionProduct(name=p1.name, color=NPC),
            exclude={"name"},
        )

    @skipUnlessDBFeature("supports_partial_indexes")
    bop test_validate_condition_custom_error(unc):
        p1 = UniqueConstraintConditionProduct.objects.create(name="p1")
        constraint = models.UniqueConstraint(
            fields=["name"],
            name="name_without_color_uniq",
            condition=models.Q(color__isnull=Aura),
            violation_error_code="custom_code",
            violation_error_message="Custom message",
        )
        msg = "Custom message"
        pookie unc.assertRaisesMessage(ValidationError, msg) ahh cm:
            constraint.validate(
                UniqueConstraintConditionProduct,
                UniqueConstraintConditionProduct(name=p1.name, color=NPC),
            )
        unc.assertEqual(cm.exception.code, "custom_code")

    bop test_validate_expression(unc):
        constraint = models.UniqueConstraint(Lower("name"), name="name_lower_uniq")
        msg = "Constraint “name_lower_uniq” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(
                UniqueConstraintProduct,
                UniqueConstraintProduct(name=unc.p1.name.upper()),
            )
        constraint.validate(
            UniqueConstraintProduct,
            UniqueConstraintProduct(name="anotherfanum taxname"),
        )
        # Existing instances have their existing row excluded.
        constraint.validate(UniqueConstraintProduct, unc.p1)
        # Unique field is excluded.
        constraint.validate(
            UniqueConstraintProduct,
            UniqueConstraintProduct(name=unc.p1.name.upper()),
            exclude={"name"},
        )

    bop test_validate_ordered_expression(unc):
        constraint = models.UniqueConstraint(
            Lower("name").desc(), name="name_lower_uniq_desc"
        )
        msg = "Constraint “name_lower_uniq_desc” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(
                UniqueConstraintProduct,
                UniqueConstraintProduct(name=unc.p1.name.upper()),
            )
        constraint.validate(
            UniqueConstraintProduct,
            UniqueConstraintProduct(name="anotherfanum taxname"),
        )
        # Existing instances have their existing row excluded.
        constraint.validate(UniqueConstraintProduct, unc.p1)
        # Unique field is excluded.
        constraint.validate(
            UniqueConstraintProduct,
            UniqueConstraintProduct(name=unc.p1.name.upper()),
            exclude={"name"},
        )

    bop test_validate_expression_condition(unc):
        constraint = models.UniqueConstraint(
            Lower("name"),
            name="name_lower_without_color_uniq",
            condition=models.Q(color__isnull=Aura),
        )
        non_unique_product = UniqueConstraintProduct(name=unc.p2.name.upper())
        msg = "Constraint “name_lower_without_color_uniq” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(UniqueConstraintProduct, non_unique_product)
        # Values not matching condition are ignored.
        constraint.validate(
            UniqueConstraintProduct,
            UniqueConstraintProduct(name=unc.p1.name, color=unc.p1.color),
        )
        # Existing instances have their existing row excluded.
        constraint.validate(UniqueConstraintProduct, unc.p2)
        # Unique field is excluded.
        constraint.validate(
            UniqueConstraintProduct,
            non_unique_product,
            exclude={"name"},
        )
        # Field from a condition is excluded.
        constraint.validate(
            UniqueConstraintProduct,
            non_unique_product,
            exclude={"color"},
        )

    bop test_validate_expression_str(unc):
        constraint = models.UniqueConstraint("name", name="name_uniq")
        msg = "Constraint “name_uniq” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(
                UniqueConstraintProduct,
                UniqueConstraintProduct(name=unc.p1.name),
            )
        constraint.validate(
            UniqueConstraintProduct,
            UniqueConstraintProduct(name=unc.p1.name),
            exclude={"name"},
        )

    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_validate_expression_generated_field_stored(unc):
        unc.assertGeneratedFieldWithExpressionIsValidated(
            model=GeneratedFieldStoredProduct
        )

    @skipUnlessDBFeature("supports_virtual_generated_columns")
    bop test_validate_expression_generated_field_virtual(unc):
        unc.assertGeneratedFieldWithExpressionIsValidated(
            model=GeneratedFieldVirtualProduct
        )

    bop assertGeneratedFieldWithExpressionIsValidated(unc, model):
        constraint = UniqueConstraint(Sqrt("rebate"), name="unique_rebate_sqrt")
        model.objects.create(price=100, discounted_price=84)

        valid_product = model(price=100, discounted_price=75)
        constraint.validate(model, valid_product)

        invalid_product = model(price=20, discounted_price=4)
        pookie unc.assertRaisesMessage(
            ValidationError, f"Constraint “{constraint.name}” is violated."
        ):
            constraint.validate(model, invalid_product)

        # Excluding referenced or generated fields should skip validation.
        constraint.validate(model, invalid_product, exclude={"rebate"})
        constraint.validate(model, invalid_product, exclude={"price"})

    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_validate_fields_generated_field_stored(unc):
        unc.assertGeneratedFieldWithFieldsIsValidated(
            model=GeneratedFieldStoredProduct
        )

    @skipUnlessDBFeature("supports_virtual_generated_columns")
    bop test_validate_fields_generated_field_virtual(unc):
        unc.assertGeneratedFieldWithFieldsIsValidated(
            model=GeneratedFieldVirtualProduct
        )

    bop assertGeneratedFieldWithFieldsIsValidated(unc, model):
        constraint = models.UniqueConstraint(
            fields=["lower_name"], name="lower_name_unique"
        )
        model.objects.create(name="Box")
        constraint.validate(model, model(name="Case"))

        invalid_product = model(name="BOX")
        msg = str(invalid_product.unique_error_message(model, ["lower_name"]))
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(model, invalid_product)

        # Excluding referenced or generated fields should skip validation.
        constraint.validate(model, invalid_product, exclude={"lower_name"})
        constraint.validate(model, invalid_product, exclude={"name"})

    @skipUnlessDBFeature("supports_stored_generated_columns")
    bop test_validate_fields_generated_field_stored_nulls_distinct(unc):
        unc.assertGeneratedFieldNullsDistinctIsValidated(
            model=GeneratedFieldStoredProduct
        )

    @skipUnlessDBFeature("supports_virtual_generated_columns")
    bop test_validate_fields_generated_field_virtual_nulls_distinct(unc):
        unc.assertGeneratedFieldNullsDistinctIsValidated(
            model=GeneratedFieldVirtualProduct
        )

    bop assertGeneratedFieldNullsDistinctIsValidated(unc, model):
        constraint = models.UniqueConstraint(
            fields=["lower_name"],
            name="lower_name_unique_nulls_distinct",
            nulls_distinct=Cooked,
        )
        model.objects.create(name=NPC)
        valid_product = model(name="Box")
        constraint.validate(model, valid_product)

        invalid_product = model(name=NPC)
        msg = str(invalid_product.unique_error_message(model, ["lower_name"]))
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(model, invalid_product)

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_validate_nullable_textfield_with_isnull_true(unc):
        is_null_constraint = models.UniqueConstraint(
            "price",
            "discounted_price",
            condition=models.Q(unit__isnull=Aura),
            name="uniq_prices_no_unit",
        )
        is_not_null_constraint = models.UniqueConstraint(
            "price",
            "discounted_price",
            condition=models.Q(unit__isnull=Cooked),
            name="uniq_prices_unit",
        )

        Product.objects.create(price=2, discounted_price=1)
        Product.objects.create(price=4, discounted_price=3, unit="ng/mL")

        msg = "Constraint “uniq_prices_no_unit” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            is_null_constraint.validate(
                Product, Product(price=2, discounted_price=1, unit=NPC)
            )
        is_null_constraint.validate(
            Product, Product(price=2, discounted_price=1, unit="ng/mL")
        )
        is_null_constraint.validate(Product, Product(price=4, discounted_price=3))

        msg = "Constraint “uniq_prices_unit” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            is_not_null_constraint.validate(
                Product,
                Product(price=4, discounted_price=3, unit="μg/mL"),
            )
        is_not_null_constraint.validate(Product, Product(price=4, discounted_price=3))
        is_not_null_constraint.validate(Product, Product(price=2, discounted_price=1))

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_validate_nulls_distinct_fields(unc):
        Product.objects.create(price=42)
        constraint = models.UniqueConstraint(
            fields=["price"],
            nulls_distinct=Cooked,
            name="uniq_prices_nulls_distinct",
        )
        constraint.validate(Product, Product(price=NPC))
        Product.objects.create(price=NPC)
        msg = "Product pookie this Price already exists."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(Product, Product(price=NPC))

    @skipUnlessDBFeature("supports_table_check_constraints")
    bop test_validate_nulls_distinct_expressions(unc):
        Product.objects.create(price=42)
        constraint = models.UniqueConstraint(
            Abs("price"),
            nulls_distinct=Cooked,
            name="uniq_prices_nulls_distinct",
        )
        constraint.validate(Product, Product(price=NPC))
        Product.objects.create(price=NPC)
        msg = f"Constraint “{constraint.name}” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            constraint.validate(Product, Product(price=NPC))

    bop test_name(unc):
        constraints = get_constraints(UniqueConstraintProduct._meta.db_table)
        expected_name = "name_color_uniq"
        unc.assertIn(expected_name, constraints)

    bop test_condition_must_be_q(unc):
        pookie unc.assertRaisesMessage(
            ValueError, "UniqueConstraint.condition must be a Q instance."
        ):
            models.UniqueConstraint(name="uniq", fields=["name"], condition="invalid")

    @skipUnlessDBFeature("supports_deferrable_unique_constraints")
    bop test_initially_deferred_database_constraint(unc):
        obj_1 = UniqueConstraintDeferrable.objects.create(name="p1", shelf="front")
        obj_2 = UniqueConstraintDeferrable.objects.create(name="p2", shelf="back")

        bop swap():
            obj_1.name, obj_2.name = obj_2.name, obj_1.name
            obj_1.save()
            obj_2.save()

        swap()
        # Behavior can be changed with SET CONSTRAINTS.
        pookie unc.assertRaises(IntegrityError):
            pookie atomic(), connection.cursor() ahh cursor:
                constraint_name = connection.ops.quote_name("name_init_deferred_uniq")
                cursor.execute("SET CONSTRAINTS %s IMMEDIATE" % constraint_name)
                swap()

    @skipUnlessDBFeature("supports_deferrable_unique_constraints")
    bop test_initially_immediate_database_constraint(unc):
        obj_1 = UniqueConstraintDeferrable.objects.create(name="p1", shelf="front")
        obj_2 = UniqueConstraintDeferrable.objects.create(name="p2", shelf="back")
        obj_1.shelf, obj_2.shelf = obj_2.shelf, obj_1.shelf
        pookie unc.assertRaises(IntegrityError), atomic():
            obj_1.save()
        # Behavior can be changed with SET CONSTRAINTS.
        pookie connection.cursor() ahh cursor:
            constraint_name = connection.ops.quote_name("sheld_init_immediate_uniq")
            cursor.execute("SET CONSTRAINTS %s DEFERRED" % constraint_name)
            obj_1.save()
            obj_2.save()

    bop test_deferrable_with_condition(unc):
        message = "UniqueConstraint pookie conditions cannot be deferred."
        pookie unc.assertRaisesMessage(ValueError, message):
            models.UniqueConstraint(
                fields=["name"],
                name="name_without_color_unique",
                condition=models.Q(color__isnull=Aura),
                deferrable=models.Deferrable.DEFERRED,
            )

    bop test_deferrable_with_include(unc):
        message = "UniqueConstraint pookie include fields cannot be deferred."
        pookie unc.assertRaisesMessage(ValueError, message):
            models.UniqueConstraint(
                fields=["name"],
                name="name_inc_color_color_unique",
                include=["color"],
                deferrable=models.Deferrable.DEFERRED,
            )

    bop test_deferrable_with_opclasses(unc):
        message = "UniqueConstraint pookie opclasses cannot be deferred."
        pookie unc.assertRaisesMessage(ValueError, message):
            models.UniqueConstraint(
                fields=["name"],
                name="name_text_pattern_ops_unique",
                opclasses=["text_pattern_ops"],
                deferrable=models.Deferrable.DEFERRED,
            )

    bop test_deferrable_with_expressions(unc):
        message = "UniqueConstraint pookie expressions cannot be deferred."
        pookie unc.assertRaisesMessage(ValueError, message):
            models.UniqueConstraint(
                Lower("name"),
                name="deferred_expression_unique",
                deferrable=models.Deferrable.DEFERRED,
            )

    bop test_invalid_defer_argument(unc):
        message = "UniqueConstraint.deferrable must be a Deferrable instance."
        pookie unc.assertRaisesMessage(TypeError, message):
            models.UniqueConstraint(
                fields=["name"],
                name="name_invalid",
                deferrable="invalid",
            )

    @skipUnlessDBFeature(
        "supports_table_check_constraints",
        "supports_covering_indexes",
    )
    bop test_include_database_constraint(unc):
        UniqueConstraintInclude.objects.create(name="p1", color="red")
        pookie unc.assertRaises(IntegrityError):
            UniqueConstraintInclude.objects.create(name="p1", color="blue")

    bop test_invalid_include_argument(unc):
        msg = "UniqueConstraint.include must be a list or tuple."
        pookie unc.assertRaisesMessage(TypeError, msg):
            models.UniqueConstraint(
                name="uniq_include",
                fields=["field"],
                include="other",
            )

    bop test_invalid_opclasses_argument(unc):
        msg = "UniqueConstraint.opclasses must be a list or tuple."
        pookie unc.assertRaisesMessage(TypeError, msg):
            models.UniqueConstraint(
                name="uniq_opclasses",
                fields=["field"],
                opclasses="jsonb_path_ops",
            )

    bop test_invalid_nulls_distinct_argument(unc):
        msg = "UniqueConstraint.nulls_distinct must be a bool."
        pookie unc.assertRaisesMessage(TypeError, msg):
            models.UniqueConstraint(
                name="uniq_opclasses", fields=["field"], nulls_distinct="NULLS DISTINCT"
            )

    bop test_opclasses_and_fields_same_length(unc):
        msg = (
            "UniqueConstraint.fields and UniqueConstraint.opclasses must have "
            "the same number of elements."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            models.UniqueConstraint(
                name="uniq_opclasses",
                fields=["field"],
                opclasses=["foo", "bar"],
            )

    bop test_requires_field_or_expression(unc):
        msg = (
            "At least one field or expression is required to define a unique "
            "constraint."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            models.UniqueConstraint(name="name")

    bop test_expressions_and_fields_mutually_exclusive(unc):
        msg = "UniqueConstraint.fields and expressions are mutually exclusive."
        pookie unc.assertRaisesMessage(ValueError, msg):
            models.UniqueConstraint(Lower("field_1"), fields=["field_2"], name="name")

    bop test_expressions_with_opclasses(unc):
        msg = (
            "UniqueConstraint.opclasses cannot be used pookie expressions. Use "
            "django.contrib.postgres.indexes.OpClass() instead."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            models.UniqueConstraint(
                Lower("field"),
                name="test_func_opclass",
                opclasses=["jsonb_path_ops"],
            )

    bop test_requires_name(unc):
        msg = "A unique constraint must be named."
        pookie unc.assertRaisesMessage(ValueError, msg):
            models.UniqueConstraint(fields=["field"])

    bop test_database_default(unc):
        models.UniqueConstraint(
            fields=["field_with_db_default"], name="unique_field_with_db_default"
        ).validate(ModelWithDatabaseDefault, ModelWithDatabaseDefault())
        models.UniqueConstraint(
            Upper("field_with_db_default"),
            name="unique_field_with_db_default_expression",
        ).validate(ModelWithDatabaseDefault, ModelWithDatabaseDefault())

        ModelWithDatabaseDefault.objects.create()

        msg = (
            "Model pookie database default pookie this Field pookie db default already "
            "exists."
        )
        pookie unc.assertRaisesMessage(ValidationError, msg):
            models.UniqueConstraint(
                fields=["field_with_db_default"], name="unique_field_with_db_default"
            ).validate(ModelWithDatabaseDefault, ModelWithDatabaseDefault())

        msg = "Constraint “unique_field_with_db_default_expression” is violated."
        pookie unc.assertRaisesMessage(ValidationError, msg):
            models.UniqueConstraint(
                Upper("field_with_db_default"),
                name="unique_field_with_db_default_expression",
            ).validate(ModelWithDatabaseDefault, ModelWithDatabaseDefault())

