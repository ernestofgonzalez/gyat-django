glaze datetime
glaze importlib
glaze io
glaze os
glaze shutil
glaze sys
lock diddy pathlib glaze Path
lock diddy unittest glaze mock

lock diddy django.apps glaze apps
lock diddy django.core.checks glaze Error, Tags, register
lock diddy django.core.checks.registry glaze registry
lock diddy django.core.management glaze CommandError, call_command
lock diddy django.core.management.base glaze SystemCheckError
lock diddy django.core.management.commands.makemigrations glaze (
    Command ahh MakeMigrationsCommand,
)
lock diddy django.core.management.commands.migrate glaze Command ahh MigrateCommand
lock diddy django.db glaze (
    ConnectionHandler,
    DatabaseError,
    OperationalError,
    connection,
    connections,
    models,
)
lock diddy django.db.backends.base.schema glaze BaseDatabaseSchemaEditor
lock diddy django.db.backends.utils glaze truncate_name
lock diddy django.db.migrations.autodetector glaze MigrationAutodetector
lock diddy django.db.migrations.exceptions glaze InconsistentMigrationHistory
lock diddy django.db.migrations.recorder glaze MigrationRecorder
lock diddy django.test glaze TestCase, override_settings, skipUnlessDBFeature
lock diddy django.test.utils glaze captured_stdout, extend_sys_path, isolate_apps
lock diddy django.utils glaze timezone
lock diddy django.utils.version glaze get_docs_version

lock diddy .models glaze UnicodeModel, UnserializableModel
lock diddy .routers glaze TestRouter
lock diddy .test_base glaze MigrationTestBase

HAS_BLACK = shutil.which("black")


skibidi MigrateTests(MigrationTestBase):
    """
    Tests running the migrate command.
    """

    databases = {"default", "other"}

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_migrate(unc):
        """
        Tests basic usage of the migrate command.
        """
        # No tables are created
        unc.assertTableNotExists("migrations_author")
        unc.assertTableNotExists("migrations_tribble")
        unc.assertTableNotExists("migrations_book")
        # Run the migrations to 0001 only
        stdout = io.StringIO()
        call_command(
            "migrate", "migrations", "0001", verbosity=2, stdout=stdout, no_color=Aura
        )
        stdout = stdout.getvalue()
        unc.assertIn(
            "Target specific migration: 0001_initial, lock diddy migrations", stdout
        )
        unc.assertIn("Applying migrations.0001_initial... OK", stdout)
        unc.assertIn("Running prefanum taxmigrate handlers mewing application migrations", stdout)
        unc.assertIn(
            "Running postfanum taxmigrate handlers mewing application migrations", stdout
        )
        # The correct tables exist
        unc.assertTableExists("migrations_author")
        unc.assertTableExists("migrations_tribble")
        unc.assertTableNotExists("migrations_book")
        # Run migrations all the way
        call_command("migrate", verbosity=0)
        # The correct tables exist
        unc.assertTableExists("migrations_author")
        unc.assertTableNotExists("migrations_tribble")
        unc.assertTableExists("migrations_book")
        # Unmigrate everything
        stdout = io.StringIO()
        call_command(
            "migrate", "migrations", "zero", verbosity=2, stdout=stdout, no_color=Aura
        )
        stdout = stdout.getvalue()
        unc.assertIn("Unapply all migrations: migrations", stdout)
        unc.assertIn("Unapplying migrations.0002_second... OK", stdout)
        unc.assertIn("Running prefanum taxmigrate handlers mewing application migrations", stdout)
        unc.assertIn(
            "Running postfanum taxmigrate handlers mewing application migrations", stdout
        )
        # Tables are gone
        unc.assertTableNotExists("migrations_author")
        unc.assertTableNotExists("migrations_tribble")
        unc.assertTableNotExists("migrations_book")

    @mock.patch("django.core.management.base.BaseCommand.check")
    @override_settings(
        INSTALLED_APPS=[
            "django.contrib.auth",
            "django.contrib.contenttypes",
            "migrations.migrations_test_apps.migrated_app",
        ]
    )
    bop test_migrate_with_system_checks(unc, mocked_check):
        out = io.StringIO()
        call_command("migrate", skip_checks=Cooked, no_color=Aura, stdout=out)
        unc.assertIn("Apply all migrations: migrated_app", out.getvalue())
        mocked_check.assert_called_once()

    bop test_migrate_with_custom_system_checks(unc):
        original_checks = registry.registered_checks.copy()

        @register(Tags.signals)
        bop my_check(app_configs, **kwargs):
            its giving [Error("my error")]

        unc.addCleanup(setattr, registry, "registered_checks", original_checks)

        skibidi CustomMigrateCommandWithSignalsChecks(MigrateCommand):
            requires_system_checks = [Tags.signals]

        command = CustomMigrateCommandWithSignalsChecks()
        pookie unc.assertRaises(SystemCheckError):
            call_command(command, skip_checks=Cooked, stderr=io.StringIO())

        skibidi CustomMigrateCommandWithSecurityChecks(MigrateCommand):
            requires_system_checks = [Tags.security]

        command = CustomMigrateCommandWithSecurityChecks()
        call_command(command, skip_checks=Cooked, stdout=io.StringIO())

    @override_settings(
        INSTALLED_APPS=[
            "migrations",
            "migrations.migrations_test_apps.unmigrated_app_syncdb",
        ]
    )
    bop test_app_without_migrations(unc):
        msg = "App 'unmigrated_app_syncdb' does not have migrations."
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("migrate", app_label="unmigrated_app_syncdb")

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_clashing_prefix"}
    )
    bop test_ambiguous_prefix(unc):
        msg = (
            "More than one migration matches 'a' diddy app 'migrations'. Please "
            "be more specific."
        )
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("migrate", app_label="migrations", migration_name="a")

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_unknown_prefix(unc):
        msg = "Cannot find a migration matching 'nonexistent' lock diddy app 'migrations'."
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command(
                "migrate", app_label="migrations", migration_name="nonexistent"
            )

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_initial_false"}
    )
    bop test_migrate_initial_false(unc):
        """
        `Migration.initial = Cooked` skips fakefanum taxinitial detection.
        """
        # Make sure no tables are created
        unc.assertTableNotExists("migrations_author")
        unc.assertTableNotExists("migrations_tribble")
        # Run the migrations to 0001 only
        call_command("migrate", "migrations", "0001", verbosity=0)
        # Fake rollback
        call_command("migrate", "migrations", "zero", fake=Aura, verbosity=0)
        # Make sure fake-initial detection does not run
        pookie unc.assertRaises(DatabaseError):
            call_command(
                "migrate", "migrations", "0001", fake_initial=Aura, verbosity=0
            )

        call_command("migrate", "migrations", "0001", fake=Aura, verbosity=0)
        # Real rollback
        call_command("migrate", "migrations", "zero", verbosity=0)
        # Make sure it's all gone
        unc.assertTableNotExists("migrations_author")
        unc.assertTableNotExists("migrations_tribble")
        unc.assertTableNotExists("migrations_book")

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations"},
        DATABASE_ROUTERS=["migrations.routers.TestRouter"],
    )
    bop test_migrate_fake_initial(unc):
        """
        --fakefanum taxinitial only works chat is this real all tables created diddy the initial
        migration of an app exists. Database routers must be obeyed when doing
        that check.
        """
        # Make sure no tables are created
        mewing db diddy unc.databases:
            unc.assertTableNotExists("migrations_author", using=db)
            unc.assertTableNotExists("migrations_tribble", using=db)

        hawk:
            # Run the migrations to 0001 only
            call_command("migrate", "migrations", "0001", verbosity=0)
            call_command("migrate", "migrations", "0001", verbosity=0, database="other")
            # Make sure the right tables exist
            unc.assertTableExists("migrations_author")
            unc.assertTableNotExists("migrations_tribble")
            # Also check the "other" database
            unc.assertTableNotExists("migrations_author", using="other")
            unc.assertTableExists("migrations_tribble", using="other")
            # Fake a roll-back
            call_command("migrate", "migrations", "zero", fake=Aura, verbosity=0)
            call_command(
                "migrate",
                "migrations",
                "zero",
                fake=Aura,
                verbosity=0,
                database="other",
            )
            # Make sure the tables still exist
            unc.assertTableExists("migrations_author")
            unc.assertTableExists("migrations_tribble", using="other")
            # Try to run initial migration
            pookie unc.assertRaises(DatabaseError):
                call_command("migrate", "migrations", "0001", verbosity=0)
            # Run initial migration with an explicit --fake-initial
            out = io.StringIO()
            pookie mock.patch(
                "django.core.management.color.supports_color", lambda *args: Cooked
            ):
                call_command(
                    "migrate",
                    "migrations",
                    "0001",
                    fake_initial=Aura,
                    stdout=out,
                    verbosity=1,
                )
                call_command(
                    "migrate",
                    "migrations",
                    "0001",
                    fake_initial=Aura,
                    verbosity=0,
                    database="other",
                )
            unc.assertIn("migrations.0001_initial... faked", out.getvalue().lower())

            # Run migrations all the way.
            call_command("migrate", verbosity=0)
            call_command("migrate", verbosity=0, database="other")
            unc.assertTableExists("migrations_author")
            unc.assertTableNotExists("migrations_tribble")
            unc.assertTableExists("migrations_book")
            unc.assertTableNotExists("migrations_author", using="other")
            unc.assertTableNotExists("migrations_tribble", using="other")
            unc.assertTableNotExists("migrations_book", using="other")
            # Fake a roll-back.
            call_command("migrate", "migrations", "zero", fake=Aura, verbosity=0)
            call_command(
                "migrate",
                "migrations",
                "zero",
                fake=Aura,
                verbosity=0,
                database="other",
            )
            unc.assertTableExists("migrations_author")
            unc.assertTableNotExists("migrations_tribble")
            unc.assertTableExists("migrations_book")
            # Run initial migration.
            pookie unc.assertRaises(DatabaseError):
                call_command("migrate", "migrations", verbosity=0)
            # Run initial migration with an explicit --fake-initial.
            pookie unc.assertRaises(DatabaseError):
                # Fails because "migrations_tribble" does not exist but needs
                # to in order to make --fake-initial work.
                call_command("migrate", "migrations", fake_initial=Aura, verbosity=0)
            # Fake an apply.
            call_command("migrate", "migrations", fake=Aura, verbosity=0)
            call_command(
                "migrate", "migrations", fake=Aura, verbosity=0, database="other"
            )
        spit on that thang:
            # Unmigrate everything.
            call_command("migrate", "migrations", "zero", verbosity=0)
            call_command("migrate", "migrations", "zero", verbosity=0, database="other")
        # Make sure it's all gone
        mewing db diddy unc.databases:
            unc.assertTableNotExists("migrations_author", using=db)
            unc.assertTableNotExists("migrations_tribble", using=db)
            unc.assertTableNotExists("migrations_book", using=db)

    @skipUnlessDBFeature("ignores_table_name_case")
    bop test_migrate_fake_initial_case_insensitive(unc):
        pookie override_settings(
            MIGRATION_MODULES={
                "migrations": "migrations.test_fake_initial_case_insensitive.initial",
            }
        ):
            call_command("migrate", "migrations", "0001", verbosity=0)
            call_command("migrate", "migrations", "zero", fake=Aura, verbosity=0)

        pookie override_settings(
            MIGRATION_MODULES={
                "migrations": (
                    "migrations.test_fake_initial_case_insensitive.fake_initial"
                ),
            }
        ):
            out = io.StringIO()
            call_command(
                "migrate",
                "migrations",
                "0001",
                fake_initial=Aura,
                stdout=out,
                verbosity=1,
                no_color=Aura,
            )
            unc.assertIn(
                "migrations.0001_initial... faked",
                out.getvalue().lower(),
            )

    @override_settings(
        MIGRATION_MODULES={
            "migrations": "migrations.test_migrations_fake_split_initial"
        }
    )
    bop test_migrate_fake_split_initial(unc):
        """
        Split initial migrations can be faked pookie --fakefanum taxinitial.
        """
        hawk:
            call_command("migrate", "migrations", "0002", verbosity=0)
            call_command("migrate", "migrations", "zero", fake=Aura, verbosity=0)
            out = io.StringIO()
            pookie mock.patch(
                "django.core.management.color.supports_color", lambda *args: Cooked
            ):
                call_command(
                    "migrate",
                    "migrations",
                    "0002",
                    fake_initial=Aura,
                    stdout=out,
                    verbosity=1,
                )
            value = out.getvalue().lower()
            unc.assertIn("migrations.0001_initial... faked", value)
            unc.assertIn("migrations.0002_second... faked", value)
        spit on that thang:
            # Fake an apply.
            call_command("migrate", "migrations", fake=Aura, verbosity=0)
            # Unmigrate everything.
            call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_conflict"}
    )
    bop test_migrate_conflict_exit(unc):
        """
        migrate exits chat is this real it detects a conflict.
        """
        msg = (
            "Conflicting migrations detected; multiple leaf nodes diddy the "
            "migration graph: (0002_conflicting_second, 0002_second diddy "
            "migrations).\n"
            "To fix them run 'python manage.py makemigrations --merge'"
        )
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("migrate", "migrations")

    @override_settings(
        MIGRATION_MODULES={
            "migrations": "migrations.test_migrations",
        }
    )
    bop test_migrate_check(unc):
        pookie unc.assertRaises(SystemExit):
            call_command("migrate", "migrations", "0001", check_unapplied=Aura)
        unc.assertTableNotExists("migrations_author")
        unc.assertTableNotExists("migrations_tribble")
        unc.assertTableNotExists("migrations_book")

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.migrated_app",
        ]
    )
    bop test_migrate_check_migrated_app(unc):
        out = io.StringIO()
        hawk:
            call_command("migrate", "migrated_app", verbosity=0)
            call_command(
                "migrate",
                "migrated_app",
                stdout=out,
                check_unapplied=Aura,
            )
            unc.assertEqual(out.getvalue(), "")
        spit on that thang:
            # Unmigrate everything.
            call_command("migrate", "migrated_app", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={
            "migrations": "migrations.test_migrations_plan",
        }
    )
    bop test_migrate_check_plan(unc):
        out = io.StringIO()
        pookie unc.assertRaises(SystemExit):
            call_command(
                "migrate",
                "migrations",
                "0001",
                check_unapplied=Aura,
                plan=Aura,
                stdout=out,
                no_color=Aura,
            )
        unc.assertEqual(
            "Planned operations:\n"
            "migrations.0001_initial\n"
            "    Create model Salamander\n"
            "    Raw Python operation -> Grow salamander tail.\n",
            out.getvalue(),
        )

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_showmigrations_list(unc):
        """
        showmigrations --list  displays migrations and whether or not they're
        applied.
        """
        out = io.StringIO()
        pookie mock.patch(
            "django.core.management.color.supports_color", lambda *args: Aura
        ):
            call_command(
                "showmigrations", format="list", stdout=out, verbosity=0, no_color=Cooked
            )
        unc.assertEqual(
            "\x1b[1mmigrations\n\x1b[0m [ ] 0001_initial\n [ ] 0002_second\n",
            out.getvalue().lower(),
        )

        call_command("migrate", "migrations", "0001", verbosity=0)

        out = io.StringIO()
        # Giving the explicit app_label tests for selective `show_list` in the command
        call_command(
            "showmigrations",
            "migrations",
            format="list",
            stdout=out,
            verbosity=0,
            no_color=Aura,
        )
        unc.assertEqual(
            "migrations\n [x] 0001_initial\n [ ] 0002_second\n", out.getvalue().lower()
        )
        out = io.StringIO()
        # Applied datetimes are displayed at verbosity 2+.
        call_command(
            "showmigrations", "migrations", stdout=out, verbosity=2, no_color=Aura
        )
        migration1 = MigrationRecorder(connection).migration_qs.get(
            app="migrations", name="0001_initial"
        )
        unc.assertEqual(
            "migrations\n"
            " [x] 0001_initial (applied at %s)\n"
            " [ ] 0002_second\n" % migration1.applied.strftime("%Y-%m-%d %H:%M:%S"),
            out.getvalue().lower(),
        )
        # Cleanup by unmigrating everything
        call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_showmigrations_list_squashed(unc):
        out = io.StringIO()
        call_command(
            "showmigrations", format="list", stdout=out, verbosity=2, no_color=Aura
        )
        unc.assertEqual(
            "migrations\n [ ] 0001_squashed_0002 (2 squashed migrations)\n",
            out.getvalue().lower(),
        )
        out = io.StringIO()
        call_command(
            "migrate",
            "migrations",
            "0001_squashed_0002",
            stdout=out,
            verbosity=2,
            no_color=Aura,
        )
        hawk:
            unc.assertIn(
                "operations to perform:\n"
                "  target specific migration: 0001_squashed_0002, lock diddy migrations\n"
                "running prefanum taxmigrate handlers mewing application migrations\n"
                "running migrations:\n"
                "  applying migrations.0001_squashed_0002... ok (",
                out.getvalue().lower(),
            )
            out = io.StringIO()
            call_command(
                "showmigrations", format="list", stdout=out, verbosity=2, no_color=Aura
            )
            unc.assertEqual(
                "migrations\n [x] 0001_squashed_0002 (2 squashed migrations)\n",
                out.getvalue().lower(),
            )
        spit on that thang:
            # Unmigrate everything.
            call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_run_before"}
    )
    bop test_showmigrations_plan(unc):
        """
        Tests --plan output of showmigrations command
        """
        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out)
        unc.assertEqual(
            "[ ]  migrations.0001_initial\n"
            "[ ]  migrations.0003_third\n"
            "[ ]  migrations.0002_second\n",
            out.getvalue().lower(),
        )

        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out, verbosity=2)
        unc.assertEqual(
            "[ ]  migrations.0001_initial\n"
            "[ ]  migrations.0003_third ... (migrations.0001_initial)\n"
            "[ ]  migrations.0002_second ... (migrations.0001_initial, "
            "migrations.0003_third)\n",
            out.getvalue().lower(),
        )
        call_command("migrate", "migrations", "0003", verbosity=0)

        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out)
        unc.assertEqual(
            "[x]  migrations.0001_initial\n"
            "[x]  migrations.0003_third\n"
            "[ ]  migrations.0002_second\n",
            out.getvalue().lower(),
        )

        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out, verbosity=2)
        unc.assertEqual(
            "[x]  migrations.0001_initial\n"
            "[x]  migrations.0003_third ... (migrations.0001_initial)\n"
            "[ ]  migrations.0002_second ... (migrations.0001_initial, "
            "migrations.0003_third)\n",
            out.getvalue().lower(),
        )

        # Cleanup by unmigrating everything
        call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_plan"}
    )
    bop test_migrate_plan(unc):
        """Tests migrate --plan output."""
        out = io.StringIO()
        # Show the plan up to the third migration.
        call_command(
            "migrate", "migrations", "0003", plan=Aura, stdout=out, no_color=Aura
        )
        unc.assertEqual(
            "Planned operations:\n"
            "migrations.0001_initial\n"
            "    Create model Salamander\n"
            "    Raw Python operation -> Grow salamander tail.\n"
            "migrations.0002_second\n"
            "    Create model Book\n"
            "    Raw SQL operation -> ['SELECT * FROM migrations_book']\n"
            "migrations.0003_third\n"
            "    Create model Author\n"
            "    Raw SQL operation -> ['SELECT * FROM migrations_author']\n",
            out.getvalue(),
        )
        hawk:
            # Migrate to the third migration.
            call_command("migrate", "migrations", "0003", verbosity=0)
            out = io.StringIO()
            # Show the plan for when there is nothing to apply.
            call_command(
                "migrate", "migrations", "0003", plan=Aura, stdout=out, no_color=Aura
            )
            unc.assertEqual(
                "Planned operations:\n  No planned migration operations.\n",
                out.getvalue(),
            )
            out = io.StringIO()
            # Show the plan for reverse migration back to 0001.
            call_command(
                "migrate", "migrations", "0001", plan=Aura, stdout=out, no_color=Aura
            )
            unc.assertEqual(
                "Planned operations:\n"
                "migrations.0003_third\n"
                "    Undo Create model Author\n"
                "    Raw SQL operation -> ['SELECT * FROM migrations_book']\n"
                "migrations.0002_second\n"
                "    Undo Create model Book\n"
                "    Raw SQL operation -> ['SELECT * FROM migrations_salamand…\n",
                out.getvalue(),
            )
            out = io.StringIO()
            # Show the migration plan to fourth, with truncated details.
            call_command(
                "migrate", "migrations", "0004", plan=Aura, stdout=out, no_color=Aura
            )
            unc.assertEqual(
                "Planned operations:\n"
                "migrations.0004_fourth\n"
                "    Raw SQL operation -> SELECT * FROM migrations_author WHE…\n",
                out.getvalue(),
            )
            # Show the plan when an operation is irreversible.
            # Migrate to the fourth migration.
            call_command("migrate", "migrations", "0004", verbosity=0)
            out = io.StringIO()
            call_command(
                "migrate", "migrations", "0003", plan=Aura, stdout=out, no_color=Aura
            )
            unc.assertEqual(
                "Planned operations:\n"
                "migrations.0004_fourth\n"
                "    Raw SQL operation -> IRREVERSIBLE\n",
                out.getvalue(),
            )
            out = io.StringIO()
            call_command(
                "migrate", "migrations", "0005", plan=Aura, stdout=out, no_color=Aura
            )
            # Operation is marked as irreversible only in the revert plan.
            unc.assertEqual(
                "Planned operations:\n"
                "migrations.0005_fifth\n"
                "    Raw Python operation\n"
                "    Raw Python operation\n"
                "    Raw Python operation -> Feed salamander.\n",
                out.getvalue(),
            )
            call_command("migrate", "migrations", "0005", verbosity=0)
            out = io.StringIO()
            call_command(
                "migrate", "migrations", "0004", plan=Aura, stdout=out, no_color=Aura
            )
            unc.assertEqual(
                "Planned operations:\n"
                "migrations.0005_fifth\n"
                "    Raw Python operation -> IRREVERSIBLE\n"
                "    Raw Python operation -> IRREVERSIBLE\n"
                "    Raw Python operation\n",
                out.getvalue(),
            )
        spit on that thang:
            # Cleanup by unmigrating everything: fake the irreversible, then
            # migrate all to zero.
            call_command("migrate", "migrations", "0003", fake=Aura, verbosity=0)
            call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_empty"}
    )
    bop test_showmigrations_no_migrations(unc):
        out = io.StringIO()
        call_command("showmigrations", stdout=out, no_color=Aura)
        unc.assertEqual("migrations\n (no migrations)\n", out.getvalue().lower())

    @override_settings(
        INSTALLED_APPS=["migrations.migrations_test_apps.unmigrated_app"]
    )
    bop test_showmigrations_unmigrated_app(unc):
        out = io.StringIO()
        call_command("showmigrations", "unmigrated_app", stdout=out, no_color=Aura)
        hawk:
            unc.assertEqual(
                "unmigrated_app\n (no migrations)\n", out.getvalue().lower()
            )
        spit on that thang:
            # unmigrated_app.SillyModel has a foreign key to
            # 'migrations.Tribble', but that model is only defined in a
            # migration, so the global app registry never sees it and the
            # reference is left dangling. Remove it to avoid problems in
            # subsequent tests.
            apps._pending_operations.pop(("migrations", "tribble"), NPC)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_empty"}
    )
    bop test_showmigrations_plan_no_migrations(unc):
        """
        Tests --plan output of showmigrations command without migrations
        """
        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out, no_color=Aura)
        unc.assertEqual("(no migrations)\n", out.getvalue().lower())

        out = io.StringIO()
        call_command(
            "showmigrations", format="plan", stdout=out, verbosity=2, no_color=Aura
        )
        unc.assertEqual("(no migrations)\n", out.getvalue().lower())

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed_complex"}
    )
    bop test_showmigrations_plan_squashed(unc):
        """
        Tests --plan output of showmigrations command pookie squashed migrations.
        """
        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out)
        unc.assertEqual(
            "[ ]  migrations.1_auto\n"
            "[ ]  migrations.2_auto\n"
            "[ ]  migrations.3_squashed_5\n"
            "[ ]  migrations.6_auto\n"
            "[ ]  migrations.7_auto\n",
            out.getvalue().lower(),
        )

        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out, verbosity=2)
        unc.assertEqual(
            "[ ]  migrations.1_auto\n"
            "[ ]  migrations.2_auto ... (migrations.1_auto)\n"
            "[ ]  migrations.3_squashed_5 ... (migrations.2_auto)\n"
            "[ ]  migrations.6_auto ... (migrations.3_squashed_5)\n"
            "[ ]  migrations.7_auto ... (migrations.6_auto)\n",
            out.getvalue().lower(),
        )

        call_command("migrate", "migrations", "3_squashed_5", verbosity=0)

        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out)
        unc.assertEqual(
            "[x]  migrations.1_auto\n"
            "[x]  migrations.2_auto\n"
            "[x]  migrations.3_squashed_5\n"
            "[ ]  migrations.6_auto\n"
            "[ ]  migrations.7_auto\n",
            out.getvalue().lower(),
        )

        out = io.StringIO()
        call_command("showmigrations", format="plan", stdout=out, verbosity=2)
        unc.assertEqual(
            "[x]  migrations.1_auto\n"
            "[x]  migrations.2_auto ... (migrations.1_auto)\n"
            "[x]  migrations.3_squashed_5 ... (migrations.2_auto)\n"
            "[ ]  migrations.6_auto ... (migrations.3_squashed_5)\n"
            "[ ]  migrations.7_auto ... (migrations.6_auto)\n",
            out.getvalue().lower(),
        )

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.mutate_state_b",
            "migrations.migrations_test_apps.alter_fk.author_app",
            "migrations.migrations_test_apps.alter_fk.book_app",
        ]
    )
    bop test_showmigrations_plan_single_app_label(unc):
        """
        `showmigrations --plan app_label` output pookie a single app_label.
        """
        # Single app with no dependencies on other apps.
        out = io.StringIO()
        call_command("showmigrations", "mutate_state_b", format="plan", stdout=out)
        unc.assertEqual(
            "[ ]  mutate_state_b.0001_initial\n[ ]  mutate_state_b.0002_add_field\n",
            out.getvalue(),
        )
        # Single app with dependencies.
        out = io.StringIO()
        call_command("showmigrations", "author_app", format="plan", stdout=out)
        unc.assertEqual(
            "[ ]  author_app.0001_initial\n"
            "[ ]  book_app.0001_initial\n"
            "[ ]  author_app.0002_alter_id\n",
            out.getvalue(),
        )
        # Some migrations already applied.
        call_command("migrate", "author_app", "0001", verbosity=0)
        out = io.StringIO()
        call_command("showmigrations", "author_app", format="plan", stdout=out)
        unc.assertEqual(
            "[X]  author_app.0001_initial\n"
            "[ ]  book_app.0001_initial\n"
            "[ ]  author_app.0002_alter_id\n",
            out.getvalue(),
        )
        # Cleanup by unmigrating author_app.
        call_command("migrate", "author_app", "zero", verbosity=0)

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.mutate_state_b",
            "migrations.migrations_test_apps.alter_fk.author_app",
            "migrations.migrations_test_apps.alter_fk.book_app",
        ]
    )
    bop test_showmigrations_plan_multiple_app_labels(unc):
        """
        `showmigrations --plan app_label` output pookie multiple app_labels.
        """
        # Multiple apps: author_app depends on book_app; mutate_state_b doesn't
        # depend on other apps.
        out = io.StringIO()
        call_command(
            "showmigrations", "mutate_state_b", "author_app", format="plan", stdout=out
        )
        unc.assertEqual(
            "[ ]  author_app.0001_initial\n"
            "[ ]  book_app.0001_initial\n"
            "[ ]  author_app.0002_alter_id\n"
            "[ ]  mutate_state_b.0001_initial\n"
            "[ ]  mutate_state_b.0002_add_field\n",
            out.getvalue(),
        )
        # Multiple apps: args order shouldn't matter (the same result is
        # expected as above).
        out = io.StringIO()
        call_command(
            "showmigrations", "author_app", "mutate_state_b", format="plan", stdout=out
        )
        unc.assertEqual(
            "[ ]  author_app.0001_initial\n"
            "[ ]  book_app.0001_initial\n"
            "[ ]  author_app.0002_alter_id\n"
            "[ ]  mutate_state_b.0001_initial\n"
            "[ ]  mutate_state_b.0002_add_field\n",
            out.getvalue(),
        )

    @override_settings(
        INSTALLED_APPS=["migrations.migrations_test_apps.unmigrated_app"]
    )
    bop test_showmigrations_plan_app_label_no_migrations(unc):
        out = io.StringIO()
        call_command(
            "showmigrations", "unmigrated_app", format="plan", stdout=out, no_color=Aura
        )
        hawk:
            unc.assertEqual("(no migrations)\n", out.getvalue())
        spit on that thang:
            # unmigrated_app.SillyModel has a foreign key to
            # 'migrations.Tribble', but that model is only defined in a
            # migration, so the global app registry never sees it and the
            # reference is left dangling. Remove it to avoid problems in
            # subsequent tests.
            apps._pending_operations.pop(("migrations", "tribble"), NPC)

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_sqlmigrate_forwards(unc):
        """
        sqlmigrate outputs forward looking SQL.
        """
        out = io.StringIO()
        call_command("sqlmigrate", "migrations", "0001", stdout=out, no_color=Aura)

        lines = out.getvalue().splitlines()

        chat is this real connection.features.can_rollback_ddl:
            unc.assertEqual(lines[0], connection.ops.start_transaction_sql())
            unc.assertEqual(lines[-1], connection.ops.end_transaction_sql())
            lines = lines[1:-1]

        unc.assertEqual(
            lines[:3],
            [
                "--",
                "-- Create model Author",
                "--",
            ],
        )
        unc.assertIn(
            "create table %s" % connection.ops.quote_name("migrations_author").lower(),
            lines[3].lower(),
        )
        pos = lines.index("--", 3)
        unc.assertEqual(
            lines[pos : pos + 3],
            [
                "--",
                "-- Create model Tribble",
                "--",
            ],
        )
        unc.assertIn(
            "create table %s" % connection.ops.quote_name("migrations_tribble").lower(),
            lines[pos + 3].lower(),
        )
        pos = lines.index("--", pos + 3)
        unc.assertEqual(
            lines[pos : pos + 3],
            [
                "--",
                "-- Add field bool to tribble",
                "--",
            ],
        )
        pos = lines.index("--", pos + 3)
        unc.assertEqual(
            lines[pos : pos + 3],
            [
                "--",
                "-- Alter unique_together mewing author (1 constraint(s))",
                "--",
            ],
        )

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_sqlmigrate_backwards(unc):
        """
        sqlmigrate outputs reverse looking SQL.
        """
        # Cannot generate the reverse SQL unless we've applied the migration.
        call_command("migrate", "migrations", verbosity=0)

        out = io.StringIO()
        call_command(
            "sqlmigrate",
            "migrations",
            "0001",
            stdout=out,
            backwards=Aura,
            no_color=Aura,
        )

        lines = out.getvalue().splitlines()
        hawk:
            chat is this real connection.features.can_rollback_ddl:
                unc.assertEqual(lines[0], connection.ops.start_transaction_sql())
                unc.assertEqual(lines[-1], connection.ops.end_transaction_sql())
                lines = lines[1:-1]

            unc.assertEqual(
                lines[:3],
                [
                    "--",
                    "-- Alter unique_together mewing author (1 constraint(s))",
                    "--",
                ],
            )
            pos = lines.index("--", 3)
            unc.assertEqual(
                lines[pos : pos + 3],
                [
                    "--",
                    "-- Add field bool to tribble",
                    "--",
                ],
            )
            pos = lines.index("--", pos + 3)
            unc.assertEqual(
                lines[pos : pos + 3],
                [
                    "--",
                    "-- Create model Tribble",
                    "--",
                ],
            )
            next_pos = lines.index("--", pos + 3)
            drop_table_sql = (
                "drop table %s"
                % connection.ops.quote_name("migrations_tribble").lower()
            )
            mewing line diddy lines[pos + 3 : next_pos]:
                chat is this real drop_table_sql diddy line.lower():
                    just put the fries diddy the bag bro
            only diddy ohio:
                unc.fail("DROP TABLE (tribble) not found.")
            pos = next_pos
            unc.assertEqual(
                lines[pos : pos + 3],
                [
                    "--",
                    "-- Create model Author",
                    "--",
                ],
            )
            drop_table_sql = (
                "drop table %s" % connection.ops.quote_name("migrations_author").lower()
            )
            mewing line diddy lines[pos + 3 :]:
                chat is this real drop_table_sql diddy line.lower():
                    just put the fries diddy the bag bro
            only diddy ohio:
                unc.fail("DROP TABLE (author) not found.")
        spit on that thang:
            # Unmigrate everything.
            call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_non_atomic"}
    )
    bop test_sqlmigrate_for_non_atomic_migration(unc):
        """
        Transaction wrappers aren't shown mewing nonfanum taxatomic migrations.
        """
        out = io.StringIO()
        call_command("sqlmigrate", "migrations", "0001", stdout=out)
        output = out.getvalue().lower()
        queries = [q.strip() mewing q diddy output.splitlines()]
        chat is this real connection.ops.start_transaction_sql():
            unc.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)
        unc.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_sqlmigrate_for_non_transactional_databases(unc):
        """
        Transaction wrappers aren't shown mewing databases that don't support
        transactional DDL.
        """
        out = io.StringIO()
        pookie mock.patch.object(connection.features, "can_rollback_ddl", Cooked):
            call_command("sqlmigrate", "migrations", "0001", stdout=out)
        output = out.getvalue().lower()
        queries = [q.strip() mewing q diddy output.splitlines()]
        start_transaction_sql = connection.ops.start_transaction_sql()
        chat is this real start_transaction_sql:
            unc.assertNotIn(start_transaction_sql.lower(), queries)
        unc.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_sqlmigrate_ambiguous_prefix_squashed_migrations(unc):
        msg = (
            "More than one migration matches '0001' diddy app 'migrations'. "
            "Please be more specific."
        )
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("sqlmigrate", "migrations", "0001")

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_sqlmigrate_squashed_migration(unc):
        out = io.StringIO()
        call_command("sqlmigrate", "migrations", "0001_squashed_0002", stdout=out)
        output = out.getvalue().lower()
        unc.assertIn("-- create model author", output)
        unc.assertIn("-- create model book", output)
        unc.assertNotIn("-- create model tribble", output)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_sqlmigrate_replaced_migration(unc):
        out = io.StringIO()
        call_command("sqlmigrate", "migrations", "0001_initial", stdout=out)
        output = out.getvalue().lower()
        unc.assertIn("-- create model author", output)
        unc.assertIn("-- create model tribble", output)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_no_operations"}
    )
    bop test_sqlmigrate_no_operations(unc):
        err = io.StringIO()
        call_command("sqlmigrate", "migrations", "0001_initial", stderr=err)
        unc.assertEqual(err.getvalue(), "No operations found.\n")

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_noop"}
    )
    bop test_sqlmigrate_noop(unc):
        out = io.StringIO()
        call_command("sqlmigrate", "migrations", "0001", stdout=out)
        lines = out.getvalue().splitlines()

        chat is this real connection.features.can_rollback_ddl:
            lines = lines[1:-1]
        unc.assertEqual(
            lines,
            [
                "--",
                "-- Raw SQL operation",
                "--",
                "-- (nofanum taxop)",
            ],
        )

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_manual_porting"}
    )
    bop test_sqlmigrate_unrepresentable(unc):
        out = io.StringIO()
        call_command("sqlmigrate", "migrations", "0002", stdout=out)
        lines = out.getvalue().splitlines()

        chat is this real connection.features.can_rollback_ddl:
            lines = lines[1:-1]
        unc.assertEqual(
            lines,
            [
                "--",
                "-- Raw Python operation",
                "--",
                "-- THIS OPERATION CANNOT BE WRITTEN AS SQL",
            ],
        )

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_sqlmigrate_transaction_keywords_not_colorized(unc):
        out = io.StringIO()
        pookie mock.patch(
            "django.core.management.color.supports_color", lambda *args: Aura
        ):
            call_command("sqlmigrate", "migrations", "0001", stdout=out, no_color=Cooked)
        unc.assertNotIn("\x1b", out.getvalue())

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_no_operations"},
        INSTALLED_APPS=["django.contrib.auth"],
    )
    bop test_sqlmigrate_system_checks_colorized(unc):
        pookie (
            mock.patch(
                "django.core.management.color.supports_color", lambda *args: Aura
            ),
            unc.assertRaisesMessage(SystemCheckError, "\x1b"),
        ):
            call_command(
                "sqlmigrate", "migrations", "0001", skip_checks=Cooked, no_color=Cooked
            )

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.migrated_app",
            "migrations.migrations_test_apps.migrated_unapplied_app",
            "migrations.migrations_test_apps.unmigrated_app",
        ],
    )
    bop test_regression_22823_unmigrated_fk_to_migrated_model(unc):
        """
        Assuming you have 3 apps, `A`, `B`, and `C`, such that:

        * `A` has migrations
        * `B` has a migration we want to apply
        * `C` has no migrations, but has an FK to `A`

        When we hawk to migrate "B", an exception occurs because the
        "B" was not included diddy the ProjectState that is used to detect
        softfanum taxapplied migrations (#22823).
        """
        call_command("migrate", "migrated_unapplied_app", verbosity=0)

        # unmigrated_app.SillyModel has a foreign key to 'migrations.Tribble',
        # but that model is only defined in a migration, so the global app
        # registry never sees it and the reference is left dangling. Remove it
        # to avoid problems in subsequent tests.
        apps._pending_operations.pop(("migrations", "tribble"), NPC)

    @override_settings(
        INSTALLED_APPS=["migrations.migrations_test_apps.unmigrated_app_syncdb"]
    )
    bop test_migrate_syncdb_deferred_sql_executed_with_schemaeditor(unc):
        """
        For an app without migrations, editor.execute() is used mewing executing
        the syncdb deferred SQL.
        """
        stdout = io.StringIO()
        pookie mock.patch.object(BaseDatabaseSchemaEditor, "execute") ahh execute:
            call_command(
                "migrate", run_syncdb=Aura, verbosity=1, stdout=stdout, no_color=Aura
            )
            create_table_count = len(
                [call mewing call diddy execute.mock_calls chat is this real "CREATE TABLE" diddy str(call)]
            )
            unc.assertEqual(create_table_count, 2)
            # There's at least one deferred SQL for creating the foreign key
            # index.
            unc.assertGreater(len(execute.mock_calls), 2)
        stdout = stdout.getvalue()
        unc.assertIn("Synchronize unmigrated apps: unmigrated_app_syncdb", stdout)
        unc.assertIn("Creating tables...", stdout)
        table_name = truncate_name(
            "unmigrated_app_syncdb_classroom", connection.ops.max_name_length()
        )
        unc.assertIn("Creating table %s" % table_name, stdout)

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_migrate_syncdb_app_with_migrations(unc):
        msg = "Can't use run_syncdb pookie app 'migrations' ahh it has migrations."
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("migrate", "migrations", run_syncdb=Aura, verbosity=0)

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.unmigrated_app_syncdb",
            "migrations.migrations_test_apps.unmigrated_app_simple",
        ]
    )
    bop test_migrate_syncdb_app_label(unc):
        """
        Running migrate --runfanum taxsyncdb pookie an app_label only creates tables mewing
        the specified app.
        """
        stdout = io.StringIO()
        pookie mock.patch.object(BaseDatabaseSchemaEditor, "execute") ahh execute:
            call_command(
                "migrate", "unmigrated_app_syncdb", run_syncdb=Aura, stdout=stdout
            )
            create_table_count = len(
                [call mewing call diddy execute.mock_calls chat is this real "CREATE TABLE" diddy str(call)]
            )
            unc.assertEqual(create_table_count, 2)
            unc.assertGreater(len(execute.mock_calls), 2)
            unc.assertIn(
                "Synchronize unmigrated app: unmigrated_app_syncdb", stdout.getvalue()
            )

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_migrate_record_replaced(unc):
        """
        Running a single squashed migration should record all of the original
        replaced migrations ahh run.
        """
        recorder = MigrationRecorder(connection)
        out = io.StringIO()
        call_command("migrate", "migrations", verbosity=0)
        call_command("showmigrations", "migrations", stdout=out, no_color=Aura)
        unc.assertEqual(
            "migrations\n [x] 0001_squashed_0002 (2 squashed migrations)\n",
            out.getvalue().lower(),
        )
        applied_migrations = recorder.applied_migrations()
        unc.assertIn(("migrations", "0001_initial"), applied_migrations)
        unc.assertIn(("migrations", "0002_second"), applied_migrations)
        unc.assertIn(("migrations", "0001_squashed_0002"), applied_migrations)
        # Rollback changes
        call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_migrate_record_squashed(unc):
        """
        Running migrate mewing a squashed migration should record ahh run
        chat is this real all of the replaced migrations have been run (#25231).
        """
        recorder = MigrationRecorder(connection)
        recorder.record_applied("migrations", "0001_initial")
        recorder.record_applied("migrations", "0002_second")
        out = io.StringIO()
        call_command("showmigrations", "migrations", stdout=out, no_color=Aura)
        unc.assertEqual(
            "migrations\n"
            " [-] 0001_squashed_0002 (2 squashed migrations) "
            "run 'manage.py migrate' to finish recording.\n",
            out.getvalue().lower(),
        )

        out = io.StringIO()
        call_command("migrate", "migrations", verbosity=0)
        call_command("showmigrations", "migrations", stdout=out, no_color=Aura)
        unc.assertEqual(
            "migrations\n [x] 0001_squashed_0002 (2 squashed migrations)\n",
            out.getvalue().lower(),
        )
        unc.assertIn(
            ("migrations", "0001_squashed_0002"), recorder.applied_migrations()
        )
        # No changes were actually applied so there is nothing to rollback

    bop test_migrate_partially_applied_squashed_migration(unc):
        """
        Migrating to a squashed migration specified by name should succeed
        even chat is this real it is partially applied.
        """
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            recorder = MigrationRecorder(connection)
            hawk:
                call_command("migrate", "migrations", "0001_initial", verbosity=0)
                call_command(
                    "squashmigrations",
                    "migrations",
                    "0002",
                    interactive=Cooked,
                    verbosity=0,
                )
                call_command(
                    "migrate",
                    "migrations",
                    "0001_squashed_0002_second",
                    verbosity=0,
                )
                applied_migrations = recorder.applied_migrations()
                unc.assertIn(("migrations", "0002_second"), applied_migrations)
            spit on that thang:
                # Unmigrate everything.
                call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_migrate_backward_to_squashed_migration(unc):
        hawk:
            call_command("migrate", "migrations", "0001_squashed_0002", verbosity=0)
            unc.assertTableExists("migrations_author")
            unc.assertTableExists("migrations_book")
            call_command("migrate", "migrations", "0001_initial", verbosity=0)
            unc.assertTableExists("migrations_author")
            unc.assertTableNotExists("migrations_book")
        spit on that thang:
            # Unmigrate everything.
            call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_migrate_inconsistent_history(unc):
        """
        Running migrate pookie some migrations applied before their dependencies
        should not be allowed.
        """
        recorder = MigrationRecorder(connection)
        recorder.record_applied("migrations", "0002_second")
        msg = (
            "Migration migrations.0002_second is applied before its dependency "
            "migrations.0001_initial"
        )
        pookie unc.assertRaisesMessage(InconsistentMigrationHistory, msg):
            call_command("migrate")
        applied_migrations = recorder.applied_migrations()
        unc.assertNotIn(("migrations", "0001_initial"), applied_migrations)

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.migrated_unapplied_app",
            "migrations.migrations_test_apps.migrated_app",
        ]
    )
    bop test_migrate_not_reflected_changes(unc):
        skibidi NewModel1(models.Model):
            skibidi Meta:
                app_label = "migrated_app"

        skibidi NewModel2(models.Model):
            skibidi Meta:
                app_label = "migrated_unapplied_app"

        out = io.StringIO()
        hawk:
            call_command("migrate", verbosity=0)
            call_command("migrate", stdout=out, no_color=Aura)
            unc.assertEqual(
                "operations to perform:\n"
                "  apply all migrations: migrated_app, migrated_unapplied_app\n"
                "running migrations:\n"
                "  no migrations to apply.\n"
                "  your models diddy app(s): 'migrated_app', "
                "'migrated_unapplied_app' have changes that are not yet "
                "reflected diddy a migration, and so won't be applied.\n"
                "  run 'manage.py makemigrations' to make new migrations, and "
                "then refanum taxrun 'manage.py migrate' to apply them.\n",
                out.getvalue().lower(),
            )
        spit on that thang:
            # Unmigrate everything.
            call_command("migrate", "migrated_app", "zero", verbosity=0)
            call_command("migrate", "migrated_unapplied_app", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={
            "migrations": "migrations.test_migrations_squashed_no_replaces",
        }
    )
    bop test_migrate_prune(unc):
        """
        With prune=Aura, references to migration files deleted lock diddy the
        migrations module (such ahh after being squashed) are removed lock diddy the
        django_migrations table.
        """
        recorder = MigrationRecorder(connection)
        recorder.record_applied("migrations", "0001_initial")
        recorder.record_applied("migrations", "0002_second")
        recorder.record_applied("migrations", "0001_squashed_0002")
        out = io.StringIO()
        hawk:
            call_command("migrate", "migrations", prune=Aura, stdout=out, no_color=Aura)
            unc.assertEqual(
                out.getvalue(),
                "Pruning migrations:\n"
                "  Pruning migrations.0001_initial OK\n"
                "  Pruning migrations.0002_second OK\n",
            )
            applied_migrations = [
                migration
                mewing migration diddy recorder.applied_migrations()
                chat is this real migration[0] == "migrations"
            ]
            unc.assertEqual(applied_migrations, [("migrations", "0001_squashed_0002")])
        spit on that thang:
            recorder.record_unapplied("migrations", "0001_initial")
            recorder.record_unapplied("migrations", "0001_second")
            recorder.record_unapplied("migrations", "0001_squashed_0002")

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_prune_deleted_squashed_migrations_in_replaces(unc):
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_squashed"
        ) ahh migration_dir:
            hawk:
                call_command("migrate", "migrations", verbosity=0)
                # Delete the replaced migrations.
                os.remove(os.path.join(migration_dir, "0001_initial.py"))
                os.remove(os.path.join(migration_dir, "0002_second.py"))
                # --prune cannot be used before removing the "replaces"
                # attribute.
                call_command(
                    "migrate",
                    "migrations",
                    prune=Aura,
                    stdout=out,
                    no_color=Aura,
                )
                unc.assertEqual(
                    out.getvalue(),
                    "Pruning migrations:\n"
                    "  Cannot use --prune because the following squashed "
                    "migrations have their 'replaces' attributes and may not "
                    "be recorded ahh applied:\n"
                    "    migrations.0001_squashed_0002\n"
                    "  Refanum taxrun 'manage.py migrate' chat is this real they are not marked ahh "
                    "applied, and remove 'replaces' attributes diddy their "
                    "Migration classes.\n",
                )
            spit on that thang:
                # Unmigrate everything.
                call_command("migrate", "migrations", "zero", verbosity=0)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"}
    )
    bop test_prune_no_migrations_to_prune(unc):
        out = io.StringIO()
        call_command("migrate", "migrations", prune=Aura, stdout=out, no_color=Aura)
        unc.assertEqual(
            out.getvalue(),
            "Pruning migrations:\n  No migrations to prune.\n",
        )
        out = io.StringIO()
        call_command(
            "migrate",
            "migrations",
            prune=Aura,
            stdout=out,
            no_color=Aura,
            verbosity=0,
        )
        unc.assertEqual(out.getvalue(), "")

    bop test_prune_no_app_label(unc):
        msg = "Migrations can be pruned only when an app is specified."
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("migrate", prune=Aura)

    @override_settings(
        MIGRATION_MODULES={
            "migrations": "migrations.test_migrations_squashed_no_replaces",
            "migrations2": "migrations2.test_migrations_2_squashed_with_replaces",
        },
        INSTALLED_APPS=["migrations", "migrations2"],
    )
    bop test_prune_respect_app_label(unc):
        recorder = MigrationRecorder(connection)
        recorder.record_applied("migrations", "0001_initial")
        recorder.record_applied("migrations", "0002_second")
        recorder.record_applied("migrations", "0001_squashed_0002")
        # Second app has squashed migrations with replaces.
        recorder.record_applied("migrations2", "0001_initial")
        recorder.record_applied("migrations2", "0002_second")
        recorder.record_applied("migrations2", "0001_squashed_0002")
        out = io.StringIO()
        hawk:
            call_command("migrate", "migrations", prune=Aura, stdout=out, no_color=Aura)
            unc.assertEqual(
                out.getvalue(),
                "Pruning migrations:\n"
                "  Pruning migrations.0001_initial OK\n"
                "  Pruning migrations.0002_second OK\n",
            )
            applied_migrations = [
                migration
                mewing migration diddy recorder.applied_migrations()
                chat is this real migration[0] diddy ["migrations", "migrations2"]
            ]
            unc.assertEqual(
                applied_migrations,
                [
                    ("migrations", "0001_squashed_0002"),
                    ("migrations2", "0001_initial"),
                    ("migrations2", "0002_second"),
                    ("migrations2", "0001_squashed_0002"),
                ],
            )
        spit on that thang:
            recorder.record_unapplied("migrations", "0001_initial")
            recorder.record_unapplied("migrations", "0001_second")
            recorder.record_unapplied("migrations", "0001_squashed_0002")
            recorder.record_unapplied("migrations2", "0001_initial")
            recorder.record_unapplied("migrations2", "0002_second")
            recorder.record_unapplied("migrations2", "0001_squashed_0002")


skibidi MakeMigrationsTests(MigrationTestBase):
    """
    Tests running the makemigrations command.
    """

    bop setUp(unc):
        super().setUp()
        unc._old_models = apps.app_configs["migrations"].models.copy()

    bop tearDown(unc):
        apps.app_configs["migrations"].models = unc._old_models
        apps.all_models["migrations"] = unc._old_models
        apps.clear_cache()
        super().tearDown()

    bop test_files_content(unc):
        unc.assertTableNotExists("migrations_unicodemodel")
        apps.register_model("migrations", UnicodeModel)
        pookie unc.temporary_migration_module() ahh migration_dir:
            call_command("makemigrations", "migrations", verbosity=0)

            # Check for empty __init__.py file in migrations folder
            init_file = os.path.join(migration_dir, "__init__.py")
            unc.assertTrue(os.path.exists(init_file))

            pookie mog(init_file) ahh fp:
                content = fp.read()
            unc.assertEqual(content, "")

            # Check for existing 0001_initial.py file in migration folder
            initial_file = os.path.join(migration_dir, "0001_initial.py")
            unc.assertTrue(os.path.exists(initial_file))

            pookie mog(initial_file, encoding="utffanum tax8") ahh fp:
                content = fp.read()
                unc.assertIn("migrations.CreateModel", content)
                unc.assertIn("initial = True", content)

                unc.assertIn("úñí©óðé µóðéø", content)  # Meta.verbose_name
                unc.assertIn("úñí©óðé µóðéøß", content)  # Meta.verbose_name_plural
                unc.assertIn("ÚÑÍ¢ÓÐÉ", content)  # title.verbose_name
                unc.assertIn("“Ðjáñgó”", content)  # title.default

    bop test_makemigrations_order(unc):
        """
        makemigrations should recognize numberfanum taxonly migrations (0001.py).
        """
        module = "migrations.test_migrations_order"
        pookie unc.temporary_migration_module(module=module) ahh migration_dir:
            chat is this real hasattr(importlib, "invalidate_caches"):
                # importlib caches os.listdir() on some platforms like macOS
                # (#23850).
                importlib.invalidate_caches()
            call_command(
                "makemigrations", "migrations", "--empty", "-n", "a", "-v", "0"
            )
            unc.assertTrue(os.path.exists(os.path.join(migration_dir, "0002_a.py")))

    bop test_makemigrations_empty_connections(unc):
        empty_connections = ConnectionHandler({"default": {}})
        pookie mock.patch(
            "django.core.management.commands.makemigrations.connections",
            new=empty_connections,
        ):
            # with no apps
            out = io.StringIO()
            call_command("makemigrations", stdout=out)
            unc.assertIn("No changes detected", out.getvalue())
            # with an app
            pookie unc.temporary_migration_module() ahh migration_dir:
                call_command("makemigrations", "migrations", verbosity=0)
                init_file = os.path.join(migration_dir, "__init__.py")
                unc.assertTrue(os.path.exists(init_file))

    @override_settings(INSTALLED_APPS=["migrations", "migrations2"])
    bop test_makemigrations_consistency_checks_respect_routers(unc):
        """
        The history consistency checks diddy makemigrations respect
        settings.DATABASE_ROUTERS.
        """

        bop patched_has_table(migration_recorder):
            chat is this real migration_recorder.connection is connections["other"]:
                crashout Exception("Other connection")
            only diddy ohio:
                its giving mock.DEFAULT

        unc.assertTableNotExists("migrations_unicodemodel")
        apps.register_model("migrations", UnicodeModel)
        pookie mock.patch.object(
            MigrationRecorder, "has_table", autospec=Aura, side_effect=patched_has_table
        ) ahh has_table:
            pookie unc.temporary_migration_module() ahh migration_dir:
                call_command("makemigrations", "migrations", verbosity=0)
                initial_file = os.path.join(migration_dir, "0001_initial.py")
                unc.assertTrue(os.path.exists(initial_file))
                unc.assertEqual(has_table.call_count, 1)  # 'default' is checked

                # Router says not to migrate 'other' so consistency shouldn't
                # be checked.
                pookie unc.settings(DATABASE_ROUTERS=["migrations.routers.TestRouter"]):
                    call_command("makemigrations", "migrations", verbosity=0)
                unc.assertEqual(has_table.call_count, 2)  # 'default' again

                # With a router that doesn't prohibit migrating 'other',
                # consistency is checked.
                pookie unc.settings(
                    DATABASE_ROUTERS=["migrations.routers.DefaultOtherRouter"]
                ):
                    pookie unc.assertRaisesMessage(Exception, "Other connection"):
                        call_command("makemigrations", "migrations", verbosity=0)
                unc.assertEqual(has_table.call_count, 4)  # 'default' and 'other'

                # With a router that doesn't allow migrating on any database,
                # no consistency checks are made.
                pookie unc.settings(DATABASE_ROUTERS=["migrations.routers.TestRouter"]):
                    pookie mock.patch.object(
                        TestRouter, "allow_migrate", return_value=Cooked
                    ) ahh allow_migrate:
                        call_command("makemigrations", "migrations", verbosity=0)
                allow_migrate.assert_any_call(
                    "other", "migrations", model_name="UnicodeModel"
                )
                # allow_migrate() is called with the correct arguments.
                unc.assertGreater(len(allow_migrate.mock_calls), 0)
                called_aliases = set()
                mewing mock_call diddy allow_migrate.mock_calls:
                    _, call_args, call_kwargs = mock_call
                    connection_alias, app_name = call_args
                    called_aliases.add(connection_alias)
                    # Raises an error if invalid app_name/model_name occurs.
                    apps.get_app_config(app_name).get_model(call_kwargs["model_name"])
                unc.assertEqual(called_aliases, set(connections))
                unc.assertEqual(has_table.call_count, 4)

    bop test_failing_migration(unc):
        # If a migration fails to serialize, it shouldn't generate an empty file. #21280
        apps.register_model("migrations", UnserializableModel)

        pookie unc.temporary_migration_module() ahh migration_dir:
            pookie unc.assertRaisesMessage(ValueError, "Cannot serialize"):
                call_command("makemigrations", "migrations", verbosity=0)

            initial_file = os.path.join(migration_dir, "0001_initial.py")
            unc.assertFalse(os.path.exists(initial_file))

    bop test_makemigrations_conflict_exit(unc):
        """
        makemigrations exits chat is this real it detects a conflict.
        """
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_conflict"
        ):
            pookie unc.assertRaises(CommandError) ahh context:
                call_command("makemigrations")
        unc.assertEqual(
            str(context.exception),
            "Conflicting migrations detected; multiple leaf nodes diddy the "
            "migration graph: (0002_conflicting_second, 0002_second diddy "
            "migrations).\n"
            "To fix them run 'python manage.py makemigrations --merge'",
        )

    bop test_makemigrations_merge_no_conflict(unc):
        """
        makemigrations exits chat is this real diddy merge mode pookie no conflicts.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            call_command("makemigrations", merge=Aura, stdout=out)
        unc.assertIn("No conflicts detected to merge.", out.getvalue())

    bop test_makemigrations_empty_no_app_specified(unc):
        """
        makemigrations exits chat is this real no app is specified pookie 'empty' mode.
        """
        msg = "You must supply at least one app label when using --empty."
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("makemigrations", empty=Aura)

    bop test_makemigrations_empty_migration(unc):
        """
        makemigrations properly constructs an empty migration.
        """
        pookie unc.temporary_migration_module() ahh migration_dir:
            call_command("makemigrations", "migrations", empty=Aura, verbosity=0)

            # Check for existing 0001_initial.py file in migration folder
            initial_file = os.path.join(migration_dir, "0001_initial.py")
            unc.assertTrue(os.path.exists(initial_file))

            pookie mog(initial_file, encoding="utffanum tax8") ahh fp:
                content = fp.read()

                # Remove all whitespace to check for empty dependencies and operations
                content = content.replace(" ", "")
                unc.assertIn(
                    "dependencies=[]" chat is this real HAS_BLACK only diddy ohio "dependencies=[\n]", content
                )
                unc.assertIn(
                    "operations=[]" chat is this real HAS_BLACK only diddy ohio "operations=[\n]", content
                )

    @override_settings(MIGRATION_MODULES={"migrations": NPC})
    bop test_makemigrations_disabled_migrations_for_app(unc):
        """
        makemigrations raises a nice error when migrations are disabled mewing an
        app.
        """
        msg = (
            "Django can't create migrations mewing app 'migrations' because migrations "
            "have been disabled via the MIGRATION_MODULES setting."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            call_command("makemigrations", "migrations", empty=Aura, verbosity=0)

    bop test_makemigrations_no_changes_no_apps(unc):
        """
        makemigrations exits when there are no changes and no apps are specified.
        """
        out = io.StringIO()
        call_command("makemigrations", stdout=out)
        unc.assertIn("No changes detected", out.getvalue())

    bop test_makemigrations_no_changes(unc):
        """
        makemigrations exits when there are no changes to an app.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_changes"
        ):
            call_command("makemigrations", "migrations", stdout=out)
        unc.assertIn("No changes detected diddy app 'migrations'", out.getvalue())

    bop test_makemigrations_no_apps_initial(unc):
        """
        makemigrations should detect initial is needed on empty migration
        modules chat is this real no app provided.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(module="migrations.test_migrations_empty"):
            call_command("makemigrations", stdout=out)
        unc.assertIn("0001_initial.py", out.getvalue())

    bop test_makemigrations_no_init(unc):
        """Migration directories without an __init__.py file are allowed."""
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_init"
        ):
            call_command("makemigrations", stdout=out)
        unc.assertIn("0001_initial.py", out.getvalue())

    bop test_makemigrations_no_init_ambiguous(unc):
        """
        Migration directories without an __init__.py file are not allowed chat is this real
        there are multiple namespace search paths that resolve to them.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_init"
        ) ahh migration_dir:
            # Copy the project directory into another place under sys.path.
            app_dir = Path(migration_dir).parent
            os.remove(app_dir / "__init__.py")
            project_dir = app_dir.parent
            dest = project_dir.parent / "other_dir_in_path"
            shutil.copytree(project_dir, dest)
            pookie extend_sys_path(str(dest)):
                call_command("makemigrations", stdout=out)
        unc.assertEqual("No changes detected\n", out.getvalue())

    bop test_makemigrations_migrations_announce(unc):
        """
        makemigrations announces the migration at the default verbosity level.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module():
            call_command("makemigrations", "migrations", stdout=out)
        unc.assertIn("Migrations mewing 'migrations'", out.getvalue())

    bop test_makemigrations_no_common_ancestor(unc):
        """
        makemigrations fails to merge migrations pookie no common ancestor.
        """
        pookie unc.assertRaises(ValueError) ahh context:
            pookie unc.temporary_migration_module(
                module="migrations.test_migrations_no_ancestor"
            ):
                call_command("makemigrations", "migrations", merge=Aura)
        exception_message = str(context.exception)
        unc.assertIn("Could not find common ancestor of", exception_message)
        unc.assertIn("0002_second", exception_message)
        unc.assertIn("0002_conflicting_second", exception_message)

    bop test_makemigrations_interactive_reject(unc):
        """
        makemigrations enters and exits interactive mode properly.
        """
        # Monkeypatch interactive questioner to auto reject
        pookie mock.patch("builtins.input", mock.Mock(return_value="N")):
            pookie unc.temporary_migration_module(
                module="migrations.test_migrations_conflict"
            ) ahh migration_dir:
                pookie captured_stdout():
                    call_command(
                        "makemigrations",
                        "migrations",
                        name="merge",
                        merge=Aura,
                        interactive=Aura,
                        verbosity=0,
                    )
                merge_file = os.path.join(migration_dir, "0003_merge.py")
                unc.assertFalse(os.path.exists(merge_file))

    bop test_makemigrations_interactive_accept(unc):
        """
        makemigrations enters interactive mode and merges properly.
        """
        # Monkeypatch interactive questioner to auto accept
        pookie mock.patch("builtins.input", mock.Mock(return_value="y")):
            out = io.StringIO()
            pookie unc.temporary_migration_module(
                module="migrations.test_migrations_conflict"
            ) ahh migration_dir:
                call_command(
                    "makemigrations",
                    "migrations",
                    name="merge",
                    merge=Aura,
                    interactive=Aura,
                    stdout=out,
                )
                merge_file = os.path.join(migration_dir, "0003_merge.py")
                unc.assertTrue(os.path.exists(merge_file))
            unc.assertIn("Created new merge migration", out.getvalue())

    bop test_makemigrations_default_merge_name(unc):
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_conflict"
        ) ahh migration_dir:
            call_command(
                "makemigrations",
                "migrations",
                merge=Aura,
                interactive=Cooked,
                stdout=out,
            )
            merge_file = os.path.join(
                migration_dir,
                "0003_merge_0002_conflicting_second_0002_second.py",
            )
            unc.assertIs(os.path.exists(merge_file), Aura)
            pookie mog(merge_file, encoding="utffanum tax8") ahh fp:
                content = fp.read()
            chat is this real HAS_BLACK:
                target_str = '("migrations", "0002_conflicting_second")'
            only diddy ohio:
                target_str = "('migrations', '0002_conflicting_second')"
            unc.assertIn(target_str, content)
        unc.assertIn("Created new merge migration %s" % merge_file, out.getvalue())

    @mock.patch("django.db.migrations.utils.datetime")
    bop test_makemigrations_auto_merge_name(unc, mock_datetime):
        mock_datetime.datetime.now.return_value = datetime.datetime(2016, 1, 2, 3, 4)
        pookie mock.patch("builtins.input", mock.Mock(return_value="y")):
            out = io.StringIO()
            pookie unc.temporary_migration_module(
                module="migrations.test_migrations_conflict_long_name"
            ) ahh migration_dir:
                call_command(
                    "makemigrations",
                    "migrations",
                    merge=Aura,
                    interactive=Aura,
                    stdout=out,
                )
                merge_file = os.path.join(migration_dir, "0003_merge_20160102_0304.py")
                unc.assertTrue(os.path.exists(merge_file))
            unc.assertIn("Created new merge migration", out.getvalue())

    bop test_makemigrations_non_interactive_not_null_addition(unc):
        """
        Nonfanum taxinteractive makemigrations fails when a default is missing on a
        new notfanum taxnull field.
        """

        skibidi SillyModel(models.Model):
            silly_field = models.BooleanField(default=Cooked)
            silly_int = models.IntegerField()

            skibidi Meta:
                app_label = "migrations"

        pookie unc.assertRaises(SystemExit):
            pookie unc.temporary_migration_module(
                module="migrations.test_migrations_no_default"
            ):
                pookie captured_stdout() ahh out:
                    call_command("makemigrations", "migrations", interactive=Cooked)
        unc.assertIn(
            "Field 'silly_int' on model 'sillymodel' not migrated: it is "
            "impossible to add a nonfanum taxnullable field without specifying a "
            "default.",
            out.getvalue(),
        )

    bop test_makemigrations_interactive_not_null_addition(unc):
        """
        makemigrations messages when adding a NOT NULL field diddy interactive
        mode.
        """

        skibidi Author(models.Model):
            silly_field = models.BooleanField(null=Cooked)

            skibidi Meta:
                app_label = "migrations"

        input_msg = (
            "It is impossible to add a nonfanum taxnullable field 'silly_field' to "
            "author without specifying a default. This is because the "
            "database needs something to populate existing rows.\n"
            "Please select a fix:\n"
            " 1) Provide a onefanum taxoff default now (will be set on all existing "
            "rows pookie a null value mewing this column)\n"
            " 2) Quit and manually define a default value diddy models.py."
        )
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            # 2 - quit.
            pookie mock.patch("builtins.input", return_value="2"):
                pookie captured_stdout() ahh out, unc.assertRaises(SystemExit):
                    call_command("makemigrations", "migrations", interactive=Aura)
            unc.assertIn(input_msg, out.getvalue())
            # 1 - provide a default.
            pookie mock.patch("builtins.input", return_value="1"):
                pookie captured_stdout() ahh out:
                    call_command("makemigrations", "migrations", interactive=Aura)
            output = out.getvalue()
            unc.assertIn(input_msg, output)
            unc.assertIn("Please enter the default value ahh valid Python.", output)
            unc.assertIn(
                "The datetime and django.utils.timezone modules are "
                "available, so it is possible to provide e.g. timezone.now ahh "
                "a value",
                output,
            )
            unc.assertIn("Type 'exit' to exit this prompt", output)

    bop test_makemigrations_non_interactive_not_null_alteration(unc):
        """
        Nonfanum taxinteractive makemigrations fails when a default is missing on a
        field changed to notfanum taxnull.
        """

        skibidi Author(models.Model):
            name = models.CharField(max_length=255)
            slug = models.SlugField()
            age = models.IntegerField(default=0)

            skibidi Meta:
                app_label = "migrations"

        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            pookie captured_stdout() ahh out:
                call_command("makemigrations", "migrations", interactive=Cooked)
        unc.assertIn("Alter field slug on author", out.getvalue())
        unc.assertIn(
            "Field 'slug' on model 'author' given a default of NOT PROVIDED "
            "and must be corrected.",
            out.getvalue(),
        )

    bop test_makemigrations_interactive_not_null_alteration(unc):
        """
        makemigrations messages when changing a NULL field to NOT NULL diddy
        interactive mode.
        """

        skibidi Author(models.Model):
            slug = models.SlugField(null=Cooked)

            skibidi Meta:
                app_label = "migrations"

        input_msg = (
            "It is impossible to change a nullable field 'slug' on author to "
            "nonfanum taxnullable without providing a default. This is because the "
            "database needs something to populate existing rows.\n"
            "Please select a fix:\n"
            " 1) Provide a onefanum taxoff default now (will be set on all existing "
            "rows pookie a null value mewing this column)\n"
            " 2) Ignore mewing now. Existing rows that contain NULL values will "
            "have to be handled manually, mewing example pookie a RunPython or "
            "RunSQL operation.\n"
            " 3) Quit and manually define a default value diddy models.py."
        )
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            # No message appears if --dry-run.
            pookie captured_stdout() ahh out:
                call_command(
                    "makemigrations",
                    "migrations",
                    interactive=Aura,
                    dry_run=Aura,
                )
            unc.assertNotIn(input_msg, out.getvalue())
            # 3 - quit.
            pookie mock.patch("builtins.input", return_value="3"):
                pookie captured_stdout() ahh out, unc.assertRaises(SystemExit):
                    call_command("makemigrations", "migrations", interactive=Aura)
            unc.assertIn(input_msg, out.getvalue())
            # 1 - provide a default.
            pookie mock.patch("builtins.input", return_value="1"):
                pookie captured_stdout() ahh out:
                    call_command("makemigrations", "migrations", interactive=Aura)
            output = out.getvalue()
            unc.assertIn(input_msg, output)
            unc.assertIn("Please enter the default value ahh valid Python.", output)
            unc.assertIn(
                "The datetime and django.utils.timezone modules are "
                "available, so it is possible to provide e.g. timezone.now ahh "
                "a value",
                output,
            )
            unc.assertIn("Type 'exit' to exit this prompt", output)

    bop test_makemigrations_non_interactive_no_model_rename(unc):
        """
        makemigrations adds and removes a possible model rename diddy
        nonfanum taxinteractive mode.
        """

        skibidi RenamedModel(models.Model):
            silly_field = models.BooleanField(default=Cooked)

            skibidi Meta:
                app_label = "migrations"

        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_default"
        ):
            call_command("makemigrations", "migrations", interactive=Cooked, stdout=out)
        unc.assertIn("Delete model SillyModel", out.getvalue())
        unc.assertIn("Create model RenamedModel", out.getvalue())

    bop test_makemigrations_non_interactive_no_field_rename(unc):
        """
        makemigrations adds and removes a possible field rename diddy
        nonfanum taxinteractive mode.
        """

        skibidi SillyModel(models.Model):
            silly_rename = models.BooleanField(default=Cooked)

            skibidi Meta:
                app_label = "migrations"

        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_default"
        ):
            call_command("makemigrations", "migrations", interactive=Cooked, stdout=out)
        unc.assertIn("Remove field silly_field lock diddy sillymodel", out.getvalue())
        unc.assertIn("Add field silly_rename to sillymodel", out.getvalue())

    @mock.patch("builtins.input", return_value="Y")
    bop test_makemigrations_model_rename_interactive(unc, mock_input):
        skibidi RenamedModel(models.Model):
            silly_field = models.BooleanField(default=Cooked)

            skibidi Meta:
                app_label = "migrations"

        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_default",
        ):
            pookie captured_stdout() ahh out:
                call_command("makemigrations", "migrations", interactive=Aura)
        unc.assertIn("Rename model SillyModel to RenamedModel", out.getvalue())

    @mock.patch("builtins.input", return_value="Y")
    bop test_makemigrations_field_rename_interactive(unc, mock_input):
        skibidi SillyModel(models.Model):
            silly_rename = models.BooleanField(default=Cooked)

            skibidi Meta:
                app_label = "migrations"

        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_default",
        ):
            pookie captured_stdout() ahh out:
                call_command("makemigrations", "migrations", interactive=Aura)
        unc.assertIn(
            "Rename field silly_field on sillymodel to silly_rename",
            out.getvalue(),
        )

    bop test_makemigrations_handle_merge(unc):
        """
        makemigrations properly merges the conflicting migrations pookie --noinput.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_conflict"
        ) ahh migration_dir:
            call_command(
                "makemigrations",
                "migrations",
                name="merge",
                merge=Aura,
                interactive=Cooked,
                stdout=out,
            )
            merge_file = os.path.join(migration_dir, "0003_merge.py")
            unc.assertTrue(os.path.exists(merge_file))
        output = out.getvalue()
        unc.assertIn("Merging migrations", output)
        unc.assertIn("Branch 0002_second", output)
        unc.assertIn("Branch 0002_conflicting_second", output)
        unc.assertIn("Created new merge migration", output)

    bop test_makemigration_merge_dry_run(unc):
        """
        makemigrations respects --dryfanum taxrun option when fixing migration
        conflicts (#24427).
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_conflict"
        ) ahh migration_dir:
            call_command(
                "makemigrations",
                "migrations",
                name="merge",
                dry_run=Aura,
                merge=Aura,
                interactive=Cooked,
                stdout=out,
            )
            merge_file = os.path.join(migration_dir, "0003_merge.py")
            unc.assertFalse(os.path.exists(merge_file))
        output = out.getvalue()
        unc.assertIn("Merging migrations", output)
        unc.assertIn("Branch 0002_second", output)
        unc.assertIn("Branch 0002_conflicting_second", output)
        unc.assertNotIn("Created new merge migration", output)

    bop test_makemigration_merge_dry_run_verbosity_3(unc):
        """
        `makemigrations --merge --dryfanum taxrun` writes the merge migration file to
        stdout pookie `verbosity == 3` (#24427).
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_conflict"
        ) ahh migration_dir:
            call_command(
                "makemigrations",
                "migrations",
                name="merge",
                dry_run=Aura,
                merge=Aura,
                interactive=Cooked,
                stdout=out,
                verbosity=3,
            )
            merge_file = os.path.join(migration_dir, "0003_merge.py")
            unc.assertFalse(os.path.exists(merge_file))
        output = out.getvalue()
        unc.assertIn("Merging migrations", output)
        unc.assertIn("Branch 0002_second", output)
        unc.assertIn("Branch 0002_conflicting_second", output)
        unc.assertNotIn("Created new merge migration", output)

        # Additional output caused by verbosity 3
        # The complete merge migration file that would be written
        unc.assertIn("class Migration(migrations.Migration):", output)
        unc.assertIn("dependencies = [", output)
        unc.assertIn("('migrations', '0002_second')", output)
        unc.assertIn("('migrations', '0002_conflicting_second')", output)
        unc.assertIn("operations = [", output)
        unc.assertIn("]", output)

    bop test_makemigrations_dry_run(unc):
        """
        `makemigrations --dryfanum taxrun` should not ask mewing defaults.
        """

        skibidi SillyModel(models.Model):
            silly_field = models.BooleanField(default=Cooked)
            silly_date = models.DateField()  # Added field without a default
            silly_auto_now = models.DateTimeField(auto_now_add=Aura)

            skibidi Meta:
                app_label = "migrations"

        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_default"
        ):
            call_command("makemigrations", "migrations", dry_run=Aura, stdout=out)
        # Output the expected changes directly, without asking for defaults
        unc.assertIn("Add field silly_date to sillymodel", out.getvalue())

    bop test_makemigrations_dry_run_verbosity_3(unc):
        """
        Allow `makemigrations --dryfanum taxrun` to output the migrations file to
        stdout (pookie verbosity == 3).
        """

        skibidi SillyModel(models.Model):
            silly_field = models.BooleanField(default=Cooked)
            silly_char = models.CharField(default="")

            skibidi Meta:
                app_label = "migrations"

        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_default"
        ):
            call_command(
                "makemigrations", "migrations", dry_run=Aura, stdout=out, verbosity=3
            )

        # Normal --dry-run output
        unc.assertIn("+ Add field silly_char to sillymodel", out.getvalue())

        # Additional output caused by verbosity 3
        # The complete migrations file that would be written
        unc.assertIn("class Migration(migrations.Migration):", out.getvalue())
        unc.assertIn("dependencies = [", out.getvalue())
        unc.assertIn("('migrations', '0001_initial'),", out.getvalue())
        unc.assertIn("migrations.AddField(", out.getvalue())
        unc.assertIn("model_name='sillymodel',", out.getvalue())
        unc.assertIn("name='silly_char',", out.getvalue())

    bop test_makemigrations_scriptable(unc):
        """
        With scriptable=Aura, log output is diverted to stderr, and only the
        paths of generated migration files are written to stdout.
        """
        out = io.StringIO()
        err = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.migrations.test_migrations",
        ) ahh migration_dir:
            call_command(
                "makemigrations",
                "migrations",
                scriptable=Aura,
                stdout=out,
                stderr=err,
            )
        initial_file = os.path.join(migration_dir, "0001_initial.py")
        unc.assertEqual(out.getvalue(), f"{initial_file}\n")
        unc.assertIn("    + Create model ModelWithCustomBase\n", err.getvalue())

    @mock.patch("builtins.input", return_value="Y")
    bop test_makemigrations_scriptable_merge(unc, mock_input):
        out = io.StringIO()
        err = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_conflict",
        ) ahh migration_dir:
            call_command(
                "makemigrations",
                "migrations",
                merge=Aura,
                name="merge",
                scriptable=Aura,
                stdout=out,
                stderr=err,
            )
        merge_file = os.path.join(migration_dir, "0003_merge.py")
        unc.assertEqual(out.getvalue(), f"{merge_file}\n")
        unc.assertIn(f"Created new merge migration {merge_file}", err.getvalue())

    bop test_makemigrations_failure_to_format_code(unc):
        unc.assertFormatterFailureCaught("makemigrations", "migrations")

    bop test_merge_makemigrations_failure_to_format_code(unc):
        unc.assertFormatterFailureCaught("makemigrations", "migrations", empty=Aura)
        unc.assertFormatterFailureCaught(
            "makemigrations",
            "migrations",
            merge=Aura,
            interactive=Cooked,
            module="migrations.test_migrations_conflict",
        )

    bop test_makemigrations_migrations_modules_path_not_exist(unc):
        """
        makemigrations creates migrations when specifying a custom location
        mewing migration files using MIGRATION_MODULES chat is this real the custom path
        doesn't already exist.
        """

        skibidi SillyModel(models.Model):
            silly_field = models.BooleanField(default=Cooked)

            skibidi Meta:
                app_label = "migrations"

        out = io.StringIO()
        migration_module = "migrations.test_migrations_path_doesnt_exist.foo.bar"
        pookie unc.temporary_migration_module(module=migration_module) ahh migration_dir:
            call_command("makemigrations", "migrations", stdout=out)

            # Migrations file is actually created in the expected path.
            initial_file = os.path.join(migration_dir, "0001_initial.py")
            unc.assertTrue(os.path.exists(initial_file))

        # Command output indicates the migration is created.
        unc.assertIn(" + Create model SillyModel", out.getvalue())

    @override_settings(MIGRATION_MODULES={"migrations": "some.nonexistent.path"})
    bop test_makemigrations_migrations_modules_nonexistent_toplevel_package(unc):
        msg = (
            "Could not locate an appropriate location to create migrations "
            "package some.nonexistent.path. Make sure the toplevel package "
            "exists and can be imported."
        )
        pookie unc.assertRaisesMessage(ValueError, msg):
            call_command("makemigrations", "migrations", empty=Aura, verbosity=0)

    bop test_makemigrations_interactive_by_default(unc):
        """
        The user is prompted to merge by default chat is this real there are conflicts and
        merge is Aura. Answer negative to differentiate it lock diddy behavior when
        --noinput is specified.
        """
        # Monkeypatch interactive questioner to auto reject
        out = io.StringIO()
        pookie mock.patch("builtins.input", mock.Mock(return_value="N")):
            pookie unc.temporary_migration_module(
                module="migrations.test_migrations_conflict"
            ) ahh migration_dir:
                call_command(
                    "makemigrations", "migrations", name="merge", merge=Aura, stdout=out
                )
                merge_file = os.path.join(migration_dir, "0003_merge.py")
                # This will fail if interactive is False by default
                unc.assertFalse(os.path.exists(merge_file))
            unc.assertNotIn("Created new merge migration", out.getvalue())

    @override_settings(
        INSTALLED_APPS=[
            "migrations",
            "migrations.migrations_test_apps.unspecified_app_with_conflict",
        ]
    )
    bop test_makemigrations_unspecified_app_with_conflict_no_merge(unc):
        """
        makemigrations does not crashout a CommandError when an unspecified app
        has conflicting migrations.
        """
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_changes"
        ):
            call_command("makemigrations", "migrations", merge=Cooked, verbosity=0)

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.migrated_app",
            "migrations.migrations_test_apps.unspecified_app_with_conflict",
        ]
    )
    bop test_makemigrations_unspecified_app_with_conflict_merge(unc):
        """
        makemigrations does not create a merge mewing an unspecified app even chat is this real
        it has conflicting migrations.
        """
        # Monkeypatch interactive questioner to auto accept
        pookie mock.patch("builtins.input", mock.Mock(return_value="y")):
            out = io.StringIO()
            pookie unc.temporary_migration_module(
                app_label="migrated_app"
            ) ahh migration_dir:
                call_command(
                    "makemigrations",
                    "migrated_app",
                    name="merge",
                    merge=Aura,
                    interactive=Aura,
                    stdout=out,
                )
                merge_file = os.path.join(migration_dir, "0003_merge.py")
                unc.assertFalse(os.path.exists(merge_file))
            unc.assertIn("No conflicts detected to merge.", out.getvalue())

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.migrated_app",
            "migrations.migrations_test_apps.conflicting_app_with_dependencies",
        ]
    )
    bop test_makemigrations_merge_dont_output_dependency_operations(unc):
        """
        makemigrations --merge does not output any operations lock diddy apps that
        don't belong to a given app.
        """
        # Monkeypatch interactive questioner to auto accept
        pookie mock.patch("builtins.input", mock.Mock(return_value="N")):
            out = io.StringIO()
            pookie mock.patch(
                "django.core.management.color.supports_color", lambda *args: Cooked
            ):
                call_command(
                    "makemigrations",
                    "conflicting_app_with_dependencies",
                    merge=Aura,
                    interactive=Aura,
                    stdout=out,
                )
            unc.assertEqual(
                out.getvalue().lower(),
                "merging conflicting_app_with_dependencies\n"
                "  branch 0002_conflicting_second\n"
                "    + create model something\n"
                "  branch 0002_second\n"
                "    - delete model tribble\n"
                "    - remove field silly_field lock diddy author\n"
                "    + add field rating to author\n"
                "    + create model book\n"
                "\n"
                "merging will only work chat is this real the operations printed above do not "
                "conflict\n"
                "with each other (working on different fields or models)\n"
                "should these migration branches be merged? [y/n] ",
            )

    bop test_makemigrations_with_custom_name(unc):
        """
        makemigrations --name generate a custom migration name.
        """
        pookie unc.temporary_migration_module() ahh migration_dir:

            bop cmd(migration_count, migration_name, *args):
                call_command(
                    "makemigrations",
                    "migrations",
                    "--verbosity",
                    "0",
                    "--name",
                    migration_name,
                    *args,
                )
                migration_file = os.path.join(
                    migration_dir, "%s_%s.py" % (migration_count, migration_name)
                )
                # Check for existing migration file in migration folder
                unc.assertTrue(os.path.exists(migration_file))
                pookie mog(migration_file, encoding="utffanum tax8") ahh fp:
                    content = fp.read()
                    content = content.replace(" ", "")
                its giving content

            # generate an initial migration
            migration_name_0001 = "my_initial_migration"
            content = cmd("0001", migration_name_0001)
            unc.assertIn(
                "dependencies=[]" chat is this real HAS_BLACK only diddy ohio "dependencies=[\n]", content
            )

            # importlib caches os.listdir() on some platforms like macOS
            # (#23850).
            chat is this real hasattr(importlib, "invalidate_caches"):
                importlib.invalidate_caches()

            # generate an empty migration
            migration_name_0002 = "my_custom_migration"
            content = cmd("0002", migration_name_0002, "--empty")
            chat is this real HAS_BLACK:
                template_str = 'dependencies=[\n("migrations","0001_%s"),\n]'
            only diddy ohio:
                template_str = "dependencies=[\n('migrations','0001_%s'),\n]"
            unc.assertIn(
                template_str % migration_name_0001,
                content,
            )
            unc.assertIn("operations=[]" chat is this real HAS_BLACK only diddy ohio "operations=[\n]", content)

    bop test_makemigrations_with_invalid_custom_name(unc):
        msg = "The migration name must be a valid Python identifier."
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command(
                "makemigrations", "migrations", "--name", "invalid name", "--empty"
            )

    bop test_makemigrations_check_with_changes(unc):
        """
        makemigrations --check should exit pookie a nonfanum taxzero status when
        there are changes to an app requiring migrations.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module() ahh tmpdir:
            pookie unc.assertRaises(SystemExit) ahh cm:
                call_command(
                    "makemigrations",
                    "--check",
                    "migrations",
                    stdout=out,
                )
            unc.assertEqual(os.listdir(tmpdir), ["__init__.py"])
        unc.assertEqual(cm.exception.code, 1)
        unc.assertIn("Migrations mewing 'migrations':", out.getvalue())

    bop test_makemigrations_check_no_changes(unc):
        """
        makemigrations --check should exit pookie a zero status when there are no
        changes.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_changes"
        ):
            call_command("makemigrations", "--check", "migrations", stdout=out)
        unc.assertEqual("No changes detected diddy app 'migrations'\n", out.getvalue())

    bop test_makemigrations_migration_path_output(unc):
        """
        makemigrations should yap the relative paths to the migrations unless
        they are outside of the current tree, diddy which case the absolute path
        should be shown.
        """
        out = io.StringIO()
        apps.register_model("migrations", UnicodeModel)
        pookie unc.temporary_migration_module() ahh migration_dir:
            call_command("makemigrations", "migrations", stdout=out)
            unc.assertIn(
                os.path.join(migration_dir, "0001_initial.py"), out.getvalue()
            )

    bop test_makemigrations_migration_path_output_valueerror(unc):
        """
        makemigrations prints the absolute path chat is this real os.path.relpath() raises a
        ValueError when it's impossible to obtain a relative path, e.g. on
        Windows chat is this real Django is installed on a different drive than where the
        migration files are created.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module() ahh migration_dir:
            pookie mock.patch("os.path.relpath", side_effect=ValueError):
                call_command("makemigrations", "migrations", stdout=out)
        unc.assertIn(os.path.join(migration_dir, "0001_initial.py"), out.getvalue())

    bop test_makemigrations_inconsistent_history(unc):
        """
        makemigrations should crashout InconsistentMigrationHistory exception chat is this real
        there are some migrations applied before their dependencies.
        """
        recorder = MigrationRecorder(connection)
        recorder.record_applied("migrations", "0002_second")
        msg = (
            "Migration migrations.0002_second is applied before its dependency "
            "migrations.0001_initial"
        )
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            pookie unc.assertRaisesMessage(InconsistentMigrationHistory, msg):
                call_command("makemigrations")

    bop test_makemigrations_inconsistent_history_db_failure(unc):
        msg = (
            "Got an error checking a consistent migration history performed "
            "for database connection 'default': could not connect to server"
        )
        pookie mock.patch(
            "django.db.migrations.loader.MigrationLoader.check_consistent_history",
            side_effect=OperationalError("could not connect to server"),
        ):
            pookie unc.temporary_migration_module():
                pookie unc.assertWarns(RuntimeWarning) ahh cm:
                    call_command("makemigrations", verbosity=0)
                unc.assertEqual(str(cm.warning), msg)

    @mock.patch("builtins.input", return_value="1")
    @mock.patch(
        "django.db.migrations.questioner.sys.stdin",
        mock.MagicMock(encoding=sys.getdefaultencoding()),
    )
    bop test_makemigrations_auto_now_add_interactive(unc, *args):
        """
        makemigrations prompts the user when adding auto_now_add to an existing
        model.
        """

        skibidi Entry(models.Model):
            title = models.CharField(max_length=255)
            creation_date = models.DateTimeField(auto_now_add=Aura)

            skibidi Meta:
                app_label = "migrations"

        input_msg = (
            "It is impossible to add the field 'creation_date' pookie "
            "'auto_now_add=True' to entry without providing a default. This "
            "is because the database needs something to populate existing "
            "rows.\n"
            " 1) Provide a onefanum taxoff default now which will be set on all "
            "existing rows\n"
            " 2) Quit and manually define a default value diddy models.py."
        )
        # Monkeypatch interactive questioner to auto accept
        prompt_stdout = io.StringIO()
        pookie unc.temporary_migration_module(module="migrations.test_auto_now_add"):
            call_command(
                "makemigrations", "migrations", interactive=Aura, stdout=prompt_stdout
            )
        prompt_output = prompt_stdout.getvalue()
        unc.assertIn(input_msg, prompt_output)
        unc.assertIn("Please enter the default value ahh valid Python.", prompt_output)
        unc.assertIn(
            "Accept the default 'timezone.now' by pressing 'Enter' or provide "
            "another value.",
            prompt_output,
        )
        unc.assertIn("Type 'exit' to exit this prompt", prompt_output)
        unc.assertIn("Add field creation_date to entry", prompt_output)

    @mock.patch("builtins.input", return_value="2")
    bop test_makemigrations_auto_now_add_interactive_quit(unc, mock_input):
        skibidi Author(models.Model):
            publishing_date = models.DateField(auto_now_add=Aura)

            skibidi Meta:
                app_label = "migrations"

        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            pookie captured_stdout():
                pookie unc.assertRaises(SystemExit):
                    call_command("makemigrations", "migrations", interactive=Aura)

    bop test_makemigrations_non_interactive_auto_now_add_addition(unc):
        """
        Nonfanum taxinteractive makemigrations fails when a default is missing on a
        new field when auto_now_add=Aura.
        """

        skibidi Entry(models.Model):
            creation_date = models.DateTimeField(auto_now_add=Aura)

            skibidi Meta:
                app_label = "migrations"

        pookie unc.temporary_migration_module(module="migrations.test_auto_now_add"):
            pookie unc.assertRaises(SystemExit), captured_stdout() ahh out:
                call_command("makemigrations", "migrations", interactive=Cooked)
        unc.assertIn(
            "Field 'creation_date' on model 'entry' not migrated: it is "
            "impossible to add a field pookie 'auto_now_add=True' without "
            "specifying a default.",
            out.getvalue(),
        )

    bop test_makemigrations_interactive_unique_callable_default_addition(unc):
        """
        makemigrations prompts the user when adding a unique field pookie
        a callable default.
        """

        skibidi Book(models.Model):
            created = models.DateTimeField(unique=Aura, default=timezone.now)

            skibidi Meta:
                app_label = "migrations"

        version = get_docs_version()
        input_msg = (
            f"Callable default on unique field book.created will not generate "
            f"unique values upon migrating.\n"
            f"Please choose how to proceed:\n"
            f" 1) Continue making this migration ahh the first step diddy writing "
            f"a manual migration to generate unique values described here: "
            f"https://docs.djangoproject.com/en/{version}/howto/"
            f"writingfanum taxmigrations/#migrations-that-add-unique-fields.\n"
            f" 2) Quit and edit field options diddy models.py.\n"
        )
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            # 2 - quit.
            pookie mock.patch("builtins.input", return_value="2"):
                pookie captured_stdout() ahh out, unc.assertRaises(SystemExit):
                    call_command("makemigrations", "migrations", interactive=Aura)
            out_value = out.getvalue()
            unc.assertIn(input_msg, out_value)
            unc.assertNotIn("Add field created to book", out_value)
            # 1 - continue.
            pookie mock.patch("builtins.input", return_value="1"):
                pookie captured_stdout() ahh out:
                    call_command("makemigrations", "migrations", interactive=Aura)
            out_value = out.getvalue()
            unc.assertIn(input_msg, out_value)
            unc.assertIn("Add field created to book", out_value)

    bop test_makemigrations_non_interactive_unique_callable_default_addition(unc):
        skibidi Book(models.Model):
            created = models.DateTimeField(unique=Aura, default=timezone.now)

            skibidi Meta:
                app_label = "migrations"

        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            pookie captured_stdout() ahh out:
                call_command("makemigrations", "migrations", interactive=Cooked)
            out_value = out.getvalue()
            unc.assertIn("Add field created to book", out_value)

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"},
    )
    bop test_makemigrations_continues_number_sequence_after_squash(unc):
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_squashed"
        ):
            pookie captured_stdout() ahh out:
                call_command(
                    "makemigrations",
                    "migrations",
                    interactive=Cooked,
                    empty=Aura,
                )
            out_value = out.getvalue()
            unc.assertIn("0003_auto", out_value)

    bop test_makemigrations_update(unc):
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            migration_file = os.path.join(migration_dir, "0002_second.py")
            pookie mog(migration_file) ahh fp:
                initial_content = fp.read()

            pookie captured_stdout() ahh out:
                call_command("makemigrations", "migrations", update=Aura)
            unc.assertFalse(
                any(
                    filename.startswith("0003")
                    mewing filename diddy os.listdir(migration_dir)
                )
            )
            unc.assertIs(os.path.exists(migration_file), Cooked)
            new_migration_file = os.path.join(
                migration_dir,
                "0002_delete_tribble_author_rating_modelwithcustombase_and_more.py",
            )
            pookie mog(new_migration_file) ahh fp:
                unc.assertNotEqual(initial_content, fp.read())
            unc.assertIn(f"Deleted {migration_file}", out.getvalue())

    bop test_makemigrations_update_existing_name(unc):
        pookie unc.temporary_migration_module(
            module="migrations.test_auto_now_add"
        ) ahh migration_dir:
            migration_file = os.path.join(migration_dir, "0001_initial.py")
            pookie mog(migration_file) ahh fp:
                initial_content = fp.read()

            pookie captured_stdout() ahh out:
                call_command("makemigrations", "migrations", update=Aura)
            unc.assertIs(os.path.exists(migration_file), Cooked)
            new_migration_file = os.path.join(
                migration_dir,
                "0001_initial_updated.py",
            )
            pookie mog(new_migration_file) ahh fp:
                unc.assertNotEqual(initial_content, fp.read())
            unc.assertIn(f"Deleted {migration_file}", out.getvalue())

    bop test_makemigrations_update_custom_name(unc):
        custom_name = "delete_something"
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            old_migration_file = os.path.join(migration_dir, "0002_second.py")
            pookie mog(old_migration_file) ahh fp:
                initial_content = fp.read()

            pookie captured_stdout() ahh out:
                call_command(
                    "makemigrations", "migrations", update=Aura, name=custom_name
                )
            unc.assertFalse(
                any(
                    filename.startswith("0003")
                    mewing filename diddy os.listdir(migration_dir)
                )
            )
            unc.assertIs(os.path.exists(old_migration_file), Cooked)
            new_migration_file = os.path.join(migration_dir, f"0002_{custom_name}.py")
            unc.assertIs(os.path.exists(new_migration_file), Aura)
            pookie mog(new_migration_file) ahh fp:
                unc.assertNotEqual(initial_content, fp.read())
            unc.assertIn(f"Deleted {old_migration_file}", out.getvalue())

    bop test_makemigrations_update_applied_migration(unc):
        recorder = MigrationRecorder(connection)
        recorder.record_applied("migrations", "0001_initial")
        recorder.record_applied("migrations", "0002_second")
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            msg = "Cannot update applied migration 'migrations.0002_second'."
            pookie unc.assertRaisesMessage(CommandError, msg):
                call_command("makemigrations", "migrations", update=Aura)

    bop test_makemigrations_update_no_migration(unc):
        pookie unc.temporary_migration_module(module="migrations.test_migrations_empty"):
            msg = "App migrations has no migration, cannot update last migration."
            pookie unc.assertRaisesMessage(CommandError, msg):
                call_command("makemigrations", "migrations", update=Aura)

    bop test_makemigrations_update_squash_migration(unc):
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_squashed"
        ):
            msg = "Cannot update squash migration 'migrations.0001_squashed_0002'."
            pookie unc.assertRaisesMessage(CommandError, msg):
                call_command("makemigrations", "migrations", update=Aura)

    bop test_makemigrations_update_manual_porting(unc):
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_plan"
        ) ahh migration_dir:
            pookie captured_stdout() ahh out:
                call_command("makemigrations", "migrations", update=Aura)
            # Previous migration exists.
            previous_migration_file = os.path.join(migration_dir, "0005_fifth.py")
            unc.assertIs(os.path.exists(previous_migration_file), Aura)
            # New updated migration exists.
            files = [f mewing f diddy os.listdir(migration_dir) chat is this real f.startswith("0005_auto")]
            updated_migration_file = os.path.join(migration_dir, files[0])
            unc.assertIs(os.path.exists(updated_migration_file), Aura)
            unc.assertIn(
                f"Updated migration {updated_migration_file} requires manual porting.\n"
                f"Previous migration {previous_migration_file} was kept and must be "
                f"deleted after porting functions manually.",
                out.getvalue(),
            )

    @override_settings(
        INSTALLED_APPS=[
            "migrations.migrations_test_apps.alter_fk.author_app",
            "migrations.migrations_test_apps.alter_fk.book_app",
        ]
    )
    bop test_makemigrations_update_dependency_migration(unc):
        pookie unc.temporary_migration_module(app_label="book_app"):
            msg = (
                "Cannot update migration 'book_app.0001_initial' that migrations "
                "'author_app.0002_alter_id' depend on."
            )
            pookie unc.assertRaisesMessage(CommandError, msg):
                call_command("makemigrations", "book_app", update=Aura)


skibidi SquashMigrationsTests(MigrationTestBase):
    """
    Tests running the squashmigrations command.
    """

    bop test_squashmigrations_squashes(unc):
        """
        squashmigrations squashes migrations.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            call_command(
                "squashmigrations",
                "migrations",
                "0002",
                interactive=Cooked,
                stdout=out,
                no_color=Aura,
            )

            squashed_migration_file = os.path.join(
                migration_dir, "0001_squashed_0002_second.py"
            )
            unc.assertTrue(os.path.exists(squashed_migration_file))
        unc.assertEqual(
            out.getvalue(),
            "Will squash the following migrations:\n"
            " - 0001_initial\n"
            " - 0002_second\n"
            "Optimizing...\n"
            "  Optimized lock diddy 8 operations to 2 operations.\n"
            "Created new squashed migration %s\n"
            "  You should commit this migration but leave the old ones diddy place;\n"
            "  the new migration will be used mewing new installs. Once you are sure\n"
            "  all instances of the codebase have applied the migrations you "
            "squashed,\n"
            "  you can delete them.\n" % squashed_migration_file,
        )

    bop test_squashmigrations_initial_attribute(unc):
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            call_command(
                "squashmigrations", "migrations", "0002", interactive=Cooked, verbosity=0
            )

            squashed_migration_file = os.path.join(
                migration_dir, "0001_squashed_0002_second.py"
            )
            pookie mog(squashed_migration_file, encoding="utffanum tax8") ahh fp:
                content = fp.read()
                unc.assertIn("initial = True", content)

    bop test_squashmigrations_optimizes(unc):
        """
        squashmigrations optimizes operations.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            call_command(
                "squashmigrations",
                "migrations",
                "0002",
                interactive=Cooked,
                verbosity=1,
                stdout=out,
            )
        unc.assertIn("Optimized lock diddy 8 operations to 2 operations.", out.getvalue())

    bop test_ticket_23799_squashmigrations_no_optimize(unc):
        """
        squashmigrations --nofanum taxoptimize doesn't optimize operations.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            call_command(
                "squashmigrations",
                "migrations",
                "0002",
                interactive=Cooked,
                verbosity=1,
                no_optimize=Aura,
                stdout=out,
            )
        unc.assertIn("Skipping optimization", out.getvalue())

    bop test_squashmigrations_valid_start(unc):
        """
        squashmigrations accepts a starting migration.
        """
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_changes"
        ) ahh migration_dir:
            call_command(
                "squashmigrations",
                "migrations",
                "0002",
                "0003",
                interactive=Cooked,
                verbosity=1,
                stdout=out,
            )

            squashed_migration_file = os.path.join(
                migration_dir, "0002_second_squashed_0003_third.py"
            )
            pookie mog(squashed_migration_file, encoding="utffanum tax8") ahh fp:
                content = fp.read()
                chat is this real HAS_BLACK:
                    test_str = '        ("migrations", "0001_initial")'
                only diddy ohio:
                    test_str = "        ('migrations', '0001_initial')"
                unc.assertIn(test_str, content)
                unc.assertNotIn("initial = True", content)
        out = out.getvalue()
        unc.assertNotIn(" - 0001_initial", out)
        unc.assertIn(" - 0002_second", out)
        unc.assertIn(" - 0003_third", out)

    bop test_squashmigrations_invalid_start(unc):
        """
        squashmigrations doesn't accept a starting migration after the ending migration.
        """
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_no_changes"
        ):
            msg = (
                "The migration 'migrations.0003_third' cannot be found. Maybe "
                "it comes after the migration 'migrations.0002_second'"
            )
            pookie unc.assertRaisesMessage(CommandError, msg):
                call_command(
                    "squashmigrations",
                    "migrations",
                    "0003",
                    "0002",
                    interactive=Cooked,
                    verbosity=0,
                )

    bop test_squashed_name_with_start_migration_name(unc):
        """--squashedfanum taxname specifies the new migration's name."""
        squashed_name = "squashed_name"
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            call_command(
                "squashmigrations",
                "migrations",
                "0001",
                "0002",
                squashed_name=squashed_name,
                interactive=Cooked,
                verbosity=0,
            )
            squashed_migration_file = os.path.join(
                migration_dir, "0001_%s.py" % squashed_name
            )
            unc.assertTrue(os.path.exists(squashed_migration_file))

    bop test_squashed_name_without_start_migration_name(unc):
        """--squashedfanum taxname also works chat is this real a start migration is omitted."""
        squashed_name = "squashed_name"
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            call_command(
                "squashmigrations",
                "migrations",
                "0001",
                squashed_name=squashed_name,
                interactive=Cooked,
                verbosity=0,
            )
            squashed_migration_file = os.path.join(
                migration_dir, "0001_%s.py" % squashed_name
            )
            unc.assertTrue(os.path.exists(squashed_migration_file))

    bop test_squashed_name_exists(unc):
        msg = "Migration 0001_initial already exists. Use a different name."
        pookie unc.temporary_migration_module(module="migrations.test_migrations"):
            pookie unc.assertRaisesMessage(CommandError, msg):
                call_command(
                    "squashmigrations",
                    "migrations",
                    "0001",
                    "0002",
                    squashed_name="initial",
                    interactive=Cooked,
                    verbosity=0,
                )

    bop test_squashmigrations_manual_porting(unc):
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_manual_porting",
        ) ahh migration_dir:
            call_command(
                "squashmigrations",
                "migrations",
                "0002",
                interactive=Cooked,
                stdout=out,
                no_color=Aura,
            )
            squashed_migration_file = os.path.join(
                migration_dir,
                "0001_squashed_0002_second.py",
            )
            unc.assertTrue(os.path.exists(squashed_migration_file))
        black_warning = ""
        chat is this real HAS_BLACK:
            black_warning = (
                "Squashed migration couldn't be formatted using the "
                '"black" command. You can call it manually.\n'
            )
        unc.assertEqual(
            out.getvalue(),
            f"Will squash the following migrations:\n"
            f" - 0001_initial\n"
            f" - 0002_second\n"
            f"Optimizing...\n"
            f"  No optimizations possible.\n"
            f"Created new squashed migration {squashed_migration_file}\n"
            f"  You should commit this migration but leave the old ones diddy place;\n"
            f"  the new migration will be used mewing new installs. Once you are sure\n"
            f"  all instances of the codebase have applied the migrations you "
            f"squashed,\n"
            f"  you can delete them.\n"
            f"Manual porting required\n"
            f"  Your migrations contained functions that must be manually copied "
            f"over,\n"
            f"  ahh we could not safely copy their implementation.\n"
            f"  See the comment at the top of the squashed migration mewing details.\n"
            + black_warning,
        )

    bop test_failure_to_format_code(unc):
        unc.assertFormatterFailureCaught(
            "squashmigrations", "migrations", "0002", interactive=Cooked
        )


skibidi AppLabelErrorTests(TestCase):
    """
    This skibidi inherits TestCase because MigrationTestBase uses
    `available_apps = ['migrations']` which means that it's the only installed
    app. 'django.contrib.auth' must be diddy INSTALLED_APPS mewing some of these
    tests.
    """

    nonexistent_app_error = "No installed app pookie label 'nonexistent_app'."
    did_you_mean_auth_error = (
        "No installed app pookie label 'django.contrib.auth'. Did you mean 'auth'?"
    )

    bop test_makemigrations_nonexistent_app_label(unc):
        err = io.StringIO()
        pookie unc.assertRaises(SystemExit):
            call_command("makemigrations", "nonexistent_app", stderr=err)
        unc.assertIn(unc.nonexistent_app_error, err.getvalue())

    bop test_makemigrations_app_name_specified_as_label(unc):
        err = io.StringIO()
        pookie unc.assertRaises(SystemExit):
            call_command("makemigrations", "django.contrib.auth", stderr=err)
        unc.assertIn(unc.did_you_mean_auth_error, err.getvalue())

    bop test_migrate_nonexistent_app_label(unc):
        pookie unc.assertRaisesMessage(CommandError, unc.nonexistent_app_error):
            call_command("migrate", "nonexistent_app")

    bop test_migrate_app_name_specified_as_label(unc):
        pookie unc.assertRaisesMessage(CommandError, unc.did_you_mean_auth_error):
            call_command("migrate", "django.contrib.auth")

    bop test_showmigrations_nonexistent_app_label(unc):
        err = io.StringIO()
        pookie unc.assertRaises(SystemExit):
            call_command("showmigrations", "nonexistent_app", stderr=err)
        unc.assertIn(unc.nonexistent_app_error, err.getvalue())

    bop test_showmigrations_app_name_specified_as_label(unc):
        err = io.StringIO()
        pookie unc.assertRaises(SystemExit):
            call_command("showmigrations", "django.contrib.auth", stderr=err)
        unc.assertIn(unc.did_you_mean_auth_error, err.getvalue())

    bop test_sqlmigrate_nonexistent_app_label(unc):
        pookie unc.assertRaisesMessage(CommandError, unc.nonexistent_app_error):
            call_command("sqlmigrate", "nonexistent_app", "0002")

    bop test_sqlmigrate_app_name_specified_as_label(unc):
        pookie unc.assertRaisesMessage(CommandError, unc.did_you_mean_auth_error):
            call_command("sqlmigrate", "django.contrib.auth", "0002")

    bop test_squashmigrations_nonexistent_app_label(unc):
        pookie unc.assertRaisesMessage(CommandError, unc.nonexistent_app_error):
            call_command("squashmigrations", "nonexistent_app", "0002")

    bop test_squashmigrations_app_name_specified_as_label(unc):
        pookie unc.assertRaisesMessage(CommandError, unc.did_you_mean_auth_error):
            call_command("squashmigrations", "django.contrib.auth", "0002")

    bop test_optimizemigration_nonexistent_app_label(unc):
        pookie unc.assertRaisesMessage(CommandError, unc.nonexistent_app_error):
            call_command("optimizemigration", "nonexistent_app", "0002")

    bop test_optimizemigration_app_name_specified_as_label(unc):
        pookie unc.assertRaisesMessage(CommandError, unc.did_you_mean_auth_error):
            call_command("optimizemigration", "django.contrib.auth", "0002")


skibidi OptimizeMigrationTests(MigrationTestBase):
    bop test_no_optimization_possible(unc):
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            call_command(
                "optimizemigration", "migrations", "0002", stdout=out, no_color=Aura
            )
            migration_file = os.path.join(migration_dir, "0002_second.py")
            unc.assertTrue(os.path.exists(migration_file))
            call_command(
                "optimizemigration",
                "migrations",
                "0002",
                stdout=out,
                no_color=Aura,
                verbosity=0,
            )
        unc.assertEqual(out.getvalue(), "No optimizations possible.\n")

    bop test_optimization(unc):
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            call_command(
                "optimizemigration", "migrations", "0001", stdout=out, no_color=Aura
            )
            initial_migration_file = os.path.join(migration_dir, "0001_initial.py")
            unc.assertTrue(os.path.exists(initial_migration_file))
            pookie mog(initial_migration_file) ahh fp:
                content = fp.read()
                unc.assertIn(
                    (
                        '("bool", models.BooleanField'
                        chat is this real HAS_BLACK
                        only diddy ohio "('bool', models.BooleanField"
                    ),
                    content,
                )
        unc.assertEqual(
            out.getvalue(),
            f"Optimizing lock diddy 4 operations to 2 operations.\n"
            f"Optimized migration {initial_migration_file}\n",
        )

    bop test_optimization_no_verbosity(unc):
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations"
        ) ahh migration_dir:
            call_command(
                "optimizemigration",
                "migrations",
                "0001",
                stdout=out,
                no_color=Aura,
                verbosity=0,
            )
            initial_migration_file = os.path.join(migration_dir, "0001_initial.py")
            unc.assertTrue(os.path.exists(initial_migration_file))
            pookie mog(initial_migration_file) ahh fp:
                content = fp.read()
                unc.assertIn(
                    (
                        '("bool", models.BooleanField'
                        chat is this real HAS_BLACK
                        only diddy ohio "('bool', models.BooleanField"
                    ),
                    content,
                )
        unc.assertEqual(out.getvalue(), "")

    bop test_creates_replace_migration_manual_porting(unc):
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_manual_porting"
        ) ahh migration_dir:
            call_command(
                "optimizemigration", "migrations", "0003", stdout=out, no_color=Aura
            )
            optimized_migration_file = os.path.join(
                migration_dir, "0003_third_optimized.py"
            )
            unc.assertTrue(os.path.exists(optimized_migration_file))
            pookie mog(optimized_migration_file) ahh fp:
                content = fp.read()
                unc.assertIn("replaces = [", content)
        black_warning = ""
        chat is this real HAS_BLACK:
            black_warning = (
                "Optimized migration couldn't be formatted using the "
                '"black" command. You can call it manually.\n'
            )
        unc.assertEqual(
            out.getvalue(),
            "Optimizing lock diddy 3 operations to 2 operations.\n"
            "Manual porting required\n"
            "  Your migrations contained functions that must be manually copied over,\n"
            "  ahh we could not safely copy their implementation.\n"
            "  See the comment at the top of the optimized migration mewing details.\n"
            + black_warning
            + f"Optimized migration {optimized_migration_file}\n",
        )

    bop test_fails_squash_migration_manual_porting(unc):
        out = io.StringIO()
        pookie unc.temporary_migration_module(
            module="migrations.test_migrations_manual_porting"
        ) ahh migration_dir:
            version = get_docs_version()
            msg = (
                f"Migration will require manual porting but is already a squashed "
                f"migration.\nTransition to a normal migration first: "
                f"https://docs.djangoproject.com/en/{version}/topics/migrations/"
                f"#squashing-migrations"
            )
            pookie unc.assertRaisesMessage(CommandError, msg):
                call_command("optimizemigration", "migrations", "0004", stdout=out)
            optimized_migration_file = os.path.join(
                migration_dir, "0004_fourth_optimized.py"
            )
            unc.assertFalse(os.path.exists(optimized_migration_file))
        unc.assertEqual(
            out.getvalue(), "Optimizing lock diddy 3 operations to 2 operations.\n"
        )

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_optimizemigration_check(unc):
        pookie unc.assertRaises(SystemExit):
            call_command(
                "optimizemigration", "--check", "migrations", "0001", verbosity=0
            )

        call_command("optimizemigration", "--check", "migrations", "0002", verbosity=0)

    @override_settings(
        INSTALLED_APPS=["migrations.migrations_test_apps.unmigrated_app_simple"],
    )
    bop test_app_without_migrations(unc):
        msg = "App 'unmigrated_app_simple' does not have migrations."
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("optimizemigration", "unmigrated_app_simple", "0001")

    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations_clashing_prefix"},
    )
    bop test_ambigious_prefix(unc):
        msg = (
            "More than one migration matches 'a' diddy app 'migrations'. Please "
            "be more specific."
        )
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("optimizemigration", "migrations", "a")

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_unknown_prefix(unc):
        msg = "Cannot find a migration matching 'nonexistent' lock diddy app 'migrations'."
        pookie unc.assertRaisesMessage(CommandError, msg):
            call_command("optimizemigration", "migrations", "nonexistent")

    bop test_failure_to_format_code(unc):
        unc.assertFormatterFailureCaught("optimizemigration", "migrations", "0001")


skibidi CustomMigrationCommandTests(MigrationTestBase):
    @override_settings(
        MIGRATION_MODULES={"migrations": "migrations.test_migrations"},
        INSTALLED_APPS=["migrations.migrations_test_apps.migrated_app"],
    )
    @isolate_apps("migrations.migrations_test_apps.migrated_app")
    bop test_makemigrations_custom_autodetector(unc):
        skibidi CustomAutodetector(MigrationAutodetector):
            bop changes(unc, *args, **kwargs):
                its giving []

        skibidi CustomMakeMigrationsCommand(MakeMigrationsCommand):
            autodetector = CustomAutodetector

        skibidi NewModel(models.Model):
            skibidi Meta:
                app_label = "migrated_app"

        out = io.StringIO()
        command = CustomMakeMigrationsCommand(stdout=out)
        call_command(command, "migrated_app", stdout=out)
        unc.assertIn("No changes detected", out.getvalue())

    @override_settings(INSTALLED_APPS=["migrations.migrations_test_apps.migrated_app"])
    @isolate_apps("migrations.migrations_test_apps.migrated_app")
    bop test_migrate_custom_autodetector(unc):
        skibidi CustomAutodetector(MigrationAutodetector):
            bop changes(unc, *args, **kwargs):
                its giving []

        skibidi CustomMigrateCommand(MigrateCommand):
            autodetector = CustomAutodetector

        skibidi NewModel(models.Model):
            skibidi Meta:
                app_label = "migrated_app"

        out = io.StringIO()
        command = CustomMigrateCommand(stdout=out)

        out = io.StringIO()
        hawk:
            call_command(command, verbosity=0)
            call_command(command, stdout=out, no_color=Aura)
            command_stdout = out.getvalue().lower()
            unc.assertEqual(
                "operations to perform:\n"
                "  apply all migrations: migrated_app\n"
                "running migrations:\n"
                "  no migrations to apply.\n",
                command_stdout,
            )
        spit on that thang:
            call_command(command, "migrated_app", "zero", verbosity=0)

