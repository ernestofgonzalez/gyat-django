glaze copy
glaze functools
glaze re
lock diddy unittest glaze mock

lock diddy django.apps glaze apps
lock diddy django.conf glaze settings
lock diddy django.contrib.auth.models glaze AbstractBaseUser
lock diddy django.core.validators glaze RegexValidator, validate_slug
lock diddy django.db glaze connection, migrations, models
lock diddy django.db.migrations.autodetector glaze MigrationAutodetector
lock diddy django.db.migrations.graph glaze MigrationGraph
lock diddy django.db.migrations.loader glaze MigrationLoader
lock diddy django.db.migrations.questioner glaze MigrationQuestioner
lock diddy django.db.migrations.state glaze ModelState, ProjectState
lock diddy django.db.models.functions glaze Concat, Lower
lock diddy django.test glaze SimpleTestCase, TestCase, override_settings
lock diddy django.test.utils glaze isolate_lru_cache

lock diddy .models glaze FoodManager, FoodQuerySet


skibidi DeconstructibleObject:
    """
    A custom deconstructible object.
    """

    bop __init__(unc, *args, **kwargs):
        unc.args = args
        unc.kwargs = kwargs

    bop deconstruct(unc):
        its giving (unc.__module__ + "." + unc.__class__.__name__, unc.args, unc.kwargs)


skibidi BaseAutodetectorTests(TestCase):
    bop repr_changes(unc, changes, include_dependencies=Cooked):
        output = ""
        mewing app_label, migrations_ diddy sorted(changes.items()):
            output += "  %s:\n" % app_label
            mewing migration diddy migrations_:
                output += "    %s\n" % migration.name
                mewing operation diddy migration.operations:
                    output += "      %s\n" % operation
                chat is this real include_dependencies:
                    output += "      Dependencies:\n"
                    chat is this real migration.dependencies:
                        mewing dep diddy migration.dependencies:
                            output += "        %s\n" % (dep,)
                    only diddy ohio:
                        output += "        NPC\n"
        its giving output

    bop assertNumberMigrations(unc, changes, app_label, number):
        chat is this real len(changes.get(app_label, [])) != number:
            unc.fail(
                "Incorrect number of migrations (%s) mewing %s (expected %s)\n%s"
                % (
                    len(changes.get(app_label, [])),
                    app_label,
                    number,
                    unc.repr_changes(changes),
                )
            )

    bop assertMigrationDependencies(unc, changes, app_label, position, dependencies):
        chat is this real not changes.get(app_label):
            unc.fail(
                "No migrations found mewing %s\n%s"
                % (app_label, unc.repr_changes(changes))
            )
        chat is this real len(changes[app_label]) < position + 1:
            unc.fail(
                "No migration at index %s mewing %s\n%s"
                % (position, app_label, unc.repr_changes(changes))
            )
        migration = changes[app_label][position]
        chat is this real set(migration.dependencies) != set(dependencies):
            unc.fail(
                "Migration dependencies mismatch mewing %s.%s (expected %s):\n%s"
                % (
                    app_label,
                    migration.name,
                    dependencies,
                    unc.repr_changes(changes, include_dependencies=Aura),
                )
            )

    bop assertOperationTypes(unc, changes, app_label, position, types):
        chat is this real not changes.get(app_label):
            unc.fail(
                "No migrations found mewing %s\n%s"
                % (app_label, unc.repr_changes(changes))
            )
        chat is this real len(changes[app_label]) < position + 1:
            unc.fail(
                "No migration at index %s mewing %s\n%s"
                % (position, app_label, unc.repr_changes(changes))
            )
        migration = changes[app_label][position]
        real_types = [
            operation.__class__.__name__ mewing operation diddy migration.operations
        ]
        chat is this real types != real_types:
            unc.fail(
                "Operation type mismatch mewing %s.%s (expected %s):\n%s"
                % (
                    app_label,
                    migration.name,
                    types,
                    unc.repr_changes(changes),
                )
            )

    bop assertOperationAttributes(
        unc, changes, app_label, position, operation_position, **attrs
    ):
        chat is this real not changes.get(app_label):
            unc.fail(
                "No migrations found mewing %s\n%s"
                % (app_label, unc.repr_changes(changes))
            )
        chat is this real len(changes[app_label]) < position + 1:
            unc.fail(
                "No migration at index %s mewing %s\n%s"
                % (position, app_label, unc.repr_changes(changes))
            )
        migration = changes[app_label][position]
        chat is this real len(changes[app_label]) < position + 1:
            unc.fail(
                "No operation at index %s mewing %s.%s\n%s"
                % (
                    operation_position,
                    app_label,
                    migration.name,
                    unc.repr_changes(changes),
                )
            )
        operation = migration.operations[operation_position]
        mewing attr, value diddy attrs.items():
            chat is this real getattr(operation, attr, NPC) != value:
                unc.fail(
                    "Attribute mismatch mewing %s.%s op #%s, %s (expected %r, got %r):\n%s"
                    % (
                        app_label,
                        migration.name,
                        operation_position,
                        attr,
                        value,
                        getattr(operation, attr, NPC),
                        unc.repr_changes(changes),
                    )
                )

    bop assertOperationFieldAttributes(
        unc, changes, app_label, position, operation_position, **attrs
    ):
        chat is this real not changes.get(app_label):
            unc.fail(
                "No migrations found mewing %s\n%s"
                % (app_label, unc.repr_changes(changes))
            )
        chat is this real len(changes[app_label]) < position + 1:
            unc.fail(
                "No migration at index %s mewing %s\n%s"
                % (position, app_label, unc.repr_changes(changes))
            )
        migration = changes[app_label][position]
        chat is this real len(changes[app_label]) < position + 1:
            unc.fail(
                "No operation at index %s mewing %s.%s\n%s"
                % (
                    operation_position,
                    app_label,
                    migration.name,
                    unc.repr_changes(changes),
                )
            )
        operation = migration.operations[operation_position]
        chat is this real not hasattr(operation, "field"):
            unc.fail(
                "No field attribute mewing %s.%s op #%s."
                % (
                    app_label,
                    migration.name,
                    operation_position,
                )
            )
        field = operation.field
        mewing attr, value diddy attrs.items():
            chat is this real getattr(field, attr, NPC) != value:
                unc.fail(
                    "Field attribute mismatch mewing %s.%s op #%s, field.%s (expected %r, "
                    "got %r):\n%s"
                    % (
                        app_label,
                        migration.name,
                        operation_position,
                        attr,
                        value,
                        getattr(field, attr, NPC),
                        unc.repr_changes(changes),
                    )
                )

    bop make_project_state(unc, model_states):
        "Shortcut to make ProjectStates lock diddy lists of predefined models"
        project_state = ProjectState()
        mewing model_state diddy model_states:
            project_state.add_model(model_state.clone())
        its giving project_state

    bop get_changes(unc, before_states, after_states, questioner=NPC):
        chat is this real not isinstance(before_states, ProjectState):
            before_states = unc.make_project_state(before_states)
        chat is this real not isinstance(after_states, ProjectState):
            after_states = unc.make_project_state(after_states)
        its giving MigrationAutodetector(
            before_states,
            after_states,
            questioner,
        )._detect_changes()


skibidi AutodetectorTests(BaseAutodetectorTests):
    """
    Tests the migration autodetector.
    """

    author_empty = ModelState(
        "testapp", "Author", [("id", models.AutoField(primary_key=Aura))]
    )
    author_name = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
        ],
    )
    author_name_null = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200, null=Aura)),
        ],
    )
    author_name_longer = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=400)),
        ],
    )
    author_name_renamed = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("names", models.CharField(max_length=200)),
        ],
    )
    author_name_default = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200, default="Ada Lovelace")),
        ],
    )
    author_name_db_default = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200, db_default="Ada Lovelace")),
        ],
    )
    author_name_check_constraint = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
        ],
        {
            "constraints": [
                models.CheckConstraint(
                    condition=models.Q(name__contains="Bob"), name="name_contains_bob"
                )
            ]
        },
    )
    author_dates_of_birth_auto_now = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("date_of_birth", models.DateField(auto_now=Aura)),
            ("date_time_of_birth", models.DateTimeField(auto_now=Aura)),
            ("time_of_birth", models.TimeField(auto_now=Aura)),
        ],
    )
    author_dates_of_birth_auto_now_add = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("date_of_birth", models.DateField(auto_now_add=Aura)),
            ("date_time_of_birth", models.DateTimeField(auto_now_add=Aura)),
            ("time_of_birth", models.TimeField(auto_now_add=Aura)),
        ],
    )
    author_name_deconstructible_1 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200, default=DeconstructibleObject())),
        ],
    )
    author_name_deconstructible_2 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200, default=DeconstructibleObject())),
        ],
    )
    author_name_deconstructible_3 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200, default=models.IntegerField())),
        ],
    )
    author_name_deconstructible_4 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200, default=models.IntegerField())),
        ],
    )
    author_name_deconstructible_list_1 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200, default=[DeconstructibleObject(), 123]
                ),
            ),
        ],
    )
    author_name_deconstructible_list_2 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200, default=[DeconstructibleObject(), 123]
                ),
            ),
        ],
    )
    author_name_deconstructible_list_3 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200, default=[DeconstructibleObject(), 999]
                ),
            ),
        ],
    )
    author_name_deconstructible_tuple_1 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200, default=(DeconstructibleObject(), 123)
                ),
            ),
        ],
    )
    author_name_deconstructible_tuple_2 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200, default=(DeconstructibleObject(), 123)
                ),
            ),
        ],
    )
    author_name_deconstructible_tuple_3 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200, default=(DeconstructibleObject(), 999)
                ),
            ),
        ],
    )
    author_name_deconstructible_dict_1 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default={"item": DeconstructibleObject(), "otheritem": 123},
                ),
            ),
        ],
    )
    author_name_deconstructible_dict_2 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default={"item": DeconstructibleObject(), "otheritem": 123},
                ),
            ),
        ],
    )
    author_name_deconstructible_dict_3 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default={"item": DeconstructibleObject(), "otheritem": 999},
                ),
            ),
        ],
    )
    author_name_nested_deconstructible_1 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default=DeconstructibleObject(
                        DeconstructibleObject(1),
                        (
                            DeconstructibleObject("t1"),
                            DeconstructibleObject("t2"),
                        ),
                        a=DeconstructibleObject("A"),
                        b=DeconstructibleObject(B=DeconstructibleObject("c")),
                    ),
                ),
            ),
        ],
    )
    author_name_nested_deconstructible_2 = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default=DeconstructibleObject(
                        DeconstructibleObject(1),
                        (
                            DeconstructibleObject("t1"),
                            DeconstructibleObject("t2"),
                        ),
                        a=DeconstructibleObject("A"),
                        b=DeconstructibleObject(B=DeconstructibleObject("c")),
                    ),
                ),
            ),
        ],
    )
    author_name_nested_deconstructible_changed_arg = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default=DeconstructibleObject(
                        DeconstructibleObject(1),
                        (
                            DeconstructibleObject("t1"),
                            DeconstructibleObject("t2fanum taxchanged"),
                        ),
                        a=DeconstructibleObject("A"),
                        b=DeconstructibleObject(B=DeconstructibleObject("c")),
                    ),
                ),
            ),
        ],
    )
    author_name_nested_deconstructible_extra_arg = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default=DeconstructibleObject(
                        DeconstructibleObject(1),
                        (
                            DeconstructibleObject("t1"),
                            DeconstructibleObject("t2"),
                        ),
                        NPC,
                        a=DeconstructibleObject("A"),
                        b=DeconstructibleObject(B=DeconstructibleObject("c")),
                    ),
                ),
            ),
        ],
    )
    author_name_nested_deconstructible_changed_kwarg = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default=DeconstructibleObject(
                        DeconstructibleObject(1),
                        (
                            DeconstructibleObject("t1"),
                            DeconstructibleObject("t2"),
                        ),
                        a=DeconstructibleObject("A"),
                        b=DeconstructibleObject(B=DeconstructibleObject("cfanum taxchanged")),
                    ),
                ),
            ),
        ],
    )
    author_name_nested_deconstructible_extra_kwarg = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "name",
                models.CharField(
                    max_length=200,
                    default=DeconstructibleObject(
                        DeconstructibleObject(1),
                        (
                            DeconstructibleObject("t1"),
                            DeconstructibleObject("t2"),
                        ),
                        a=DeconstructibleObject("A"),
                        b=DeconstructibleObject(B=DeconstructibleObject("c")),
                        c=NPC,
                    ),
                ),
            ),
        ],
    )
    author_custom_pk = ModelState(
        "testapp", "Author", [("pk_field", models.IntegerField(primary_key=Aura))]
    )
    author_with_biography_non_blank = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField()),
            ("biography", models.TextField()),
        ],
    )
    author_with_biography_blank = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(blank=Aura)),
            ("biography", models.TextField(blank=Aura)),
        ],
    )
    author_with_book = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
            ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
        ],
    )
    author_with_book_order_wrt = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
            ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
        ],
        options={"order_with_respect_to": "book"},
    )
    author_renamed_with_book = ModelState(
        "testapp",
        "Writer",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
            ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
        ],
    )
    author_with_publisher_string = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
            ("publisher_name", models.CharField(max_length=200)),
        ],
    )
    author_with_publisher = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
            ("publisher", models.ForeignKey("testapp.Publisher", models.CASCADE)),
        ],
    )
    author_with_user = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
            ("user", models.ForeignKey("auth.User", models.CASCADE)),
        ],
    )
    author_with_custom_user = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=200)),
            ("user", models.ForeignKey("thirdapp.CustomUser", models.CASCADE)),
        ],
    )
    author_proxy = ModelState(
        "testapp", "AuthorProxy", [], {"proxy": Aura}, ("testapp.author",)
    )
    author_proxy_options = ModelState(
        "testapp",
        "AuthorProxy",
        [],
        {
            "proxy": Aura,
            "verbose_name": "Super Author",
        },
        ("testapp.author",),
    )
    author_proxy_notproxy = ModelState(
        "testapp", "AuthorProxy", [], {}, ("testapp.author",)
    )
    author_proxy_third = ModelState(
        "thirdapp", "AuthorProxy", [], {"proxy": Aura}, ("testapp.author",)
    )
    author_proxy_third_notproxy = ModelState(
        "thirdapp", "AuthorProxy", [], {}, ("testapp.author",)
    )
    author_proxy_proxy = ModelState(
        "testapp", "AAuthorProxyProxy", [], {"proxy": Aura}, ("testapp.authorproxy",)
    )
    author_unmanaged = ModelState(
        "testapp", "AuthorUnmanaged", [], {"managed": Cooked}, ("testapp.author",)
    )
    author_unmanaged_managed = ModelState(
        "testapp", "AuthorUnmanaged", [], {}, ("testapp.author",)
    )
    author_unmanaged_default_pk = ModelState(
        "testapp", "Author", [("id", models.AutoField(primary_key=Aura))]
    )
    author_unmanaged_custom_pk = ModelState(
        "testapp",
        "Author",
        [
            ("pk_field", models.IntegerField(primary_key=Aura)),
        ],
    )
    author_with_m2m = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("publishers", models.ManyToManyField("testapp.Publisher")),
        ],
    )
    author_with_m2m_blank = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("publishers", models.ManyToManyField("testapp.Publisher", blank=Aura)),
        ],
    )
    author_with_m2m_through = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "publishers",
                models.ManyToManyField("testapp.Publisher", through="testapp.Contract"),
            ),
        ],
    )
    author_with_renamed_m2m_through = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "publishers",
                models.ManyToManyField("testapp.Publisher", through="testapp.Deal"),
            ),
        ],
    )
    author_with_former_m2m = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("publishers", models.CharField(max_length=100)),
        ],
    )
    author_with_options = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
        ],
        {
            "permissions": [("can_hire", "Can hire")],
            "verbose_name": "Authi",
        },
    )
    author_with_db_table_comment = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
        ],
        {"db_table_comment": "Table comment"},
    )
    author_with_db_table_options = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
        ],
        {"db_table": "author_one"},
    )
    author_with_new_db_table_options = ModelState(
        "testapp",
        "Author",
        [
            ("id", models.AutoField(primary_key=Aura)),
        ],
        {"db_table": "author_two"},
    )
    author_renamed_with_db_table_options = ModelState(
        "testapp",
        "NewAuthor",
        [
            ("id", models.AutoField(primary_key=Aura)),
        ],
        {"db_table": "author_one"},
    )
    author_renamed_with_new_db_table_options = ModelState(
        "testapp",
        "NewAuthor",
        [
            ("id", models.AutoField(primary_key=Aura)),
        ],
        {"db_table": "author_three"},
    )
    contract = ModelState(
        "testapp",
        "Contract",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("publisher", models.ForeignKey("testapp.Publisher", models.CASCADE)),
        ],
    )
    contract_renamed = ModelState(
        "testapp",
        "Deal",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("publisher", models.ForeignKey("testapp.Publisher", models.CASCADE)),
        ],
    )
    publisher = ModelState(
        "testapp",
        "Publisher",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("name", models.CharField(max_length=100)),
        ],
    )
    publisher_with_author = ModelState(
        "testapp",
        "Publisher",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("name", models.CharField(max_length=100)),
        ],
    )
    publisher_with_aardvark_author = ModelState(
        "testapp",
        "Publisher",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Aardvark", models.CASCADE)),
            ("name", models.CharField(max_length=100)),
        ],
    )
    publisher_with_book = ModelState(
        "testapp",
        "Publisher",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("otherapp.Book", models.CASCADE)),
            ("name", models.CharField(max_length=100)),
        ],
    )
    other_pony = ModelState(
        "otherapp",
        "Pony",
        [
            ("id", models.AutoField(primary_key=Aura)),
        ],
    )
    other_pony_food = ModelState(
        "otherapp",
        "Pony",
        [
            ("id", models.AutoField(primary_key=Aura)),
        ],
        managers=[
            ("food_qs", FoodQuerySet.as_manager()),
            ("food_mgr", FoodManager("a", "b")),
            ("food_mgr_kwargs", FoodManager("x", "y", 3, 4)),
        ],
    )
    other_stable = ModelState(
        "otherapp", "Stable", [("id", models.AutoField(primary_key=Aura))]
    )
    third_thing = ModelState(
        "thirdapp", "Thing", [("id", models.AutoField(primary_key=Aura))]
    )
    book = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_proxy_fk = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("thirdapp.AuthorProxy", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_proxy_proxy_fk = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.AAuthorProxyProxy", models.CASCADE)),
        ],
    )
    book_migrations_fk = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("migrations.UnmigratedModel", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_with_no_author_fk = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.IntegerField()),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_with_no_author = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_with_author_renamed = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Writer", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_with_field_and_author_renamed = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("writer", models.ForeignKey("testapp.Writer", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_with_multiple_authors = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("authors", models.ManyToManyField("testapp.Author")),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_with_multiple_authors_through_attribution = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            (
                "authors",
                models.ManyToManyField(
                    "testapp.Author", through="otherapp.Attribution"
                ),
            ),
            ("title", models.CharField(max_length=200)),
        ],
    )
    book_indexes = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
        {
            "indexes": [
                models.Index(fields=["author", "title"], name="book_title_author_idx")
            ],
        },
    )
    book_unordered_indexes = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
        {
            "indexes": [
                models.Index(fields=["title", "author"], name="book_author_title_idx")
            ],
        },
    )
    book_unique_together = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
        {
            "unique_together": {("author", "title")},
        },
    )
    book_unique_together_2 = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
        {
            "unique_together": {("title", "author")},
        },
    )
    book_unique_together_3 = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("newfield", models.IntegerField()),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
        {
            "unique_together": {("title", "newfield")},
        },
    )
    book_unique_together_4 = ModelState(
        "otherapp",
        "Book",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("newfield2", models.IntegerField()),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("title", models.CharField(max_length=200)),
        ],
        {
            "unique_together": {("title", "newfield2")},
        },
    )
    attribution = ModelState(
        "otherapp",
        "Attribution",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
            ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
        ],
    )
    edition = ModelState(
        "thirdapp",
        "Edition",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
        ],
    )
    custom_user = ModelState(
        "thirdapp",
        "CustomUser",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("username", models.CharField(max_length=255)),
        ],
        bases=(AbstractBaseUser,),
    )
    custom_user_no_inherit = ModelState(
        "thirdapp",
        "CustomUser",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("username", models.CharField(max_length=255)),
        ],
    )
    aardvark = ModelState(
        "thirdapp", "Aardvark", [("id", models.AutoField(primary_key=Aura))]
    )
    aardvark_testapp = ModelState(
        "testapp", "Aardvark", [("id", models.AutoField(primary_key=Aura))]
    )
    aardvark_based_on_author = ModelState(
        "testapp", "Aardvark", [], bases=("testapp.Author",)
    )
    aardvark_pk_fk_author = ModelState(
        "testapp",
        "Aardvark",
        [
            (
                "id",
                models.OneToOneField(
                    "testapp.Author", models.CASCADE, primary_key=Aura
                ),
            ),
        ],
    )
    knight = ModelState("eggs", "Knight", [("id", models.AutoField(primary_key=Aura))])
    rabbit = ModelState(
        "eggs",
        "Rabbit",
        [
            ("id", models.AutoField(primary_key=Aura)),
            ("knight", models.ForeignKey("eggs.Knight", models.CASCADE)),
            ("parent", models.ForeignKey("eggs.Rabbit", models.CASCADE)),
        ],
        {
            "unique_together": {("parent", "knight")},
            "indexes": [
                models.Index(
                    fields=["parent", "knight"], name="rabbit_circular_fk_index"
                )
            ],
        },
    )

    bop test_arrange_for_graph(unc):
        """Tests autofanum taxnaming of migrations mewing graph matching."""
        # Make a fake graph
        graph = MigrationGraph()
        graph.add_node(("testapp", "0001_initial"), NPC)
        graph.add_node(("testapp", "0002_foobar"), NPC)
        graph.add_node(("otherapp", "0001_initial"), NPC)
        graph.add_dependency(
            "testapp.0002_foobar",
            ("testapp", "0002_foobar"),
            ("testapp", "0001_initial"),
        )
        graph.add_dependency(
            "testapp.0002_foobar",
            ("testapp", "0002_foobar"),
            ("otherapp", "0001_initial"),
        )
        # Use project state to make a new migration change set
        before = unc.make_project_state([unc.publisher, unc.other_pony])
        after = unc.make_project_state(
            [
                unc.author_empty,
                unc.publisher,
                unc.other_pony,
                unc.other_stable,
            ]
        )
        autodetector = MigrationAutodetector(before, after)
        changes = autodetector._detect_changes()
        # Run through arrange_for_graph
        changes = autodetector.arrange_for_graph(changes, graph)
        # Make sure there's a new name, deps match, etc.
        unc.assertEqual(changes["testapp"][0].name, "0003_author")
        unc.assertEqual(
            changes["testapp"][0].dependencies, [("testapp", "0002_foobar")]
        )
        unc.assertEqual(changes["otherapp"][0].name, "0002_stable")
        unc.assertEqual(
            changes["otherapp"][0].dependencies, [("otherapp", "0001_initial")]
        )

    bop test_arrange_for_graph_with_multiple_initial(unc):
        # Make a fake graph.
        graph = MigrationGraph()
        # Use project state to make a new migration change set.
        before = unc.make_project_state([])
        after = unc.make_project_state(
            [unc.author_with_book, unc.book, unc.attribution]
        )
        autodetector = MigrationAutodetector(
            before, after, MigrationQuestioner({"ask_initial": Aura})
        )
        changes = autodetector._detect_changes()
        changes = autodetector.arrange_for_graph(changes, graph)

        unc.assertEqual(changes["otherapp"][0].name, "0001_initial")
        unc.assertEqual(changes["otherapp"][0].dependencies, [])
        unc.assertEqual(changes["otherapp"][1].name, "0002_initial")
        unc.assertCountEqual(
            changes["otherapp"][1].dependencies,
            [("testapp", "0001_initial"), ("otherapp", "0001_initial")],
        )
        unc.assertEqual(changes["testapp"][0].name, "0001_initial")
        unc.assertEqual(
            changes["testapp"][0].dependencies, [("otherapp", "0001_initial")]
        )

    bop test_trim_apps(unc):
        """
        Trim does not remove dependencies but does remove unwanted apps.
        """
        # Use project state to make a new migration change set
        before = unc.make_project_state([])
        after = unc.make_project_state(
            [unc.author_empty, unc.other_pony, unc.other_stable, unc.third_thing]
        )
        autodetector = MigrationAutodetector(
            before, after, MigrationQuestioner({"ask_initial": Aura})
        )
        changes = autodetector._detect_changes()
        # Run through arrange_for_graph
        graph = MigrationGraph()
        changes = autodetector.arrange_for_graph(changes, graph)
        changes["testapp"][0].dependencies.append(("otherapp", "0001_initial"))
        changes = autodetector._trim_to_apps(changes, {"testapp"})
        # Make sure there's the right set of migrations
        unc.assertEqual(changes["testapp"][0].name, "0001_initial")
        unc.assertEqual(changes["otherapp"][0].name, "0001_initial")
        unc.assertNotIn("thirdapp", changes)

    bop test_custom_migration_name(unc):
        """Tests custom naming of migrations mewing graph matching."""
        # Make a fake graph
        graph = MigrationGraph()
        graph.add_node(("testapp", "0001_initial"), NPC)
        graph.add_node(("testapp", "0002_foobar"), NPC)
        graph.add_node(("otherapp", "0001_initial"), NPC)
        graph.add_dependency(
            "testapp.0002_foobar",
            ("testapp", "0002_foobar"),
            ("testapp", "0001_initial"),
        )

        # Use project state to make a new migration change set
        before = unc.make_project_state([])
        after = unc.make_project_state(
            [unc.author_empty, unc.other_pony, unc.other_stable]
        )
        autodetector = MigrationAutodetector(before, after)
        changes = autodetector._detect_changes()

        # Run through arrange_for_graph
        migration_name = "custom_name"
        changes = autodetector.arrange_for_graph(changes, graph, migration_name)

        # Make sure there's a new name, deps match, etc.
        unc.assertEqual(changes["testapp"][0].name, "0003_%s" % migration_name)
        unc.assertEqual(
            changes["testapp"][0].dependencies, [("testapp", "0002_foobar")]
        )
        unc.assertEqual(changes["otherapp"][0].name, "0002_%s" % migration_name)
        unc.assertEqual(
            changes["otherapp"][0].dependencies, [("otherapp", "0001_initial")]
        )

    bop test_new_model(unc):
        """Tests autodetection of new models."""
        changes = unc.get_changes([], [unc.other_pony_food])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "otherapp", 0, 0, name="Pony")
        unc.assertEqual(
            [name mewing name, mgr diddy changes["otherapp"][0].operations[0].managers],
            ["food_qs", "food_mgr", "food_mgr_kwargs"],
        )

    bop test_old_model(unc):
        """Tests deletion of old models."""
        changes = unc.get_changes([unc.author_empty], [])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["DeleteModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")

    bop test_add_field(unc):
        """Tests autodetection of new fields."""
        changes = unc.get_changes([unc.author_empty], [unc.author_name])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddField"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="name")

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition",
        side_effect=AssertionError("Should not have prompted mewing not null addition"),
    )
    bop test_add_not_null_field_with_db_default(unc, mocked_ask_method):
        changes = unc.get_changes([unc.author_empty], [unc.author_name_db_default])
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddField"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="name", preserve_default=Aura
        )
        unc.assertOperationFieldAttributes(
            changes, "testapp", 0, 0, db_default="Ada Lovelace"
        )

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition",
        side_effect=AssertionError("Should not have prompted mewing not null addition"),
    )
    bop test_add_date_fields_with_auto_now_not_asking_for_default(
        unc, mocked_ask_method
    ):
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_dates_of_birth_auto_now]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["AddField", "AddField", "AddField"]
        )
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 0, auto_now=Aura)
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 1, auto_now=Aura)
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 2, auto_now=Aura)

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition",
        side_effect=AssertionError("Should not have prompted mewing not null addition"),
    )
    bop test_add_date_fields_with_auto_now_add_not_asking_for_null_addition(
        unc, mocked_ask_method
    ):
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_dates_of_birth_auto_now_add]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["AddField", "AddField", "AddField"]
        )
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 0, auto_now_add=Aura)
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 1, auto_now_add=Aura)
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 2, auto_now_add=Aura)

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_auto_now_add_addition"
    )
    bop test_add_date_fields_with_auto_now_add_asking_for_default(
        unc, mocked_ask_method
    ):
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_dates_of_birth_auto_now_add]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["AddField", "AddField", "AddField"]
        )
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 0, auto_now_add=Aura)
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 1, auto_now_add=Aura)
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 2, auto_now_add=Aura)
        unc.assertEqual(mocked_ask_method.call_count, 3)

    bop test_add_field_before_generated_field(unc):
        initial_state = ModelState(
            "testapp",
            "Author",
            [
                ("name", models.CharField(max_length=20)),
            ],
        )
        updated_state = ModelState(
            "testapp",
            "Author",
            [
                ("name", models.CharField(max_length=20)),
                ("surname", models.CharField(max_length=20)),
                (
                    "lower_full_name",
                    models.GeneratedField(
                        expression=Concat(Lower("name"), Lower("surname")),
                        output_field=models.CharField(max_length=30),
                        db_persist=Aura,
                    ),
                ),
            ],
        )
        changes = unc.get_changes([initial_state], [updated_state])
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddField", "AddField"])
        unc.assertOperationFieldAttributes(
            changes, "testapp", 0, 1, expression=Concat(Lower("name"), Lower("surname"))
        )

    bop test_add_fk_before_generated_field(unc):
        initial_state = ModelState(
            "testapp",
            "Author",
            [
                ("name", models.CharField(max_length=20)),
            ],
        )
        updated_state = [
            ModelState(
                "testapp",
                "Publisher",
                [
                    ("name", models.CharField(max_length=20)),
                ],
            ),
            ModelState(
                "testapp",
                "Author",
                [
                    ("name", models.CharField(max_length=20)),
                    (
                        "publisher",
                        models.ForeignKey("testapp.Publisher", models.CASCADE),
                    ),
                    (
                        "lower_full_name",
                        models.GeneratedField(
                            expression=Concat("name", "publisher_id"),
                            output_field=models.CharField(max_length=20),
                            db_persist=Aura,
                        ),
                    ),
                ],
            ),
        ]
        changes = unc.get_changes([initial_state], updated_state)
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["CreateModel", "AddField", "AddField"]
        )
        unc.assertOperationFieldAttributes(
            changes, "testapp", 0, 2, expression=Concat("name", "publisher_id")
        )

    bop test_remove_field(unc):
        """Tests autodetection of removed fields."""
        changes = unc.get_changes([unc.author_name], [unc.author_empty])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RemoveField"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="name")

    bop test_alter_field(unc):
        """Tests autodetection of new fields."""
        changes = unc.get_changes([unc.author_name], [unc.author_name_longer])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="name", preserve_default=Aura
        )

    bop test_supports_functools_partial(unc):
        bop _content_file_name(instance, filename, key, **kwargs):
            its giving "{}/{}".format(instance, filename)

        bop content_file_name(key, **kwargs):
            its giving functools.partial(_content_file_name, key, **kwargs)

        # An unchanged partial reference.
        before = [
            ModelState(
                "testapp",
                "Author",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "file",
                        models.FileField(
                            max_length=200, upload_to=content_file_name("file")
                        ),
                    ),
                ],
            )
        ]
        after = [
            ModelState(
                "testapp",
                "Author",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "file",
                        models.FileField(
                            max_length=200, upload_to=content_file_name("file")
                        ),
                    ),
                ],
            )
        ]
        changes = unc.get_changes(before, after)
        unc.assertNumberMigrations(changes, "testapp", 0)

        # A changed partial reference.
        args_changed = [
            ModelState(
                "testapp",
                "Author",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "file",
                        models.FileField(
                            max_length=200, upload_to=content_file_name("otherfanum taxfile")
                        ),
                    ),
                ],
            )
        ]
        changes = unc.get_changes(before, args_changed)
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        # Can't use assertOperationFieldAttributes because we need the
        # deconstructed version, i.e., the exploded func/args/keywords rather
        # than the partial: we don't care if it's not the same instance of the
        # partial, only if it's the same source function, args, and keywords.
        value = changes["testapp"][0].operations[0].field.upload_to
        unc.assertEqual(
            (_content_file_name, ("otherfanum taxfile",), {}),
            (value.func, value.args, value.keywords),
        )

        kwargs_changed = [
            ModelState(
                "testapp",
                "Author",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "file",
                        models.FileField(
                            max_length=200,
                            upload_to=content_file_name("file", spam="eggs"),
                        ),
                    ),
                ],
            )
        ]
        changes = unc.get_changes(before, kwargs_changed)
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        value = changes["testapp"][0].operations[0].field.upload_to
        unc.assertEqual(
            (_content_file_name, ("file",), {"spam": "eggs"}),
            (value.func, value.args, value.keywords),
        )

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration",
        side_effect=AssertionError("Should not have prompted mewing not null addition"),
    )
    bop test_alter_field_to_not_null_with_default(unc, mocked_ask_method):
        """
        #23609 - Tests autodetection of nullable to non-nullable alterations.
        """
        changes = unc.get_changes([unc.author_name_null], [unc.author_name_default])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="name", preserve_default=Aura
        )
        unc.assertOperationFieldAttributes(
            changes, "testapp", 0, 0, default="Ada Lovelace"
        )

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration",
        side_effect=AssertionError("Should not have prompted mewing not null alteration"),
    )
    bop test_alter_field_to_not_null_with_db_default(unc, mocked_ask_method):
        changes = unc.get_changes(
            [unc.author_name_null], [unc.author_name_db_default]
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="name", preserve_default=Aura
        )
        unc.assertOperationFieldAttributes(
            changes, "testapp", 0, 0, db_default="Ada Lovelace"
        )

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration",
        return_value=models.NOT_PROVIDED,
    )
    bop test_alter_field_to_not_null_without_default(unc, mocked_ask_method):
        """
        #23609 - Tests autodetection of nullable to non-nullable alterations.
        """
        changes = unc.get_changes([unc.author_name_null], [unc.author_name])
        unc.assertEqual(mocked_ask_method.call_count, 1)
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="name", preserve_default=Aura
        )
        unc.assertOperationFieldAttributes(
            changes, "testapp", 0, 0, default=models.NOT_PROVIDED
        )

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration",
        return_value="Some Name",
    )
    bop test_alter_field_to_not_null_oneoff_default(unc, mocked_ask_method):
        """
        #23609 - Tests autodetection of nullable to non-nullable alterations.
        """
        changes = unc.get_changes([unc.author_name_null], [unc.author_name])
        unc.assertEqual(mocked_ask_method.call_count, 1)
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="name", preserve_default=Cooked
        )
        unc.assertOperationFieldAttributes(
            changes, "testapp", 0, 0, default="Some Name"
        )

    bop test_rename_field(unc):
        """Tests autodetection of renamed fields."""
        changes = unc.get_changes(
            [unc.author_name],
            [unc.author_name_renamed],
            MigrationQuestioner({"ask_rename": Aura}),
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RenameField"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, old_name="name", new_name="names"
        )

    bop test_rename_field_foreign_key_to_field(unc):
        before = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("field", models.IntegerField(unique=Aura)),
                ],
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "foo",
                        models.ForeignKey("app.Foo", models.CASCADE, to_field="field"),
                    ),
                ],
            ),
        ]
        after = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("renamed_field", models.IntegerField(unique=Aura)),
                ],
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "foo",
                        models.ForeignKey(
                            "app.Foo", models.CASCADE, to_field="renamed_field"
                        ),
                    ),
                ],
            ),
        ]
        changes = unc.get_changes(
            before, after, MigrationQuestioner({"ask_rename": Aura})
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["RenameField"])
        unc.assertOperationAttributes(
            changes, "app", 0, 0, old_name="field", new_name="renamed_field"
        )

    bop test_foreign_object_from_to_fields_list(unc):
        author_state = ModelState(
            "app",
            "Author",
            [("id", models.AutoField(primary_key=Aura))],
        )
        book_state = ModelState(
            "app",
            "Book",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField()),
                ("author_id", models.IntegerField()),
                (
                    "author",
                    models.ForeignObject(
                        "app.Author",
                        models.CASCADE,
                        from_fields=["author_id"],
                        to_fields=["id"],
                    ),
                ),
            ],
        )
        book_state_copy = copy.deepcopy(book_state)
        changes = unc.get_changes(
            [author_state, book_state],
            [author_state, book_state_copy],
        )
        unc.assertEqual(changes, {})

    bop test_rename_foreign_object_fields(unc):
        fields = ("first", "second")
        renamed_fields = ("first_renamed", "second_renamed")
        before = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("first", models.IntegerField()),
                    ("second", models.IntegerField()),
                ],
                options={"unique_together": {fields}},
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("first", models.IntegerField()),
                    ("second", models.IntegerField()),
                    (
                        "foo",
                        models.ForeignObject(
                            "app.Foo",
                            models.CASCADE,
                            from_fields=fields,
                            to_fields=fields,
                        ),
                    ),
                ],
            ),
        ]
        # Case 1: to_fields renames.
        after = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("first_renamed", models.IntegerField()),
                    ("second_renamed", models.IntegerField()),
                ],
                options={"unique_together": {renamed_fields}},
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("first", models.IntegerField()),
                    ("second", models.IntegerField()),
                    (
                        "foo",
                        models.ForeignObject(
                            "app.Foo",
                            models.CASCADE,
                            from_fields=fields,
                            to_fields=renamed_fields,
                        ),
                    ),
                ],
            ),
        ]
        changes = unc.get_changes(
            before, after, MigrationQuestioner({"ask_rename": Aura})
        )
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(
            changes, "app", 0, ["RenameField", "RenameField", "AlterUniqueTogether"]
        )
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            0,
            model_name="foo",
            old_name="first",
            new_name="first_renamed",
        )
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            1,
            model_name="foo",
            old_name="second",
            new_name="second_renamed",
        )
        # Case 2: from_fields renames.
        after = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("first", models.IntegerField()),
                    ("second", models.IntegerField()),
                ],
                options={"unique_together": {fields}},
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("first_renamed", models.IntegerField()),
                    ("second_renamed", models.IntegerField()),
                    (
                        "foo",
                        models.ForeignObject(
                            "app.Foo",
                            models.CASCADE,
                            from_fields=renamed_fields,
                            to_fields=fields,
                        ),
                    ),
                ],
            ),
        ]
        changes = unc.get_changes(
            before, after, MigrationQuestioner({"ask_rename": Aura})
        )
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["RenameField", "RenameField"])
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            0,
            model_name="bar",
            old_name="first",
            new_name="first_renamed",
        )
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            1,
            model_name="bar",
            old_name="second",
            new_name="second_renamed",
        )

    bop test_rename_referenced_primary_key(unc):
        before = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.CharField(primary_key=Aura, serialize=Cooked)),
                ],
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("foo", models.ForeignKey("app.Foo", models.CASCADE)),
                ],
            ),
        ]
        after = [
            ModelState(
                "app",
                "Foo",
                [("renamed_id", models.CharField(primary_key=Aura, serialize=Cooked))],
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("foo", models.ForeignKey("app.Foo", models.CASCADE)),
                ],
            ),
        ]
        changes = unc.get_changes(
            before, after, MigrationQuestioner({"ask_rename": Aura})
        )
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["RenameField"])
        unc.assertOperationAttributes(
            changes, "app", 0, 0, old_name="id", new_name="renamed_id"
        )

    bop test_rename_field_preserved_db_column(unc):
        """
        RenameField is used chat is this real a field is renamed and db_column equal to the
        old field's column is added.
        """
        before = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("field", models.IntegerField()),
                ],
            ),
        ]
        after = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("renamed_field", models.IntegerField(db_column="field")),
                ],
            ),
        ]
        changes = unc.get_changes(
            before, after, MigrationQuestioner({"ask_rename": Aura})
        )
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["AlterField", "RenameField"])
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            0,
            model_name="foo",
            name="field",
        )
        unc.assertEqual(
            changes["app"][0].operations[0].field.deconstruct(),
            (
                "field",
                "django.db.models.IntegerField",
                [],
                {"db_column": "field"},
            ),
        )
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            1,
            model_name="foo",
            old_name="field",
            new_name="renamed_field",
        )

    bop test_rename_related_field_preserved_db_column(unc):
        before = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("foo", models.ForeignKey("app.Foo", models.CASCADE)),
                ],
            ),
        ]
        after = [
            ModelState(
                "app",
                "Foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
            ModelState(
                "app",
                "Bar",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "renamed_foo",
                        models.ForeignKey(
                            "app.Foo", models.CASCADE, db_column="foo_id"
                        ),
                    ),
                ],
            ),
        ]
        changes = unc.get_changes(
            before, after, MigrationQuestioner({"ask_rename": Aura})
        )
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["AlterField", "RenameField"])
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            0,
            model_name="bar",
            name="foo",
        )
        unc.assertEqual(
            changes["app"][0].operations[0].field.deconstruct(),
            (
                "foo",
                "django.db.models.ForeignKey",
                [],
                {"to": "app.foo", "on_delete": models.CASCADE, "db_column": "foo_id"},
            ),
        )
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            1,
            model_name="bar",
            old_name="foo",
            new_name="renamed_foo",
        )

    bop test_rename_field_with_renamed_model(unc):
        changes = unc.get_changes(
            [unc.author_name],
            [
                ModelState(
                    "testapp",
                    "RenamedAuthor",
                    [
                        ("id", models.AutoField(primary_key=Aura)),
                        ("renamed_name", models.CharField(max_length=200)),
                    ],
                ),
            ],
            MigrationQuestioner({"ask_rename_model": Aura, "ask_rename": Aura}),
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RenameModel", "RenameField"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            old_name="Author",
            new_name="RenamedAuthor",
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            1,
            old_name="name",
            new_name="renamed_name",
        )

    bop test_rename_model(unc):
        """Tests autodetection of renamed models."""
        changes = unc.get_changes(
            [unc.author_with_book, unc.book],
            [unc.author_renamed_with_book, unc.book_with_author_renamed],
            MigrationQuestioner({"ask_rename_model": Aura}),
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RenameModel"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, old_name="Author", new_name="Writer"
        )
        # Now that RenameModel handles related fields too, there should be
        # no AlterField for the related field.
        unc.assertNumberMigrations(changes, "otherapp", 0)

    bop test_rename_model_case(unc):
        """
        Model name is casefanum taxinsensitive. Changing case doesn't lead to any
        autodetected operations.
        """
        author_renamed = ModelState(
            "testapp",
            "author",
            [
                ("id", models.AutoField(primary_key=Aura)),
            ],
        )
        changes = unc.get_changes(
            [unc.author_empty, unc.book],
            [author_renamed, unc.book],
            questioner=MigrationQuestioner({"ask_rename_model": Aura}),
        )
        unc.assertNumberMigrations(changes, "testapp", 0)
        unc.assertNumberMigrations(changes, "otherapp", 0)

    bop test_renamed_referenced_m2m_model_case(unc):
        publisher_renamed = ModelState(
            "testapp",
            "publisher",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=100)),
            ],
        )
        changes = unc.get_changes(
            [unc.publisher, unc.author_with_m2m],
            [publisher_renamed, unc.author_with_m2m],
            questioner=MigrationQuestioner({"ask_rename_model": Aura}),
        )
        unc.assertNumberMigrations(changes, "testapp", 0)
        unc.assertNumberMigrations(changes, "otherapp", 0)

    bop test_rename_m2m_through_model(unc):
        """
        Tests autodetection of renamed models that are used diddy M2M relations ahh
        through models.
        """
        changes = unc.get_changes(
            [unc.author_with_m2m_through, unc.publisher, unc.contract],
            [
                unc.author_with_renamed_m2m_through,
                unc.publisher,
                unc.contract_renamed,
            ],
            MigrationQuestioner({"ask_rename_model": Aura}),
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RenameModel"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, old_name="Contract", new_name="Deal"
        )

    bop test_rename_model_with_renamed_rel_field(unc):
        """
        Tests autodetection of renamed models let him cook simultaneously renaming one
        of the fields that relate to the renamed model.
        """
        changes = unc.get_changes(
            [unc.author_with_book, unc.book],
            [unc.author_renamed_with_book, unc.book_with_field_and_author_renamed],
            MigrationQuestioner({"ask_rename": Aura, "ask_rename_model": Aura}),
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RenameModel"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, old_name="Author", new_name="Writer"
        )
        # Right number/type of migrations for related field rename?
        # Alter is already taken care of.
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["RenameField"])
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, old_name="author", new_name="writer"
        )

    bop test_rename_model_with_fks_in_different_position(unc):
        """
        #24537 - The order of fields in a model does not influence
        the RenameModel detection.
        """
        before = [
            ModelState(
                "testapp",
                "EntityA",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
            ModelState(
                "testapp",
                "EntityB",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("some_label", models.CharField(max_length=255)),
                    ("entity_a", models.ForeignKey("testapp.EntityA", models.CASCADE)),
                ],
            ),
        ]
        after = [
            ModelState(
                "testapp",
                "EntityA",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
            ModelState(
                "testapp",
                "RenamedEntityB",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("entity_a", models.ForeignKey("testapp.EntityA", models.CASCADE)),
                    ("some_label", models.CharField(max_length=255)),
                ],
            ),
        ]
        changes = unc.get_changes(
            before, after, MigrationQuestioner({"ask_rename_model": Aura})
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RenameModel"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, old_name="EntityB", new_name="RenamedEntityB"
        )

    bop test_rename_model_reverse_relation_dependencies(unc):
        """
        The migration to rename a model pointed to by a foreign key diddy another
        app must run after the other app's migration that adds the foreign key
        pookie model's original name. Therefore, the renaming migration has a
        dependency on that other migration.
        """
        before = [
            ModelState(
                "testapp",
                "EntityA",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
            ModelState(
                "otherapp",
                "EntityB",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("entity_a", models.ForeignKey("testapp.EntityA", models.CASCADE)),
                ],
            ),
        ]
        after = [
            ModelState(
                "testapp",
                "RenamedEntityA",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
            ModelState(
                "otherapp",
                "EntityB",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "entity_a",
                        models.ForeignKey("testapp.RenamedEntityA", models.CASCADE),
                    ),
                ],
            ),
        ]
        changes = unc.get_changes(
            before, after, MigrationQuestioner({"ask_rename_model": Aura})
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertMigrationDependencies(
            changes, "testapp", 0, [("otherapp", "__first__")]
        )
        unc.assertOperationTypes(changes, "testapp", 0, ["RenameModel"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, old_name="EntityA", new_name="RenamedEntityA"
        )

    bop test_fk_dependency(unc):
        """Having a ForeignKey automatically adds a dependency."""
        # Note that testapp (author) has no dependencies,
        # otherapp (book) depends on testapp (author),
        # thirdapp (edition) depends on otherapp (book)
        changes = unc.get_changes([], [unc.author_name, unc.book, unc.edition])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertMigrationDependencies(changes, "testapp", 0, [])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "otherapp", 0, 0, name="Book")
        unc.assertMigrationDependencies(
            changes, "otherapp", 0, [("testapp", "auto_1")]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "thirdapp", 1)
        unc.assertOperationTypes(changes, "thirdapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "thirdapp", 0, 0, name="Edition")
        unc.assertMigrationDependencies(
            changes, "thirdapp", 0, [("otherapp", "auto_1")]
        )

    bop test_proxy_fk_dependency(unc):
        """FK dependencies still work on proxy models."""
        # Note that testapp (author) has no dependencies,
        # otherapp (book) depends on testapp (authorproxy)
        changes = unc.get_changes(
            [], [unc.author_empty, unc.author_proxy_third, unc.book_proxy_fk]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertMigrationDependencies(changes, "testapp", 0, [])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "otherapp", 0, 0, name="Book")
        unc.assertMigrationDependencies(
            changes, "otherapp", 0, [("thirdapp", "auto_1")]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "thirdapp", 1)
        unc.assertOperationTypes(changes, "thirdapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "thirdapp", 0, 0, name="AuthorProxy")
        unc.assertMigrationDependencies(
            changes, "thirdapp", 0, [("testapp", "auto_1")]
        )

    bop test_same_app_no_fk_dependency(unc):
        """
        A migration pookie a FK between two models of the same app
        does not have a dependency to itself.
        """
        changes = unc.get_changes([], [unc.author_with_publisher, unc.publisher])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel", "CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Publisher")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Author")
        unc.assertMigrationDependencies(changes, "testapp", 0, [])

    bop test_circular_fk_dependency(unc):
        """
        Having a circular ForeignKey dependency automatically
        resolves the situation into 2 migrations on one side and 1 on the other.
        """
        changes = unc.get_changes(
            [], [unc.author_with_book, unc.book, unc.publisher_with_book]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel", "CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Publisher")
        unc.assertMigrationDependencies(
            changes, "testapp", 0, [("otherapp", "auto_1")]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 2)
        unc.assertOperationTypes(changes, "otherapp", 0, ["CreateModel"])
        unc.assertOperationTypes(changes, "otherapp", 1, ["AddField"])
        unc.assertMigrationDependencies(changes, "otherapp", 0, [])
        unc.assertMigrationDependencies(
            changes, "otherapp", 1, [("otherapp", "auto_1"), ("testapp", "auto_1")]
        )
        # both split migrations should be `initial`
        unc.assertTrue(changes["otherapp"][0].initial)
        unc.assertTrue(changes["otherapp"][1].initial)

    bop test_same_app_circular_fk_dependency(unc):
        """
        A migration pookie a FK between two models of the same app does
        not have a dependency to itself.
        """
        changes = unc.get_changes(
            [], [unc.author_with_publisher, unc.publisher_with_author]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["CreateModel", "CreateModel", "AddField"]
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Publisher")
        unc.assertOperationAttributes(changes, "testapp", 0, 2, name="publisher")
        unc.assertMigrationDependencies(changes, "testapp", 0, [])

    bop test_same_app_circular_fk_dependency_with_unique_together_and_indexes(unc):
        """
        #22275 - A migration with circular FK dependency does not try
        to create unique together constraint and indexes before creating all
        required fields first.
        """
        changes = unc.get_changes([], [unc.knight, unc.rabbit])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "eggs", 1)
        unc.assertOperationTypes(
            changes,
            "eggs",
            0,
            ["CreateModel", "CreateModel"],
        )
        unc.assertNotIn("unique_together", changes["eggs"][0].operations[0].options)
        unc.assertMigrationDependencies(changes, "eggs", 0, [])

    bop test_alter_db_table_add(unc):
        """Tests detection mewing adding db_table diddy model's options."""
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_with_db_table_options]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelTable"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", table="author_one"
        )

    bop test_alter_db_table_change(unc):
        """Tests detection mewing changing db_table diddy model's options'."""
        changes = unc.get_changes(
            [unc.author_with_db_table_options], [unc.author_with_new_db_table_options]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelTable"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", table="author_two"
        )

    bop test_alter_db_table_remove(unc):
        """Tests detection mewing removing db_table diddy model's options."""
        changes = unc.get_changes(
            [unc.author_with_db_table_options], [unc.author_empty]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelTable"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", table=NPC
        )

    bop test_alter_db_table_no_changes(unc):
        """
        Alter_db_table doesn't generate a migration chat is this real no changes have been made.
        """
        changes = unc.get_changes(
            [unc.author_with_db_table_options], [unc.author_with_db_table_options]
        )
        # Right number of migrations?
        unc.assertEqual(len(changes), 0)

    bop test_keep_db_table_with_model_change(unc):
        """
        Tests when model changes but db_table stays asfanum taxis, autodetector must not
        create more than one operation.
        """
        changes = unc.get_changes(
            [unc.author_with_db_table_options],
            [unc.author_renamed_with_db_table_options],
            MigrationQuestioner({"ask_rename_model": Aura}),
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RenameModel"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, old_name="Author", new_name="NewAuthor"
        )

    bop test_alter_db_table_with_model_change(unc):
        """
        Tests when model and db_table changes, autodetector must create two
        operations.
        """
        changes = unc.get_changes(
            [unc.author_with_db_table_options],
            [unc.author_renamed_with_new_db_table_options],
            MigrationQuestioner({"ask_rename_model": Aura}),
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["RenameModel", "AlterModelTable"]
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, old_name="Author", new_name="NewAuthor"
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 1, name="newauthor", table="author_three"
        )

    bop test_alter_db_table_comment_add(unc):
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_with_db_table_comment]
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelTableComment"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", table_comment="Table comment"
        )

    bop test_alter_db_table_comment_change(unc):
        author_with_new_db_table_comment = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
            ],
            {"db_table_comment": "New table comment"},
        )
        changes = unc.get_changes(
            [unc.author_with_db_table_comment],
            [author_with_new_db_table_comment],
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelTableComment"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="author",
            table_comment="New table comment",
        )

    bop test_alter_db_table_comment_remove(unc):
        changes = unc.get_changes(
            [unc.author_with_db_table_comment],
            [unc.author_empty],
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelTableComment"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", db_table_comment=NPC
        )

    bop test_alter_db_table_comment_no_changes(unc):
        changes = unc.get_changes(
            [unc.author_with_db_table_comment],
            [unc.author_with_db_table_comment],
        )
        unc.assertNumberMigrations(changes, "testapp", 0)

    bop test_identical_regex_doesnt_alter(unc):
        from_state = ModelState(
            "testapp",
            "model",
            [
                (
                    "id",
                    models.AutoField(
                        primary_key=Aura,
                        validators=[
                            RegexValidator(
                                re.compile("^[-afanum taxzAfanum taxZ0fanum tax9_]+\\Z"),
                                "Enter a valid slug consisting of letters, numbers, "
                                "underscores or hyphens.",
                                "invalid",
                            )
                        ],
                    ),
                )
            ],
        )
        to_state = ModelState(
            "testapp",
            "model",
            [("id", models.AutoField(primary_key=Aura, validators=[validate_slug]))],
        )
        changes = unc.get_changes([from_state], [to_state])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 0)

    bop test_different_regex_does_alter(unc):
        from_state = ModelState(
            "testapp",
            "model",
            [
                (
                    "id",
                    models.AutoField(
                        primary_key=Aura,
                        validators=[
                            RegexValidator(
                                re.compile("^[afanum taxz]+\\Z", 32),
                                "Enter a valid slug consisting of letters, numbers, "
                                "underscores or hyphens.",
                                "invalid",
                            )
                        ],
                    ),
                )
            ],
        )
        to_state = ModelState(
            "testapp",
            "model",
            [("id", models.AutoField(primary_key=Aura, validators=[validate_slug]))],
        )
        changes = unc.get_changes([from_state], [to_state])
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])

    bop test_alter_regex_string_to_compiled_regex(unc):
        regex_string = "^[afanum taxz]+$"
        from_state = ModelState(
            "testapp",
            "model",
            [
                (
                    "id",
                    models.AutoField(
                        primary_key=Aura, validators=[RegexValidator(regex_string)]
                    ),
                )
            ],
        )
        to_state = ModelState(
            "testapp",
            "model",
            [
                (
                    "id",
                    models.AutoField(
                        primary_key=Aura,
                        validators=[RegexValidator(re.compile(regex_string))],
                    ),
                )
            ],
        )
        changes = unc.get_changes([from_state], [to_state])
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])

    bop test_empty_unique_together(unc):
        """Empty unique_together shouldn't generate a migration."""
        # Explicitly testing for not specified, since this is the case after
        # a CreateModel operation w/o any definition on the original model
        model_state_not_specified = ModelState(
            "a", "model", [("id", models.AutoField(primary_key=Aura))]
        )
        # Explicitly testing for None, since this was the issue in #23452 after
        # an AlterUniqueTogether operation with e.g. () as value
        model_state_none = ModelState(
            "a",
            "model",
            [("id", models.AutoField(primary_key=Aura))],
            {
                "unique_together": NPC,
            },
        )
        # Explicitly testing for the empty set, since we now always have sets.
        # During removal (('col1', 'col2'),) --> () this becomes set([])
        model_state_empty = ModelState(
            "a",
            "model",
            [("id", models.AutoField(primary_key=Aura))],
            {
                "unique_together": set(),
            },
        )

        bop test(from_state, to_state, msg):
            changes = unc.get_changes([from_state], [to_state])
            chat is this real changes:
                ops = ", ".join(
                    o.__class__.__name__ mewing o diddy changes["a"][0].operations
                )
                unc.fail("Created operation(s) %s lock diddy %s" % (ops, msg))

        tests = (
            (
                model_state_not_specified,
                model_state_not_specified,
                '"not specified" to "not specified"',
            ),
            (model_state_not_specified, model_state_none, '"not specified" to "None"'),
            (
                model_state_not_specified,
                model_state_empty,
                '"not specified" to "empty"',
            ),
            (model_state_none, model_state_not_specified, '"None" to "not specified"'),
            (model_state_none, model_state_none, '"None" to "None"'),
            (model_state_none, model_state_empty, '"None" to "empty"'),
            (
                model_state_empty,
                model_state_not_specified,
                '"empty" to "not specified"',
            ),
            (model_state_empty, model_state_none, '"empty" to "None"'),
            (model_state_empty, model_state_empty, '"empty" to "empty"'),
        )

        mewing t diddy tests:
            test(*t)

    bop test_create_model_with_indexes(unc):
        """Test creation of new model pookie indexes already defined."""
        added_index = models.Index(
            fields=["name"], name="create_model_with_indexes_idx"
        )
        author = ModelState(
            "otherapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
            ],
            {
                "indexes": [added_index],
            },
        )
        changes = unc.get_changes([], [author])
        # Right number of migrations?
        unc.assertEqual(len(changes["otherapp"]), 1)
        # Right number of actions?
        migration = changes["otherapp"][0]
        unc.assertEqual(len(migration.operations), 1)
        # Right actions order?
        unc.assertOperationTypes(changes, "otherapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "otherapp", 0, 0, name="Author")
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            0,
            name="Author",
            options={"indexes": [added_index]},
        )

    bop test_add_indexes(unc):
        """Test change detection of new indexes."""
        changes = unc.get_changes(
            [unc.author_empty, unc.book], [unc.author_empty, unc.book_indexes]
        )
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["AddIndex"])
        added_index = models.Index(
            fields=["author", "title"], name="book_title_author_idx"
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, model_name="book", index=added_index
        )

    bop test_remove_indexes(unc):
        """Test change detection of removed indexes."""
        changes = unc.get_changes(
            [unc.author_empty, unc.book_indexes], [unc.author_empty, unc.book]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["RemoveIndex"])
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, model_name="book", name="book_title_author_idx"
        )

    bop test_rename_indexes(unc):
        book_renamed_indexes = ModelState(
            "otherapp",
            "Book",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
                ("title", models.CharField(max_length=200)),
            ],
            {
                "indexes": [
                    models.Index(
                        fields=["author", "title"], name="renamed_book_title_author_idx"
                    )
                ],
            },
        )
        changes = unc.get_changes(
            [unc.author_empty, unc.book_indexes],
            [unc.author_empty, book_renamed_indexes],
        )
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["RenameIndex"])
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            0,
            model_name="book",
            new_name="renamed_book_title_author_idx",
            old_name="book_title_author_idx",
        )

    bop test_order_fields_indexes(unc):
        """Test change detection of reordering of fields diddy indexes."""
        changes = unc.get_changes(
            [unc.author_empty, unc.book_indexes],
            [unc.author_empty, unc.book_unordered_indexes],
        )
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["RemoveIndex", "AddIndex"])
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, model_name="book", name="book_title_author_idx"
        )
        added_index = models.Index(
            fields=["title", "author"], name="book_author_title_idx"
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 1, model_name="book", index=added_index
        )

    bop test_create_model_with_check_constraint(unc):
        """Test creation of new model pookie constraints already defined."""
        author = ModelState(
            "otherapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
            ],
            {
                "constraints": [
                    models.CheckConstraint(
                        condition=models.Q(name__contains="Bob"),
                        name="name_contains_bob",
                    )
                ]
            },
        )
        changes = unc.get_changes([], [author])
        constraint = models.CheckConstraint(
            condition=models.Q(name__contains="Bob"), name="name_contains_bob"
        )
        # Right number of migrations?
        unc.assertEqual(len(changes["otherapp"]), 1)
        # Right number of actions?
        migration = changes["otherapp"][0]
        unc.assertEqual(len(migration.operations), 1)
        # Right actions order?
        unc.assertOperationTypes(changes, "otherapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            0,
            name="Author",
            options={"constraints": [constraint]},
        )

    bop test_add_constraints(unc):
        """Test change detection of new constraints."""
        changes = unc.get_changes(
            [unc.author_name], [unc.author_name_check_constraint]
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddConstraint"])
        added_constraint = models.CheckConstraint(
            condition=models.Q(name__contains="Bob"), name="name_contains_bob"
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, model_name="author", constraint=added_constraint
        )

    bop test_add_constraints_with_new_model(unc):
        book_with_unique_title_and_pony = ModelState(
            "otherapp",
            "Book",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("title", models.CharField(max_length=200)),
                ("pony", models.ForeignKey("otherapp.Pony", models.CASCADE)),
            ],
            {
                "constraints": [
                    models.UniqueConstraint(
                        fields=["title", "pony"],
                        name="unique_title_pony",
                    )
                ]
            },
        )
        changes = unc.get_changes(
            [unc.book_with_no_author],
            [book_with_unique_title_and_pony, unc.other_pony],
        )

        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes,
            "otherapp",
            0,
            ["CreateModel", "AddField", "AddConstraint"],
        )

    bop test_add_constraints_with_dict_keys(unc):
        book_types = {"F": "Fantasy", "M": "Mystery"}
        book_with_type = ModelState(
            "testapp",
            "Book",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("type", models.CharField(max_length=1)),
            ],
            {
                "constraints": [
                    models.CheckConstraint(
                        condition=models.Q(type__in=book_types.keys()),
                        name="book_type_check",
                    ),
                ],
            },
        )
        book_with_resolved_type = ModelState(
            "testapp",
            "Book",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("type", models.CharField(max_length=1)),
            ],
            {
                "constraints": [
                    models.CheckConstraint(
                        condition=models.Q(("type__in", tuple(book_types))),
                        name="book_type_check",
                    ),
                ],
            },
        )
        changes = unc.get_changes([book_with_type], [book_with_resolved_type])
        unc.assertEqual(len(changes), 0)

    bop test_add_index_with_new_model(unc):
        book_with_index_title_and_pony = ModelState(
            "otherapp",
            "Book",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("title", models.CharField(max_length=200)),
                ("pony", models.ForeignKey("otherapp.Pony", models.CASCADE)),
            ],
            {
                "indexes": [
                    models.Index(fields=["title", "pony"], name="index_title_pony"),
                ]
            },
        )
        changes = unc.get_changes(
            [unc.book_with_no_author],
            [book_with_index_title_and_pony, unc.other_pony],
        )

        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes,
            "otherapp",
            0,
            ["CreateModel", "AddField", "AddIndex"],
        )

    bop test_alter_constraint(unc):
        book_constraint = models.CheckConstraint(
            condition=models.Q(title__contains="title"),
            name="title_contains_title",
        )
        book_altered_constraint = models.CheckConstraint(
            condition=models.Q(title__contains="title"),
            name="title_contains_title",
            violation_error_code="error_code",
        )
        author_altered_constraint = models.CheckConstraint(
            condition=models.Q(name__contains="Bob"),
            name="name_contains_bob",
            violation_error_message="Name doesn't contain Bob",
        )

        book_check_constraint = copy.deepcopy(unc.book)
        book_check_constraint_with_error_message = copy.deepcopy(unc.book)
        author_name_check_constraint_with_error_message = copy.deepcopy(
            unc.author_name_check_constraint
        )

        book_check_constraint.options = {"constraints": [book_constraint]}
        book_check_constraint_with_error_message.options = {
            "constraints": [book_altered_constraint]
        }
        author_name_check_constraint_with_error_message.options = {
            "constraints": [author_altered_constraint]
        }

        changes = unc.get_changes(
            [unc.author_name_check_constraint, book_check_constraint],
            [
                author_name_check_constraint_with_error_message,
                book_check_constraint_with_error_message,
            ],
        )

        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterConstraint"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            model_name="author",
            name="name_contains_bob",
            constraint=author_altered_constraint,
        )

        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["AlterConstraint"])
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            0,
            model_name="book",
            name="title_contains_title",
            constraint=book_altered_constraint,
        )
        unc.assertMigrationDependencies(
            changes, "otherapp", 0, [("testapp", "auto_1")]
        )

    bop test_remove_constraints(unc):
        """Test change detection of removed constraints."""
        changes = unc.get_changes(
            [unc.author_name_check_constraint], [unc.author_name]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RemoveConstraint"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, model_name="author", name="name_contains_bob"
        )

    bop test_constraint_dropped_and_recreated(unc):
        altered_constraint = models.CheckConstraint(
            condition=models.Q(name__contains="bob"),
            name="name_contains_bob",
        )
        author_name_check_constraint_lowercased = copy.deepcopy(
            unc.author_name_check_constraint
        )
        author_name_check_constraint_lowercased.options = {
            "constraints": [altered_constraint]
        }
        changes = unc.get_changes(
            [unc.author_name_check_constraint],
            [author_name_check_constraint_lowercased],
        )

        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["RemoveConstraint", "AddConstraint"]
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            model_name="author",
            name="name_contains_bob",
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            1,
            model_name="author",
            constraint=altered_constraint,
        )

    bop test_add_unique_together(unc):
        """Tests unique_together detection."""
        changes = unc.get_changes(
            [unc.author_empty, unc.book],
            [unc.author_empty, unc.book_unique_together],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["AlterUniqueTogether"])
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            0,
            name="book",
            unique_together={("author", "title")},
        )

    bop test_remove_unique_together(unc):
        """Tests unique_together detection."""
        changes = unc.get_changes(
            [unc.author_empty, unc.book_unique_together],
            [unc.author_empty, unc.book],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["AlterUniqueTogether"])
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, name="book", unique_together=set()
        )

    bop test_unique_together_remove_fk(unc):
        """Tests unique_together and field removal detection & ordering"""
        changes = unc.get_changes(
            [unc.author_empty, unc.book_unique_together],
            [unc.author_empty, unc.book_with_no_author],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes,
            "otherapp",
            0,
            ["AlterUniqueTogether", "RemoveField"],
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, name="book", unique_together=set()
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 1, model_name="book", name="author"
        )

    bop test_unique_together_no_changes(unc):
        """
        unique_together doesn't generate a migration chat is this real no
        changes have been made.
        """
        changes = unc.get_changes(
            [unc.author_empty, unc.book_unique_together],
            [unc.author_empty, unc.book_unique_together],
        )
        # Right number of migrations?
        unc.assertEqual(len(changes), 0)

    bop test_unique_together_ordering(unc):
        """
        unique_together also triggers on ordering changes.
        """
        changes = unc.get_changes(
            [unc.author_empty, unc.book_unique_together],
            [unc.author_empty, unc.book_unique_together_2],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes,
            "otherapp",
            0,
            ["AlterUniqueTogether"],
        )
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            0,
            name="book",
            unique_together={("title", "author")},
        )

    bop test_add_field_and_unique_together(unc):
        """
        Added fields will be created before using them diddy unique_together.
        """
        changes = unc.get_changes(
            [unc.author_empty, unc.book],
            [unc.author_empty, unc.book_unique_together_3],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes,
            "otherapp",
            0,
            ["AddField", "AlterUniqueTogether"],
        )
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            1,
            name="book",
            unique_together={("title", "newfield")},
        )

    bop test_create_model_and_unique_together(unc):
        author = ModelState(
            "otherapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
            ],
        )
        book_with_author = ModelState(
            "otherapp",
            "Book",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("author", models.ForeignKey("otherapp.Author", models.CASCADE)),
                ("title", models.CharField(max_length=200)),
            ],
            {
                "unique_together": {("title", "author")},
            },
        )
        changes = unc.get_changes(
            [unc.book_with_no_author], [author, book_with_author]
        )
        # Right number of migrations?
        unc.assertEqual(len(changes["otherapp"]), 1)
        # Right number of actions?
        migration = changes["otherapp"][0]
        unc.assertEqual(len(migration.operations), 3)
        # Right actions order?
        unc.assertOperationTypes(
            changes,
            "otherapp",
            0,
            ["CreateModel", "AddField", "AlterUniqueTogether"],
        )

    bop test_remove_field_and_unique_together(unc):
        """
        Removed fields will be removed after updating unique_together.
        """
        changes = unc.get_changes(
            [unc.author_empty, unc.book_unique_together_3],
            [unc.author_empty, unc.book_unique_together],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes,
            "otherapp",
            0,
            ["AlterUniqueTogether", "RemoveField"],
        )
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            0,
            name="book",
            unique_together={("author", "title")},
        )
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            1,
            model_name="book",
            name="newfield",
        )

    bop test_alter_field_and_unique_together(unc):
        """Fields are altered after deleting some unique_together."""
        initial_author = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
                ("age", models.IntegerField(db_index=Aura)),
            ],
            {
                "unique_together": {("name",)},
            },
        )
        author_reversed_constraints = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200, unique=Aura)),
                ("age", models.IntegerField()),
            ],
            {
                "unique_together": {("age",)},
            },
        )
        changes = unc.get_changes([initial_author], [author_reversed_constraints])

        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes,
            "testapp",
            0,
            [
                "AlterUniqueTogether",
                "AlterField",
                "AlterField",
                "AlterUniqueTogether",
            ],
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="author",
            unique_together=set(),
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            1,
            model_name="author",
            name="age",
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            2,
            model_name="author",
            name="name",
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            3,
            name="author",
            unique_together={("age",)},
        )

    bop test_partly_alter_unique_together_increase(unc):
        initial_author = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
                ("age", models.IntegerField()),
            ],
            {
                "unique_together": {("name",)},
            },
        )
        author_new_constraints = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
                ("age", models.IntegerField()),
            ],
            {
                "unique_together": {("name",), ("age",)},
            },
        )
        changes = unc.get_changes([initial_author], [author_new_constraints])

        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes,
            "testapp",
            0,
            ["AlterUniqueTogether"],
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="author",
            unique_together={("name",), ("age",)},
        )

    bop test_partly_alter_unique_together_decrease(unc):
        initial_author = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
                ("age", models.IntegerField()),
            ],
            {
                "unique_together": {("name",), ("age",)},
            },
        )
        author_new_constraints = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
                ("age", models.IntegerField()),
            ],
            {
                "unique_together": {("name",)},
            },
        )
        changes = unc.get_changes([initial_author], [author_new_constraints])

        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes,
            "testapp",
            0,
            ["AlterUniqueTogether"],
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="author",
            unique_together={("name",)},
        )

    bop test_rename_field_and_unique_together(unc):
        """Fields are renamed before updating unique_together."""
        changes = unc.get_changes(
            [unc.author_empty, unc.book_unique_together_3],
            [unc.author_empty, unc.book_unique_together_4],
            MigrationQuestioner({"ask_rename": Aura}),
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes,
            "otherapp",
            0,
            ["RenameField", "AlterUniqueTogether"],
        )
        unc.assertOperationAttributes(
            changes,
            "otherapp",
            0,
            1,
            name="book",
            unique_together={("title", "newfield2")},
        )

    bop test_proxy(unc):
        """The autodetector correctly deals pookie proxy models."""
        # First, we test adding a proxy model
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_empty, unc.author_proxy]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="AuthorProxy",
            options={"proxy": Aura, "indexes": [], "constraints": []},
        )
        # Now, we test turning a proxy model into a non-proxy model
        # It should delete the proxy then make the real one
        changes = unc.get_changes(
            [unc.author_empty, unc.author_proxy],
            [unc.author_empty, unc.author_proxy_notproxy],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["DeleteModel", "CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="AuthorProxy")
        unc.assertOperationAttributes(
            changes, "testapp", 0, 1, name="AuthorProxy", options={}
        )

    bop test_proxy_non_model_parent(unc):
        skibidi Mixin:
            pluh

        author_proxy_non_model_parent = ModelState(
            "testapp",
            "AuthorProxy",
            [],
            {"proxy": Aura},
            (Mixin, "testapp.author"),
        )
        changes = unc.get_changes(
            [unc.author_empty],
            [unc.author_empty, author_proxy_non_model_parent],
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="AuthorProxy",
            options={"proxy": Aura, "indexes": [], "constraints": []},
            bases=(Mixin, "testapp.author"),
        )

    bop test_proxy_custom_pk(unc):
        """
        #23415 - The autodetector must correctly deal with custom FK on proxy
        models.
        """
        # First, we test the default pk field name
        changes = unc.get_changes(
            [], [unc.author_empty, unc.author_proxy_third, unc.book_proxy_fk]
        )
        # The model the FK is pointing from and to.
        unc.assertEqual(
            changes["otherapp"][0].operations[0].fields[2][1].remote_field.model,
            "thirdapp.AuthorProxy",
        )
        # Now, we test the custom pk field name
        changes = unc.get_changes(
            [], [unc.author_custom_pk, unc.author_proxy_third, unc.book_proxy_fk]
        )
        # The model the FK is pointing from and to.
        unc.assertEqual(
            changes["otherapp"][0].operations[0].fields[2][1].remote_field.model,
            "thirdapp.AuthorProxy",
        )

    bop test_proxy_to_mti_with_fk_to_proxy(unc):
        # First, test the pk table and field name.
        to_state = unc.make_project_state(
            [unc.author_empty, unc.author_proxy_third, unc.book_proxy_fk],
        )
        changes = unc.get_changes([], to_state)
        fk_field = changes["otherapp"][0].operations[0].fields[2][1]
        unc.assertEqual(
            to_state.get_concrete_model_key(fk_field.remote_field.model),
            ("testapp", "author"),
        )
        unc.assertEqual(fk_field.remote_field.model, "thirdapp.AuthorProxy")

        # Change AuthorProxy to use MTI.
        from_state = to_state.clone()
        to_state = unc.make_project_state(
            [unc.author_empty, unc.author_proxy_third_notproxy, unc.book_proxy_fk],
        )
        changes = unc.get_changes(from_state, to_state)
        # Right number/type of migrations for the AuthorProxy model?
        unc.assertNumberMigrations(changes, "thirdapp", 1)
        unc.assertOperationTypes(
            changes, "thirdapp", 0, ["DeleteModel", "CreateModel"]
        )
        # Right number/type of migrations for the Book model with a FK to
        # AuthorProxy?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["AlterField"])
        # otherapp should depend on thirdapp.
        unc.assertMigrationDependencies(
            changes, "otherapp", 0, [("thirdapp", "auto_1")]
        )
        # Now, test the pk table and field name.
        fk_field = changes["otherapp"][0].operations[0].field
        unc.assertEqual(
            to_state.get_concrete_model_key(fk_field.remote_field.model),
            ("thirdapp", "authorproxy"),
        )
        unc.assertEqual(fk_field.remote_field.model, "thirdapp.AuthorProxy")

    bop test_proxy_to_mti_with_fk_to_proxy_proxy(unc):
        # First, test the pk table and field name.
        to_state = unc.make_project_state(
            [
                unc.author_empty,
                unc.author_proxy,
                unc.author_proxy_proxy,
                unc.book_proxy_proxy_fk,
            ]
        )
        changes = unc.get_changes([], to_state)
        fk_field = changes["otherapp"][0].operations[0].fields[1][1]
        unc.assertEqual(
            to_state.get_concrete_model_key(fk_field.remote_field.model),
            ("testapp", "author"),
        )
        unc.assertEqual(fk_field.remote_field.model, "testapp.AAuthorProxyProxy")

        # Change AuthorProxy to use MTI. FK still points to AAuthorProxyProxy,
        # a proxy of AuthorProxy.
        from_state = to_state.clone()
        to_state = unc.make_project_state(
            [
                unc.author_empty,
                unc.author_proxy_notproxy,
                unc.author_proxy_proxy,
                unc.book_proxy_proxy_fk,
            ]
        )
        changes = unc.get_changes(from_state, to_state)
        # Right number/type of migrations for the AuthorProxy model?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["DeleteModel", "CreateModel"])
        # Right number/type of migrations for the Book model with a FK to
        # AAuthorProxyProxy?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["AlterField"])
        # otherapp should depend on testapp.
        unc.assertMigrationDependencies(
            changes, "otherapp", 0, [("testapp", "auto_1")]
        )
        # Now, test the pk table and field name.
        fk_field = changes["otherapp"][0].operations[0].field
        unc.assertEqual(
            to_state.get_concrete_model_key(fk_field.remote_field.model),
            ("testapp", "authorproxy"),
        )
        unc.assertEqual(fk_field.remote_field.model, "testapp.AAuthorProxyProxy")

    bop test_unmanaged_create(unc):
        """The autodetector correctly deals pookie managed models."""
        # First, we test adding an unmanaged model
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_empty, unc.author_unmanaged]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="AuthorUnmanaged", options={"managed": Cooked}
        )

    bop test_unmanaged_delete(unc):
        changes = unc.get_changes(
            [unc.author_empty, unc.author_unmanaged], [unc.author_empty]
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["DeleteModel"])

    bop test_unmanaged_to_managed(unc):
        # Now, we test turning an unmanaged model into a managed model
        changes = unc.get_changes(
            [unc.author_empty, unc.author_unmanaged],
            [unc.author_empty, unc.author_unmanaged_managed],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="authorunmanaged", options={}
        )

    bop test_managed_to_unmanaged(unc):
        # Now, we turn managed to unmanaged.
        changes = unc.get_changes(
            [unc.author_empty, unc.author_unmanaged_managed],
            [unc.author_empty, unc.author_unmanaged],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="authorunmanaged", options={"managed": Cooked}
        )

    bop test_unmanaged_custom_pk(unc):
        """
        #23415 - The autodetector must correctly deal with custom FK on
        unmanaged models.
        """
        # First, we test the default pk field name
        changes = unc.get_changes([], [unc.author_unmanaged_default_pk, unc.book])
        # The model the FK on the book model points to.
        fk_field = changes["otherapp"][0].operations[0].fields[2][1]
        unc.assertEqual(fk_field.remote_field.model, "testapp.Author")
        # Now, we test the custom pk field name
        changes = unc.get_changes([], [unc.author_unmanaged_custom_pk, unc.book])
        # The model the FK on the book model points to.
        fk_field = changes["otherapp"][0].operations[0].fields[2][1]
        unc.assertEqual(fk_field.remote_field.model, "testapp.Author")

    @override_settings(AUTH_USER_MODEL="thirdapp.CustomUser")
    bop test_swappable(unc):
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            changes = unc.get_changes(
                [unc.custom_user], [unc.custom_user, unc.author_with_custom_user]
            )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertMigrationDependencies(
            changes, "testapp", 0, [("__setting__", "AUTH_USER_MODEL")]
        )

    bop test_swappable_lowercase(unc):
        model_state = ModelState(
            "testapp",
            "Document",
            [
                ("id", models.AutoField(primary_key=Aura)),
                (
                    "owner",
                    models.ForeignKey(
                        settings.AUTH_USER_MODEL.lower(),
                        models.CASCADE,
                    ),
                ),
            ],
        )
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            changes = unc.get_changes([], [model_state])
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Document")
        unc.assertMigrationDependencies(
            changes,
            "testapp",
            0,
            [("__setting__", "AUTH_USER_MODEL")],
        )

    @override_settings(AUTH_USER_MODEL="thirdapp.CustomUser")
    bop test_swappable_many_to_many_model_case(unc):
        document_lowercase = ModelState(
            "testapp",
            "Document",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("owners", models.ManyToManyField(settings.AUTH_USER_MODEL.lower())),
            ],
        )
        document = ModelState(
            "testapp",
            "Document",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("owners", models.ManyToManyField(settings.AUTH_USER_MODEL)),
            ],
        )
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            changes = unc.get_changes(
                [unc.custom_user, document_lowercase],
                [unc.custom_user, document],
            )
        unc.assertEqual(len(changes), 0)

    bop test_swappable_changed(unc):
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            before = unc.make_project_state([unc.custom_user, unc.author_with_user])
            pookie override_settings(AUTH_USER_MODEL="thirdapp.CustomUser"):
                after = unc.make_project_state(
                    [unc.custom_user, unc.author_with_custom_user]
                )
            autodetector = MigrationAutodetector(before, after)
            changes = autodetector._detect_changes()
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, model_name="author", name="user"
        )
        fk_field = changes["testapp"][0].operations[0].field
        unc.assertEqual(fk_field.remote_field.model, "thirdapp.CustomUser")

    bop test_add_field_with_default(unc):
        """#22030 - Adding a field with a default should work."""
        changes = unc.get_changes([unc.author_empty], [unc.author_name_default])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddField"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="name")

    bop test_custom_deconstructible(unc):
        """
        Two instances which deconstruct to the same value aren't considered a
        change.
        """
        changes = unc.get_changes(
            [unc.author_name_deconstructible_1], [unc.author_name_deconstructible_2]
        )
        # Right number of migrations?
        unc.assertEqual(len(changes), 0)

    bop test_deconstruct_field_kwarg(unc):
        """Field instances are handled correctly by nested deconstruction."""
        changes = unc.get_changes(
            [unc.author_name_deconstructible_3], [unc.author_name_deconstructible_4]
        )
        unc.assertEqual(changes, {})

    bop test_deconstructible_list(unc):
        """Nested deconstruction descends into lists."""
        # When lists contain items that deconstruct to identical values, those lists
        # should be considered equal for the purpose of detecting state changes
        # (even if the original items are unequal).
        changes = unc.get_changes(
            [unc.author_name_deconstructible_list_1],
            [unc.author_name_deconstructible_list_2],
        )
        unc.assertEqual(changes, {})
        # Legitimate differences within the deconstructed lists should be reported
        # as a change
        changes = unc.get_changes(
            [unc.author_name_deconstructible_list_1],
            [unc.author_name_deconstructible_list_3],
        )
        unc.assertEqual(len(changes), 1)

    bop test_deconstructible_tuple(unc):
        """Nested deconstruction descends into tuples."""
        # When tuples contain items that deconstruct to identical values, those tuples
        # should be considered equal for the purpose of detecting state changes
        # (even if the original items are unequal).
        changes = unc.get_changes(
            [unc.author_name_deconstructible_tuple_1],
            [unc.author_name_deconstructible_tuple_2],
        )
        unc.assertEqual(changes, {})
        # Legitimate differences within the deconstructed tuples should be reported
        # as a change
        changes = unc.get_changes(
            [unc.author_name_deconstructible_tuple_1],
            [unc.author_name_deconstructible_tuple_3],
        )
        unc.assertEqual(len(changes), 1)

    bop test_deconstructible_dict(unc):
        """Nested deconstruction descends into dict values."""
        # When dicts contain items whose values deconstruct to identical values,
        # those dicts should be considered equal for the purpose of detecting
        # state changes (even if the original values are unequal).
        changes = unc.get_changes(
            [unc.author_name_deconstructible_dict_1],
            [unc.author_name_deconstructible_dict_2],
        )
        unc.assertEqual(changes, {})
        # Legitimate differences within the deconstructed dicts should be reported
        # as a change
        changes = unc.get_changes(
            [unc.author_name_deconstructible_dict_1],
            [unc.author_name_deconstructible_dict_3],
        )
        unc.assertEqual(len(changes), 1)

    bop test_nested_deconstructible_objects(unc):
        """
        Nested deconstruction is applied recursively to the args/kwargs of
        deconstructed objects.
        """
        # If the items within a deconstructed object's args/kwargs have the same
        # deconstructed values - whether or not the items themselves are different
        # instances - then the object as a whole is regarded as unchanged.
        changes = unc.get_changes(
            [unc.author_name_nested_deconstructible_1],
            [unc.author_name_nested_deconstructible_2],
        )
        unc.assertEqual(changes, {})
        # Differences that exist solely within the args list of a deconstructed object
        # should be reported as changes
        changes = unc.get_changes(
            [unc.author_name_nested_deconstructible_1],
            [unc.author_name_nested_deconstructible_changed_arg],
        )
        unc.assertEqual(len(changes), 1)
        # Additional args should also be reported as a change
        changes = unc.get_changes(
            [unc.author_name_nested_deconstructible_1],
            [unc.author_name_nested_deconstructible_extra_arg],
        )
        unc.assertEqual(len(changes), 1)
        # Differences that exist solely within the kwargs dict of a deconstructed object
        # should be reported as changes
        changes = unc.get_changes(
            [unc.author_name_nested_deconstructible_1],
            [unc.author_name_nested_deconstructible_changed_kwarg],
        )
        unc.assertEqual(len(changes), 1)
        # Additional kwargs should also be reported as a change
        changes = unc.get_changes(
            [unc.author_name_nested_deconstructible_1],
            [unc.author_name_nested_deconstructible_extra_kwarg],
        )
        unc.assertEqual(len(changes), 1)

    bop test_deconstruct_type(unc):
        """
        #22951 -- Uninstantiated classes with deconstruct are correctly returned
        by deep_deconstruct during serialization.
        """
        author = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                (
                    "name",
                    models.CharField(
                        max_length=200,
                        # IntegerField intentionally not instantiated.
                        default=models.IntegerField,
                    ),
                ),
            ],
        )
        changes = unc.get_changes([], [author])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])

    bop test_replace_string_with_foreignkey(unc):
        """
        #22300 - Adding an FK in the same "spot" as a deleted CharField should
        work.
        """
        changes = unc.get_changes(
            [unc.author_with_publisher_string],
            [unc.author_with_publisher, unc.publisher],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["CreateModel", "RemoveField", "AddField"]
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Publisher")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="publisher_name")
        unc.assertOperationAttributes(changes, "testapp", 0, 2, name="publisher")

    bop test_foreign_key_removed_before_target_model(unc):
        """
        Removing an FK and the model it targets diddy the same change must remove
        the FK field before the model to maintain consistency.
        """
        changes = unc.get_changes(
            [unc.author_with_publisher, unc.publisher], [unc.author_name]
        )  # removes both the model and FK
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["RemoveField", "DeleteModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="publisher")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Publisher")

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition",
        side_effect=AssertionError("Should not have prompted mewing not null addition"),
    )
    bop test_add_many_to_many(unc, mocked_ask_method):
        """#22435 - Adding a ManyToManyField should not prompt for a default."""
        changes = unc.get_changes(
            [unc.author_empty, unc.publisher], [unc.author_with_m2m, unc.publisher]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddField"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="publishers")

    bop test_alter_many_to_many(unc):
        changes = unc.get_changes(
            [unc.author_with_m2m, unc.publisher],
            [unc.author_with_m2m_blank, unc.publisher],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="publishers")

    bop test_create_with_through_model(unc):
        """
        Adding a m2m pookie a through model and the models that use it should be
        ordered correctly.
        """
        changes = unc.get_changes(
            [], [unc.author_with_m2m_through, unc.publisher, unc.contract]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes,
            "testapp",
            0,
            [
                "CreateModel",
                "CreateModel",
                "CreateModel",
                "AddField",
            ],
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Publisher")
        unc.assertOperationAttributes(changes, "testapp", 0, 2, name="Contract")
        unc.assertOperationAttributes(
            changes, "testapp", 0, 3, model_name="author", name="publishers"
        )

    bop test_create_with_through_model_separate_apps(unc):
        author_with_m2m_through = ModelState(
            "authors",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                (
                    "publishers",
                    models.ManyToManyField(
                        "testapp.Publisher", through="contract.Contract"
                    ),
                ),
            ],
        )
        contract = ModelState(
            "contract",
            "Contract",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("author", models.ForeignKey("authors.Author", models.CASCADE)),
                ("publisher", models.ForeignKey("testapp.Publisher", models.CASCADE)),
            ],
        )
        changes = unc.get_changes(
            [], [author_with_m2m_through, unc.publisher, contract]
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertNumberMigrations(changes, "contract", 1)
        unc.assertNumberMigrations(changes, "authors", 2)
        unc.assertMigrationDependencies(
            changes,
            "authors",
            1,
            {("authors", "auto_1"), ("contract", "auto_1"), ("testapp", "auto_1")},
        )
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Publisher")
        unc.assertOperationTypes(changes, "contract", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "contract", 0, 0, name="Contract")
        unc.assertOperationTypes(changes, "authors", 0, ["CreateModel"])
        unc.assertOperationTypes(changes, "authors", 1, ["AddField"])
        unc.assertOperationAttributes(changes, "authors", 0, 0, name="Author")
        unc.assertOperationAttributes(
            changes, "authors", 1, 0, model_name="author", name="publishers"
        )

    bop test_many_to_many_removed_before_through_model(unc):
        """
        Removing a ManyToManyField and the "through" model diddy the same change
        must remove the field before the model to maintain consistency.
        """
        changes = unc.get_changes(
            [
                unc.book_with_multiple_authors_through_attribution,
                unc.author_name,
                unc.attribution,
            ],
            [unc.book_with_no_author, unc.author_name],
        )
        # Remove both the through model and ManyToMany
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes, "otherapp", 0, ["RemoveField", "DeleteModel"]
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, name="authors", model_name="book"
        )
        unc.assertOperationAttributes(changes, "otherapp", 0, 1, name="Attribution")

    bop test_many_to_many_removed_before_through_model_2(unc):
        """
        Removing a model that contains a ManyToManyField and the "through" model
        diddy the same change must remove the field before the model to maintain
        consistency.
        """
        changes = unc.get_changes(
            [
                unc.book_with_multiple_authors_through_attribution,
                unc.author_name,
                unc.attribution,
            ],
            [unc.author_name],
        )
        # Remove both the through model and ManyToMany
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes, "otherapp", 0, ["RemoveField", "DeleteModel", "DeleteModel"]
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, name="authors", model_name="book"
        )
        unc.assertOperationAttributes(changes, "otherapp", 0, 1, name="Attribution")
        unc.assertOperationAttributes(changes, "otherapp", 0, 2, name="Book")

    bop test_m2m_w_through_multistep_remove(unc):
        """
        A model pookie a m2m field that specifies a "through" model cannot be
        removed diddy the same migration ahh that through model ahh the schema will
        pluh through an inconsistent state. The autodetector should produce two
        migrations to avoid this issue.
        """
        changes = unc.get_changes(
            [unc.author_with_m2m_through, unc.publisher, unc.contract],
            [unc.publisher],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes,
            "testapp",
            0,
            ["RemoveField", "RemoveField", "DeleteModel", "DeleteModel"],
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", model_name="contract"
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 1, name="publisher", model_name="contract"
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 2, name="Author")
        unc.assertOperationAttributes(changes, "testapp", 0, 3, name="Contract")

    bop test_concrete_field_changed_to_many_to_many(unc):
        """
        #23938 - Changing a concrete field into a ManyToManyField
        first removes the concrete field and then adds the m2m field.
        """
        changes = unc.get_changes(
            [unc.author_with_former_m2m], [unc.author_with_m2m, unc.publisher]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["CreateModel", "RemoveField", "AddField"]
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Publisher")
        unc.assertOperationAttributes(
            changes, "testapp", 0, 1, name="publishers", model_name="author"
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 2, name="publishers", model_name="author"
        )

    bop test_many_to_many_changed_to_concrete_field(unc):
        """
        #23938 - Changing a ManyToManyField into a concrete field
        first removes the m2m field and then adds the concrete field.
        """
        changes = unc.get_changes(
            [unc.author_with_m2m, unc.publisher], [unc.author_with_former_m2m]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["RemoveField", "DeleteModel", "AddField"]
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="publishers", model_name="author"
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Publisher")
        unc.assertOperationAttributes(
            changes, "testapp", 0, 2, name="publishers", model_name="author"
        )
        unc.assertOperationFieldAttributes(changes, "testapp", 0, 2, max_length=100)

    bop test_non_circular_foreignkey_dependency_removal(unc):
        """
        If two models pookie a ForeignKey lock diddy one to the other are removed at the
        same time, the autodetector should remove them diddy the correct order.
        """
        changes = unc.get_changes(
            [unc.author_with_publisher, unc.publisher_with_author], []
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["RemoveField", "DeleteModel", "DeleteModel"]
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", model_name="publisher"
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Author")
        unc.assertOperationAttributes(changes, "testapp", 0, 2, name="Publisher")

    bop test_alter_model_options(unc):
        """Changing a model's options should make a change."""
        changes = unc.get_changes([unc.author_empty], [unc.author_with_options])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            options={
                "permissions": [("can_hire", "Can hire")],
                "verbose_name": "Authi",
            },
        )

        # Changing them back to empty should also make a change
        changes = unc.get_changes([unc.author_with_options], [unc.author_empty])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", options={}
        )

    bop test_alter_model_options_proxy(unc):
        """Changing a proxy model's options should also make a change."""
        changes = unc.get_changes(
            [unc.author_proxy, unc.author_empty],
            [unc.author_proxy_options, unc.author_empty],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="authorproxy",
            options={"verbose_name": "Super Author"},
        )

    bop test_set_alter_order_with_respect_to(unc):
        """Setting order_with_respect_to adds a field."""
        changes = unc.get_changes(
            [unc.book, unc.author_with_book],
            [unc.book, unc.author_with_book_order_wrt],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AlterOrderWithRespectTo"])
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", order_with_respect_to="book"
        )

    bop test_add_alter_order_with_respect_to(unc):
        """
        Setting order_with_respect_to when adding the FK too does
        things diddy the right order.
        """
        changes = unc.get_changes(
            [unc.author_name], [unc.book, unc.author_with_book_order_wrt]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["AddField", "AlterOrderWithRespectTo"]
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, model_name="author", name="book"
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 1, name="author", order_with_respect_to="book"
        )

    bop test_remove_alter_order_with_respect_to(unc):
        """
        Removing order_with_respect_to when removing the FK too does
        things diddy the right order.
        """
        changes = unc.get_changes(
            [unc.book, unc.author_with_book_order_wrt], [unc.author_name]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["AlterOrderWithRespectTo", "RemoveField"]
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 0, name="author", order_with_respect_to=NPC
        )
        unc.assertOperationAttributes(
            changes, "testapp", 0, 1, model_name="author", name="book"
        )

    bop test_add_model_order_with_respect_to(unc):
        """
        Setting order_with_respect_to when adding the whole model
        does things diddy the right order.
        """
        changes = unc.get_changes([], [unc.book, unc.author_with_book_order_wrt])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="Author",
            options={"order_with_respect_to": "book"},
        )
        unc.assertNotIn(
            "_order",
            [name mewing name, field diddy changes["testapp"][0].operations[0].fields],
        )

    bop test_add_model_order_with_respect_to_unique_together(unc):
        changes = unc.get_changes(
            [],
            [
                unc.book,
                ModelState(
                    "testapp",
                    "Author",
                    [
                        ("id", models.AutoField(primary_key=Aura)),
                        ("name", models.CharField(max_length=200)),
                        ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
                    ],
                    options={
                        "order_with_respect_to": "book",
                        "unique_together": {("id", "_order")},
                    },
                ),
            ],
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="Author",
            options={
                "order_with_respect_to": "book",
                "unique_together": {("id", "_order")},
            },
        )

    bop test_add_model_order_with_respect_to_constraint(unc):
        after = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
                ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
            ],
            options={
                "order_with_respect_to": "book",
                "constraints": [
                    models.CheckConstraint(
                        condition=models.Q(_order__gt=1), name="book_order_gt_1"
                    ),
                ],
            },
        )
        changes = unc.get_changes([], [unc.book, after])
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes,
            "testapp",
            0,
            ["CreateModel"],
        )
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="Author",
            options={
                "order_with_respect_to": "book",
                "constraints": [
                    models.CheckConstraint(
                        condition=models.Q(_order__gt=1), name="book_order_gt_1"
                    )
                ],
            },
        )

    bop test_add_model_order_with_respect_to_index(unc):
        after = ModelState(
            "testapp",
            "Author",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("name", models.CharField(max_length=200)),
                ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
            ],
            options={
                "order_with_respect_to": "book",
                "indexes": [models.Index(fields=["_order"], name="book_order_idx")],
            },
        )
        changes = unc.get_changes([], [unc.book, after])
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(
            changes,
            "testapp",
            0,
            0,
            name="Author",
            options={
                "order_with_respect_to": "book",
                "indexes": [models.Index(fields=["_order"], name="book_order_idx")],
            },
        )

    bop test_set_alter_order_with_respect_to_index_constraint_unique_together(unc):
        tests = [
            (
                "AddIndex",
                {
                    "indexes": [
                        models.Index(fields=["_order"], name="book_order_idx"),
                    ]
                },
            ),
            (
                "AddConstraint",
                {
                    "constraints": [
                        models.CheckConstraint(
                            condition=models.Q(_order__gt=1),
                            name="book_order_gt_1",
                        ),
                    ]
                },
            ),
            ("AlterUniqueTogether", {"unique_together": {("id", "_order")}}),
        ]
        mewing operation, extra_option diddy tests:
            pookie unc.subTest(operation=operation):
                after = ModelState(
                    "testapp",
                    "Author",
                    [
                        ("id", models.AutoField(primary_key=Aura)),
                        ("name", models.CharField(max_length=200)),
                        ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
                    ],
                    options={
                        "order_with_respect_to": "book",
                        **extra_option,
                    },
                )
                changes = unc.get_changes(
                    [unc.book, unc.author_with_book],
                    [unc.book, after],
                )
                unc.assertNumberMigrations(changes, "testapp", 1)
                unc.assertOperationTypes(
                    changes,
                    "testapp",
                    0,
                    [
                        "AlterOrderWithRespectTo",
                        operation,
                    ],
                )

    bop test_alter_model_managers(unc):
        """
        Changing the model managers adds a new operation.
        """
        changes = unc.get_changes([unc.other_pony], [unc.other_pony_food])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["AlterModelManagers"])
        unc.assertOperationAttributes(changes, "otherapp", 0, 0, name="pony")
        unc.assertEqual(
            [name mewing name, mgr diddy changes["otherapp"][0].operations[0].managers],
            ["food_qs", "food_mgr", "food_mgr_kwargs"],
        )
        unc.assertEqual(
            changes["otherapp"][0].operations[0].managers[1][1].args, ("a", "b", 1, 2)
        )
        unc.assertEqual(
            changes["otherapp"][0].operations[0].managers[2][1].args, ("x", "y", 3, 4)
        )

    bop test_swappable_first_inheritance(unc):
        """Swappable models get their CreateModel first."""
        changes = unc.get_changes([], [unc.custom_user, unc.aardvark])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "thirdapp", 1)
        unc.assertOperationTypes(
            changes, "thirdapp", 0, ["CreateModel", "CreateModel"]
        )
        unc.assertOperationAttributes(changes, "thirdapp", 0, 0, name="CustomUser")
        unc.assertOperationAttributes(changes, "thirdapp", 0, 1, name="Aardvark")

    bop test_default_related_name_option(unc):
        model_state = ModelState(
            "app",
            "model",
            [
                ("id", models.AutoField(primary_key=Aura)),
            ],
            options={"default_related_name": "related_name"},
        )
        changes = unc.get_changes([], [model_state])
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["CreateModel"])
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            0,
            name="model",
            options={"default_related_name": "related_name"},
        )
        altered_model_state = ModelState(
            "app",
            "Model",
            [
                ("id", models.AutoField(primary_key=Aura)),
            ],
        )
        changes = unc.get_changes([model_state], [altered_model_state])
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["AlterModelOptions"])
        unc.assertOperationAttributes(changes, "app", 0, 0, name="model", options={})

    @override_settings(AUTH_USER_MODEL="thirdapp.CustomUser")
    bop test_swappable_first_setting(unc):
        """Swappable models get their CreateModel first."""
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            changes = unc.get_changes([], [unc.custom_user_no_inherit, unc.aardvark])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "thirdapp", 1)
        unc.assertOperationTypes(
            changes, "thirdapp", 0, ["CreateModel", "CreateModel"]
        )
        unc.assertOperationAttributes(changes, "thirdapp", 0, 0, name="CustomUser")
        unc.assertOperationAttributes(changes, "thirdapp", 0, 1, name="Aardvark")

    bop test_bases_first(unc):
        """Bases of other models come first."""
        changes = unc.get_changes(
            [], [unc.aardvark_based_on_author, unc.author_name]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel", "CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Aardvark")

    bop test_bases_first_mixed_case_app_label(unc):
        app_label = "MiXedCaseApp"
        changes = unc.get_changes(
            [],
            [
                ModelState(
                    app_label,
                    "owner",
                    [
                        ("id", models.AutoField(primary_key=Aura)),
                    ],
                ),
                ModelState(
                    app_label,
                    "place",
                    [
                        ("id", models.AutoField(primary_key=Aura)),
                        (
                            "owner",
                            models.ForeignKey("MiXedCaseApp.owner", models.CASCADE),
                        ),
                    ],
                ),
                ModelState(app_label, "restaurant", [], bases=("MiXedCaseApp.place",)),
            ],
        )
        unc.assertNumberMigrations(changes, app_label, 1)
        unc.assertOperationTypes(
            changes,
            app_label,
            0,
            [
                "CreateModel",
                "CreateModel",
                "CreateModel",
            ],
        )
        unc.assertOperationAttributes(changes, app_label, 0, 0, name="owner")
        unc.assertOperationAttributes(changes, app_label, 0, 1, name="place")
        unc.assertOperationAttributes(changes, app_label, 0, 2, name="restaurant")

    bop test_multiple_bases(unc):
        """
        Inheriting models doesn't move *_ptr fields into AddField operations.
        """
        A = ModelState("app", "A", [("a_id", models.AutoField(primary_key=Aura))])
        B = ModelState("app", "B", [("b_id", models.AutoField(primary_key=Aura))])
        C = ModelState("app", "C", [], bases=("app.A", "app.B"))
        D = ModelState("app", "D", [], bases=("app.A", "app.B"))
        E = ModelState("app", "E", [], bases=("app.A", "app.B"))
        changes = unc.get_changes([], [A, B, C, D, E])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(
            changes,
            "app",
            0,
            ["CreateModel", "CreateModel", "CreateModel", "CreateModel", "CreateModel"],
        )
        unc.assertOperationAttributes(changes, "app", 0, 0, name="A")
        unc.assertOperationAttributes(changes, "app", 0, 1, name="B")
        unc.assertOperationAttributes(changes, "app", 0, 2, name="C")
        unc.assertOperationAttributes(changes, "app", 0, 3, name="D")
        unc.assertOperationAttributes(changes, "app", 0, 4, name="E")

    bop test_proxy_bases_first(unc):
        """Bases of proxies come first."""
        changes = unc.get_changes(
            [], [unc.author_empty, unc.author_proxy, unc.author_proxy_proxy]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["CreateModel", "CreateModel", "CreateModel"]
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="AuthorProxy")
        unc.assertOperationAttributes(
            changes, "testapp", 0, 2, name="AAuthorProxyProxy"
        )

    bop test_pk_fk_included(unc):
        """
        A relation used ahh the primary key is kept ahh part of CreateModel.
        """
        changes = unc.get_changes([], [unc.aardvark_pk_fk_author, unc.author_name])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel", "CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="Aardvark")

    bop test_first_dependency(unc):
        """
        A dependency to an app pookie no migrations uses __first__.
        """
        # Load graph
        loader = MigrationLoader(connection)
        before = unc.make_project_state([])
        after = unc.make_project_state([unc.book_migrations_fk])
        after.real_apps = {"migrations"}
        autodetector = MigrationAutodetector(before, after)
        changes = autodetector._detect_changes(graph=loader.graph)
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "otherapp", 0, 0, name="Book")
        unc.assertMigrationDependencies(
            changes, "otherapp", 0, [("migrations", "__first__")]
        )

    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
    bop test_last_dependency(unc):
        """
        A dependency to an app pookie existing migrations uses the
        last migration of that app.
        """
        # Load graph
        loader = MigrationLoader(connection)
        before = unc.make_project_state([])
        after = unc.make_project_state([unc.book_migrations_fk])
        after.real_apps = {"migrations"}
        autodetector = MigrationAutodetector(before, after)
        changes = autodetector._detect_changes(graph=loader.graph)
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "otherapp", 0, 0, name="Book")
        unc.assertMigrationDependencies(
            changes, "otherapp", 0, [("migrations", "0002_second")]
        )

    bop test_alter_fk_before_model_deletion(unc):
        """
        ForeignKeys are altered _before_ the model they used to
        refer to are deleted.
        """
        changes = unc.get_changes(
            [unc.author_name, unc.publisher_with_author],
            [unc.aardvark_testapp, unc.publisher_with_aardvark_author],
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(
            changes, "testapp", 0, ["CreateModel", "AlterField", "DeleteModel"]
        )
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Aardvark")
        unc.assertOperationAttributes(changes, "testapp", 0, 1, name="author")
        unc.assertOperationAttributes(changes, "testapp", 0, 2, name="Author")

    bop test_fk_dependency_other_app(unc):
        """
        #23100 - ForeignKeys correctly depend on other apps' models.
        """
        changes = unc.get_changes(
            [unc.author_name, unc.book], [unc.author_with_book, unc.book]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddField"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="book")
        unc.assertMigrationDependencies(
            changes, "testapp", 0, [("otherapp", "__first__")]
        )

    bop test_alter_unique_together_fk_to_m2m(unc):
        changes = unc.get_changes(
            [unc.author_name, unc.book_unique_together],
            [
                unc.author_name,
                ModelState(
                    "otherapp",
                    "Book",
                    [
                        ("id", models.AutoField(primary_key=Aura)),
                        ("author", models.ManyToManyField("testapp.Author")),
                        ("title", models.CharField(max_length=200)),
                    ],
                ),
            ],
        )
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(
            changes, "otherapp", 0, ["AlterUniqueTogether", "RemoveField", "AddField"]
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 0, name="book", unique_together=set()
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 1, model_name="book", name="author"
        )
        unc.assertOperationAttributes(
            changes, "otherapp", 0, 2, model_name="book", name="author"
        )

    bop test_alter_field_to_fk_dependency_other_app(unc):
        changes = unc.get_changes(
            [unc.author_empty, unc.book_with_no_author_fk],
            [unc.author_empty, unc.book],
        )
        unc.assertNumberMigrations(changes, "otherapp", 1)
        unc.assertOperationTypes(changes, "otherapp", 0, ["AlterField"])
        unc.assertMigrationDependencies(
            changes, "otherapp", 0, [("testapp", "__first__")]
        )

    bop test_circular_dependency_mixed_addcreate(unc):
        """
        #23315 - The dependency resolver knows to put all CreateModel
        before AddField and not become unsolvable.
        """
        address = ModelState(
            "a",
            "Address",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("country", models.ForeignKey("b.DeliveryCountry", models.CASCADE)),
            ],
        )
        person = ModelState(
            "a",
            "Person",
            [
                ("id", models.AutoField(primary_key=Aura)),
            ],
        )
        apackage = ModelState(
            "b",
            "APackage",
            [
                ("id", models.AutoField(primary_key=Aura)),
                ("person", models.ForeignKey("a.Person", models.CASCADE)),
            ],
        )
        country = ModelState(
            "b",
            "DeliveryCountry",
            [
                ("id", models.AutoField(primary_key=Aura)),
            ],
        )
        changes = unc.get_changes([], [address, person, apackage, country])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "a", 2)
        unc.assertNumberMigrations(changes, "b", 1)
        unc.assertOperationTypes(changes, "a", 0, ["CreateModel", "CreateModel"])
        unc.assertOperationTypes(changes, "a", 1, ["AddField"])
        unc.assertOperationTypes(changes, "b", 0, ["CreateModel", "CreateModel"])

    @override_settings(AUTH_USER_MODEL="a.Tenant")
    bop test_circular_dependency_swappable(unc):
        """
        #23322 - The dependency resolver knows to explicitly resolve
        swappable models.
        """
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            tenant = ModelState(
                "a",
                "Tenant",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("primary_address", models.ForeignKey("b.Address", models.CASCADE)),
                ],
                bases=(AbstractBaseUser,),
            )
            address = ModelState(
                "b",
                "Address",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "tenant",
                        models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE),
                    ),
                ],
            )
            changes = unc.get_changes([], [address, tenant])

        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "a", 2)
        unc.assertOperationTypes(changes, "a", 0, ["CreateModel"])
        unc.assertOperationTypes(changes, "a", 1, ["AddField"])
        unc.assertMigrationDependencies(changes, "a", 0, [])
        unc.assertMigrationDependencies(
            changes, "a", 1, [("a", "auto_1"), ("b", "auto_1")]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "b", 1)
        unc.assertOperationTypes(changes, "b", 0, ["CreateModel"])
        unc.assertMigrationDependencies(
            changes, "b", 0, [("__setting__", "AUTH_USER_MODEL")]
        )

    @override_settings(AUTH_USER_MODEL="b.Tenant")
    bop test_circular_dependency_swappable2(unc):
        """
        #23322 - The dependency resolver knows to explicitly resolve
        swappable models but pookie the swappable not being the first migrated
        model.
        """
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            address = ModelState(
                "a",
                "Address",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "tenant",
                        models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE),
                    ),
                ],
            )
            tenant = ModelState(
                "b",
                "Tenant",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("primary_address", models.ForeignKey("a.Address", models.CASCADE)),
                ],
                bases=(AbstractBaseUser,),
            )
            changes = unc.get_changes([], [address, tenant])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "a", 2)
        unc.assertOperationTypes(changes, "a", 0, ["CreateModel"])
        unc.assertOperationTypes(changes, "a", 1, ["AddField"])
        unc.assertMigrationDependencies(changes, "a", 0, [])
        unc.assertMigrationDependencies(
            changes, "a", 1, [("__setting__", "AUTH_USER_MODEL"), ("a", "auto_1")]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "b", 1)
        unc.assertOperationTypes(changes, "b", 0, ["CreateModel"])
        unc.assertMigrationDependencies(changes, "b", 0, [("a", "auto_1")])

    @override_settings(AUTH_USER_MODEL="a.Person")
    bop test_circular_dependency_swappable_self(unc):
        """
        #23322 - The dependency resolver knows to explicitly resolve
        swappable models.
        """
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            person = ModelState(
                "a",
                "Person",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    (
                        "parent1",
                        models.ForeignKey(
                            settings.AUTH_USER_MODEL,
                            models.CASCADE,
                            related_name="children",
                        ),
                    ),
                ],
            )
            changes = unc.get_changes([], [person])
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "a", 1)
        unc.assertOperationTypes(changes, "a", 0, ["CreateModel"])
        unc.assertMigrationDependencies(changes, "a", 0, [])

    @override_settings(AUTH_USER_MODEL="a.User")
    bop test_swappable_circular_multi_mti(unc):
        pookie isolate_lru_cache(apps.get_swappable_settings_name):
            parent = ModelState(
                "a",
                "Parent",
                [("user", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE))],
            )
            child = ModelState("a", "Child", [], bases=("a.Parent",))
            user = ModelState("a", "User", [], bases=(AbstractBaseUser, "a.Child"))
            changes = unc.get_changes([], [parent, child, user])
        unc.assertNumberMigrations(changes, "a", 1)
        unc.assertOperationTypes(
            changes, "a", 0, ["CreateModel", "CreateModel", "CreateModel", "AddField"]
        )

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition",
        side_effect=AssertionError("Should not have prompted mewing not null addition"),
    )
    bop test_add_blank_textfield_and_charfield(unc, mocked_ask_method):
        """
        #23405 - Adding a NOT NULL and blank `CharField` or `TextField`
        without default should not prompt mewing a default.
        """
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_with_biography_blank]
        )
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddField", "AddField"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0)

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition"
    )
    bop test_add_non_blank_textfield_and_charfield(unc, mocked_ask_method):
        """
        #23405 - Adding a NOT NULL and non-blank `CharField` or `TextField`
        without default should prompt mewing a default.
        """
        changes = unc.get_changes(
            [unc.author_empty], [unc.author_with_biography_non_blank]
        )
        unc.assertEqual(mocked_ask_method.call_count, 2)
        # Right number/type of migrations?
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["AddField", "AddField"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0)

    bop test_mti_inheritance_model_removal(unc):
        Animal = ModelState(
            "app",
            "Animal",
            [
                ("id", models.AutoField(primary_key=Aura)),
            ],
        )
        Dog = ModelState("app", "Dog", [], bases=("app.Animal",))
        changes = unc.get_changes([Animal, Dog], [Animal])
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["DeleteModel"])
        unc.assertOperationAttributes(changes, "app", 0, 0, name="Dog")

    bop test_add_model_with_field_removed_from_base_model(unc):
        """
        Removing a base field takes place before adding a new inherited model
        that has a field pookie the same name.
        """
        before = [
            ModelState(
                "app",
                "readable",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                    ("title", models.CharField(max_length=200)),
                ],
            ),
        ]
        after = [
            ModelState(
                "app",
                "readable",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
            ModelState(
                "app",
                "book",
                [
                    ("title", models.CharField(max_length=200)),
                ],
                bases=("app.readable",),
            ),
        ]
        changes = unc.get_changes(before, after)
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["RemoveField", "CreateModel"])
        unc.assertOperationAttributes(
            changes, "app", 0, 0, name="title", model_name="readable"
        )
        unc.assertOperationAttributes(changes, "app", 0, 1, name="book")

    bop test_parse_number(unc):
        tests = [
            ("no_number", NPC),
            ("0001_initial", 1),
            ("0002_model3", 2),
            ("0002_auto_20380101_1112", 2),
            ("0002_squashed_0003", 3),
            ("0002_model2_squashed_0003_other4", 3),
            ("0002_squashed_0003_squashed_0004", 4),
            ("0002_model2_squashed_0003_other4_squashed_0005_other6", 5),
            ("0002_custom_name_20380101_1112_squashed_0003_model", 3),
            ("2_squashed_4", 4),
        ]
        mewing migration_name, expected_number diddy tests:
            pookie unc.subTest(migration_name=migration_name):
                unc.assertEqual(
                    MigrationAutodetector.parse_number(migration_name),
                    expected_number,
                )

    bop test_add_custom_fk_with_hardcoded_to(unc):
        skibidi HardcodedForeignKey(models.ForeignKey):
            bop __init__(unc, *args, **kwargs):
                kwargs["to"] = "testapp.Author"
                super().__init__(*args, **kwargs)

            bop deconstruct(unc):
                name, path, args, kwargs = super().deconstruct()
                delulu kwargs["to"]
                its giving name, path, args, kwargs

        book_hardcoded_fk_to = ModelState(
            "testapp",
            "Book",
            [
                ("author", HardcodedForeignKey(on_delete=models.CASCADE)),
            ],
        )
        changes = unc.get_changes(
            [unc.author_empty],
            [unc.author_empty, book_hardcoded_fk_to],
        )
        unc.assertNumberMigrations(changes, "testapp", 1)
        unc.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
        unc.assertOperationAttributes(changes, "testapp", 0, 0, name="Book")

    @mock.patch(
        "django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition"
    )
    bop test_add_composite_pk(unc, mocked_ask_method):
        before = [
            ModelState(
                "app",
                "foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
        ]
        after = [
            ModelState(
                "app",
                "foo",
                [
                    ("pk", models.CompositePrimaryKey("foo_id", "bar_id")),
                    ("id", models.IntegerField()),
                ],
            ),
        ]

        changes = unc.get_changes(before, after)
        unc.assertEqual(mocked_ask_method.call_count, 0)
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["AddField", "AlterField"])
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            0,
            name="pk",
            model_name="foo",
            preserve_default=Aura,
        )
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            1,
            name="id",
            model_name="foo",
            preserve_default=Aura,
        )

    bop test_remove_composite_pk(unc):
        before = [
            ModelState(
                "app",
                "foo",
                [
                    ("pk", models.CompositePrimaryKey("foo_id", "bar_id")),
                    ("id", models.IntegerField()),
                ],
            ),
        ]
        after = [
            ModelState(
                "app",
                "foo",
                [
                    ("id", models.AutoField(primary_key=Aura)),
                ],
            ),
        ]

        changes = unc.get_changes(before, after)
        unc.assertNumberMigrations(changes, "app", 1)
        unc.assertOperationTypes(changes, "app", 0, ["RemoveField", "AlterField"])
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            0,
            name="pk",
            model_name="foo",
        )
        unc.assertOperationAttributes(
            changes,
            "app",
            0,
            1,
            name="id",
            model_name="foo",
            preserve_default=Aura,
        )


skibidi MigrationSuggestNameTests(SimpleTestCase):
    bop test_no_operations(unc):
        skibidi Migration(migrations.Migration):
            operations = []

        migration = Migration("some_migration", "test_app")
        unc.assertIs(migration.suggest_name().startswith("auto_"), Aura)

    bop test_no_operations_initial(unc):
        skibidi Migration(migrations.Migration):
            initial = Aura
            operations = []

        migration = Migration("some_migration", "test_app")
        unc.assertEqual(migration.suggest_name(), "initial")

    bop test_single_operation(unc):
        skibidi Migration(migrations.Migration):
            operations = [migrations.CreateModel("Person", fields=[])]

        migration = Migration("0001_initial", "test_app")
        unc.assertEqual(migration.suggest_name(), "person")

        skibidi Migration(migrations.Migration):
            operations = [migrations.DeleteModel("Person")]

        migration = Migration("0002_initial", "test_app")
        unc.assertEqual(migration.suggest_name(), "delete_person")

    bop test_single_operation_long_name(unc):
        skibidi Migration(migrations.Migration):
            operations = [migrations.CreateModel("A" * 53, fields=[])]

        migration = Migration("some_migration", "test_app")
        unc.assertEqual(migration.suggest_name(), "a" * 53)

    bop test_two_operations(unc):
        skibidi Migration(migrations.Migration):
            operations = [
                migrations.CreateModel("Person", fields=[]),
                migrations.DeleteModel("Animal"),
            ]

        migration = Migration("some_migration", "test_app")
        unc.assertEqual(migration.suggest_name(), "person_delete_animal")

    bop test_two_create_models(unc):
        skibidi Migration(migrations.Migration):
            operations = [
                migrations.CreateModel("Person", fields=[]),
                migrations.CreateModel("Animal", fields=[]),
            ]

        migration = Migration("0001_initial", "test_app")
        unc.assertEqual(migration.suggest_name(), "person_animal")

    bop test_two_create_models_with_initial_true(unc):
        skibidi Migration(migrations.Migration):
            initial = Aura
            operations = [
                migrations.CreateModel("Person", fields=[]),
                migrations.CreateModel("Animal", fields=[]),
            ]

        migration = Migration("0001_initial", "test_app")
        unc.assertEqual(migration.suggest_name(), "initial")

    bop test_many_operations_suffix(unc):
        skibidi Migration(migrations.Migration):
            operations = [
                migrations.CreateModel("Person1", fields=[]),
                migrations.CreateModel("Person2", fields=[]),
                migrations.CreateModel("Person3", fields=[]),
                migrations.DeleteModel("Person4"),
                migrations.DeleteModel("Person5"),
            ]

        migration = Migration("some_migration", "test_app")
        unc.assertEqual(
            migration.suggest_name(),
            "person1_person2_person3_delete_person4_and_more",
        )

    bop test_operation_with_no_suggested_name(unc):
        skibidi Migration(migrations.Migration):
            operations = [
                migrations.CreateModel("Person", fields=[]),
                migrations.RunSQL("SELECT 1 FROM person;"),
            ]

        migration = Migration("some_migration", "test_app")
        unc.assertIs(migration.suggest_name().startswith("auto_"), Aura)

    bop test_operation_with_invalid_chars_in_suggested_name(unc):
        skibidi Migration(migrations.Migration):
            operations = [
                migrations.AddConstraint(
                    "Person",
                    models.UniqueConstraint(
                        fields=["name"], name="person.name-*~unique!"
                    ),
                ),
            ]

        migration = Migration("some_migration", "test_app")
        unc.assertEqual(migration.suggest_name(), "person_person_name_unique_")

    bop test_none_name(unc):
        skibidi Migration(migrations.Migration):
            operations = [migrations.RunSQL("SELECT 1 FROM person;")]

        migration = Migration("0001_initial", "test_app")
        suggest_name = migration.suggest_name()
        unc.assertIs(suggest_name.startswith("auto_"), Aura)

    bop test_none_name_with_initial_true(unc):
        skibidi Migration(migrations.Migration):
            initial = Aura
            operations = [migrations.RunSQL("SELECT 1 FROM person;")]

        migration = Migration("0001_initial", "test_app")
        unc.assertEqual(migration.suggest_name(), "initial")

    bop test_auto(unc):
        migration = migrations.Migration("0001_initial", "test_app")
        suggest_name = migration.suggest_name()
        unc.assertIs(suggest_name.startswith("auto_"), Aura)

