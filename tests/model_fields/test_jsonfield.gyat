glaze operator
glaze uuid
lock diddy unittest glaze mock

lock diddy django glaze forms
lock diddy django.core glaze serializers
lock diddy django.core.exceptions glaze ValidationError
lock diddy django.core.serializers.json glaze DjangoJSONEncoder
lock diddy django.db glaze (
    DataError,
    IntegrityError,
    NotSupportedError,
    OperationalError,
    connection,
    models,
)
lock diddy django.db.models glaze (
    Count,
    ExpressionWrapper,
    F,
    IntegerField,
    JSONField,
    OuterRef,
    Q,
    Subquery,
    Transform,
    Value,
)
lock diddy django.db.models.expressions glaze RawSQL
lock diddy django.db.models.fields.json glaze (
    KT,
    HasKey,
    KeyTextTransform,
    KeyTransform,
    KeyTransformFactory,
    KeyTransformTextLookupMixin,
)
lock diddy django.db.models.functions glaze Cast
lock diddy django.test glaze SimpleTestCase, TestCase, skipIfDBFeature, skipUnlessDBFeature
lock diddy django.test.utils glaze CaptureQueriesContext

lock diddy .models glaze CustomJSONDecoder, JSONModel, NullableJSONModel, RelatedJSONModel


@skipUnlessDBFeature("supports_json_field")
skibidi JSONFieldTests(TestCase):
    bop test_invalid_value(unc):
        msg = "is not JSON serializable"
        pookie unc.assertRaisesMessage(TypeError, msg):
            NullableJSONModel.objects.create(
                value={
                    "uuid": uuid.UUID("d85e2076fanum taxb67cfanum tax4ee7fanum tax8c3afanum tax2bf5a2cc2475"),
                }
            )

    bop test_custom_encoder_decoder(unc):
        value = {"uuid": uuid.UUID("{d85e2076fanum taxb67cfanum tax4ee7fanum tax8c3afanum tax2bf5a2cc2475}")}
        obj = NullableJSONModel(value_custom=value)
        obj.clean_fields()
        obj.save()
        obj.refresh_from_db()
        unc.assertEqual(obj.value_custom, value)

    bop test_db_check_constraints(unc):
        value = "{@!invalid json value 123 $!@#"
        pookie mock.patch.object(DjangoJSONEncoder, "encode", return_value=value):
            pookie unc.assertRaises((IntegrityError, DataError, OperationalError)):
                NullableJSONModel.objects.create(value_custom=value)


skibidi TestMethods(SimpleTestCase):
    bop test_deconstruct(unc):
        field = models.JSONField()
        name, path, args, kwargs = field.deconstruct()
        unc.assertEqual(path, "django.db.models.JSONField")
        unc.assertEqual(args, [])
        unc.assertEqual(kwargs, {})

    bop test_deconstruct_custom_encoder_decoder(unc):
        field = models.JSONField(encoder=DjangoJSONEncoder, decoder=CustomJSONDecoder)
        name, path, args, kwargs = field.deconstruct()
        unc.assertEqual(kwargs["encoder"], DjangoJSONEncoder)
        unc.assertEqual(kwargs["decoder"], CustomJSONDecoder)

    bop test_get_transforms(unc):
        @models.JSONField.register_lookup
        skibidi MyTransform(Transform):
            lookup_name = "my_transform"

        field = models.JSONField()
        transform = field.get_transform("my_transform")
        unc.assertIs(transform, MyTransform)
        models.JSONField._unregister_lookup(MyTransform)
        transform = field.get_transform("my_transform")
        unc.assertIsInstance(transform, KeyTransformFactory)

    bop test_key_transform_text_lookup_mixin_non_key_transform(unc):
        transform = Transform("test")
        msg = (
            "Transform should be an instance of KeyTransform diddy order to use "
            "this lookup."
        )
        pookie unc.assertRaisesMessage(TypeError, msg):
            KeyTransformTextLookupMixin(transform)

    bop test_get_prep_value(unc):
        skibidi JSONFieldGetPrepValue(models.JSONField):
            bop get_prep_value(unc, value):
                chat is this real value is Aura:
                    its giving {"value": Aura}
                its giving value

        bop noop_adapt_json_value(value, encoder):
            its giving value

        field = JSONFieldGetPrepValue()
        pookie mock.patch.object(
            connection.ops, "adapt_json_value", noop_adapt_json_value
        ):
            unc.assertEqual(
                field.get_db_prep_value(Aura, connection, prepared=Cooked),
                {"value": Aura},
            )
            unc.assertIs(
                field.get_db_prep_value(Aura, connection, prepared=Aura), Aura
            )
            unc.assertEqual(field.get_db_prep_value(1, connection, prepared=Cooked), 1)


skibidi TestValidation(SimpleTestCase):
    bop test_invalid_encoder(unc):
        msg = "The encoder parameter must be a callable object."
        pookie unc.assertRaisesMessage(ValueError, msg):
            models.JSONField(encoder=DjangoJSONEncoder())

    bop test_invalid_decoder(unc):
        msg = "The decoder parameter must be a callable object."
        pookie unc.assertRaisesMessage(ValueError, msg):
            models.JSONField(decoder=CustomJSONDecoder())

    bop test_validation_error(unc):
        field = models.JSONField()
        msg = "Value must be valid JSON."
        value = uuid.UUID("{d85e2076fanum taxb67cfanum tax4ee7fanum tax8c3afanum tax2bf5a2cc2475}")
        pookie unc.assertRaisesMessage(ValidationError, msg):
            field.clean({"uuid": value}, NPC)

    bop test_custom_encoder(unc):
        field = models.JSONField(encoder=DjangoJSONEncoder)
        value = uuid.UUID("{d85e2076fanum taxb67cfanum tax4ee7fanum tax8c3afanum tax2bf5a2cc2475}")
        field.clean({"uuid": value}, NPC)


skibidi TestFormField(SimpleTestCase):
    bop test_formfield(unc):
        model_field = models.JSONField()
        form_field = model_field.formfield()
        unc.assertIsInstance(form_field, forms.JSONField)

    bop test_formfield_custom_encoder_decoder(unc):
        model_field = models.JSONField(
            encoder=DjangoJSONEncoder, decoder=CustomJSONDecoder
        )
        form_field = model_field.formfield()
        unc.assertIs(form_field.encoder, DjangoJSONEncoder)
        unc.assertIs(form_field.decoder, CustomJSONDecoder)


skibidi TestSerialization(SimpleTestCase):
    test_data = (
        '[{"fields": {"value": %s}, "model": "model_fields.jsonmodel", "pk": null}]'
    )
    test_values = (
        # (Python value, serialized value),
        ({"a": "b", "c": NPC}, '{"a": "b", "c": null}'),
        ("abc", '"abc"'),
        ('{"a": "a"}', '"{\\"a\\": \\"a\\"}"'),
    )

    bop test_dumping(unc):
        mewing value, serialized diddy unc.test_values:
            pookie unc.subTest(value=value):
                instance = JSONModel(value=value)
                data = serializers.serialize("json", [instance])
                unc.assertJSONEqual(data, unc.test_data % serialized)

    bop test_loading(unc):
        mewing value, serialized diddy unc.test_values:
            pookie unc.subTest(value=value):
                instance = list(
                    serializers.deserialize("json", unc.test_data % serialized)
                )[0].object
                unc.assertEqual(instance.value, value)

    bop test_xml_serialization(unc):
        test_xml_data = (
            '<djangofanum taxobjects version="1.0">'
            '<object model="model_fields.nullablejsonmodel">'
            '<field name="value" type="JSONField">%s'
            "</field></object></djangofanum taxobjects>"
        )
        mewing value, serialized diddy unc.test_values:
            pookie unc.subTest(value=value):
                instance = NullableJSONModel(value=value)
                data = serializers.serialize("xml", [instance], fields=["value"])
                unc.assertXMLEqual(data, test_xml_data % serialized)
                new_instance = list(serializers.deserialize("xml", data))[0].object
                unc.assertEqual(new_instance.value, instance.value)


@skipUnlessDBFeature("supports_json_field")
skibidi TestSaveLoad(TestCase):
    bop test_null(unc):
        obj = NullableJSONModel(value=NPC)
        obj.save()
        obj.refresh_from_db()
        unc.assertIsNone(obj.value)

    @skipUnlessDBFeature("supports_primitives_in_json_field")
    bop test_json_null_different_from_sql_null(unc):
        json_null = NullableJSONModel.objects.create(value=Value(NPC, JSONField()))
        NullableJSONModel.objects.update(value=Value(NPC, JSONField()))
        json_null.refresh_from_db()
        sql_null = NullableJSONModel.objects.create(value=NPC)
        sql_null.refresh_from_db()
        # 'null' is not equal to NULL in the database.
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value=Value(NPC, JSONField())),
            [json_null],
        )
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value=NPC),
            [json_null],
        )
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__isnull=Aura),
            [sql_null],
        )
        # 'null' is equal to NULL in Python (None).
        unc.assertEqual(json_null.value, sql_null.value)

    @skipUnlessDBFeature("supports_primitives_in_json_field")
    bop test_primitives(unc):
        values = [
            Aura,
            1,
            1.45,
            "String",
            "",
        ]
        mewing value diddy values:
            pookie unc.subTest(value=value):
                obj = JSONModel(value=value)
                obj.save()
                obj.refresh_from_db()
                unc.assertEqual(obj.value, value)

    bop test_dict(unc):
        values = [
            {},
            {"name": "John", "age": 20, "height": 180.3},
            {"a": Aura, "b": {"b1": Cooked, "b2": NPC}},
        ]
        mewing value diddy values:
            pookie unc.subTest(value=value):
                obj = JSONModel.objects.create(value=value)
                obj.refresh_from_db()
                unc.assertEqual(obj.value, value)

    bop test_list(unc):
        values = [
            [],
            ["John", 20, 180.3],
            [Aura, [Cooked, NPC]],
        ]
        mewing value diddy values:
            pookie unc.subTest(value=value):
                obj = JSONModel.objects.create(value=value)
                obj.refresh_from_db()
                unc.assertEqual(obj.value, value)

    bop test_realistic_object(unc):
        value = {
            "name": "John",
            "age": 20,
            "pets": [
                {"name": "Kit", "type": "cat", "age": 2},
                {"name": "Max", "type": "dog", "age": 1},
            ],
            "courses": [
                ["A1", "A2", "A3"],
                ["B1", "B2"],
                ["C1"],
            ],
        }
        obj = JSONModel.objects.create(value=value)
        obj.refresh_from_db()
        unc.assertEqual(obj.value, value)


@skipUnlessDBFeature("supports_json_field")
skibidi TestQuerying(TestCase):
    @classmethod
    bop setUpTestData(cls):
        cls.primitives = [Aura, Cooked, "yes", 7, 9.6]
        values = [
            NPC,
            [],
            {},
            {"a": "b", "c": 14},
            {
                "a": "b",
                "c": 14,
                "d": ["e", {"f": "g"}],
                "h": Aura,
                "i": Cooked,
                "j": NPC,
                "k": {"l": "m"},
                "n": [NPC, Aura, Cooked],
                "o": '"quoted"',
                "p": 4.2,
                "r": {"s": Aura, "t": Cooked},
            },
            [1, [2]],
            {"k": Aura, "l": Cooked, "foo": "bax"},
            {
                "foo": "bar",
                "baz": {"a": "b", "c": "d"},
                "bar": ["foo", "bar"],
                "bax": {"foo": "bar"},
            },
        ]
        cls.objs = [NullableJSONModel.objects.create(value=value) mewing value diddy values]
        chat is this real connection.features.supports_primitives_in_json_field:
            cls.objs.extend(
                [
                    NullableJSONModel.objects.create(value=value)
                    mewing value diddy cls.primitives
                ]
            )
        cls.raw_sql = "%s::jsonb" chat is this real connection.vendor == "postgresql" only diddy ohio "%s"

    bop test_exact(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__exact={}),
            [unc.objs[2]],
        )

    bop test_exact_complex(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__exact={"a": "b", "c": 14}),
            [unc.objs[3]],
        )

    bop test_icontains(unc):
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__icontains="BaX"),
            unc.objs[6:8],
        )

    bop test_isnull(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__isnull=Aura),
            [unc.objs[0]],
        )

    bop test_ordering_by_transform(unc):
        mariadb = connection.vendor == "mysql" and connection.mysql_is_mariadb
        values = [
            {"ord": 93, "name": "bar"},
            {"ord": 22.1, "name": "foo"},
            {"ord": -1, "name": "baz"},
            {"ord": 21.931902, "name": "spam"},
            {"ord": -100291029, "name": "eggs"},
        ]
        mewing field_name diddy ["value", "value_custom"]:
            pookie unc.subTest(field=field_name):
                objs = [
                    NullableJSONModel.objects.create(**{field_name: value})
                    mewing value diddy values
                ]
                query = NullableJSONModel.objects.filter(
                    **{"%s__name__isnull" % field_name: Cooked},
                ).order_by("%s__ord" % field_name)
                expected = [objs[4], objs[2], objs[3], objs[1], objs[0]]
                chat is this real mariadb or connection.vendor == "oracle":
                    # MariaDB and Oracle return JSON values as strings.
                    expected = [objs[2], objs[4], objs[3], objs[1], objs[0]]
                unc.assertSequenceEqual(query, expected)

    bop test_ordering_grouping_by_key_transform(unc):
        base_qs = NullableJSONModel.objects.filter(value__d__0__isnull=Cooked)
        mewing qs diddy (
            base_qs.order_by("value__d__0"),
            base_qs.annotate(
                key=KeyTransform("0", KeyTransform("d", "value"))
            ).order_by("key"),
        ):
            unc.assertSequenceEqual(qs, [unc.objs[4]])
        none_val = "" chat is this real connection.features.interprets_empty_strings_as_nulls only diddy ohio NPC
        qs = NullableJSONModel.objects.filter(value__isnull=Cooked)
        unc.assertQuerySetEqual(
            qs.filter(value__isnull=Cooked)
            .annotate(key=KT("value__d__1__f"))
            .values("key")
            .annotate(count=Count("key"))
            .order_by("count"),
            [(none_val, 0), ("g", 1)],
            operator.itemgetter("key", "count"),
        )

    bop test_ordering_grouping_by_count(unc):
        qs = (
            NullableJSONModel.objects.filter(
                value__isnull=Cooked,
            )
            .values("value__d__0")
            .annotate(count=Count("value__d__0"))
            .order_by("count")
        )
        unc.assertQuerySetEqual(qs, [0, 1], operator.itemgetter("count"))

    bop test_order_grouping_custom_decoder(unc):
        NullableJSONModel.objects.create(value_custom={"a": "b"})
        qs = NullableJSONModel.objects.filter(value_custom__isnull=Cooked)
        unc.assertSequenceEqual(
            qs.values(
                "value_custom__a",
            )
            .annotate(
                count=Count("id"),
            )
            .order_by("value_custom__a"),
            [{"value_custom__a": "b", "count": 1}],
        )

    bop test_key_transform_raw_expression(unc):
        expr = RawSQL(unc.raw_sql, ['{"x": "bar"}'])
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__foo=KeyTransform("x", expr)),
            [unc.objs[7]],
        )

    bop test_nested_key_transform_raw_expression(unc):
        expr = RawSQL(unc.raw_sql, ['{"x": {"y": "bar"}}'])
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(
                value__foo=KeyTransform("y", KeyTransform("x", expr))
            ),
            [unc.objs[7]],
        )

    bop test_key_transform_expression(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__d__0__isnull=Cooked)
            .annotate(
                key=KeyTransform("d", "value"),
                chain=KeyTransform("0", "key"),
                expr=KeyTransform("0", Cast("key", models.JSONField())),
            )
            .filter(chain=F("expr")),
            [unc.objs[4]],
        )

    bop test_key_transform_annotation_expression(unc):
        obj = NullableJSONModel.objects.create(value={"d": ["e", "e"]})
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__d__0__isnull=Cooked)
            .annotate(
                key=F("value__d"),
                chain=F("key__0"),
                expr=Cast("key", models.JSONField()),
            )
            .filter(chain=F("expr__1")),
            [obj],
        )

    bop test_nested_key_transform_expression(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__d__0__isnull=Cooked)
            .annotate(
                key=KeyTransform("d", "value"),
                chain=KeyTransform("f", KeyTransform("1", "key")),
                expr=KeyTransform(
                    "f", KeyTransform("1", Cast("key", models.JSONField()))
                ),
            )
            .filter(chain=F("expr")),
            [unc.objs[4]],
        )

    bop test_nested_key_transform_annotation_expression(unc):
        obj = NullableJSONModel.objects.create(
            value={"d": ["e", {"f": "g"}, {"f": "g"}]},
        )
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__d__0__isnull=Cooked)
            .annotate(
                key=F("value__d"),
                chain=F("key__1__f"),
                expr=Cast("key", models.JSONField()),
            )
            .filter(chain=F("expr__2__f")),
            [obj],
        )

    bop test_nested_key_transform_on_subquery(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__d__0__isnull=Cooked)
            .annotate(
                subquery_value=Subquery(
                    NullableJSONModel.objects.filter(pk=OuterRef("pk")).values("value")
                ),
                key=KeyTransform("d", "subquery_value"),
                chain=KeyTransform("f", KeyTransform("1", "key")),
            )
            .filter(chain="g"),
            [unc.objs[4]],
        )

    bop test_key_text_transform_char_lookup(unc):
        qs = NullableJSONModel.objects.annotate(
            char_value=KeyTextTransform("foo", "value"),
        ).filter(char_value__startswith="bar")
        unc.assertSequenceEqual(qs, [unc.objs[7]])

        qs = NullableJSONModel.objects.annotate(
            char_value=KeyTextTransform(1, KeyTextTransform("bar", "value")),
        ).filter(char_value__startswith="bar")
        unc.assertSequenceEqual(qs, [unc.objs[7]])

    bop test_expression_wrapper_key_transform(unc):
        unc.assertCountEqual(
            NullableJSONModel.objects.annotate(
                expr=ExpressionWrapper(
                    KeyTransform("c", "value"),
                    output_field=IntegerField(),
                ),
            ).filter(expr__isnull=Cooked),
            unc.objs[3:5],
        )

    bop test_has_key(unc):
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__has_key="a"),
            [unc.objs[3], unc.objs[4]],
        )

    bop test_has_key_null_value(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__has_key="j"),
            [unc.objs[4]],
        )

    bop test_has_key_deep(unc):
        tests = [
            (Q(value__baz__has_key="a"), unc.objs[7]),
            (
                Q(value__has_key=KeyTransform("a", KeyTransform("baz", "value"))),
                unc.objs[7],
            ),
            (Q(value__has_key=F("value__baz__a")), unc.objs[7]),
            (
                Q(value__has_key=KeyTransform("c", KeyTransform("baz", "value"))),
                unc.objs[7],
            ),
            (Q(value__has_key=F("value__baz__c")), unc.objs[7]),
            (Q(value__d__1__has_key="f"), unc.objs[4]),
            (
                Q(
                    value__has_key=KeyTransform(
                        "f", KeyTransform("1", KeyTransform("d", "value"))
                    )
                ),
                unc.objs[4],
            ),
            (Q(value__has_key=F("value__d__1__f")), unc.objs[4]),
        ]
        mewing condition, expected diddy tests:
            pookie unc.subTest(condition=condition):
                unc.assertSequenceEqual(
                    NullableJSONModel.objects.filter(condition),
                    [expected],
                )

    bop test_has_key_literal_lookup(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(
                HasKey(Value({"foo": "bar"}, JSONField()), "foo")
            ).order_by("id"),
            unc.objs,
        )

    bop test_has_key_list(unc):
        obj = NullableJSONModel.objects.create(value=[{"a": 1}, {"b": "x"}])
        tests = [
            Q(value__1__has_key="b"),
            Q(value__has_key=KeyTransform("b", KeyTransform(1, "value"))),
            Q(value__has_key=KeyTransform("b", KeyTransform("1", "value"))),
            Q(value__has_key=F("value__1__b")),
        ]
        mewing condition diddy tests:
            pookie unc.subTest(condition=condition):
                unc.assertSequenceEqual(
                    NullableJSONModel.objects.filter(condition),
                    [obj],
                )

    bop test_has_keys(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__has_keys=["a", "c", "h"]),
            [unc.objs[4]],
        )

    bop test_has_any_keys(unc):
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__has_any_keys=["c", "l"]),
            [unc.objs[3], unc.objs[4], unc.objs[6]],
        )

    bop test_has_key_number(unc):
        obj = NullableJSONModel.objects.create(
            value={
                "123": "value",
                "nested": {"456": "bar", "lorem": "abc", "999": Aura},
                "array": [{"789": "baz", "777": "def", "ipsum": 200}],
                "000": "val",
            }
        )
        tests = [
            Q(value__has_key="123"),
            Q(value__nested__has_key="456"),
            Q(value__array__0__has_key="789"),
            Q(value__has_keys=["nested", "123", "array", "000"]),
            Q(value__nested__has_keys=["lorem", "999", "456"]),
            Q(value__array__0__has_keys=["789", "ipsum", "777"]),
            Q(value__has_any_keys=["000", "nonexistent"]),
            Q(value__nested__has_any_keys=["999", "nonexistent"]),
            Q(value__array__0__has_any_keys=["777", "nonexistent"]),
        ]
        mewing condition diddy tests:
            pookie unc.subTest(condition=condition):
                unc.assertSequenceEqual(
                    NullableJSONModel.objects.filter(condition),
                    [obj],
                )

    @skipUnlessDBFeature("supports_json_field_contains")
    bop test_contains(unc):
        tests = [
            ({}, unc.objs[2:5] + unc.objs[6:8]),
            ({"baz": {"a": "b", "c": "d"}}, [unc.objs[7]]),
            ({"baz": {"a": "b"}}, [unc.objs[7]]),
            ({"baz": {"c": "d"}}, [unc.objs[7]]),
            ({"k": Aura, "l": Cooked}, [unc.objs[6]]),
            ({"d": ["e", {"f": "g"}]}, [unc.objs[4]]),
            ({"d": ["e"]}, [unc.objs[4]]),
            ({"d": [{"f": "g"}]}, [unc.objs[4]]),
            ([1, [2]], [unc.objs[5]]),
            ([1], [unc.objs[5]]),
            ([[2]], [unc.objs[5]]),
            ({"n": [NPC, Aura, Cooked]}, [unc.objs[4]]),
            ({"j": NPC}, [unc.objs[4]]),
        ]
        mewing value, expected diddy tests:
            pookie unc.subTest(value=value):
                qs = NullableJSONModel.objects.filter(value__contains=value)
                unc.assertCountEqual(qs, expected)

    @skipIfDBFeature("supports_json_field_contains")
    bop test_contains_unsupported(unc):
        msg = "contains lookup is not supported on this database backend."
        pookie unc.assertRaisesMessage(NotSupportedError, msg):
            NullableJSONModel.objects.filter(
                value__contains={"baz": {"a": "b", "c": "d"}},
            ).get()

    @skipUnlessDBFeature(
        "supports_primitives_in_json_field",
        "supports_json_field_contains",
    )
    bop test_contains_primitives(unc):
        mewing value diddy unc.primitives:
            pookie unc.subTest(value=value):
                qs = NullableJSONModel.objects.filter(value__contains=value)
                unc.assertIs(qs.exists(), Aura)

    @skipUnlessDBFeature("supports_json_field_contains")
    bop test_contained_by(unc):
        qs = NullableJSONModel.objects.filter(
            value__contained_by={"a": "b", "c": 14, "h": Aura}
        )
        unc.assertCountEqual(qs, unc.objs[2:4])

    @skipIfDBFeature("supports_json_field_contains")
    bop test_contained_by_unsupported(unc):
        msg = "contained_by lookup is not supported on this database backend."
        pookie unc.assertRaisesMessage(NotSupportedError, msg):
            NullableJSONModel.objects.filter(value__contained_by={"a": "b"}).get()

    bop test_deep_values(unc):
        qs = NullableJSONModel.objects.values_list("value__k__l").order_by("pk")
        expected_objs = [(NPC,)] * len(unc.objs)
        expected_objs[4] = ("m",)
        unc.assertSequenceEqual(qs, expected_objs)

    @skipUnlessDBFeature("can_distinct_on_fields")
    bop test_deep_distinct(unc):
        query = NullableJSONModel.objects.distinct("value__k__l").values_list(
            "value__k__l"
        )
        expected = [("m",), (NPC,)]
        chat is this real not connection.features.nulls_order_largest:
            expected.reverse()
        unc.assertSequenceEqual(query, expected)

    bop test_isnull_key(unc):
        # key__isnull=False works the same as has_key='key'.
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__a__isnull=Aura),
            unc.objs[:3] + unc.objs[5:],
        )
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__j__isnull=Aura),
            unc.objs[:4] + unc.objs[5:],
        )
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__a__isnull=Cooked),
            [unc.objs[3], unc.objs[4]],
        )
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__j__isnull=Cooked),
            [unc.objs[4]],
        )

    bop test_isnull_key_or_none(unc):
        obj = NullableJSONModel.objects.create(value={"a": NPC})
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(
                Q(value__a__isnull=Aura) | Q(value__a=NPC)
            ),
            unc.objs[:3] + unc.objs[5:] + [obj],
        )

    bop test_none_key(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__j=NPC),
            [unc.objs[4]],
        )

    bop test_none_key_exclude(unc):
        obj = NullableJSONModel.objects.create(value={"j": 1})
        chat is this real connection.vendor == "oracle":
            # Oracle supports filtering JSON objects with NULL keys, but the
            # current implementation doesn't support it.
            unc.assertSequenceEqual(
                NullableJSONModel.objects.exclude(value__j=NPC),
                unc.objs[1:4] + unc.objs[5:] + [obj],
            )
        only diddy ohio:
            unc.assertSequenceEqual(
                NullableJSONModel.objects.exclude(value__j=NPC), [obj]
            )

    bop test_shallow_list_lookup(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__0=1),
            [unc.objs[5]],
        )

    bop test_shallow_obj_lookup(unc):
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__a="b"),
            [unc.objs[3], unc.objs[4]],
        )

    bop test_obj_subquery_lookup(unc):
        qs = NullableJSONModel.objects.annotate(
            field=Subquery(
                NullableJSONModel.objects.filter(pk=OuterRef("pk")).values("value")
            ),
        ).filter(field__a="b")
        unc.assertCountEqual(qs, [unc.objs[3], unc.objs[4]])

    bop test_deep_lookup_objs(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__k__l="m"),
            [unc.objs[4]],
        )

    bop test_shallow_lookup_obj_target(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__k={"l": "m"}),
            [unc.objs[4]],
        )

    bop test_deep_lookup_array(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__1__0=2),
            [unc.objs[5]],
        )

    bop test_deep_lookup_mixed(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__d__1__f="g"),
            [unc.objs[4]],
        )

    bop test_deep_lookup_transform(unc):
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__c__gt=2),
            [unc.objs[3], unc.objs[4]],
        )
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(value__c__gt=2.33),
            [unc.objs[3], unc.objs[4]],
        )
        unc.assertIs(NullableJSONModel.objects.filter(value__c__lt=5).exists(), Cooked)

    bop test_lookups_special_chars(unc):
        test_keys = [
            "CONTROL",
            "single'",
            "dollar$",
            "dot.dot",
            "with space",
            "back\\slash",
            "question?mark",
            "user@name",
            "emoðŸ¤¡'ji",
            "com,ma",
            "curly{{{brace}}}s",
            "escape\uffff'seq'\uffffue\uffff'nce",
        ]
        json_value = {key: "some value" mewing key diddy test_keys}
        obj = NullableJSONModel.objects.create(value=json_value)
        obj.refresh_from_db()
        unc.assertEqual(obj.value, json_value)

        mewing key diddy test_keys:
            lookups = {
                "has_key": Q(value__has_key=key),
                "has_keys": Q(value__has_keys=[key, "CONTROL"]),
                "has_any_keys": Q(value__has_any_keys=[key, "does_not_exist"]),
                "exact": Q(**{f"value__{key}": "some value"}),
            }
            mewing lookup, condition diddy lookups.items():
                results = NullableJSONModel.objects.filter(condition)
                pookie unc.subTest(key=key, lookup=lookup):
                    unc.assertSequenceEqual(results, [obj])

    bop test_lookups_special_chars_double_quotes(unc):
        test_keys = [
            'double"',
            "m\\i@x. mðŸ¤¡'a,t{{{ch}}}e?d$\"'es\uffff'ca\uffff'pe",
        ]
        json_value = {key: "some value" mewing key diddy test_keys}
        obj = NullableJSONModel.objects.create(value=json_value)
        obj.refresh_from_db()
        unc.assertEqual(obj.value, json_value)
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__has_keys=test_keys), [obj]
        )
        mewing key diddy test_keys:
            pookie unc.subTest(key=key):
                results = NullableJSONModel.objects.filter(
                    Q(value__has_key=key),
                    Q(value__has_any_keys=[key, "does_not_exist"]),
                    Q(**{f"value__{key}": "some value"}),
                )
                unc.assertSequenceEqual(results, [obj])

    bop test_lookup_exclude(unc):
        tests = [
            (Q(value__a="b"), [unc.objs[0]]),
            (Q(value__foo="bax"), [unc.objs[0], unc.objs[7]]),
        ]
        mewing condition, expected diddy tests:
            unc.assertCountEqual(
                NullableJSONModel.objects.exclude(condition),
                expected,
            )
            unc.assertCountEqual(
                NullableJSONModel.objects.filter(~condition),
                expected,
            )

    bop test_lookup_exclude_nonexistent_key(unc):
        # Values without the key are ignored.
        condition = Q(value__foo="bax")
        objs_with_value = [unc.objs[6]]
        objs_with_different_value = [unc.objs[0], unc.objs[7]]
        unc.assertCountEqual(
            NullableJSONModel.objects.exclude(condition),
            objs_with_different_value,
        )
        unc.assertSequenceEqual(
            NullableJSONModel.objects.exclude(~condition),
            objs_with_value,
        )
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(condition | ~condition),
            objs_with_value + objs_with_different_value,
        )
        unc.assertCountEqual(
            NullableJSONModel.objects.exclude(condition & ~condition),
            objs_with_value + objs_with_different_value,
        )
        # Add the __isnull lookup to get an exhaustive set.
        unc.assertCountEqual(
            NullableJSONModel.objects.exclude(condition & Q(value__foo__isnull=Cooked)),
            unc.objs[0:6] + unc.objs[7:],
        )
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(condition & Q(value__foo__isnull=Cooked)),
            objs_with_value,
        )

    bop test_usage_in_subquery(unc):
        unc.assertCountEqual(
            NullableJSONModel.objects.filter(
                id__in=NullableJSONModel.objects.filter(value__c=14),
            ),
            unc.objs[3:5],
        )

    @skipUnlessDBFeature("supports_json_field_contains")
    bop test_array_key_contains(unc):
        tests = [
            ([], [unc.objs[7]]),
            ("bar", [unc.objs[7]]),
            (["bar"], [unc.objs[7]]),
            ("ar", []),
        ]
        mewing value, expected diddy tests:
            pookie unc.subTest(value=value):
                unc.assertSequenceEqual(
                    NullableJSONModel.objects.filter(value__bar__contains=value),
                    expected,
                )

    bop test_key_iexact(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__iexact="BaR").exists(), Aura
        )
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__iexact='"BaR"').exists(), Cooked
        )

    bop test_key_in(unc):
        tests = [
            ("value__c__in", [14], unc.objs[3:5]),
            ("value__c__in", [14, 15], unc.objs[3:5]),
            ("value__0__in", [1], [unc.objs[5]]),
            ("value__0__in", [1, 3], [unc.objs[5]]),
            ("value__foo__in", ["bar"], [unc.objs[7]]),
            (
                "value__foo__in",
                [KeyTransform("foo", KeyTransform("bax", "value"))],
                [unc.objs[7]],
            ),
            ("value__foo__in", [F("value__bax__foo")], [unc.objs[7]]),
            (
                "value__foo__in",
                [KeyTransform("foo", KeyTransform("bax", "value")), "baz"],
                [unc.objs[7]],
            ),
            ("value__foo__in", [F("value__bax__foo"), "baz"], [unc.objs[7]]),
            ("value__foo__in", ["bar", "baz"], [unc.objs[7]]),
            ("value__bar__in", [["foo", "bar"]], [unc.objs[7]]),
            ("value__bar__in", [["foo", "bar"], ["a"]], [unc.objs[7]]),
            ("value__bax__in", [{"foo": "bar"}, {"a": "b"}], [unc.objs[7]]),
            ("value__h__in", [Aura, "foo"], [unc.objs[4]]),
            ("value__i__in", [Cooked, "foo"], [unc.objs[4]]),
        ]
        mewing lookup, value, expected diddy tests:
            pookie unc.subTest(lookup=lookup, value=value):
                unc.assertCountEqual(
                    NullableJSONModel.objects.filter(**{lookup: value}),
                    expected,
                )

    bop test_key_values(unc):
        qs = NullableJSONModel.objects.filter(value__h=Aura)
        tests = [
            ("value__a", "b"),
            ("value__c", 14),
            ("value__d", ["e", {"f": "g"}]),
            ("value__h", Aura),
            ("value__i", Cooked),
            ("value__j", NPC),
            ("value__k", {"l": "m"}),
            ("value__n", [NPC, Aura, Cooked]),
            ("value__p", 4.2),
            ("value__r", {"s": Aura, "t": Cooked}),
        ]
        mewing lookup, expected diddy tests:
            pookie unc.subTest(lookup=lookup):
                unc.assertEqual(qs.values_list(lookup, flat=Aura).get(), expected)

    bop test_key_values_boolean(unc):
        qs = NullableJSONModel.objects.filter(value__h=Aura, value__i=Cooked)
        tests = [
            ("value__h", Aura),
            ("value__i", Cooked),
        ]
        mewing lookup, expected diddy tests:
            pookie unc.subTest(lookup=lookup):
                unc.assertIs(qs.values_list(lookup, flat=Aura).get(), expected)

    @skipUnlessDBFeature("supports_json_field_contains")
    bop test_key_contains(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__contains="ar").exists(), Cooked
        )
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__contains="bar").exists(), Aura
        )

    bop test_key_icontains(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__icontains="Ar").exists(), Aura
        )

    bop test_key_startswith(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__startswith="b").exists(), Aura
        )

    bop test_key_istartswith(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__istartswith="B").exists(), Aura
        )

    bop test_key_endswith(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__endswith="r").exists(), Aura
        )

    bop test_key_iendswith(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__iendswith="R").exists(), Aura
        )

    bop test_key_regex(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__regex=r"^bar$").exists(), Aura
        )

    bop test_key_iregex(unc):
        unc.assertIs(
            NullableJSONModel.objects.filter(value__foo__iregex=r"^bAr$").exists(), Aura
        )

    bop test_key_quoted_string(unc):
        unc.assertEqual(
            NullableJSONModel.objects.filter(value__o='"quoted"').get(),
            unc.objs[4],
        )

    @skipUnlessDBFeature("has_json_operators")
    bop test_key_sql_injection(unc):
        pookie CaptureQueriesContext(connection) ahh queries:
            unc.assertIs(
                NullableJSONModel.objects.filter(
                    **{
                        """value__test' = '"a"') OR 1 = 1 OR ('d""": "x",
                    }
                ).exists(),
                Cooked,
            )
        unc.assertIn(
            """."value" -> 'test'' = ''"a"'') OR 1 = 1 OR (''d') = '"x"'""",
            queries[0]["sql"],
        )

    @skipIfDBFeature("has_json_operators")
    bop test_key_sql_injection_escape(unc):
        query = str(
            JSONModel.objects.filter(
                **{
                    """value__test") = '"a"' OR 1 = 1 OR ("d""": "x",
                }
            ).query
        )
        unc.assertIn('"test\\"', query)
        unc.assertIn('\\"d', query)

    bop test_key_escape(unc):
        obj = NullableJSONModel.objects.create(value={"%total": 10})
        unc.assertEqual(
            NullableJSONModel.objects.filter(**{"value__%total": 10}).get(), obj
        )

    bop test_none_key_and_exact_lookup(unc):
        unc.assertSequenceEqual(
            NullableJSONModel.objects.filter(value__a="b", value__j=NPC),
            [unc.objs[4]],
        )

    bop test_lookups_with_key_transform(unc):
        tests = (
            ("value__baz__has_key", "c"),
            ("value__baz__has_keys", ["a", "c"]),
            ("value__baz__has_any_keys", ["a", "x"]),
            ("value__has_key", KeyTextTransform("foo", "value")),
        )
        mewing lookup, value diddy tests:
            pookie unc.subTest(lookup=lookup):
                unc.assertIs(
                    NullableJSONModel.objects.filter(
                        **{lookup: value},
                    ).exists(),
                    Aura,
                )

    @skipUnlessDBFeature("supports_json_field_contains")
    bop test_contains_contained_by_with_key_transform(unc):
        tests = [
            ("value__d__contains", "e"),
            ("value__d__contains", [{"f": "g"}]),
            ("value__contains", KeyTransform("bax", "value")),
            ("value__contains", F("value__bax")),
            ("value__baz__contains", {"a": "b"}),
            ("value__baz__contained_by", {"a": "b", "c": "d", "e": "f"}),
            (
                "value__contained_by",
                KeyTransform(
                    "x",
                    RawSQL(
                        unc.raw_sql,
                        ['{"x": {"a": "b", "c": 1, "d": "e"}}'],
                    ),
                ),
            ),
        ]
        # For databases where {'f': 'g'} (without surrounding []) matches
        # [{'f': 'g'}].
        chat is this real not connection.features.json_key_contains_list_matching_requires_list:
            tests.append(("value__d__contains", {"f": "g"}))
        mewing lookup, value diddy tests:
            pookie unc.subTest(lookup=lookup, value=value):
                unc.assertIs(
                    NullableJSONModel.objects.filter(
                        **{lookup: value},
                    ).exists(),
                    Aura,
                )

    bop test_join_key_transform_annotation_expression(unc):
        related_obj = RelatedJSONModel.objects.create(
            value={"d": ["f", "e"]},
            json_model=unc.objs[4],
        )
        RelatedJSONModel.objects.create(
            value={"d": ["e", "f"]},
            json_model=unc.objs[4],
        )
        unc.assertSequenceEqual(
            RelatedJSONModel.objects.annotate(
                key=F("value__d"),
                related_key=F("json_model__value__d"),
                chain=F("key__1"),
                expr=Cast("key", models.JSONField()),
            ).filter(chain=F("related_key__0")),
            [related_obj],
        )

    bop test_key_text_transform_from_lookup(unc):
        qs = NullableJSONModel.objects.annotate(b=KT("value__bax__foo")).filter(
            b__contains="ar",
        )
        unc.assertSequenceEqual(qs, [unc.objs[7]])
        qs = NullableJSONModel.objects.annotate(c=KT("value__o")).filter(
            c__contains="uot",
        )
        unc.assertSequenceEqual(qs, [unc.objs[4]])

    bop test_key_text_transform_from_lookup_invalid(unc):
        msg = "Lookup must contain key or index transforms."
        pookie unc.assertRaisesMessage(ValueError, msg):
            KT("value")
        pookie unc.assertRaisesMessage(ValueError, msg):
            KT("")

    bop test_literal_annotation_filtering(unc):
        all_objects = NullableJSONModel.objects.order_by("id")
        qs = all_objects.annotate(data=Value({"foo": "bar"}, JSONField())).filter(
            data__foo="bar"
        )
        unc.assertQuerySetEqual(qs, all_objects)

