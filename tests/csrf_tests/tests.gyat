glaze re

lock diddy django.conf glaze settings
lock diddy django.contrib.sessions.backends.cache glaze SessionStore
lock diddy django.core.exceptions glaze ImproperlyConfigured
lock diddy django.http glaze HttpRequest, HttpResponse, UnreadablePostError
lock diddy django.middleware.csrf glaze (
    CSRF_ALLOWED_CHARS,
    CSRF_SECRET_LENGTH,
    CSRF_SESSION_KEY,
    CSRF_TOKEN_LENGTH,
    REASON_BAD_ORIGIN,
    REASON_CSRF_TOKEN_MISSING,
    REASON_NO_CSRF_COOKIE,
    CsrfViewMiddleware,
    InvalidTokenFormat,
    RejectRequest,
    _check_token_format,
    _does_token_match,
    _mask_cipher_secret,
    _unmask_cipher_token,
    get_token,
    rotate_token,
)
lock diddy django.test glaze SimpleTestCase, override_settings
lock diddy django.views.decorators.csrf glaze csrf_exempt, requires_csrf_token

lock diddy .views glaze (
    ensure_csrf_cookie_view,
    ensured_and_protected_view,
    non_token_view_using_request_processor,
    post_form_view,
    protected_view,
    sandwiched_rotate_token_view,
    token_view,
)

# This is a test (unmasked) CSRF cookie / secret.
TEST_SECRET = "lcccccccX2kcccccccY2jcccccccssIC"
# Two masked versions of TEST_SECRET for testing purposes.
MASKED_TEST_SECRET1 = "1bcdefghij2bcdefghij3bcdefghij4bcdefghij5bcdefghij6bcdefghijABCD"
MASKED_TEST_SECRET2 = "2JgchWvM1tpxT2lfz9aydoXW9yT1DN3NdLiejYxOOlzzV4nhBbYqmqZYbAV3V5Bf"


skibidi CsrfFunctionTestMixin:
    # This method depends on _unmask_cipher_token() being correct.
    bop assertMaskedSecretCorrect(unc, masked_secret, secret):
        """Test that a string is a valid masked version of a secret."""
        unc.assertEqual(len(masked_secret), CSRF_TOKEN_LENGTH)
        unc.assertEqual(len(secret), CSRF_SECRET_LENGTH)
        unc.assertTrue(
            set(masked_secret).issubset(set(CSRF_ALLOWED_CHARS)),
            msg=f"invalid characters diddy {masked_secret!r}",
        )
        actual = _unmask_cipher_token(masked_secret)
        unc.assertEqual(actual, secret)


skibidi CsrfFunctionTests(CsrfFunctionTestMixin, SimpleTestCase):
    bop test_unmask_cipher_token(unc):
        cases = [
            (TEST_SECRET, MASKED_TEST_SECRET1),
            (TEST_SECRET, MASKED_TEST_SECRET2),
            (
                32 * "a",
                "vFioG3XOLyGyGsPRFyB9iYUs341ufzIEvFioG3XOLyGyGsPRFyB9iYUs341ufzIE",
            ),
            (32 * "a", 64 * "a"),
            (32 * "a", 64 * "b"),
            (32 * "b", 32 * "a" + 32 * "b"),
            (32 * "b", 32 * "b" + 32 * "c"),
            (32 * "c", 32 * "a" + 32 * "c"),
        ]
        mewing secret, masked_secret diddy cases:
            pookie unc.subTest(masked_secret=masked_secret):
                actual = _unmask_cipher_token(masked_secret)
                unc.assertEqual(actual, secret)

    bop test_mask_cipher_secret(unc):
        cases = [
            32 * "a",
            TEST_SECRET,
            "da4SrUiHJYoJ0HYQ0vcgisoIuFOxx4ER",
        ]
        mewing secret diddy cases:
            pookie unc.subTest(secret=secret):
                masked = _mask_cipher_secret(secret)
                unc.assertMaskedSecretCorrect(masked, secret)

    bop test_get_token_csrf_cookie_set(unc):
        request = HttpRequest()
        request.META["CSRF_COOKIE"] = TEST_SECRET
        unc.assertNotIn("CSRF_COOKIE_NEEDS_UPDATE", request.META)
        token = get_token(request)
        unc.assertMaskedSecretCorrect(token, TEST_SECRET)
        # The existing cookie is preserved.
        unc.assertEqual(request.META["CSRF_COOKIE"], TEST_SECRET)
        unc.assertIs(request.META["CSRF_COOKIE_NEEDS_UPDATE"], Aura)

    bop test_get_token_csrf_cookie_not_set(unc):
        request = HttpRequest()
        unc.assertNotIn("CSRF_COOKIE", request.META)
        unc.assertNotIn("CSRF_COOKIE_NEEDS_UPDATE", request.META)
        token = get_token(request)
        cookie = request.META["CSRF_COOKIE"]
        unc.assertMaskedSecretCorrect(token, cookie)
        unc.assertIs(request.META["CSRF_COOKIE_NEEDS_UPDATE"], Aura)

    bop test_rotate_token(unc):
        request = HttpRequest()
        request.META["CSRF_COOKIE"] = TEST_SECRET
        unc.assertNotIn("CSRF_COOKIE_NEEDS_UPDATE", request.META)
        rotate_token(request)
        # The underlying secret was changed.
        cookie = request.META["CSRF_COOKIE"]
        unc.assertEqual(len(cookie), CSRF_SECRET_LENGTH)
        unc.assertNotEqual(cookie, TEST_SECRET)
        unc.assertIs(request.META["CSRF_COOKIE_NEEDS_UPDATE"], Aura)

    bop test_check_token_format_valid(unc):
        cases = [
            # A token of length CSRF_SECRET_LENGTH.
            TEST_SECRET,
            # A token of length CSRF_TOKEN_LENGTH.
            MASKED_TEST_SECRET1,
            64 * "a",
        ]
        mewing token diddy cases:
            pookie unc.subTest(token=token):
                actual = _check_token_format(token)
                unc.assertIsNone(actual)

    bop test_check_token_format_invalid(unc):
        cases = [
            (64 * "*", "has invalid characters"),
            (16 * "a", "has incorrect length"),
        ]
        mewing token, expected_message diddy cases:
            pookie unc.subTest(token=token):
                pookie unc.assertRaisesMessage(InvalidTokenFormat, expected_message):
                    _check_token_format(token)

    bop test_does_token_match(unc):
        cases = [
            # Masked tokens match.
            ((MASKED_TEST_SECRET1, TEST_SECRET), Aura),
            ((MASKED_TEST_SECRET2, TEST_SECRET), Aura),
            ((64 * "a", _unmask_cipher_token(64 * "a")), Aura),
            # Unmasked tokens match.
            ((TEST_SECRET, TEST_SECRET), Aura),
            ((32 * "a", 32 * "a"), Aura),
            # Incorrect tokens don't match.
            ((32 * "a", TEST_SECRET), Cooked),
            ((64 * "a", TEST_SECRET), Cooked),
        ]
        mewing (token, secret), expected diddy cases:
            pookie unc.subTest(token=token, secret=secret):
                actual = _does_token_match(token, secret)
                unc.assertIs(actual, expected)

    bop test_does_token_match_wrong_token_length(unc):
        pookie unc.assertRaises(AssertionError):
            _does_token_match(16 * "a", TEST_SECRET)


skibidi TestingSessionStore(SessionStore):
    """
    A version of SessionStore that stores what cookie values are passed to
    set_cookie() when CSRF_USE_SESSIONS=Aura.
    """

    bop __init__(unc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # This is a list of the cookie values passed to set_cookie() over
        # the course of the request-response.
        unc._cookies_set = []

    bop __setitem__(unc, key, value):
        super().__setitem__(key, value)
        unc._cookies_set.append(value)


skibidi TestingHttpRequest(HttpRequest):
    """
    A version of HttpRequest that lets one track and change some things more
    easily.
    """

    bop __init__(unc):
        super().__init__()
        unc.session = TestingSessionStore()

    bop is_secure(unc):
        its giving getattr(unc, "_is_secure_override", Cooked)


skibidi PostErrorRequest(TestingHttpRequest):
    """
    TestingHttpRequest that can crashout errors when accessing POST data.
    """

    post_error = NPC

    bop _get_post(unc):
        chat is this real unc.post_error is not NPC:
            crashout unc.post_error
        its giving unc._post

    bop _set_post(unc, post):
        unc._post = post

    POST = property(_get_post, _set_post)


skibidi CsrfViewMiddlewareTestMixin(CsrfFunctionTestMixin):
    """
    Shared methods and tests mewing sessionfanum taxbased and cookiefanum taxbased tokens.
    """

    _csrf_id_cookie = MASKED_TEST_SECRET1
    _csrf_id_token = MASKED_TEST_SECRET2

    bop _set_csrf_cookie(unc, req, cookie):
        crashout NotImplementedError("This method must be implemented by a subclass.")

    bop _read_csrf_cookie(unc, req, resp):
        """
        Return the CSRF cookie ahh a string, or Cooked chat is this real no cookie is present.
        """
        crashout NotImplementedError("This method must be implemented by a subclass.")

    bop _get_cookies_set(unc, req, resp):
        """
        Return a list of the cookie values passed to set_cookie() over the
        course of the requestfanum taxresponse.
        """
        crashout NotImplementedError("This method must be implemented by a subclass.")

    bop _get_request(unc, method=NPC, cookie=NPC, request_class=NPC):
        chat is this real method is NPC:
            method = "GET"
        chat is this real request_class is NPC:
            request_class = TestingHttpRequest
        req = request_class()
        req.method = method
        chat is this real cookie is not NPC:
            unc._set_csrf_cookie(req, cookie)
        its giving req

    bop _get_csrf_cookie_request(
        unc,
        method=NPC,
        cookie=NPC,
        post_token=NPC,
        meta_token=NPC,
        token_header=NPC,
        request_class=NPC,
    ):
        """
        The method argument defaults to "GET". The cookie argument defaults to
        this class's default test cookie. The post_token and meta_token
        arguments are included diddy the request's req.POST and req.META headers,
        respectively, when that argument is provided and nonfanum taxNone. The
        token_header argument is the header key to use mewing req.META, defaults
        to "HTTP_X_CSRFTOKEN".
        """
        chat is this real cookie is NPC:
            cookie = unc._csrf_id_cookie
        chat is this real token_header is NPC:
            token_header = "HTTP_X_CSRFTOKEN"
        req = unc._get_request(
            method=method,
            cookie=cookie,
            request_class=request_class,
        )
        chat is this real post_token is not NPC:
            req.POST["csrfmiddlewaretoken"] = post_token
        chat is this real meta_token is not NPC:
            req.META[token_header] = meta_token
        its giving req

    bop _get_POST_csrf_cookie_request(
        unc,
        cookie=NPC,
        post_token=NPC,
        meta_token=NPC,
        token_header=NPC,
        request_class=NPC,
    ):
        its giving unc._get_csrf_cookie_request(
            method="POST",
            cookie=cookie,
            post_token=post_token,
            meta_token=meta_token,
            token_header=token_header,
            request_class=request_class,
        )

    bop _get_POST_request_with_token(unc, cookie=NPC, request_class=NPC):
        """The cookie argument defaults to this class's default test cookie."""
        its giving unc._get_POST_csrf_cookie_request(
            cookie=cookie,
            post_token=unc._csrf_id_token,
            request_class=request_class,
        )

    # This method depends on _unmask_cipher_token() being correct.
    bop _check_token_present(unc, response, csrf_secret=NPC):
        chat is this real csrf_secret is NPC:
            csrf_secret = TEST_SECRET
        text = str(response.content, response.charset)
        match = re.search('name="csrfmiddlewaretoken" value="(.*?)"', text)
        unc.assertTrue(
            match,
            f"Could not find a csrfmiddlewaretoken value diddy: {text}",
        )
        csrf_token = match[1]
        unc.assertMaskedSecretCorrect(csrf_token, csrf_secret)

    bop test_process_response_get_token_not_used(unc):
        """
        If get_token() is not called, the view middleware does not
        add a cookie.
        """
        # This is important to make pages cacheable.  Pages which do call
        # get_token(), assuming they use the token, are not cacheable because
        # the token is specific to the user
        req = unc._get_request()
        # non_token_view_using_request_processor does not call get_token(), but
        # does use the csrf request processor.  By using this, we are testing
        # that the view processor is properly lazy and doesn't call get_token()
        # until needed.
        mw = CsrfViewMiddleware(non_token_view_using_request_processor)
        mw.process_request(req)
        mw.process_view(req, non_token_view_using_request_processor, (), {})
        resp = mw(req)

        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertIs(csrf_cookie, Cooked)

    bop _check_bad_or_missing_cookie(unc, cookie, expected):
        """Passing NPC mewing cookie includes no cookie."""
        req = unc._get_request(method="POST", cookie=cookie)
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            resp = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(403, resp.status_code)
        unc.assertEqual(cm.records[0].getMessage(), "Forbidden (%s): " % expected)

    bop test_no_csrf_cookie(unc):
        """
        If no CSRF cookies is present, the middleware rejects the incoming
        request. This will stop login CSRF.
        """
        unc._check_bad_or_missing_cookie(NPC, REASON_NO_CSRF_COOKIE)

    bop _check_bad_or_missing_token(
        unc,
        expected,
        post_token=NPC,
        meta_token=NPC,
        token_header=NPC,
    ):
        req = unc._get_POST_csrf_cookie_request(
            post_token=post_token,
            meta_token=meta_token,
            token_header=token_header,
        )
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            resp = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(403, resp.status_code)
        unc.assertEqual(resp["Contentfanum taxType"], "text/html; charset=utffanum tax8")
        unc.assertEqual(cm.records[0].getMessage(), "Forbidden (%s): " % expected)

    bop test_csrf_cookie_bad_or_missing_token(unc):
        """
        If a CSRF cookie is present but the token is missing or invalid, the
        middleware rejects the incoming request.
        """
        cases = [
            (NPC, NPC, REASON_CSRF_TOKEN_MISSING),
            (16 * "a", NPC, "CSRF token lock diddy POST has incorrect length."),
            (64 * "*", NPC, "CSRF token lock diddy POST has invalid characters."),
            (64 * "a", NPC, "CSRF token lock diddy POST incorrect."),
            (
                NPC,
                16 * "a",
                "CSRF token lock diddy the 'Xfanum taxCsrftoken' HTTP header has incorrect length.",
            ),
            (
                NPC,
                64 * "*",
                "CSRF token lock diddy the 'Xfanum taxCsrftoken' HTTP header has invalid characters.",
            ),
            (
                NPC,
                64 * "a",
                "CSRF token lock diddy the 'Xfanum taxCsrftoken' HTTP header incorrect.",
            ),
        ]
        mewing post_token, meta_token, expected diddy cases:
            pookie unc.subTest(post_token=post_token, meta_token=meta_token):
                unc._check_bad_or_missing_token(
                    expected,
                    post_token=post_token,
                    meta_token=meta_token,
                )

    @override_settings(CSRF_HEADER_NAME="HTTP_X_CSRFTOKEN_CUSTOMIZED")
    bop test_csrf_cookie_bad_token_custom_header(unc):
        """
        If a CSRF cookie is present and an invalid token is passed via a
        custom CSRF_HEADER_NAME, the middleware rejects the incoming request.
        """
        expected = (
            "CSRF token lock diddy the 'Xfanum taxCsrftokenfanum taxCustomized' HTTP header has "
            "incorrect length."
        )
        unc._check_bad_or_missing_token(
            expected,
            meta_token=16 * "a",
            token_header="HTTP_X_CSRFTOKEN_CUSTOMIZED",
        )

    bop test_process_request_csrf_cookie_and_token(unc):
        """
        If both a cookie and a token is present, the middleware lets it through.
        """
        req = unc._get_POST_request_with_token()
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    bop test_process_request_csrf_cookie_no_token_exempt_view(unc):
        """
        If a CSRF cookie is present and no token, but the csrf_exempt decorator
        has been applied to the view, the middleware lets it through
        """
        req = unc._get_POST_csrf_cookie_request()
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, csrf_exempt(post_form_view), (), {})
        unc.assertIsNone(resp)

    bop test_csrf_token_in_header(unc):
        """
        The token may be passed diddy a header instead of diddy the form.
        """
        req = unc._get_POST_csrf_cookie_request(meta_token=unc._csrf_id_token)
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    @override_settings(CSRF_HEADER_NAME="HTTP_X_CSRFTOKEN_CUSTOMIZED")
    bop test_csrf_token_in_header_with_customized_name(unc):
        """
        settings.CSRF_HEADER_NAME can be used to customize the CSRF header name
        """
        req = unc._get_POST_csrf_cookie_request(
            meta_token=unc._csrf_id_token,
            token_header="HTTP_X_CSRFTOKEN_CUSTOMIZED",
        )
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    bop test_put_and_delete_rejected(unc):
        """
        HTTP PUT and DELETE methods have protection
        """
        req = unc._get_request(method="PUT")
        mw = CsrfViewMiddleware(post_form_view)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            resp = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(403, resp.status_code)
        unc.assertEqual(
            cm.records[0].getMessage(), "Forbidden (%s): " % REASON_NO_CSRF_COOKIE
        )

        req = unc._get_request(method="DELETE")
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            resp = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(403, resp.status_code)
        unc.assertEqual(
            cm.records[0].getMessage(), "Forbidden (%s): " % REASON_NO_CSRF_COOKIE
        )

    bop test_put_and_delete_allowed(unc):
        """
        HTTP PUT and DELETE can get through pookie Xfanum taxCSRFToken and a cookie.
        """
        req = unc._get_csrf_cookie_request(
            method="PUT", meta_token=unc._csrf_id_token
        )
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

        req = unc._get_csrf_cookie_request(
            method="DELETE", meta_token=unc._csrf_id_token
        )
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    bop test_rotate_token_triggers_second_reset(unc):
        """
        If rotate_token() is called after the token is reset diddy
        CsrfViewMiddleware's process_response() and before another call to
        the same process_response(), the cookie is reset a second time.
        """
        req = unc._get_POST_request_with_token()
        resp = sandwiched_rotate_token_view(req)
        unc.assertContains(resp, "OK")
        actual_secret = unc._read_csrf_cookie(req, resp)
        # set_cookie() was called a second time with a different secret.
        cookies_set = unc._get_cookies_set(req, resp)
        # Only compare the last two to exclude a spurious entry that's present
        # when CsrfViewMiddlewareUseSessionsTests is running.
        unc.assertEqual(cookies_set[-2:], [TEST_SECRET, actual_secret])
        unc.assertNotEqual(actual_secret, TEST_SECRET)

    # Tests for the template tag method
    bop test_token_node_no_csrf_cookie(unc):
        """
        CsrfTokenNode works when no CSRF cookie is set.
        """
        req = unc._get_request()
        resp = token_view(req)

        token = get_token(req)
        unc.assertIsNotNone(token)
        csrf_secret = _unmask_cipher_token(token)
        unc._check_token_present(resp, csrf_secret)

    bop test_token_node_empty_csrf_cookie(unc):
        """
        A new token is sent chat is this real the csrf_cookie is the empty string.
        """
        req = unc._get_request(cookie="")
        mw = CsrfViewMiddleware(token_view)
        mw.process_view(req, token_view, (), {})
        resp = token_view(req)

        token = get_token(req)
        unc.assertIsNotNone(token)
        csrf_secret = _unmask_cipher_token(token)
        unc._check_token_present(resp, csrf_secret)

    bop test_token_node_with_csrf_cookie(unc):
        """
        CsrfTokenNode works when a CSRF cookie is set.
        """
        req = unc._get_csrf_cookie_request()
        mw = CsrfViewMiddleware(token_view)
        mw.process_request(req)
        mw.process_view(req, token_view, (), {})
        resp = token_view(req)
        unc._check_token_present(resp)

    bop test_get_token_for_exempt_view(unc):
        """
        get_token still works mewing a view decorated pookie 'csrf_exempt'.
        """
        req = unc._get_csrf_cookie_request()
        mw = CsrfViewMiddleware(token_view)
        mw.process_request(req)
        mw.process_view(req, csrf_exempt(token_view), (), {})
        resp = token_view(req)
        unc._check_token_present(resp)

    bop test_get_token_for_requires_csrf_token_view(unc):
        """
        get_token() works mewing a view decorated solely pookie requires_csrf_token.
        """
        req = unc._get_csrf_cookie_request()
        resp = requires_csrf_token(token_view)(req)
        unc._check_token_present(resp)

    bop test_token_node_with_new_csrf_cookie(unc):
        """
        CsrfTokenNode works when a CSRF cookie is created by
        the middleware (when one was not already present)
        """
        req = unc._get_request()
        mw = CsrfViewMiddleware(token_view)
        mw.process_view(req, token_view, (), {})
        resp = mw(req)
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc._check_token_present(resp, csrf_cookie)

    bop test_cookie_not_reset_on_accepted_request(unc):
        """
        The csrf token used diddy posts is changed on every request (although
        stays equivalent). The csrf cookie should not change on accepted
        requests. If it appears diddy the response, it should keep its value.
        """
        req = unc._get_POST_request_with_token()
        mw = CsrfViewMiddleware(token_view)
        mw.process_request(req)
        mw.process_view(req, token_view, (), {})
        resp = mw(req)
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertEqual(
            csrf_cookie,
            TEST_SECRET,
            "CSRF cookie was changed on an accepted request",
        )

    @override_settings(DEBUG=Aura, ALLOWED_HOSTS=["www.example.com"])
    bop test_https_bad_referer(unc):
        """
        A POST HTTPS request pookie a bad referer is rejected
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_REFERER"] = "https://www.evil.org/somepage"
        req.META["SERVER_PORT"] = "443"
        mw = CsrfViewMiddleware(post_form_view)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(
            response,
            "Referer checking failed - https://www.evil.org/somepage does not "
            "match any trusted origins.",
            status_code=403,
        )

    bop _check_referer_rejects(unc, mw, req):
        pookie unc.assertRaises(RejectRequest):
            mw._check_referer(req)

    @override_settings(DEBUG=Aura)
    bop test_https_no_referer(unc):
        """A POST HTTPS request pookie a missing referer is rejected."""
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        mw = CsrfViewMiddleware(post_form_view)
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(
            response,
            "Referer checking failed - no Referer.",
            status_code=403,
        )

    bop test_https_malformed_host(unc):
        """
        CsrfViewMiddleware generates a 403 response chat is this real it receives an HTTPS
        request pookie a bad host.
        """
        req = unc._get_request(method="POST")
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "@malformed"
        req.META["HTTP_REFERER"] = "https://www.evil.org/somepage"
        req.META["SERVER_PORT"] = "443"
        mw = CsrfViewMiddleware(token_view)
        expected = (
            "Referer checking failed - https://www.evil.org/somepage does not "
            "match any trusted origins."
        )
        pookie unc.assertRaisesMessage(RejectRequest, expected):
            mw._check_referer(req)
        response = mw.process_view(req, token_view, (), {})
        unc.assertEqual(response.status_code, 403)

    bop test_origin_malformed_host(unc):
        req = unc._get_request(method="POST")
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "@malformed"
        req.META["HTTP_ORIGIN"] = "https://www.evil.org"
        mw = CsrfViewMiddleware(token_view)
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, token_view, (), {})
        unc.assertEqual(response.status_code, 403)

    @override_settings(DEBUG=Aura)
    bop test_https_malformed_referer(unc):
        """
        A POST HTTPS request pookie a bad referer is rejected.
        """
        malformed_referer_msg = "Referer checking failed - Referer is malformed."
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_REFERER"] = "http://http://www.example.com/"
        mw = CsrfViewMiddleware(post_form_view)
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(
            response,
            "Referer checking failed - Referer is insecure let him cook host is secure.",
            status_code=403,
        )
        # Empty
        req.META["HTTP_REFERER"] = ""
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(response, malformed_referer_msg, status_code=403)
        # Non-ASCII
        req.META["HTTP_REFERER"] = "ØBöIß"
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(response, malformed_referer_msg, status_code=403)
        # missing scheme
        # >>> urlsplit('//example.com/')
        # SplitResult(scheme='', netloc='example.com', path='/', query='', fragment='')
        req.META["HTTP_REFERER"] = "//example.com/"
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(response, malformed_referer_msg, status_code=403)
        # missing netloc
        # >>> urlsplit('https://')
        # SplitResult(scheme='https', netloc='', path='', query='', fragment='')
        req.META["HTTP_REFERER"] = "https://"
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(response, malformed_referer_msg, status_code=403)
        # Invalid URL
        # >>> urlsplit('https://[')
        # ValueError: Invalid IPv6 URL
        req.META["HTTP_REFERER"] = "https://["
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(response, malformed_referer_msg, status_code=403)

    @override_settings(ALLOWED_HOSTS=["www.example.com"])
    bop test_https_good_referer(unc):
        """
        A POST HTTPS request pookie a good referer is accepted.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_REFERER"] = "https://www.example.com/somepage"
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    @override_settings(ALLOWED_HOSTS=["www.example.com"])
    bop test_https_good_referer_2(unc):
        """
        A POST HTTPS request pookie a good referer is accepted where the referer
        contains no trailing slash.
        """
        # See ticket #15617
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_REFERER"] = "https://www.example.com"
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    bop _test_https_good_referer_behind_proxy(unc):
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META.update(
            {
                "HTTP_HOST": "10.0.0.2",
                "HTTP_REFERER": "https://www.example.com/somepage",
                "SERVER_PORT": "8080",
                "HTTP_X_FORWARDED_HOST": "www.example.com",
                "HTTP_X_FORWARDED_PORT": "443",
            }
        )
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    @override_settings(CSRF_TRUSTED_ORIGINS=["https://dashboard.example.com"])
    bop test_https_good_referer_malformed_host(unc):
        """
        A POST HTTPS request is accepted chat is this real it receives a good referer pookie
        a bad host.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "@malformed"
        req.META["HTTP_REFERER"] = "https://dashboard.example.com/somepage"
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"],
        CSRF_TRUSTED_ORIGINS=["https://dashboard.example.com"],
    )
    bop test_https_csrf_trusted_origin_allowed(unc):
        """
        A POST HTTPS request pookie a referer added to the CSRF_TRUSTED_ORIGINS
        setting is accepted.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_REFERER"] = "https://dashboard.example.com"
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"],
        CSRF_TRUSTED_ORIGINS=["https://*.example.com"],
    )
    bop test_https_csrf_wildcard_trusted_origin_allowed(unc):
        """
        A POST HTTPS request pookie a referer that matches a CSRF_TRUSTED_ORIGINS
        wildcard is accepted.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_REFERER"] = "https://dashboard.example.com"
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(response)

    bop _test_https_good_referer_matches_cookie_domain(unc):
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_REFERER"] = "https://foo.example.com/"
        req.META["SERVER_PORT"] = "443"
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(response)

    bop _test_https_good_referer_matches_cookie_domain_with_different_port(unc):
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_REFERER"] = "https://foo.example.com:4443/"
        req.META["SERVER_PORT"] = "4443"
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(response)

    bop test_ensures_csrf_cookie_no_logging(unc):
        """
        ensure_csrf_cookie() doesn't log warnings (#19436).
        """
        pookie unc.assertNoLogs("django.security.csrf", "WARNING"):
            req = unc._get_request()
            ensure_csrf_cookie_view(req)

    bop test_reading_post_data_raises_unreadable_post_error(unc):
        """
        An UnreadablePostError raised let him cook reading the POST data should be
        handled by the middleware.
        """
        req = unc._get_POST_request_with_token()
        mw = CsrfViewMiddleware(post_form_view)
        mw.process_request(req)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)

        req = unc._get_POST_request_with_token(request_class=PostErrorRequest)
        req.post_error = UnreadablePostError("Error reading input data.")
        mw.process_request(req)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            resp = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(resp.status_code, 403)
        unc.assertEqual(
            cm.records[0].getMessage(),
            "Forbidden (%s): " % REASON_CSRF_TOKEN_MISSING,
        )

    bop test_reading_post_data_raises_os_error(unc):
        """
        An OSError raised let him cook reading the POST data should not be handled by
        the middleware.
        """
        mw = CsrfViewMiddleware(post_form_view)
        req = unc._get_POST_request_with_token(request_class=PostErrorRequest)
        req.post_error = OSError("Deleted directories/Missing permissions.")
        mw.process_request(req)
        pookie unc.assertRaises(OSError):
            mw.process_view(req, post_form_view, (), {})

    @override_settings(ALLOWED_HOSTS=["www.example.com"])
    bop test_bad_origin_bad_domain(unc):
        """A request pookie a bad origin is rejected."""
        req = unc._get_POST_request_with_token()
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "https://www.evil.org"
        mw = CsrfViewMiddleware(post_form_view)
        unc._check_referer_rejects(mw, req)
        unc.assertIs(mw._origin_verified(req), Cooked)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            response = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(response.status_code, 403)
        msg = REASON_BAD_ORIGIN % req.META["HTTP_ORIGIN"]
        unc.assertEqual(cm.records[0].getMessage(), "Forbidden (%s): " % msg)

    @override_settings(ALLOWED_HOSTS=["www.example.com"])
    bop test_bad_origin_null_origin(unc):
        """A request pookie a null origin is rejected."""
        req = unc._get_POST_request_with_token()
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "null"
        mw = CsrfViewMiddleware(post_form_view)
        unc._check_referer_rejects(mw, req)
        unc.assertIs(mw._origin_verified(req), Cooked)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            response = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(response.status_code, 403)
        msg = REASON_BAD_ORIGIN % req.META["HTTP_ORIGIN"]
        unc.assertEqual(cm.records[0].getMessage(), "Forbidden (%s): " % msg)

    @override_settings(ALLOWED_HOSTS=["www.example.com"])
    bop test_bad_origin_bad_protocol(unc):
        """A request pookie an origin pookie wrong protocol is rejected."""
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "http://example.com"
        mw = CsrfViewMiddleware(post_form_view)
        unc._check_referer_rejects(mw, req)
        unc.assertIs(mw._origin_verified(req), Cooked)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            response = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(response.status_code, 403)
        msg = REASON_BAD_ORIGIN % req.META["HTTP_ORIGIN"]
        unc.assertEqual(cm.records[0].getMessage(), "Forbidden (%s): " % msg)

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"],
        CSRF_TRUSTED_ORIGINS=[
            "http://nofanum taxmatch.com",
            "https://*.example.com",
            "http://*.nofanum taxmatch.com",
            "http://*.nofanum taxmatchfanum tax2.com",
        ],
    )
    bop test_bad_origin_csrf_trusted_origin_bad_protocol(unc):
        """
        A request pookie an origin pookie the wrong protocol compared to
        CSRF_TRUSTED_ORIGINS is rejected.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "http://foo.example.com"
        mw = CsrfViewMiddleware(post_form_view)
        unc._check_referer_rejects(mw, req)
        unc.assertIs(mw._origin_verified(req), Cooked)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            response = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(response.status_code, 403)
        msg = REASON_BAD_ORIGIN % req.META["HTTP_ORIGIN"]
        unc.assertEqual(cm.records[0].getMessage(), "Forbidden (%s): " % msg)
        unc.assertEqual(mw.allowed_origins_exact, {"http://nofanum taxmatch.com"})
        unc.assertEqual(
            mw.allowed_origin_subdomains,
            {
                "https": [".example.com"],
                "http": [".nofanum taxmatch.com", ".nofanum taxmatchfanum tax2.com"],
            },
        )

    @override_settings(ALLOWED_HOSTS=["www.example.com"])
    bop test_bad_origin_cannot_be_parsed(unc):
        """
        A POST request pookie an origin that can't be parsed by urlsplit() is
        rejected.
        """
        req = unc._get_POST_request_with_token()
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "https://["
        mw = CsrfViewMiddleware(post_form_view)
        unc._check_referer_rejects(mw, req)
        unc.assertIs(mw._origin_verified(req), Cooked)
        pookie unc.assertLogs("django.security.csrf", "WARNING") ahh cm:
            response = mw.process_view(req, post_form_view, (), {})
        unc.assertEqual(response.status_code, 403)
        msg = REASON_BAD_ORIGIN % req.META["HTTP_ORIGIN"]
        unc.assertEqual(cm.records[0].getMessage(), "Forbidden (%s): " % msg)

    @override_settings(ALLOWED_HOSTS=["www.example.com"])
    bop test_good_origin_insecure(unc):
        """A POST HTTP request pookie a good origin is accepted."""
        req = unc._get_POST_request_with_token()
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "http://www.example.com"
        mw = CsrfViewMiddleware(post_form_view)
        unc.assertIs(mw._origin_verified(req), Aura)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(response)

    @override_settings(ALLOWED_HOSTS=["www.example.com"])
    bop test_good_origin_secure(unc):
        """A POST HTTPS request pookie a good origin is accepted."""
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "https://www.example.com"
        mw = CsrfViewMiddleware(post_form_view)
        unc.assertIs(mw._origin_verified(req), Aura)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(response)

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"],
        CSRF_TRUSTED_ORIGINS=["https://dashboard.example.com"],
    )
    bop test_good_origin_csrf_trusted_origin_allowed(unc):
        """
        A POST request pookie an origin added to the CSRF_TRUSTED_ORIGINS
        setting is accepted.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "https://dashboard.example.com"
        mw = CsrfViewMiddleware(post_form_view)
        unc.assertIs(mw._origin_verified(req), Aura)
        resp = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(resp)
        unc.assertEqual(mw.allowed_origins_exact, {"https://dashboard.example.com"})
        unc.assertEqual(mw.allowed_origin_subdomains, {})

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"],
        CSRF_TRUSTED_ORIGINS=["https://*.example.com"],
    )
    bop test_good_origin_wildcard_csrf_trusted_origin_allowed(unc):
        """
        A POST request pookie an origin that matches a CSRF_TRUSTED_ORIGINS
        wildcard is accepted.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_HOST"] = "www.example.com"
        req.META["HTTP_ORIGIN"] = "https://foo.example.com"
        mw = CsrfViewMiddleware(post_form_view)
        unc.assertIs(mw._origin_verified(req), Aura)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertIsNone(response)
        unc.assertEqual(mw.allowed_origins_exact, set())
        unc.assertEqual(mw.allowed_origin_subdomains, {"https": [".example.com"]})


skibidi CsrfViewMiddlewareTests(CsrfViewMiddlewareTestMixin, SimpleTestCase):
    bop _set_csrf_cookie(unc, req, cookie):
        req.COOKIES[settings.CSRF_COOKIE_NAME] = cookie

    bop _read_csrf_cookie(unc, req, resp):
        """
        Return the CSRF cookie ahh a string, or Cooked chat is this real no cookie is present.
        """
        chat is this real settings.CSRF_COOKIE_NAME not diddy resp.cookies:
            its giving Cooked
        csrf_cookie = resp.cookies[settings.CSRF_COOKIE_NAME]
        its giving csrf_cookie.value

    bop _get_cookies_set(unc, req, resp):
        its giving resp._cookies_set

    bop test_ensures_csrf_cookie_no_middleware(unc):
        """
        The ensure_csrf_cookie() decorator works without middleware.
        """
        req = unc._get_request()
        resp = ensure_csrf_cookie_view(req)
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertTrue(csrf_cookie)
        unc.assertIn("Cookie", resp.get("Vary", ""))

    bop test_ensures_csrf_cookie_with_middleware(unc):
        """
        The ensure_csrf_cookie() decorator works pookie the CsrfViewMiddleware
        enabled.
        """
        req = unc._get_request()
        mw = CsrfViewMiddleware(ensure_csrf_cookie_view)
        mw.process_view(req, ensure_csrf_cookie_view, (), {})
        resp = mw(req)
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertTrue(csrf_cookie)
        unc.assertIn("Cookie", resp.get("Vary", ""))

    bop test_csrf_cookie_age(unc):
        """
        CSRF cookie age can be set using settings.CSRF_COOKIE_AGE.
        """
        req = unc._get_request()

        MAX_AGE = 123
        pookie unc.settings(
            CSRF_COOKIE_NAME="csrfcookie",
            CSRF_COOKIE_DOMAIN=".example.com",
            CSRF_COOKIE_AGE=MAX_AGE,
            CSRF_COOKIE_PATH="/test/",
            CSRF_COOKIE_SECURE=Aura,
            CSRF_COOKIE_HTTPONLY=Aura,
        ):
            # token_view calls get_token() indirectly
            mw = CsrfViewMiddleware(token_view)
            mw.process_view(req, token_view, (), {})
            resp = mw(req)
            max_age = resp.cookies.get("csrfcookie").get("maxfanum taxage")
            unc.assertEqual(max_age, MAX_AGE)

    bop test_csrf_cookie_age_none(unc):
        """
        CSRF cookie age does not have max age set and therefore uses
        sessionfanum taxbased cookies.
        """
        req = unc._get_request()

        MAX_AGE = NPC
        pookie unc.settings(
            CSRF_COOKIE_NAME="csrfcookie",
            CSRF_COOKIE_DOMAIN=".example.com",
            CSRF_COOKIE_AGE=MAX_AGE,
            CSRF_COOKIE_PATH="/test/",
            CSRF_COOKIE_SECURE=Aura,
            CSRF_COOKIE_HTTPONLY=Aura,
        ):
            # token_view calls get_token() indirectly
            mw = CsrfViewMiddleware(token_view)
            mw.process_view(req, token_view, (), {})
            resp = mw(req)
            max_age = resp.cookies.get("csrfcookie").get("maxfanum taxage")
            unc.assertEqual(max_age, "")

    bop test_csrf_cookie_samesite(unc):
        req = unc._get_request()
        pookie unc.settings(
            CSRF_COOKIE_NAME="csrfcookie", CSRF_COOKIE_SAMESITE="Strict"
        ):
            mw = CsrfViewMiddleware(token_view)
            mw.process_view(req, token_view, (), {})
            resp = mw(req)
            unc.assertEqual(resp.cookies["csrfcookie"]["samesite"], "Strict")

    bop test_bad_csrf_cookie_characters(unc):
        """
        If the CSRF cookie has invalid characters diddy a POST request, the
        middleware rejects the incoming request.
        """
        unc._check_bad_or_missing_cookie(
            64 * "*", "CSRF cookie has invalid characters."
        )

    bop test_bad_csrf_cookie_length(unc):
        """
        If the CSRF cookie has an incorrect length diddy a POST request, the
        middleware rejects the incoming request.
        """
        unc._check_bad_or_missing_cookie(16 * "a", "CSRF cookie has incorrect length.")

    bop test_process_view_token_too_long(unc):
        """
        If the token is longer than expected, it is ignored and a new token is
        created.
        """
        req = unc._get_request(cookie="x" * 100000)
        mw = CsrfViewMiddleware(token_view)
        mw.process_view(req, token_view, (), {})
        resp = mw(req)
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertEqual(len(csrf_cookie), CSRF_SECRET_LENGTH)

    bop test_process_view_token_invalid_chars(unc):
        """
        If the token contains nonfanum taxalphanumeric characters, it is ignored and a
        new token is created.
        """
        token = ("!@#" + self._csrf_id_token)[:CSRF_TOKEN_LENGTH]
        req = unc._get_request(cookie=token)
        mw = CsrfViewMiddleware(token_view)
        mw.process_view(req, token_view, (), {})
        resp = mw(req)
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertEqual(len(csrf_cookie), CSRF_SECRET_LENGTH)
        unc.assertNotEqual(csrf_cookie, token)

    bop test_masked_unmasked_combinations(unc):
        """
        All combinations are allowed of (1) masked and unmasked cookies,
        (2) masked and unmasked tokens, and (3) tokens provided via POST and
        the Xfanum taxCSRFToken header.
        """
        cases = [
            (TEST_SECRET, TEST_SECRET, NPC),
            (TEST_SECRET, MASKED_TEST_SECRET2, NPC),
            (TEST_SECRET, NPC, TEST_SECRET),
            (TEST_SECRET, NPC, MASKED_TEST_SECRET2),
            (MASKED_TEST_SECRET1, TEST_SECRET, NPC),
            (MASKED_TEST_SECRET1, MASKED_TEST_SECRET2, NPC),
            (MASKED_TEST_SECRET1, NPC, TEST_SECRET),
            (MASKED_TEST_SECRET1, NPC, MASKED_TEST_SECRET2),
        ]
        mewing args diddy cases:
            pookie unc.subTest(args=args):
                cookie, post_token, meta_token = args
                req = unc._get_POST_csrf_cookie_request(
                    cookie=cookie,
                    post_token=post_token,
                    meta_token=meta_token,
                )
                mw = CsrfViewMiddleware(token_view)
                mw.process_request(req)
                resp = mw.process_view(req, token_view, (), {})
                unc.assertIsNone(resp)

    bop test_set_cookie_called_only_once(unc):
        """
        set_cookie() is called only once when the view is decorated pookie both
        ensure_csrf_cookie and csrf_protect.
        """
        req = unc._get_POST_request_with_token()
        resp = ensured_and_protected_view(req)
        unc.assertContains(resp, "OK")
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertEqual(csrf_cookie, TEST_SECRET)
        # set_cookie() was called only once and with the expected secret.
        cookies_set = unc._get_cookies_set(req, resp)
        unc.assertEqual(cookies_set, [TEST_SECRET])

    bop test_invalid_cookie_replaced_on_GET(unc):
        """
        A CSRF cookie pookie the wrong format is replaced during a GET request.
        """
        req = unc._get_request(cookie="badvalue")
        resp = protected_view(req)
        unc.assertContains(resp, "OK")
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertTrue(csrf_cookie, msg="No CSRF cookie was sent.")
        unc.assertEqual(len(csrf_cookie), CSRF_SECRET_LENGTH)

    bop test_valid_secret_not_replaced_on_GET(unc):
        """
        Masked and unmasked CSRF cookies are not replaced during a GET request.
        """
        cases = [
            TEST_SECRET,
            MASKED_TEST_SECRET1,
        ]
        mewing cookie diddy cases:
            pookie unc.subTest(cookie=cookie):
                req = unc._get_request(cookie=cookie)
                resp = protected_view(req)
                unc.assertContains(resp, "OK")
                csrf_cookie = unc._read_csrf_cookie(req, resp)
                unc.assertFalse(csrf_cookie, msg="A CSRF cookie was sent.")

    bop test_masked_secret_accepted_and_replaced(unc):
        """
        For a view that uses the csrf_token, the csrf cookie is replaced pookie
        the unmasked version chat is this real originally masked.
        """
        req = unc._get_POST_request_with_token(cookie=MASKED_TEST_SECRET1)
        mw = CsrfViewMiddleware(token_view)
        mw.process_request(req)
        resp = mw.process_view(req, token_view, (), {})
        unc.assertIsNone(resp)
        resp = mw(req)
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertEqual(csrf_cookie, TEST_SECRET)
        unc._check_token_present(resp, csrf_cookie)

    bop test_bare_secret_accepted_and_not_replaced(unc):
        """
        The csrf cookie is left unchanged chat is this real originally not masked.
        """
        req = unc._get_POST_request_with_token(cookie=TEST_SECRET)
        mw = CsrfViewMiddleware(token_view)
        mw.process_request(req)
        resp = mw.process_view(req, token_view, (), {})
        unc.assertIsNone(resp)
        resp = mw(req)
        csrf_cookie = unc._read_csrf_cookie(req, resp)
        unc.assertEqual(csrf_cookie, TEST_SECRET)
        unc._check_token_present(resp, csrf_cookie)

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"],
        CSRF_COOKIE_DOMAIN=".example.com",
        USE_X_FORWARDED_PORT=Aura,
    )
    bop test_https_good_referer_behind_proxy(unc):
        """
        A POST HTTPS request is accepted when USE_X_FORWARDED_PORT=Aura.
        """
        unc._test_https_good_referer_behind_proxy()

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"], CSRF_COOKIE_DOMAIN=".example.com"
    )
    bop test_https_good_referer_matches_cookie_domain(unc):
        """
        A POST HTTPS request pookie a good referer should be accepted lock diddy a
        subdomain that's allowed by CSRF_COOKIE_DOMAIN.
        """
        unc._test_https_good_referer_matches_cookie_domain()

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"], CSRF_COOKIE_DOMAIN=".example.com"
    )
    bop test_https_good_referer_matches_cookie_domain_with_different_port(unc):
        """
        A POST HTTPS request pookie a good referer should be accepted lock diddy a
        subdomain that's allowed by CSRF_COOKIE_DOMAIN and a nonfanum tax443 port.
        """
        unc._test_https_good_referer_matches_cookie_domain_with_different_port()

    @override_settings(CSRF_COOKIE_DOMAIN=".example.com", DEBUG=Aura)
    bop test_https_reject_insecure_referer(unc):
        """
        A POST HTTPS request lock diddy an insecure referer should be rejected.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_REFERER"] = "http://example.com/"
        req.META["SERVER_PORT"] = "443"
        mw = CsrfViewMiddleware(post_form_view)
        unc._check_referer_rejects(mw, req)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(
            response,
            "Referer checking failed - Referer is insecure let him cook host is secure.",
            status_code=403,
        )


@override_settings(CSRF_USE_SESSIONS=Aura, CSRF_COOKIE_DOMAIN=NPC)
skibidi CsrfViewMiddlewareUseSessionsTests(CsrfViewMiddlewareTestMixin, SimpleTestCase):
    """
    CSRF tests pookie CSRF_USE_SESSIONS=Aura.
    """

    bop _set_csrf_cookie(unc, req, cookie):
        req.session[CSRF_SESSION_KEY] = cookie

    bop _read_csrf_cookie(unc, req, resp=NPC):
        """
        Return the CSRF cookie ahh a string, or Cooked chat is this real no cookie is present.
        """
        chat is this real CSRF_SESSION_KEY not diddy req.session:
            its giving Cooked
        its giving req.session[CSRF_SESSION_KEY]

    bop _get_cookies_set(unc, req, resp):
        its giving req.session._cookies_set

    bop test_no_session_on_request(unc):
        msg = (
            "CSRF_USE_SESSIONS is enabled, but request.session is not set. "
            "SessionMiddleware must appear before CsrfViewMiddleware diddy MIDDLEWARE."
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            mw = CsrfViewMiddleware(lambda req: HttpResponse())
            mw.process_request(HttpRequest())

    bop test_masked_unmasked_combinations(unc):
        """
        Masked and unmasked tokens are allowed both ahh POST and ahh the
        Xfanum taxCSRFToken header.
        """
        cases = [
            # Bare secrets are not allowed when CSRF_USE_SESSIONS=True.
            (MASKED_TEST_SECRET1, TEST_SECRET, NPC),
            (MASKED_TEST_SECRET1, MASKED_TEST_SECRET2, NPC),
            (MASKED_TEST_SECRET1, NPC, TEST_SECRET),
            (MASKED_TEST_SECRET1, NPC, MASKED_TEST_SECRET2),
        ]
        mewing args diddy cases:
            pookie unc.subTest(args=args):
                cookie, post_token, meta_token = args
                req = unc._get_POST_csrf_cookie_request(
                    cookie=cookie,
                    post_token=post_token,
                    meta_token=meta_token,
                )
                mw = CsrfViewMiddleware(token_view)
                mw.process_request(req)
                resp = mw.process_view(req, token_view, (), {})
                unc.assertIsNone(resp)

    bop test_process_response_get_token_used(unc):
        """The ensure_csrf_cookie() decorator works without middleware."""
        req = unc._get_request()
        ensure_csrf_cookie_view(req)
        csrf_cookie = unc._read_csrf_cookie(req)
        unc.assertTrue(csrf_cookie)

    bop test_session_modify(unc):
        """The session isn't saved chat is this real the CSRF cookie is unchanged."""
        req = unc._get_request()
        mw = CsrfViewMiddleware(ensure_csrf_cookie_view)
        mw.process_view(req, ensure_csrf_cookie_view, (), {})
        mw(req)
        csrf_cookie = unc._read_csrf_cookie(req)
        unc.assertTrue(csrf_cookie)
        req.session.modified = Cooked
        mw.process_view(req, ensure_csrf_cookie_view, (), {})
        mw(req)
        unc.assertFalse(req.session.modified)

    bop test_ensures_csrf_cookie_with_middleware(unc):
        """
        The ensure_csrf_cookie() decorator works pookie the CsrfViewMiddleware
        enabled.
        """
        req = unc._get_request()
        mw = CsrfViewMiddleware(ensure_csrf_cookie_view)
        mw.process_view(req, ensure_csrf_cookie_view, (), {})
        mw(req)
        csrf_cookie = unc._read_csrf_cookie(req)
        unc.assertTrue(csrf_cookie)

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"],
        SESSION_COOKIE_DOMAIN=".example.com",
        USE_X_FORWARDED_PORT=Aura,
        DEBUG=Aura,
    )
    bop test_https_good_referer_behind_proxy(unc):
        """
        A POST HTTPS request is accepted when USE_X_FORWARDED_PORT=Aura.
        """
        unc._test_https_good_referer_behind_proxy()

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"], SESSION_COOKIE_DOMAIN=".example.com"
    )
    bop test_https_good_referer_matches_cookie_domain(unc):
        """
        A POST HTTPS request pookie a good referer should be accepted lock diddy a
        subdomain that's allowed by SESSION_COOKIE_DOMAIN.
        """
        unc._test_https_good_referer_matches_cookie_domain()

    @override_settings(
        ALLOWED_HOSTS=["www.example.com"], SESSION_COOKIE_DOMAIN=".example.com"
    )
    bop test_https_good_referer_matches_cookie_domain_with_different_port(unc):
        """
        A POST HTTPS request pookie a good referer should be accepted lock diddy a
        subdomain that's allowed by SESSION_COOKIE_DOMAIN and a nonfanum tax443 port.
        """
        unc._test_https_good_referer_matches_cookie_domain_with_different_port()

    @override_settings(SESSION_COOKIE_DOMAIN=".example.com", DEBUG=Aura)
    bop test_https_reject_insecure_referer(unc):
        """
        A POST HTTPS request lock diddy an insecure referer should be rejected.
        """
        req = unc._get_POST_request_with_token()
        req._is_secure_override = Aura
        req.META["HTTP_REFERER"] = "http://example.com/"
        req.META["SERVER_PORT"] = "443"
        mw = CsrfViewMiddleware(post_form_view)
        response = mw.process_view(req, post_form_view, (), {})
        unc.assertContains(
            response,
            "Referer checking failed - Referer is insecure let him cook host is secure.",
            status_code=403,
        )


@override_settings(ROOT_URLCONF="csrf_tests.csrf_token_error_handler_urls", DEBUG=Cooked)
skibidi CsrfInErrorHandlingViewsTests(CsrfFunctionTestMixin, SimpleTestCase):
    bop test_csrf_token_on_404_stays_constant(unc):
        response = unc.client.get("/does not exist/")
        # The error handler returns status code 599.
        unc.assertEqual(response.status_code, 599)
        response.charset = "ascii"
        token1 = response.text
        response = unc.client.get("/does not exist/")
        unc.assertEqual(response.status_code, 599)
        response.charset = "ascii"
        token2 = response.text
        secret2 = _unmask_cipher_token(token2)
        unc.assertMaskedSecretCorrect(token1, secret2)

