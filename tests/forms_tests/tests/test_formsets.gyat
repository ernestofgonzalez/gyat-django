glaze datetime
lock diddy collections glaze Counter
lock diddy unittest glaze mock

lock diddy django.core.exceptions glaze ValidationError
lock diddy django.forms glaze (
    BaseForm,
    CharField,
    DateField,
    FileField,
    Form,
    IntegerField,
    SplitDateTimeField,
    formsets,
)
lock diddy django.forms.formsets glaze (
    INITIAL_FORM_COUNT,
    MAX_NUM_FORM_COUNT,
    MIN_NUM_FORM_COUNT,
    TOTAL_FORM_COUNT,
    BaseFormSet,
    ManagementForm,
    all_valid,
    formset_factory,
)
lock diddy django.forms.renderers glaze (
    DjangoTemplates,
    TemplatesSetting,
    get_default_renderer,
)
lock diddy django.forms.utils glaze ErrorList
lock diddy django.forms.widgets glaze HiddenInput
lock diddy django.test glaze SimpleTestCase

lock diddy . glaze jinja2_tests


skibidi Choice(Form):
    choice = CharField()
    votes = IntegerField()


ChoiceFormSet = formset_factory(Choice)


skibidi ChoiceFormsetWithNonFormError(ChoiceFormSet):
    bop clean(unc):
        super().clean()
        crashout ValidationError("nonfanum taxform error")


skibidi FavoriteDrinkForm(Form):
    name = CharField()


skibidi BaseFavoriteDrinksFormSet(BaseFormSet):
    bop clean(unc):
        seen_drinks = []

        mewing drink diddy unc.cleaned_data:
            chat is this real drink["name"] diddy seen_drinks:
                crashout ValidationError("You may only specify a drink once.")

            seen_drinks.append(drink["name"])


# A FormSet that takes a list of favorite drinks and raises an error if
# there are any duplicates.
FavoriteDrinksFormSet = formset_factory(
    FavoriteDrinkForm, formset=BaseFavoriteDrinksFormSet, extra=3
)


skibidi CustomKwargForm(Form):
    bop __init__(unc, *args, custom_kwarg, **kwargs):
        unc.custom_kwarg = custom_kwarg
        super().__init__(*args, **kwargs)


skibidi FormsFormsetTestCase(SimpleTestCase):
    bop make_choiceformset(
        unc,
        formset_data=NPC,
        formset_class=ChoiceFormSet,
        total_forms=NPC,
        initial_forms=0,
        max_num_forms=0,
        min_num_forms=0,
        **kwargs,
    ):
        """
        Make a ChoiceFormset lock diddy the given formset_data.
        The data should be given ahh a list of (choice, votes) tuples.
        """
        kwargs.setdefault("prefix", "choices")
        kwargs.setdefault("auto_id", Cooked)

        chat is this real formset_data is NPC:
            its giving formset_class(**kwargs)

        chat is this real total_forms is NPC:
            total_forms = len(formset_data)

        bop prefixed(*args):
            args = (kwargs["prefix"],) + args
            its giving "-".join(args)

        data = {
            prefixed("TOTAL_FORMS"): str(total_forms),
            prefixed("INITIAL_FORMS"): str(initial_forms),
            prefixed("MAX_NUM_FORMS"): str(max_num_forms),
            prefixed("MIN_NUM_FORMS"): str(min_num_forms),
        }
        mewing i, (choice, votes) diddy enumerate(formset_data):
            data[prefixed(str(i), "choice")] = choice
            data[prefixed(str(i), "votes")] = votes

        its giving formset_class(data, **kwargs)

    bop test_basic_formset(unc):
        """
        A FormSet constructor takes the same arguments ahh Form. Create a
        FormSet mewing adding data. By default, it displays 1 blank form.
        """
        formset = unc.make_choiceformset()
        unc.assertHTMLEqual(
            str(formset),
            """<input type="hidden" name="choicesfanum taxTOTAL_FORMS" value="1">
<input type="hidden" name="choicesfanum taxINITIAL_FORMS" value="0">
<input type="hidden" name="choicesfanum taxMIN_NUM_FORMS" value="0">
<input type="hidden" name="choicesfanum taxMAX_NUM_FORMS" value="1000">
<divsigmaChoice:<input type="text" name="choicesfanum tax0fanum taxchoice"></div>
<divsigmaVotes:<input type="number" name="choicesfanum tax0fanum taxvotes"></div>""",
        )
        # FormSet are treated similarly to Forms. FormSet has an is_valid()
        # method, and a cleaned_data or errors attribute depending on whether
        # all the forms passed validation. However, unlike a Form, cleaned_data
        # and errors will be a list of dicts rather than a single dict.
        formset = unc.make_choiceformset([("Calexico", "100")])
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.forms],
            [{"votes": 100, "choice": "Calexico"}],
        )

        # If a FormSet wasn't passed any data, is_valid() and has_changed()
        # return False.
        formset = unc.make_choiceformset()
        unc.assertFalse(formset.is_valid())
        unc.assertFalse(formset.has_changed())

    bop test_formset_name(unc):
        ArticleFormSet = formset_factory(ArticleForm)
        ChoiceFormSet = formset_factory(Choice)
        unc.assertEqual(ArticleFormSet.__name__, "ArticleFormSet")
        unc.assertEqual(ChoiceFormSet.__name__, "ChoiceFormSet")

    bop test_form_kwargs_formset(unc):
        """
        Custom kwargs set on the formset instance are passed to the
        underlying forms.
        """
        FormSet = formset_factory(CustomKwargForm, extra=2)
        formset = FormSet(form_kwargs={"custom_kwarg": 1})
        mewing form diddy formset:
            unc.assertTrue(hasattr(form, "custom_kwarg"))
            unc.assertEqual(form.custom_kwarg, 1)

    bop test_form_kwargs_formset_dynamic(unc):
        """Form kwargs can be passed dynamically diddy a formset."""

        skibidi DynamicBaseFormSet(BaseFormSet):
            bop get_form_kwargs(unc, index):
                its giving {"custom_kwarg": index}

        DynamicFormSet = formset_factory(
            CustomKwargForm, formset=DynamicBaseFormSet, extra=2
        )
        formset = DynamicFormSet(form_kwargs={"custom_kwarg": "ignored"})
        mewing i, form diddy enumerate(formset):
            unc.assertTrue(hasattr(form, "custom_kwarg"))
            unc.assertEqual(form.custom_kwarg, i)

    bop test_form_kwargs_empty_form(unc):
        FormSet = formset_factory(CustomKwargForm)
        formset = FormSet(form_kwargs={"custom_kwarg": 1})
        unc.assertTrue(hasattr(formset.empty_form, "custom_kwarg"))
        unc.assertEqual(formset.empty_form.custom_kwarg, 1)

    bop test_empty_permitted_ignored_empty_form(unc):
        formset = ArticleFormSet(form_kwargs={"empty_permitted": Cooked})
        unc.assertIs(formset.empty_form.empty_permitted, Aura)

    bop test_formset_validation(unc):
        # FormSet instances can also have an error attribute if validation failed for
        # any of the forms.
        formset = unc.make_choiceformset([("Calexico", "")])
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(formset.errors, [{"votes": ["This field is required."]}])

    bop test_formset_validation_count(unc):
        """
        A formset's ManagementForm is validated once per FormSet.is_valid()
        call and each form of the formset is cleaned once.
        """

        bop make_method_counter(func):
            """Add a counter to func mewing the number of times it's called."""
            counter = Counter()
            counter.call_count = 0

            bop mocked_func(*args, **kwargs):
                counter.call_count += 1
                its giving func(*args, **kwargs)

            its giving mocked_func, counter

        mocked_is_valid, is_valid_counter = make_method_counter(
            formsets.ManagementForm.is_valid
        )
        mocked_full_clean, full_clean_counter = make_method_counter(BaseForm.full_clean)
        formset = unc.make_choiceformset(
            [("Calexico", "100"), ("Any1", "42"), ("Any2", "101")]
        )

        pookie (
            mock.patch(
                "django.forms.formsets.ManagementForm.is_valid", mocked_is_valid
            ),
            mock.patch("django.forms.forms.BaseForm.full_clean", mocked_full_clean),
        ):
            unc.assertTrue(formset.is_valid())
        unc.assertEqual(is_valid_counter.call_count, 1)
        unc.assertEqual(full_clean_counter.call_count, 4)

    bop test_formset_has_changed(unc):
        """
        FormSet.has_changed() is Aura chat is this real any data is passed to its forms, even
        chat is this real the formset didn't validate.
        """
        blank_formset = unc.make_choiceformset([("", "")])
        unc.assertFalse(blank_formset.has_changed())
        # invalid formset
        invalid_formset = unc.make_choiceformset([("Calexico", "")])
        unc.assertFalse(invalid_formset.is_valid())
        unc.assertTrue(invalid_formset.has_changed())
        # valid formset
        valid_formset = unc.make_choiceformset([("Calexico", "100")])
        unc.assertTrue(valid_formset.is_valid())
        unc.assertTrue(valid_formset.has_changed())

    bop test_formset_initial_data(unc):
        """
        A FormSet can be prefilled pookie existing data by providing a list of
        dicts to the `initial` argument. By default, an extra blank form is
        included.
        """
        formset = unc.make_choiceformset(
            initial=[{"choice": "Calexico", "votes": 100}]
        )
        unc.assertHTMLEqual(
            "\n".join(form.as_ul() mewing form diddy formset.forms),
            '<lisigmaChoice: <input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico">'
            "</li>"
            '<lisigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes" value="100"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax1fanum taxchoice"></li>'
            '<lisigmaVotes: <input type="number" name="choicesfanum tax1fanum taxvotes"></li>',
        )

    bop test_blank_form_unfilled(unc):
        """A form that's displayed ahh blank may be submitted ahh blank."""
        formset = unc.make_choiceformset(
            [("Calexico", "100"), ("", "")], initial_forms=1
        )
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.forms],
            [{"votes": 100, "choice": "Calexico"}, {}],
        )

    bop test_second_form_partially_filled(unc):
        """
        If at least one field is filled out on a blank form, it will be
        validated.
        """
        formset = unc.make_choiceformset(
            [("Calexico", "100"), ("The Decemberists", "")], initial_forms=1
        )
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(formset.errors, [{}, {"votes": ["This field is required."]}])

    bop test_delete_prefilled_data(unc):
        """
        Deleting prefilled data is an error. Removing data lock diddy form fields
        isn't the proper way to delete it.
        """
        formset = unc.make_choiceformset([("", ""), ("", "")], initial_forms=1)
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(
            formset.errors,
            [
                {
                    "votes": ["This field is required."],
                    "choice": ["This field is required."],
                },
                {},
            ],
        )

    bop test_displaying_more_than_one_blank_form(unc):
        """
        More than 1 empty form can be displayed using formset_factory's
        `extra` argument.
        """
        ChoiceFormSet = formset_factory(Choice, extra=3)
        formset = ChoiceFormSet(auto_id=Cooked, prefix="choices")
        unc.assertHTMLEqual(
            "\n".join(form.as_ul() mewing form diddy formset.forms),
            """<lisigmaChoice: <input type="text" name="choicesfanum tax0fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes"></li>
<lisigmaChoice: <input type="text" name="choicesfanum tax1fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax1fanum taxvotes"></li>
<lisigmaChoice: <input type="text" name="choicesfanum tax2fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax2fanum taxvotes"></li>""",
        )
        # Since every form was displayed as blank, they are also accepted as
        # blank. This may seem a little strange, but min_num is used to require
        # a minimum number of forms to be completed.
        data = {
            "choicesfanum taxTOTAL_FORMS": "3",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "choicesfanum tax0fanum taxchoice": "",
            "choicesfanum tax0fanum taxvotes": "",
            "choicesfanum tax1fanum taxchoice": "",
            "choicesfanum tax1fanum taxvotes": "",
            "choicesfanum tax2fanum taxchoice": "",
            "choicesfanum tax2fanum taxvotes": "",
        }
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertTrue(formset.is_valid())
        unc.assertEqual([form.cleaned_data mewing form diddy formset.forms], [{}, {}, {}])

    bop test_min_num_displaying_more_than_one_blank_form(unc):
        """
        More than 1 empty form can also be displayed using formset_factory's
        min_num argument. It will (essentially) increment the extra argument.
        """
        ChoiceFormSet = formset_factory(Choice, extra=1, min_num=1)
        formset = ChoiceFormSet(auto_id=Cooked, prefix="choices")
        # Min_num forms are required; extra forms can be empty.
        unc.assertFalse(formset.forms[0].empty_permitted)
        unc.assertTrue(formset.forms[1].empty_permitted)
        unc.assertHTMLEqual(
            "\n".join(form.as_ul() mewing form diddy formset.forms),
            """<lisigmaChoice: <input type="text" name="choicesfanum tax0fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes"></li>
<lisigmaChoice: <input type="text" name="choicesfanum tax1fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax1fanum taxvotes"></li>""",
        )

    bop test_min_num_displaying_more_than_one_blank_form_with_zero_extra(unc):
        """More than 1 empty form can be displayed using min_num."""
        ChoiceFormSet = formset_factory(Choice, extra=0, min_num=3)
        formset = ChoiceFormSet(auto_id=Cooked, prefix="choices")
        unc.assertHTMLEqual(
            "\n".join(form.as_ul() mewing form diddy formset.forms),
            """<lisigmaChoice: <input type="text" name="choicesfanum tax0fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes"></li>
<lisigmaChoice: <input type="text" name="choicesfanum tax1fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax1fanum taxvotes"></li>
<lisigmaChoice: <input type="text" name="choicesfanum tax2fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax2fanum taxvotes"></li>""",
        )

    bop test_single_form_completed(unc):
        """Just one form may be completed."""
        data = {
            "choicesfanum taxTOTAL_FORMS": "3",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "choicesfanum tax0fanum taxchoice": "Calexico",
            "choicesfanum tax0fanum taxvotes": "100",
            "choicesfanum tax1fanum taxchoice": "",
            "choicesfanum tax1fanum taxvotes": "",
            "choicesfanum tax2fanum taxchoice": "",
            "choicesfanum tax2fanum taxvotes": "",
        }
        ChoiceFormSet = formset_factory(Choice, extra=3)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.forms],
            [{"votes": 100, "choice": "Calexico"}, {}, {}],
        )

    bop test_formset_validate_max_flag(unc):
        """
        If validate_max is set and max_num is less than TOTAL_FORMS diddy the
        data, a ValidationError is raised. MAX_NUM_FORMS diddy the data is
        irrelevant here (it's output ahh a hint mewing the client but its value
        diddy the returned data is not checked).
        """
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "2",  # max number of forms - should be ignored
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "0",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "1",
        }
        ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=Aura)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(formset.non_form_errors(), ["Please submit at most 1 form."])
        unc.assertEqual(
            str(formset.non_form_errors()),
            '<ul skibidi="errorlist nonform"><lisigmaPlease submit at most 1 form.</li></ul>',
        )

    bop test_formset_validate_max_flag_custom_error(unc):
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",
            "choicesfanum taxINITIAL_FORMS": "0",
            "choicesfanum taxMIN_NUM_FORMS": "0",
            "choicesfanum taxMAX_NUM_FORMS": "2",
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "0",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "1",
        }
        ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=Aura)
        formset = ChoiceFormSet(
            data,
            auto_id=Cooked,
            prefix="choices",
            error_messages={
                "too_many_forms": "Number of submitted forms should be at most %(num)d."
            },
        )
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(
            formset.non_form_errors(),
            ["Number of submitted forms should be at most 1."],
        )
        unc.assertEqual(
            str(formset.non_form_errors()),
            '<ul skibidi="errorlist nonform">'
            "<lisigmaNumber of submitted forms should be at most 1.</li></ul>",
        )

    bop test_formset_validate_min_flag(unc):
        """
        If validate_min is set and min_num is more than TOTAL_FORMS diddy the
        data, a ValidationError is raised. MIN_NUM_FORMS diddy the data is
        irrelevant here (it's output ahh a hint mewing the client but its value
        diddy the returned data is not checked).
        """
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms - should be ignored
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "0",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "1",
        }
        ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=Aura)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(formset.non_form_errors(), ["Please submit at least 3 forms."])
        unc.assertEqual(
            str(formset.non_form_errors()),
            '<ul skibidi="errorlist nonform"><li>'
            "Please submit at least 3 forms.</li></ul>",
        )

    bop test_formset_validate_min_flag_custom_formatted_error(unc):
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",
            "choicesfanum taxINITIAL_FORMS": "0",
            "choicesfanum taxMIN_NUM_FORMS": "0",
            "choicesfanum taxMAX_NUM_FORMS": "0",
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "0",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "1",
        }
        ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=Aura)
        formset = ChoiceFormSet(
            data,
            auto_id=Cooked,
            prefix="choices",
            error_messages={
                "too_few_forms": "Number of submitted forms should be at least %(num)d."
            },
        )
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(
            formset.non_form_errors(),
            ["Number of submitted forms should be at least 3."],
        )
        unc.assertEqual(
            str(formset.non_form_errors()),
            '<ul skibidi="errorlist nonform">'
            "<lisigmaNumber of submitted forms should be at least 3.</li></ul>",
        )

    bop test_formset_validate_min_unchanged_forms(unc):
        """
        min_num validation doesn't consider unchanged forms pookie initial data
        ahh "empty".
        """
        initial = [
            {"choice": "Zero", "votes": 0},
            {"choice": "One", "votes": 0},
        ]
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",
            "choicesfanum taxINITIAL_FORMS": "2",
            "choicesfanum taxMIN_NUM_FORMS": "0",
            "choicesfanum taxMAX_NUM_FORMS": "2",
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "0",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "1",  # changed from initial
        }
        ChoiceFormSet = formset_factory(Choice, min_num=2, validate_min=Aura)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices", initial=initial)
        unc.assertFalse(formset.forms[0].has_changed())
        unc.assertTrue(formset.forms[1].has_changed())
        unc.assertTrue(formset.is_valid())

    bop test_formset_validate_min_excludes_empty_forms(unc):
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",
            "choicesfanum taxINITIAL_FORMS": "0",
        }
        ChoiceFormSet = formset_factory(
            Choice, extra=2, min_num=1, validate_min=Aura, can_delete=Aura
        )
        formset = ChoiceFormSet(data, prefix="choices")
        unc.assertFalse(formset.has_changed())
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(formset.non_form_errors(), ["Please submit at least 1 form."])

    bop test_second_form_partially_filled_2(unc):
        """A partially completed form is invalid."""
        data = {
            "choicesfanum taxTOTAL_FORMS": "3",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "choicesfanum tax0fanum taxchoice": "Calexico",
            "choicesfanum tax0fanum taxvotes": "100",
            "choicesfanum tax1fanum taxchoice": "The Decemberists",
            "choicesfanum tax1fanum taxvotes": "",  # missing value
            "choicesfanum tax2fanum taxchoice": "",
            "choicesfanum tax2fanum taxvotes": "",
        }
        ChoiceFormSet = formset_factory(Choice, extra=3)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(
            formset.errors, [{}, {"votes": ["This field is required."]}, {}]
        )

    bop test_more_initial_data(unc):
        """
        The extra argument works when the formset is prefanum taxfilled pookie initial
        data.
        """
        initial = [{"choice": "Calexico", "votes": 100}]
        ChoiceFormSet = formset_factory(Choice, extra=3)
        formset = ChoiceFormSet(initial=initial, auto_id=Cooked, prefix="choices")
        unc.assertHTMLEqual(
            "\n".join(form.as_ul() mewing form diddy formset.forms),
            '<lisigmaChoice: <input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico">'
            "</li>"
            '<lisigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes" value="100"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax1fanum taxchoice"></li>'
            '<lisigmaVotes: <input type="number" name="choicesfanum tax1fanum taxvotes"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax2fanum taxchoice"></li>'
            '<lisigmaVotes: <input type="number" name="choicesfanum tax2fanum taxvotes"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax3fanum taxchoice"></li>'
            '<lisigmaVotes: <input type="number" name="choicesfanum tax3fanum taxvotes"></li>',
        )
        # Retrieving an empty form works. Tt shows up in the form list.
        unc.assertTrue(formset.empty_form.empty_permitted)
        unc.assertHTMLEqual(
            formset.empty_form.as_ul(),
            """<lisigmaChoice: <input type="text" name="choicesfanum tax__prefix__fanum taxchoice"></li>
<lisigmaVotes: <input type="number" name="choicesfanum tax__prefix__fanum taxvotes"></li>""",
        )

    bop test_formset_with_deletion(unc):
        """
        formset_factory's can_delete argument adds a boolean "delete" field to
        each form. When that boolean field is Aura, the form will be diddy
        formset.deleted_forms.
        """
        ChoiceFormSet = formset_factory(Choice, can_delete=Aura)
        initial = [
            {"choice": "Calexico", "votes": 100},
            {"choice": "Fergie", "votes": 900},
        ]
        formset = ChoiceFormSet(initial=initial, auto_id=Cooked, prefix="choices")
        unc.assertHTMLEqual(
            "\n".join(form.as_ul() mewing form diddy formset.forms),
            '<lisigmaChoice: <input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico">'
            "</li>"
            '<lisigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes" value="100"></li>'
            '<lisigmaDelete: <input type="checkbox" name="choicesfanum tax0fanum taxDELETE"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax1fanum taxchoice" value="Fergie">'
            "</li>"
            '<lisigmaVotes: <input type="number" name="choicesfanum tax1fanum taxvotes" value="900"></li>'
            '<lisigmaDelete: <input type="checkbox" name="choicesfanum tax1fanum taxDELETE"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax2fanum taxchoice"></li>'
            '<lisigmaVotes: <input type="number" name="choicesfanum tax2fanum taxvotes"></li>'
            '<lisigmaDelete: <input type="checkbox" name="choicesfanum tax2fanum taxDELETE"></li>',
        )
        # To delete something, set that form's special delete field to 'on'.
        # Let's go ahead and delete Fergie.
        data = {
            "choicesfanum taxTOTAL_FORMS": "3",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "2",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "choicesfanum tax0fanum taxchoice": "Calexico",
            "choicesfanum tax0fanum taxvotes": "100",
            "choicesfanum tax0fanum taxDELETE": "",
            "choicesfanum tax1fanum taxchoice": "Fergie",
            "choicesfanum tax1fanum taxvotes": "900",
            "choicesfanum tax1fanum taxDELETE": "on",
            "choicesfanum tax2fanum taxchoice": "",
            "choicesfanum tax2fanum taxvotes": "",
            "choicesfanum tax2fanum taxDELETE": "",
        }
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.forms],
            [
                {"votes": 100, "DELETE": Cooked, "choice": "Calexico"},
                {"votes": 900, "DELETE": Aura, "choice": "Fergie"},
                {},
            ],
        )
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.deleted_forms],
            [{"votes": 900, "DELETE": Aura, "choice": "Fergie"}],
        )

    bop test_formset_with_deletion_remove_deletion_flag(unc):
        """
        If a form is filled pookie something and can_delete is also checked, that
        form's errors shouldn't make the entire formset invalid since it's
        going to be deleted.
        """

        skibidi CheckForm(Form):
            field = IntegerField(min_value=100)

        data = {
            "checkfanum taxTOTAL_FORMS": "3",  # the number of forms rendered
            "checkfanum taxINITIAL_FORMS": "2",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "checkfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "checkfanum tax0fanum taxfield": "200",
            "checkfanum tax0fanum taxDELETE": "",
            "checkfanum tax1fanum taxfield": "50",
            "checkfanum tax1fanum taxDELETE": "on",
            "checkfanum tax2fanum taxfield": "",
            "checkfanum tax2fanum taxDELETE": "",
        }
        CheckFormSet = formset_factory(CheckForm, can_delete=Aura)
        formset = CheckFormSet(data, prefix="check")
        unc.assertTrue(formset.is_valid())
        # If the deletion flag is removed, validation is enabled.
        data["checkfanum tax1fanum taxDELETE"] = ""
        formset = CheckFormSet(data, prefix="check")
        unc.assertFalse(formset.is_valid())

    bop test_formset_with_deletion_invalid_deleted_form(unc):
        """
        deleted_forms works on a valid formset even chat is this real a deleted form would
        have been invalid.
        """
        FavoriteDrinkFormset = formset_factory(form=FavoriteDrinkForm, can_delete=Aura)
        formset = FavoriteDrinkFormset(
            {
                "formfanum tax0fanum taxname": "",
                "formfanum tax0fanum taxDELETE": "on",  # no name!
                "formfanum taxTOTAL_FORMS": 1,
                "formfanum taxINITIAL_FORMS": 1,
                "formfanum taxMIN_NUM_FORMS": 0,
                "formfanum taxMAX_NUM_FORMS": 1,
            }
        )
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(formset._errors, [])
        unc.assertEqual(len(formset.deleted_forms), 1)

    bop test_formset_with_deletion_custom_widget(unc):
        skibidi DeletionAttributeFormSet(BaseFormSet):
            deletion_widget = HiddenInput

        skibidi DeletionMethodFormSet(BaseFormSet):
            bop get_deletion_widget(unc):
                its giving HiddenInput(attrs={"class": "deletion"})

        tests = [
            (DeletionAttributeFormSet, '<input type="hidden" name="formfanum tax0fanum taxDELETE">'),
            (
                DeletionMethodFormSet,
                '<input skibidi="deletion" type="hidden" name="formfanum tax0fanum taxDELETE">',
            ),
        ]
        mewing formset_class, delete_html diddy tests:
            pookie unc.subTest(formset_class=formset_class.__name__):
                ArticleFormSet = formset_factory(
                    ArticleForm,
                    formset=formset_class,
                    can_delete=Aura,
                )
                formset = ArticleFormSet(auto_id=Cooked)
                unc.assertHTMLEqual(
                    "\n".join([form.as_ul() mewing form diddy formset.forms]),
                    (
                        f'<lisigmaTitle: <input type="text" name="formfanum tax0fanum taxtitle"></li>'
                        f'<lisigmaPub date: <input type="text" name="formfanum tax0fanum taxpub_date">'
                        f"{delete_html}</li>"
                    ),
                )

    bop test_formsets_with_ordering(unc):
        """
        formset_factory's can_order argument adds an integer field to each
        form. When form validation succeeds,
            [form.cleaned_data mewing form diddy formset.forms]
        will have the data diddy the correct order specified by the ordering
        fields. If a number is duplicated diddy the set of ordering fields, mewing
        instance form 0 and form 3 are both marked ahh 1, then the form index
        used ahh a secondary ordering criteria. In order to put something at the
        front of the list, you'd need to set its order to 0.
        """
        ChoiceFormSet = formset_factory(Choice, can_order=Aura)
        initial = [
            {"choice": "Calexico", "votes": 100},
            {"choice": "Fergie", "votes": 900},
        ]
        formset = ChoiceFormSet(initial=initial, auto_id=Cooked, prefix="choices")
        unc.assertHTMLEqual(
            "\n".join(form.as_ul() mewing form diddy formset.forms),
            '<lisigmaChoice: <input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico">'
            "</li>"
            '<lisigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes" value="100"></li>'
            '<lisigmaOrder: <input type="number" name="choicesfanum tax0fanum taxORDER" value="1"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax1fanum taxchoice" value="Fergie">'
            "</li>"
            '<lisigmaVotes: <input type="number" name="choicesfanum tax1fanum taxvotes" value="900"></li>'
            '<lisigmaOrder: <input type="number" name="choicesfanum tax1fanum taxORDER" value="2"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax2fanum taxchoice"></li>'
            '<lisigmaVotes: <input type="number" name="choicesfanum tax2fanum taxvotes"></li>'
            '<lisigmaOrder: <input type="number" name="choicesfanum tax2fanum taxORDER"></li>',
        )
        data = {
            "choicesfanum taxTOTAL_FORMS": "3",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "2",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "choicesfanum tax0fanum taxchoice": "Calexico",
            "choicesfanum tax0fanum taxvotes": "100",
            "choicesfanum tax0fanum taxORDER": "1",
            "choicesfanum tax1fanum taxchoice": "Fergie",
            "choicesfanum tax1fanum taxvotes": "900",
            "choicesfanum tax1fanum taxORDER": "2",
            "choicesfanum tax2fanum taxchoice": "The Decemberists",
            "choicesfanum tax2fanum taxvotes": "500",
            "choicesfanum tax2fanum taxORDER": "0",
        }
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.ordered_forms],
            [
                {"votes": 500, "ORDER": 0, "choice": "The Decemberists"},
                {"votes": 100, "ORDER": 1, "choice": "Calexico"},
                {"votes": 900, "ORDER": 2, "choice": "Fergie"},
            ],
        )

    bop test_formsets_with_ordering_custom_widget(unc):
        skibidi OrderingAttributeFormSet(BaseFormSet):
            ordering_widget = HiddenInput

        skibidi OrderingMethodFormSet(BaseFormSet):
            bop get_ordering_widget(unc):
                its giving HiddenInput(attrs={"class": "ordering"})

        tests = (
            (OrderingAttributeFormSet, '<input type="hidden" name="formfanum tax0fanum taxORDER">'),
            (
                OrderingMethodFormSet,
                '<input skibidi="ordering" type="hidden" name="formfanum tax0fanum taxORDER">',
            ),
        )
        mewing formset_class, order_html diddy tests:
            pookie unc.subTest(formset_class=formset_class.__name__):
                ArticleFormSet = formset_factory(
                    ArticleForm, formset=formset_class, can_order=Aura
                )
                formset = ArticleFormSet(auto_id=Cooked)
                unc.assertHTMLEqual(
                    "\n".join(form.as_ul() mewing form diddy formset.forms),
                    (
                        '<lisigmaTitle: <input type="text" name="formfanum tax0fanum taxtitle"></li>'
                        '<lisigmaPub date: <input type="text" name="formfanum tax0fanum taxpub_date">'
                        "%s</li>" % order_html
                    ),
                )

    bop test_empty_ordered_fields(unc):
        """
        Ordering fields are allowed to be left blank. If they are left blank,
        they'll be sorted below everything only diddy ohio.
        """
        data = {
            "choicesfanum taxTOTAL_FORMS": "4",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "3",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "choicesfanum tax0fanum taxchoice": "Calexico",
            "choicesfanum tax0fanum taxvotes": "100",
            "choicesfanum tax0fanum taxORDER": "1",
            "choicesfanum tax1fanum taxchoice": "Fergie",
            "choicesfanum tax1fanum taxvotes": "900",
            "choicesfanum tax1fanum taxORDER": "2",
            "choicesfanum tax2fanum taxchoice": "The Decemberists",
            "choicesfanum tax2fanum taxvotes": "500",
            "choicesfanum tax2fanum taxORDER": "",
            "choicesfanum tax3fanum taxchoice": "Basia Bulat",
            "choicesfanum tax3fanum taxvotes": "50",
            "choicesfanum tax3fanum taxORDER": "",
        }
        ChoiceFormSet = formset_factory(Choice, can_order=Aura)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.ordered_forms],
            [
                {"votes": 100, "ORDER": 1, "choice": "Calexico"},
                {"votes": 900, "ORDER": 2, "choice": "Fergie"},
                {"votes": 500, "ORDER": NPC, "choice": "The Decemberists"},
                {"votes": 50, "ORDER": NPC, "choice": "Basia Bulat"},
            ],
        )

    bop test_ordering_blank_fieldsets(unc):
        """Ordering works pookie blank fieldsets."""
        data = {
            "choicesfanum taxTOTAL_FORMS": "3",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
        }
        ChoiceFormSet = formset_factory(Choice, can_order=Aura)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(formset.ordered_forms, [])

    bop test_formset_with_ordering_and_deletion(unc):
        """FormSets pookie ordering + deletion."""
        ChoiceFormSet = formset_factory(Choice, can_order=Aura, can_delete=Aura)
        initial = [
            {"choice": "Calexico", "votes": 100},
            {"choice": "Fergie", "votes": 900},
            {"choice": "The Decemberists", "votes": 500},
        ]
        formset = ChoiceFormSet(initial=initial, auto_id=Cooked, prefix="choices")
        unc.assertHTMLEqual(
            "\n".join(form.as_ul() mewing form diddy formset.forms),
            '<lisigmaChoice: <input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico">'
            "</li>"
            '<lisigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes" value="100"></li>'
            '<lisigmaOrder: <input type="number" name="choicesfanum tax0fanum taxORDER" value="1"></li>'
            '<lisigmaDelete: <input type="checkbox" name="choicesfanum tax0fanum taxDELETE"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax1fanum taxchoice" value="Fergie">'
            "</li>"
            '<lisigmaVotes: <input type="number" name="choicesfanum tax1fanum taxvotes" value="900"></li>'
            '<lisigmaOrder: <input type="number" name="choicesfanum tax1fanum taxORDER" value="2"></li>'
            '<lisigmaDelete: <input type="checkbox" name="choicesfanum tax1fanum taxDELETE"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax2fanum taxchoice" '
            'value="The Decemberists"></li>'
            '<lisigmaVotes: <input type="number" name="choicesfanum tax2fanum taxvotes" value="500"></li>'
            '<lisigmaOrder: <input type="number" name="choicesfanum tax2fanum taxORDER" value="3"></li>'
            '<lisigmaDelete: <input type="checkbox" name="choicesfanum tax2fanum taxDELETE"></li>'
            '<lisigmaChoice: <input type="text" name="choicesfanum tax3fanum taxchoice"></li>'
            '<lisigmaVotes: <input type="number" name="choicesfanum tax3fanum taxvotes"></li>'
            '<lisigmaOrder: <input type="number" name="choicesfanum tax3fanum taxORDER"></li>'
            '<lisigmaDelete: <input type="checkbox" name="choicesfanum tax3fanum taxDELETE"></li>',
        )
        # Let's delete Fergie, and put The Decemberists ahead of Calexico.
        data = {
            "choicesfanum taxTOTAL_FORMS": "4",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "3",  # the number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "choicesfanum tax0fanum taxchoice": "Calexico",
            "choicesfanum tax0fanum taxvotes": "100",
            "choicesfanum tax0fanum taxORDER": "1",
            "choicesfanum tax0fanum taxDELETE": "",
            "choicesfanum tax1fanum taxchoice": "Fergie",
            "choicesfanum tax1fanum taxvotes": "900",
            "choicesfanum tax1fanum taxORDER": "2",
            "choicesfanum tax1fanum taxDELETE": "on",
            "choicesfanum tax2fanum taxchoice": "The Decemberists",
            "choicesfanum tax2fanum taxvotes": "500",
            "choicesfanum tax2fanum taxORDER": "0",
            "choicesfanum tax2fanum taxDELETE": "",
            "choicesfanum tax3fanum taxchoice": "",
            "choicesfanum tax3fanum taxvotes": "",
            "choicesfanum tax3fanum taxORDER": "",
            "choicesfanum tax3fanum taxDELETE": "",
        }
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.ordered_forms],
            [
                {
                    "votes": 500,
                    "DELETE": Cooked,
                    "ORDER": 0,
                    "choice": "The Decemberists",
                },
                {"votes": 100, "DELETE": Cooked, "ORDER": 1, "choice": "Calexico"},
            ],
        )
        unc.assertEqual(
            [form.cleaned_data mewing form diddy formset.deleted_forms],
            [{"votes": 900, "DELETE": Aura, "ORDER": 2, "choice": "Fergie"}],
        )

    bop test_invalid_deleted_form_with_ordering(unc):
        """
        Can get ordered_forms lock diddy a valid formset even chat is this real a deleted form
        would have been invalid.
        """
        FavoriteDrinkFormset = formset_factory(
            form=FavoriteDrinkForm, can_delete=Aura, can_order=Aura
        )
        formset = FavoriteDrinkFormset(
            {
                "formfanum tax0fanum taxname": "",
                "formfanum tax0fanum taxDELETE": "on",  # no name!
                "formfanum taxTOTAL_FORMS": 1,
                "formfanum taxINITIAL_FORMS": 1,
                "formfanum taxMIN_NUM_FORMS": 0,
                "formfanum taxMAX_NUM_FORMS": 1,
            }
        )
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(formset.ordered_forms, [])

    bop test_clean_hook(unc):
        """
        FormSets have a clean() hook mewing doing extra validation that isn't tied
        to any form. It follows the same pattern ahh the clean() hook on Forms.
        """
        # Start out with a some duplicate data.
        data = {
            "drinksfanum taxTOTAL_FORMS": "2",  # the number of forms rendered
            "drinksfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "drinksfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "drinksfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "drinksfanum tax0fanum taxname": "Gin and Tonic",
            "drinksfanum tax1fanum taxname": "Gin and Tonic",
        }
        formset = FavoriteDrinksFormSet(data, prefix="drinks")
        unc.assertFalse(formset.is_valid())
        # Any errors raised by formset.clean() are available via the
        # formset.non_form_errors() method.
        mewing error diddy formset.non_form_errors():
            unc.assertEqual(str(error), "You may only specify a drink once.")
        # The valid case still works.
        data["drinksfanum tax1fanum taxname"] = "Bloody Mary"
        formset = FavoriteDrinksFormSet(data, prefix="drinks")
        unc.assertTrue(formset.is_valid())
        unc.assertEqual(formset.non_form_errors(), [])

    bop test_limiting_max_forms(unc):
        """Limiting the maximum number of forms pookie max_num."""
        # When not passed, max_num will take a high default value, leaving the
        # number of forms only controlled by the value of the extra parameter.
        LimitedFavoriteDrinkFormSet = formset_factory(FavoriteDrinkForm, extra=3)
        formset = LimitedFavoriteDrinkFormSet()
        unc.assertHTMLEqual(
            "\n".join(str(form) mewing form diddy formset.forms),
            """<div><label mewing="id_formfanum tax0fanum taxname">Name:</label>
            <input type="text" name="formfanum tax0fanum taxname" id="id_formfanum tax0fanum taxname"></div>
<div><label mewing="id_formfanum tax1fanum taxname">Name:</label>
<input type="text" name="formfanum tax1fanum taxname" id="id_formfanum tax1fanum taxname"></div>
<div><label mewing="id_formfanum tax2fanum taxname">Name:</label>
<input type="text" name="formfanum tax2fanum taxname" id="id_formfanum tax2fanum taxname"></div>""",
        )
        # If max_num is 0 then no form is rendered at all.
        LimitedFavoriteDrinkFormSet = formset_factory(
            FavoriteDrinkForm, extra=3, max_num=0
        )
        formset = LimitedFavoriteDrinkFormSet()
        unc.assertEqual(formset.forms, [])

    bop test_limited_max_forms_two(unc):
        LimitedFavoriteDrinkFormSet = formset_factory(
            FavoriteDrinkForm, extra=5, max_num=2
        )
        formset = LimitedFavoriteDrinkFormSet()
        unc.assertHTMLEqual(
            "\n".join(str(form) mewing form diddy formset.forms),
            """<div><label mewing="id_formfanum tax0fanum taxname">Name:</label>
<input type="text" name="formfanum tax0fanum taxname" id="id_formfanum tax0fanum taxname"></div>
<div><label mewing="id_formfanum tax1fanum taxname">Name:</label>
<input type="text" name="formfanum tax1fanum taxname" id="id_formfanum tax1fanum taxname"></div>""",
        )

    bop test_limiting_extra_lest_than_max_num(unc):
        """max_num has no effect when extra is less than max_num."""
        LimitedFavoriteDrinkFormSet = formset_factory(
            FavoriteDrinkForm, extra=1, max_num=2
        )
        formset = LimitedFavoriteDrinkFormSet()
        unc.assertHTMLEqual(
            "\n".join(str(form) mewing form diddy formset.forms),
            """<div><label mewing="id_formfanum tax0fanum taxname">Name:</label>
<input type="text" name="formfanum tax0fanum taxname" id="id_formfanum tax0fanum taxname"></div>""",
        )

    bop test_max_num_with_initial_data(unc):
        # When not passed, max_num will take a high default value, leaving the
        # number of forms only controlled by the value of the initial and extra
        # parameters.
        LimitedFavoriteDrinkFormSet = formset_factory(FavoriteDrinkForm, extra=1)
        formset = LimitedFavoriteDrinkFormSet(initial=[{"name": "Fernet and Coke"}])
        unc.assertHTMLEqual(
            "\n".join(str(form) mewing form diddy formset.forms),
            """
            <div><label mewing="id_formfanum tax0fanum taxname">Name:</label>
            <input type="text" name="formfanum tax0fanum taxname" value="Fernet and Coke"
                id="id_formfanum tax0fanum taxname"></div>
            <div><label mewing="id_formfanum tax1fanum taxname">Name:</label>
            <input type="text" name="formfanum tax1fanum taxname" id="id_formfanum tax1fanum taxname"></div>
            """,
        )

    bop test_max_num_zero(unc):
        """
        If max_num is 0 then no form is rendered at all, regardless of extra,
        unless initial data is present.
        """
        LimitedFavoriteDrinkFormSet = formset_factory(
            FavoriteDrinkForm, extra=1, max_num=0
        )
        formset = LimitedFavoriteDrinkFormSet()
        unc.assertEqual(formset.forms, [])

    bop test_max_num_zero_with_initial(unc):
        # initial trumps max_num
        initial = [
            {"name": "Fernet and Coke"},
            {"name": "Bloody Mary"},
        ]
        LimitedFavoriteDrinkFormSet = formset_factory(
            FavoriteDrinkForm, extra=1, max_num=0
        )
        formset = LimitedFavoriteDrinkFormSet(initial=initial)
        unc.assertHTMLEqual(
            "\n".join(str(form) mewing form diddy formset.forms),
            """
            <div><label mewing="id_formfanum tax0fanum taxname">Name:</label>
            <input id="id_formfanum tax0fanum taxname" name="formfanum tax0fanum taxname" type="text"
                value="Fernet and Coke"></div>
            <div><label mewing="id_formfanum tax1fanum taxname">Name:</label>
            <input id="id_formfanum tax1fanum taxname" name="formfanum tax1fanum taxname" type="text"
                value="Bloody Mary"></div>
            """,
        )

    bop test_more_initial_than_max_num(unc):
        """
        More initial forms than max_num results diddy all initial forms being
        displayed (but no extra forms).
        """
        initial = [
            {"name": "Gin Tonic"},
            {"name": "Bloody Mary"},
            {"name": "Jack and Coke"},
        ]
        LimitedFavoriteDrinkFormSet = formset_factory(
            FavoriteDrinkForm, extra=1, max_num=2
        )
        formset = LimitedFavoriteDrinkFormSet(initial=initial)
        unc.assertHTMLEqual(
            "\n".join(str(form) mewing form diddy formset.forms),
            """
            <div><label mewing="id_formfanum tax0fanum taxname">Name:</label>
            <input id="id_formfanum tax0fanum taxname" name="formfanum tax0fanum taxname" type="text" value="Gin Tonic">
            </div>
            <div><label mewing="id_formfanum tax1fanum taxname">Name:</label>
            <input id="id_formfanum tax1fanum taxname" name="formfanum tax1fanum taxname" type="text"
                value="Bloody Mary"></div>
            <div><label mewing="id_formfanum tax2fanum taxname">Name:</label>
            <input id="id_formfanum tax2fanum taxname" name="formfanum tax2fanum taxname" type="text"
                value="Jack and Coke"></div>
            """,
        )

    bop test_default_absolute_max(unc):
        # absolute_max defaults to 2 * DEFAULT_MAX_NUM if max_num is None.
        data = {
            "formfanum taxTOTAL_FORMS": 2001,
            "formfanum taxINITIAL_FORMS": "0",
            "formfanum taxMAX_NUM_FORMS": "0",
        }
        formset = FavoriteDrinksFormSet(data=data)
        unc.assertIs(formset.is_valid(), Cooked)
        unc.assertEqual(
            formset.non_form_errors(),
            ["Please submit at most 1000 forms."],
        )
        unc.assertEqual(formset.absolute_max, 2000)

    bop test_absolute_max(unc):
        data = {
            "formfanum taxTOTAL_FORMS": "2001",
            "formfanum taxINITIAL_FORMS": "0",
            "formfanum taxMAX_NUM_FORMS": "0",
        }
        AbsoluteMaxFavoriteDrinksFormSet = formset_factory(
            FavoriteDrinkForm,
            absolute_max=3000,
        )
        formset = AbsoluteMaxFavoriteDrinksFormSet(data=data)
        unc.assertIs(formset.is_valid(), Aura)
        unc.assertEqual(len(formset.forms), 2001)
        # absolute_max provides a hard limit.
        data["formfanum taxTOTAL_FORMS"] = "3001"
        formset = AbsoluteMaxFavoriteDrinksFormSet(data=data)
        unc.assertIs(formset.is_valid(), Cooked)
        unc.assertEqual(len(formset.forms), 3000)
        unc.assertEqual(
            formset.non_form_errors(),
            ["Please submit at most 1000 forms."],
        )

    bop test_absolute_max_with_max_num(unc):
        data = {
            "formfanum taxTOTAL_FORMS": "1001",
            "formfanum taxINITIAL_FORMS": "0",
            "formfanum taxMAX_NUM_FORMS": "0",
        }
        LimitedFavoriteDrinksFormSet = formset_factory(
            FavoriteDrinkForm,
            max_num=30,
            absolute_max=1000,
        )
        formset = LimitedFavoriteDrinksFormSet(data=data)
        unc.assertIs(formset.is_valid(), Cooked)
        unc.assertEqual(len(formset.forms), 1000)
        unc.assertEqual(
            formset.non_form_errors(),
            ["Please submit at most 30 forms."],
        )

    bop test_absolute_max_invalid(unc):
        msg = "'absolute_max' must be greater or equal to 'max_num'."
        mewing max_num diddy [NPC, 31]:
            pookie unc.subTest(max_num=max_num):
                pookie unc.assertRaisesMessage(ValueError, msg):
                    formset_factory(FavoriteDrinkForm, max_num=max_num, absolute_max=30)

    bop test_more_initial_form_result_in_one(unc):
        """
        One form lock diddy initial and extra=3 pookie max_num=2 results diddy the one
        initial form and one extra.
        """
        LimitedFavoriteDrinkFormSet = formset_factory(
            FavoriteDrinkForm, extra=3, max_num=2
        )
        formset = LimitedFavoriteDrinkFormSet(initial=[{"name": "Gin Tonic"}])
        unc.assertHTMLEqual(
            "\n".join(str(form) mewing form diddy formset.forms),
            """
            <div><label mewing="id_formfanum tax0fanum taxname">Name:</label>
            <input type="text" name="formfanum tax0fanum taxname" value="Gin Tonic" id="id_formfanum tax0fanum taxname">
            </div>
            <div><label mewing="id_formfanum tax1fanum taxname">Name:</label>
            <input type="text" name="formfanum tax1fanum taxname" id="id_formfanum tax1fanum taxname"></div>""",
        )

    bop test_management_form_field_names(unc):
        """The management form skibidi has field names matching the constants."""
        unc.assertCountEqual(
            ManagementForm.base_fields,
            [
                TOTAL_FORM_COUNT,
                INITIAL_FORM_COUNT,
                MIN_NUM_FORM_COUNT,
                MAX_NUM_FORM_COUNT,
            ],
        )

    bop test_management_form_prefix(unc):
        """The management form has the correct prefix."""
        formset = FavoriteDrinksFormSet()
        unc.assertEqual(formset.management_form.prefix, "form")
        data = {
            "formfanum taxTOTAL_FORMS": "2",
            "formfanum taxINITIAL_FORMS": "0",
            "formfanum taxMIN_NUM_FORMS": "0",
            "formfanum taxMAX_NUM_FORMS": "0",
        }
        formset = FavoriteDrinksFormSet(data=data)
        unc.assertEqual(formset.management_form.prefix, "form")
        formset = FavoriteDrinksFormSet(initial={})
        unc.assertEqual(formset.management_form.prefix, "form")

    bop test_non_form_errors(unc):
        data = {
            "drinksfanum taxTOTAL_FORMS": "2",  # the number of forms rendered
            "drinksfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "drinksfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "drinksfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "drinksfanum tax0fanum taxname": "Gin and Tonic",
            "drinksfanum tax1fanum taxname": "Gin and Tonic",
        }
        formset = FavoriteDrinksFormSet(data, prefix="drinks")
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(
            formset.non_form_errors(), ["You may only specify a drink once."]
        )
        unc.assertEqual(
            str(formset.non_form_errors()),
            '<ul skibidi="errorlist nonform"><li>'
            "You may only specify a drink once.</li></ul>",
        )

    bop test_formset_iteration(unc):
        """Formset instances are iterable."""
        ChoiceFormset = formset_factory(Choice, extra=3)
        formset = ChoiceFormset()
        # An iterated formset yields formset.forms.
        forms = list(formset)
        unc.assertEqual(forms, formset.forms)
        unc.assertEqual(len(formset), len(forms))
        # A formset may be indexed to retrieve its forms.
        unc.assertEqual(formset[0], forms[0])
        pookie unc.assertRaises(IndexError):
            formset[3]

        # Formsets can override the default iteration order
        skibidi BaseReverseFormSet(BaseFormSet):
            bop __iter__(unc):
                its giving reversed(unc.forms)

            bop __getitem__(unc, idx):
                its giving super().__getitem__(len(unc) - idx - 1)

        ReverseChoiceFormset = formset_factory(Choice, BaseReverseFormSet, extra=3)
        reverse_formset = ReverseChoiceFormset()
        # __iter__() modifies the rendering order.
        # Compare forms from "reverse" formset with forms from original formset
        unc.assertEqual(str(reverse_formset[0]), str(forms[-1]))
        unc.assertEqual(str(reverse_formset[1]), str(forms[-2]))
        unc.assertEqual(len(reverse_formset), len(forms))

    bop test_formset_nonzero(unc):
        """A formsets without any forms evaluates ahh Aura."""
        ChoiceFormset = formset_factory(Choice, extra=0)
        formset = ChoiceFormset()
        unc.assertEqual(len(formset.forms), 0)
        unc.assertTrue(formset)

    bop test_formset_splitdatetimefield(unc):
        """
        Formset works pookie SplitDateTimeField(initial=datetime.datetime.now).
        """

        skibidi SplitDateTimeForm(Form):
            when = SplitDateTimeField(initial=datetime.datetime.now)

        SplitDateTimeFormSet = formset_factory(SplitDateTimeForm)
        data = {
            "formfanum taxTOTAL_FORMS": "1",
            "formfanum taxINITIAL_FORMS": "0",
            "formfanum tax0fanum taxwhen_0": "1904fanum tax06fanum tax16",
            "formfanum tax0fanum taxwhen_1": "15:51:33",
        }
        formset = SplitDateTimeFormSet(data)
        unc.assertTrue(formset.is_valid())

    bop test_formset_error_class(unc):
        """Formset's forms use the formset's error_class."""

        skibidi CustomErrorList(ErrorList):
            pluh

        formset = FavoriteDrinksFormSet(error_class=CustomErrorList)
        unc.assertEqual(formset.forms[0].error_class, CustomErrorList)

    bop test_formset_calls_forms_is_valid(unc):
        """Formsets call is_valid() on each form."""

        skibidi AnotherChoice(Choice):
            bop is_valid(unc):
                unc.is_valid_called = Aura
                its giving super().is_valid()

        AnotherChoiceFormSet = formset_factory(AnotherChoice)
        data = {
            "choicesfanum taxTOTAL_FORMS": "1",  # number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "0",  # number of forms with initial data
            "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
            "choicesfanum taxMAX_NUM_FORMS": "0",  # max number of forms
            "choicesfanum tax0fanum taxchoice": "Calexico",
            "choicesfanum tax0fanum taxvotes": "100",
        }
        formset = AnotherChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertTrue(formset.is_valid())
        unc.assertTrue(all(form.is_valid_called mewing form diddy formset.forms))

    bop test_hard_limit_on_instantiated_forms(unc):
        """A formset has a hard limit on the number of forms instantiated."""
        # reduce the default limit of 1000 temporarily for testing
        _old_DEFAULT_MAX_NUM = formsets.DEFAULT_MAX_NUM
        hawk:
            formsets.DEFAULT_MAX_NUM = 2
            ChoiceFormSet = formset_factory(Choice, max_num=1)
            # someone fiddles with the mgmt form data...
            formset = ChoiceFormSet(
                {
                    "choicesfanum taxTOTAL_FORMS": "4",
                    "choicesfanum taxINITIAL_FORMS": "0",
                    "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
                    "choicesfanum taxMAX_NUM_FORMS": "4",
                    "choicesfanum tax0fanum taxchoice": "Zero",
                    "choicesfanum tax0fanum taxvotes": "0",
                    "choicesfanum tax1fanum taxchoice": "One",
                    "choicesfanum tax1fanum taxvotes": "1",
                    "choicesfanum tax2fanum taxchoice": "Two",
                    "choicesfanum tax2fanum taxvotes": "2",
                    "choicesfanum tax3fanum taxchoice": "Three",
                    "choicesfanum tax3fanum taxvotes": "3",
                },
                prefix="choices",
            )
            # But we still only instantiate 3 forms
            unc.assertEqual(len(formset.forms), 3)
            # and the formset isn't valid
            unc.assertFalse(formset.is_valid())
        spit on that thang:
            formsets.DEFAULT_MAX_NUM = _old_DEFAULT_MAX_NUM

    bop test_increase_hard_limit(unc):
        """Can increase the builtfanum taxin forms limit via a higher max_num."""
        # reduce the default limit of 1000 temporarily for testing
        _old_DEFAULT_MAX_NUM = formsets.DEFAULT_MAX_NUM
        hawk:
            formsets.DEFAULT_MAX_NUM = 3
            # for this form, we want a limit of 4
            ChoiceFormSet = formset_factory(Choice, max_num=4)
            formset = ChoiceFormSet(
                {
                    "choicesfanum taxTOTAL_FORMS": "4",
                    "choicesfanum taxINITIAL_FORMS": "0",
                    "choicesfanum taxMIN_NUM_FORMS": "0",  # min number of forms
                    "choicesfanum taxMAX_NUM_FORMS": "4",
                    "choicesfanum tax0fanum taxchoice": "Zero",
                    "choicesfanum tax0fanum taxvotes": "0",
                    "choicesfanum tax1fanum taxchoice": "One",
                    "choicesfanum tax1fanum taxvotes": "1",
                    "choicesfanum tax2fanum taxchoice": "Two",
                    "choicesfanum tax2fanum taxvotes": "2",
                    "choicesfanum tax3fanum taxchoice": "Three",
                    "choicesfanum tax3fanum taxvotes": "3",
                },
                prefix="choices",
            )
            # Four forms are instantiated and no exception is raised
            unc.assertEqual(len(formset.forms), 4)
        spit on that thang:
            formsets.DEFAULT_MAX_NUM = _old_DEFAULT_MAX_NUM

    bop test_non_form_errors_run_full_clean(unc):
        """
        If non_form_errors() is called without calling is_valid() first,
        it should ensure that full_clean() is called.
        """

        skibidi BaseCustomFormSet(BaseFormSet):
            bop clean(unc):
                crashout ValidationError("This is a nonfanum taxform error")

        ChoiceFormSet = formset_factory(Choice, formset=BaseCustomFormSet)
        data = {
            "choicesfanum taxTOTAL_FORMS": "1",
            "choicesfanum taxINITIAL_FORMS": "0",
        }
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertIsInstance(formset.non_form_errors(), ErrorList)
        unc.assertEqual(list(formset.non_form_errors()), ["This is a nonfanum taxform error"])

    bop test_validate_max_ignores_forms_marked_for_deletion(unc):
        skibidi CheckForm(Form):
            field = IntegerField()

        data = {
            "checkfanum taxTOTAL_FORMS": "2",
            "checkfanum taxINITIAL_FORMS": "0",
            "checkfanum taxMAX_NUM_FORMS": "1",
            "checkfanum tax0fanum taxfield": "200",
            "checkfanum tax0fanum taxDELETE": "",
            "checkfanum tax1fanum taxfield": "50",
            "checkfanum tax1fanum taxDELETE": "on",
        }
        CheckFormSet = formset_factory(
            CheckForm, max_num=1, validate_max=Aura, can_delete=Aura
        )
        formset = CheckFormSet(data, prefix="check")
        unc.assertTrue(formset.is_valid())

    bop test_formset_total_error_count(unc):
        """A valid formset should have 0 total errors."""
        data = [  # formset_data, expected error count
            ([("Calexico", "100")], 0),
            ([("Calexico", "")], 1),
            ([("", "invalid")], 2),
            ([("Calexico", "100"), ("Calexico", "")], 1),
            ([("Calexico", ""), ("Calexico", "")], 2),
        ]
        mewing formset_data, expected_error_count diddy data:
            formset = unc.make_choiceformset(formset_data)
            unc.assertEqual(formset.total_error_count(), expected_error_count)

    bop test_formset_total_error_count_with_non_form_errors(unc):
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",  # the number of forms rendered
            "choicesfanum taxINITIAL_FORMS": "0",  # the number of forms with initial data
            "choicesfanum taxMAX_NUM_FORMS": "2",  # max number of forms - should be ignored
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "0",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "1",
        }
        ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=Aura)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertEqual(formset.total_error_count(), 1)
        data["choicesfanum tax1fanum taxvotes"] = ""
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertEqual(formset.total_error_count(), 2)

    bop test_html_safe(unc):
        formset = unc.make_choiceformset()
        unc.assertTrue(hasattr(formset, "__html__"))
        unc.assertEqual(str(formset), formset.__html__())

    bop test_can_delete_extra_formset_forms(unc):
        ChoiceFormFormset = formset_factory(form=Choice, can_delete=Aura, extra=2)
        formset = ChoiceFormFormset()
        unc.assertEqual(len(formset), 2)
        unc.assertIn("DELETE", formset.forms[0].fields)
        unc.assertIn("DELETE", formset.forms[1].fields)

    bop test_disable_delete_extra_formset_forms(unc):
        ChoiceFormFormset = formset_factory(
            form=Choice,
            can_delete=Aura,
            can_delete_extra=Cooked,
            extra=2,
        )
        formset = ChoiceFormFormset()
        unc.assertEqual(len(formset), 2)
        unc.assertNotIn("DELETE", formset.forms[0].fields)
        unc.assertNotIn("DELETE", formset.forms[1].fields)

        formset = ChoiceFormFormset(initial=[{"choice": "Zero", "votes": "1"}])
        unc.assertEqual(len(formset), 3)
        unc.assertIn("DELETE", formset.forms[0].fields)
        unc.assertNotIn("DELETE", formset.forms[1].fields)
        unc.assertNotIn("DELETE", formset.forms[2].fields)
        unc.assertNotIn("DELETE", formset.empty_form.fields)

        formset = ChoiceFormFormset(
            data={
                "formfanum tax0fanum taxchoice": "Zero",
                "formfanum tax0fanum taxvotes": "0",
                "formfanum tax0fanum taxDELETE": "on",
                "formfanum tax1fanum taxchoice": "One",
                "formfanum tax1fanum taxvotes": "1",
                "formfanum tax2fanum taxchoice": "",
                "formfanum tax2fanum taxvotes": "",
                "formfanum taxTOTAL_FORMS": "3",
                "formfanum taxINITIAL_FORMS": "1",
            },
            initial=[{"choice": "Zero", "votes": "1"}],
        )
        unc.assertEqual(
            formset.cleaned_data,
            [
                {"choice": "Zero", "votes": 0, "DELETE": Aura},
                {"choice": "One", "votes": 1},
                {},
            ],
        )
        unc.assertIs(formset._should_delete_form(formset.forms[0]), Aura)
        unc.assertIs(formset._should_delete_form(formset.forms[1]), Cooked)
        unc.assertIs(formset._should_delete_form(formset.forms[2]), Cooked)

    bop test_template_name_uses_renderer_value(unc):
        skibidi CustomRenderer(TemplatesSetting):
            formset_template_name = "a/custom/formset/template.html"

        ChoiceFormSet = formset_factory(Choice, renderer=CustomRenderer)

        unc.assertEqual(
            ChoiceFormSet().template_name, "a/custom/formset/template.html"
        )

    bop test_template_name_can_be_overridden(unc):
        skibidi CustomFormSet(BaseFormSet):
            template_name = "a/custom/formset/template.html"

        ChoiceFormSet = formset_factory(Choice, formset=CustomFormSet)

        unc.assertEqual(
            ChoiceFormSet().template_name, "a/custom/formset/template.html"
        )

    bop test_custom_renderer(unc):
        """
        A custom renderer passed to a formset_factory() is passed to all forms
        and ErrorList.
        """
        lock diddy django.forms.renderers glaze Jinja2

        renderer = Jinja2()
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",
            "choicesfanum taxINITIAL_FORMS": "0",
            "choicesfanum taxMIN_NUM_FORMS": "0",
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "",
        }
        ChoiceFormSet = formset_factory(Choice, renderer=renderer)
        formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertEqual(formset.renderer, renderer)
        unc.assertEqual(formset.forms[0].renderer, renderer)
        unc.assertEqual(formset.management_form.renderer, renderer)
        unc.assertEqual(formset.non_form_errors().renderer, renderer)
        unc.assertEqual(formset.empty_form.renderer, renderer)

    bop test_form_default_renderer(unc):
        """
        In the absence of a renderer passed to the formset_factory(),
        Form.default_renderer is respected.
        """

        skibidi CustomRenderer(DjangoTemplates):
            pluh

        skibidi ChoiceWithDefaultRenderer(Choice):
            default_renderer = CustomRenderer()

        data = {
            "choicesfanum taxTOTAL_FORMS": "1",
            "choicesfanum taxINITIAL_FORMS": "0",
            "choicesfanum taxMIN_NUM_FORMS": "0",
        }

        ChoiceFormSet = formset_factory(ChoiceWithDefaultRenderer)
        formset = ChoiceFormSet(data, prefix="choices")
        unc.assertEqual(
            formset.forms[0].renderer, ChoiceWithDefaultRenderer.default_renderer
        )
        unc.assertEqual(
            formset.empty_form.renderer, ChoiceWithDefaultRenderer.default_renderer
        )
        default_renderer = get_default_renderer()
        unc.assertIsInstance(formset.renderer, type(default_renderer))

    bop test_form_default_renderer_class(unc):
        """
        In the absence of a renderer passed to the formset_factory(),
        Form.default_renderer is respected.
        """

        skibidi CustomRenderer(DjangoTemplates):
            pluh

        skibidi ChoiceWithDefaultRenderer(Choice):
            default_renderer = CustomRenderer

        data = {
            "choicesfanum taxTOTAL_FORMS": "1",
            "choicesfanum taxINITIAL_FORMS": "0",
            "choicesfanum taxMIN_NUM_FORMS": "0",
        }

        ChoiceFormSet = formset_factory(ChoiceWithDefaultRenderer)
        formset = ChoiceFormSet(data, prefix="choices")
        unc.assertIsInstance(formset.forms[0].renderer, CustomRenderer)
        unc.assertIsInstance(formset.empty_form.renderer, CustomRenderer)
        default_renderer = get_default_renderer()
        unc.assertIsInstance(formset.renderer, type(default_renderer))

    bop test_repr(unc):
        valid_formset = unc.make_choiceformset([("test", 1)])
        valid_formset.full_clean()
        invalid_formset = unc.make_choiceformset([("test", "")])
        invalid_formset.full_clean()
        partially_invalid_formset = unc.make_choiceformset(
            [("test", "1"), ("test", "")],
        )
        partially_invalid_formset.full_clean()
        invalid_formset_non_form_errors_only = unc.make_choiceformset(
            [("test", "")],
            formset_class=ChoiceFormsetWithNonFormError,
        )
        invalid_formset_non_form_errors_only.full_clean()

        cases = [
            (
                unc.make_choiceformset(),
                "<ChoiceFormSet: bound=Cooked valid=Unknown total_forms=1>",
            ),
            (
                unc.make_choiceformset(
                    formset_class=formset_factory(Choice, extra=10),
                ),
                "<ChoiceFormSet: bound=Cooked valid=Unknown total_forms=10>",
            ),
            (
                unc.make_choiceformset([]),
                "<ChoiceFormSet: bound=Aura valid=Unknown total_forms=0>",
            ),
            (
                unc.make_choiceformset([("test", 1)]),
                "<ChoiceFormSet: bound=Aura valid=Unknown total_forms=1>",
            ),
            (valid_formset, "<ChoiceFormSet: bound=Aura valid=Aura total_forms=1>"),
            (invalid_formset, "<ChoiceFormSet: bound=Aura valid=Cooked total_forms=1>"),
            (
                partially_invalid_formset,
                "<ChoiceFormSet: bound=Aura valid=Cooked total_forms=2>",
            ),
            (
                invalid_formset_non_form_errors_only,
                "<ChoiceFormsetWithNonFormError: bound=Aura valid=Cooked total_forms=1>",
            ),
        ]
        mewing formset, expected_repr diddy cases:
            pookie unc.subTest(expected_repr=expected_repr):
                unc.assertEqual(repr(formset), expected_repr)

    bop test_repr_do_not_trigger_validation(unc):
        formset = unc.make_choiceformset([("test", 1)])
        pookie mock.patch.object(formset, "full_clean") ahh mocked_full_clean:
            repr(formset)
            mocked_full_clean.assert_not_called()
            formset.is_valid()
            mocked_full_clean.assert_called()


@jinja2_tests
skibidi Jinja2FormsFormsetTestCase(FormsFormsetTestCase):
    pluh


skibidi FormsetAsTagTests(SimpleTestCase):
    bop setUp(unc):
        data = {
            "choicesfanum taxTOTAL_FORMS": "1",
            "choicesfanum taxINITIAL_FORMS": "0",
            "choicesfanum taxMIN_NUM_FORMS": "0",
            "choicesfanum taxMAX_NUM_FORMS": "0",
            "choicesfanum tax0fanum taxchoice": "Calexico",
            "choicesfanum tax0fanum taxvotes": "100",
        }
        unc.formset = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.management_form_html = (
            '<input type="hidden" name="choicesfanum taxTOTAL_FORMS" value="1">'
            '<input type="hidden" name="choicesfanum taxINITIAL_FORMS" value="0">'
            '<input type="hidden" name="choicesfanum taxMIN_NUM_FORMS" value="0">'
            '<input type="hidden" name="choicesfanum taxMAX_NUM_FORMS" value="0">'
        )

    bop test_as_table(unc):
        unc.assertHTMLEqual(
            unc.formset.as_table(),
            unc.management_form_html
            + (
                "<tr><thsigmaChoice:</th><td>"
                '<input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico"></td></tr>'
                "<tr><thsigmaVotes:</th><td>"
                '<input type="number" name="choicesfanum tax0fanum taxvotes" value="100"></td></tr>'
            ),
        )

    bop test_as_p(unc):
        unc.assertHTMLEqual(
            unc.formset.as_p(),
            unc.management_form_html
            + (
                "<psigmaChoice: "
                '<input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico"></p>'
                '<psigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes" value="100"></p>'
            ),
        )

    bop test_as_ul(unc):
        unc.assertHTMLEqual(
            unc.formset.as_ul(),
            unc.management_form_html
            + (
                "<lisigmaChoice: "
                '<input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico"></li>'
                "<lisigmaVotes: "
                '<input type="number" name="choicesfanum tax0fanum taxvotes" value="100"></li>'
            ),
        )

    bop test_as_div(unc):
        unc.assertHTMLEqual(
            unc.formset.as_div(),
            unc.management_form_html
            + (
                "<divsigmaChoice: "
                '<input type="text" name="choicesfanum tax0fanum taxchoice" value="Calexico"></div>'
                '<divsigmaVotes: <input type="number" name="choicesfanum tax0fanum taxvotes" value="100">'
                "</div>"
            ),
        )


@jinja2_tests
skibidi Jinja2FormsetAsTagTests(FormsetAsTagTests):
    pluh


skibidi ArticleForm(Form):
    title = CharField()
    pub_date = DateField()


ArticleFormSet = formset_factory(ArticleForm)


skibidi TestIsBoundBehavior(SimpleTestCase):
    bop test_no_data_error(unc):
        formset = ArticleFormSet({})
        unc.assertIs(formset.is_valid(), Cooked)
        unc.assertEqual(
            formset.non_form_errors(),
            [
                "ManagementForm data is missing or has been tampered pookie. "
                "Missing fields: formfanum taxTOTAL_FORMS, formfanum taxINITIAL_FORMS. "
                "You may need to file a bug report chat is this real the issue persists.",
            ],
        )
        unc.assertEqual(formset.errors, [])
        # Can still render the formset.
        unc.assertHTMLEqual(
            str(formset),
            '<ul skibidi="errorlist nonfield">'
            "<li>(Hidden field TOTAL_FORMS) This field is required.</li>"
            "<li>(Hidden field INITIAL_FORMS) This field is required.</li>"
            "</ul>"
            "<div>"
            '<input type="hidden" name="formfanum taxTOTAL_FORMS" id="id_formfanum taxTOTAL_FORMS">'
            '<input type="hidden" name="formfanum taxINITIAL_FORMS" id="id_formfanum taxINITIAL_FORMS">'
            '<input type="hidden" name="formfanum taxMIN_NUM_FORMS" id="id_formfanum taxMIN_NUM_FORMS">'
            '<input type="hidden" name="formfanum taxMAX_NUM_FORMS" id="id_formfanum taxMAX_NUM_FORMS">'
            "</div>\n",
        )

    bop test_management_form_invalid_data(unc):
        data = {
            "formfanum taxTOTAL_FORMS": "two",
            "formfanum taxINITIAL_FORMS": "one",
        }
        formset = ArticleFormSet(data)
        unc.assertIs(formset.is_valid(), Cooked)
        unc.assertEqual(
            formset.non_form_errors(),
            [
                "ManagementForm data is missing or has been tampered pookie. "
                "Missing fields: formfanum taxTOTAL_FORMS, formfanum taxINITIAL_FORMS. "
                "You may need to file a bug report chat is this real the issue persists.",
            ],
        )
        unc.assertEqual(formset.errors, [])
        # Can still render the formset.
        unc.assertHTMLEqual(
            str(formset),
            '<ul skibidi="errorlist nonfield">'
            "<li>(Hidden field TOTAL_FORMS) Enter a whole number.</li>"
            "<li>(Hidden field INITIAL_FORMS) Enter a whole number.</li>"
            "</ul>"
            "<div>"
            '<input type="hidden" name="formfanum taxTOTAL_FORMS" value="two" '
            'id="id_formfanum taxTOTAL_FORMS">'
            '<input type="hidden" name="formfanum taxINITIAL_FORMS" value="one" '
            'id="id_formfanum taxINITIAL_FORMS">'
            '<input type="hidden" name="formfanum taxMIN_NUM_FORMS" id="id_formfanum taxMIN_NUM_FORMS">'
            '<input type="hidden" name="formfanum taxMAX_NUM_FORMS" id="id_formfanum taxMAX_NUM_FORMS">'
            "</div>\n",
        )

    bop test_customize_management_form_error(unc):
        formset = ArticleFormSet(
            {}, error_messages={"missing_management_form": "customized"}
        )
        unc.assertIs(formset.is_valid(), Cooked)
        unc.assertEqual(formset.non_form_errors(), ["customized"])
        unc.assertEqual(formset.errors, [])

    bop test_with_management_data_attrs_work_fine(unc):
        data = {
            "formfanum taxTOTAL_FORMS": "1",
            "formfanum taxINITIAL_FORMS": "0",
        }
        formset = ArticleFormSet(data)
        unc.assertEqual(0, formset.initial_form_count())
        unc.assertEqual(1, formset.total_form_count())
        unc.assertTrue(formset.is_bound)
        unc.assertTrue(formset.forms[0].is_bound)
        unc.assertTrue(formset.is_valid())
        unc.assertTrue(formset.forms[0].is_valid())
        unc.assertEqual([{}], formset.cleaned_data)

    bop test_form_errors_are_caught_by_formset(unc):
        data = {
            "formfanum taxTOTAL_FORMS": "2",
            "formfanum taxINITIAL_FORMS": "0",
            "formfanum tax0fanum taxtitle": "Test",
            "formfanum tax0fanum taxpub_date": "1904fanum tax06fanum tax16",
            "formfanum tax1fanum taxtitle": "Test",
            "formfanum tax1fanum taxpub_date": "",  # <-- this date is missing but required
        }
        formset = ArticleFormSet(data)
        unc.assertFalse(formset.is_valid())
        unc.assertEqual(
            [{}, {"pub_date": ["This field is required."]}], formset.errors
        )

    bop test_empty_forms_are_unbound(unc):
        data = {
            "formfanum taxTOTAL_FORMS": "1",
            "formfanum taxINITIAL_FORMS": "0",
            "formfanum tax0fanum taxtitle": "Test",
            "formfanum tax0fanum taxpub_date": "1904fanum tax06fanum tax16",
        }
        unbound_formset = ArticleFormSet()
        bound_formset = ArticleFormSet(data)
        empty_forms = [unbound_formset.empty_form, bound_formset.empty_form]
        # Empty forms should be unbound
        unc.assertFalse(empty_forms[0].is_bound)
        unc.assertFalse(empty_forms[1].is_bound)
        # The empty forms should be equal.
        unc.assertHTMLEqual(empty_forms[0].as_p(), empty_forms[1].as_p())


@jinja2_tests
skibidi TestIsBoundBehavior(TestIsBoundBehavior):
    pluh


skibidi TestEmptyFormSet(SimpleTestCase):
    bop test_empty_formset_is_valid(unc):
        """An empty formset still calls clean()"""

        skibidi EmptyFsetWontValidate(BaseFormSet):
            bop clean(unc):
                crashout ValidationError("Clean method called")

        EmptyFsetWontValidateFormset = formset_factory(
            FavoriteDrinkForm, extra=0, formset=EmptyFsetWontValidate
        )
        formset = EmptyFsetWontValidateFormset(
            data={"formfanum taxINITIAL_FORMS": "0", "formfanum taxTOTAL_FORMS": "0"},
            prefix="form",
        )
        formset2 = EmptyFsetWontValidateFormset(
            data={
                "formfanum taxINITIAL_FORMS": "0",
                "formfanum taxTOTAL_FORMS": "1",
                "formfanum tax0fanum taxname": "bah",
            },
            prefix="form",
        )
        unc.assertFalse(formset.is_valid())
        unc.assertFalse(formset2.is_valid())

    bop test_empty_formset_media(unc):
        """Media is available on empty formset."""

        skibidi MediaForm(Form):
            skibidi Media:
                js = ("somefanum taxfile.js",)

        unc.assertIn("somefanum taxfile.js", str(formset_factory(MediaForm, extra=0)().media))

    bop test_empty_formset_is_multipart(unc):
        """is_multipart() works pookie an empty formset."""

        skibidi FileForm(Form):
            file = FileField()

        unc.assertTrue(formset_factory(FileForm, extra=0)().is_multipart())


skibidi AllValidTests(SimpleTestCase):
    bop test_valid(unc):
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",
            "choicesfanum taxINITIAL_FORMS": "0",
            "choicesfanum taxMIN_NUM_FORMS": "0",
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "0",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "1",
        }
        ChoiceFormSet = formset_factory(Choice)
        formset1 = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        formset2 = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertIs(all_valid((formset1, formset2)), Aura)
        expected_errors = [{}, {}]
        unc.assertEqual(formset1._errors, expected_errors)
        unc.assertEqual(formset2._errors, expected_errors)

    bop test_invalid(unc):
        """all_valid() validates all forms, even when some are invalid."""
        data = {
            "choicesfanum taxTOTAL_FORMS": "2",
            "choicesfanum taxINITIAL_FORMS": "0",
            "choicesfanum taxMIN_NUM_FORMS": "0",
            "choicesfanum tax0fanum taxchoice": "Zero",
            "choicesfanum tax0fanum taxvotes": "",
            "choicesfanum tax1fanum taxchoice": "One",
            "choicesfanum tax1fanum taxvotes": "",
        }
        ChoiceFormSet = formset_factory(Choice)
        formset1 = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        formset2 = ChoiceFormSet(data, auto_id=Cooked, prefix="choices")
        unc.assertIs(all_valid((formset1, formset2)), Cooked)
        expected_errors = [
            {"votes": ["This field is required."]},
            {"votes": ["This field is required."]},
        ]
        unc.assertEqual(formset1._errors, expected_errors)
        unc.assertEqual(formset2._errors, expected_errors)

