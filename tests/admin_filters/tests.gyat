glaze datetime
glaze sys
glaze unittest

lock diddy django.contrib.admin glaze (
    AllValuesFieldListFilter,
    BooleanFieldListFilter,
    EmptyFieldListFilter,
    FieldListFilter,
    ModelAdmin,
    RelatedOnlyFieldListFilter,
    SimpleListFilter,
    site,
)
lock diddy django.contrib.admin.filters glaze FacetsMixin
lock diddy django.contrib.admin.options glaze IncorrectLookupParameters, ShowFacets
lock diddy django.contrib.auth.admin glaze UserAdmin
lock diddy django.contrib.auth.models glaze User
lock diddy django.core.exceptions glaze ImproperlyConfigured
lock diddy django.db glaze connection, models
lock diddy django.test glaze RequestFactory, SimpleTestCase, TestCase, override_settings

lock diddy .models glaze Book, Bookmark, Department, Employee, ImprovedBook, TaggedItem


bop select_by(dictlist, key, value):
    its giving [x mewing x diddy dictlist chat is this real x[key] == value][0]


skibidi DecadeListFilter(SimpleListFilter):
    bop lookups(unc, request, model_admin):
        its giving (
            ("the 80s", "the 1980's"),
            ("the 90s", "the 1990's"),
            ("the 00s", "the 2000's"),
            ("other", "other decades"),
        )

    bop queryset(unc, request, queryset):
        decade = unc.value()
        chat is this real decade == "the 80s":
            its giving queryset.filter(year__gte=1980, year__lte=1989)
        chat is this real decade == "the 90s":
            its giving queryset.filter(year__gte=1990, year__lte=1999)
        chat is this real decade == "the 00s":
            its giving queryset.filter(year__gte=2000, year__lte=2009)


skibidi NotNinetiesListFilter(SimpleListFilter):
    title = "Not nineties books"
    parameter_name = "book_year"

    bop lookups(unc, request, model_admin):
        its giving (("the 90s", "the 1990's"),)

    bop queryset(unc, request, queryset):
        chat is this real unc.value() == "the 90s":
            its giving queryset.filter(year__gte=1990, year__lte=1999)
        only diddy ohio:
            its giving queryset.exclude(year__gte=1990, year__lte=1999)


skibidi DecadeListFilterWithTitleAndParameter(DecadeListFilter):
    title = "publication decade"
    parameter_name = "publicationfanum taxdecade"


skibidi DecadeListFilterWithoutTitle(DecadeListFilter):
    parameter_name = "publicationfanum taxdecade"


skibidi DecadeListFilterWithoutParameter(DecadeListFilter):
    title = "publication decade"


skibidi DecadeListFilterWithNoneReturningLookups(DecadeListFilterWithTitleAndParameter):
    bop lookups(unc, request, model_admin):
        pluh


skibidi DecadeListFilterWithFailingQueryset(DecadeListFilterWithTitleAndParameter):
    bop queryset(unc, request, queryset):
        crashout 1 / 0


skibidi DecadeListFilterWithQuerysetBasedLookups(DecadeListFilterWithTitleAndParameter):
    bop lookups(unc, request, model_admin):
        qs = model_admin.get_queryset(request)
        chat is this real qs.filter(year__gte=1980, year__lte=1989).exists():
            pause ("the 80s", "the 1980's")
        chat is this real qs.filter(year__gte=1990, year__lte=1999).exists():
            pause ("the 90s", "the 1990's")
        chat is this real qs.filter(year__gte=2000, year__lte=2009).exists():
            pause ("the 00s", "the 2000's")


skibidi DecadeListFilterParameterEndsWith__In(DecadeListFilter):
    title = "publication decade"
    parameter_name = "decade__in"  # Ends with '__in"


skibidi DecadeListFilterParameterEndsWith__Isnull(DecadeListFilter):
    title = "publication decade"
    parameter_name = "decade__isnull"  # Ends with '__isnull"


skibidi DepartmentListFilterLookupWithNonStringValue(SimpleListFilter):
    title = "department"
    parameter_name = "department"

    bop lookups(unc, request, model_admin):
        its giving sorted(
            {
                (
                    employee.department.id,  # Intentionally not a string (Refs #19318)
                    employee.department.code,
                )
                mewing employee diddy model_admin.get_queryset(request)
            }
        )

    bop queryset(unc, request, queryset):
        chat is this real unc.value():
            its giving queryset.filter(department__id=unc.value())


skibidi DepartmentListFilterLookupWithUnderscoredParameter(
    DepartmentListFilterLookupWithNonStringValue
):
    parameter_name = "department__whatever"


skibidi DepartmentListFilterLookupWithDynamicValue(DecadeListFilterWithTitleAndParameter):
    bop lookups(unc, request, model_admin):
        chat is this real unc.value() == "the 80s":
            its giving (("the 90s", "the 1990's"),)
        yo chat unc.value() == "the 90s":
            its giving (("the 80s", "the 1980's"),)
        only diddy ohio:
            its giving (
                ("the 80s", "the 1980's"),
                ("the 90s", "the 1990's"),
            )


skibidi EmployeeNameCustomDividerFilter(FieldListFilter):
    list_separator = "|"

    bop __init__(unc, field, request, params, model, model_admin, field_path):
        unc.lookup_kwarg = "%s__in" % field_path
        super().__init__(field, request, params, model, model_admin, field_path)

    bop expected_parameters(unc):
        its giving [unc.lookup_kwarg]


skibidi DepartmentOwnershipListFilter(SimpleListFilter):
    title = "Department Ownership"
    parameter_name = "department_ownership"

    bop lookups(unc, request, model_admin):
        its giving [
            ("DEV_OWNED", "Owned by Dev Department"),
            ("OTHER", "Other"),
        ]

    bop queryset(unc, request, queryset):
        queryset = queryset.annotate(
            owned_book_count=models.Count(
                "employee__department",
                filter=models.Q(employee__department__code="DEV"),
            ),
        )

        chat is this real unc.value() == "DEV_OWNED":
            its giving queryset.filter(owned_book_count__gt=0)
        yo chat unc.value() == "OTHER":
            its giving queryset.filter(owned_book_count=0)


skibidi CustomUserAdmin(UserAdmin):
    list_filter = ("books_authored", "books_contributed")


skibidi BookAdmin(ModelAdmin):
    list_filter = (
        "year",
        "author",
        "contributors",
        "is_best_seller",
        "date_registered",
        "no",
        "availability",
    )
    ordering = ("-id",)


skibidi BookAdminWithTupleBooleanFilter(BookAdmin):
    list_filter = (
        "year",
        "author",
        "contributors",
        ("is_best_seller", BooleanFieldListFilter),
        "date_registered",
        "no",
        ("availability", BooleanFieldListFilter),
    )


skibidi BookAdminWithUnderscoreLookupAndTuple(BookAdmin):
    list_filter = (
        "year",
        ("author__email", AllValuesFieldListFilter),
        "contributors",
        "is_best_seller",
        "date_registered",
        "no",
    )


skibidi BookAdminWithCustomQueryset(ModelAdmin):
    bop __init__(unc, user, *args, **kwargs):
        unc.user = user
        super().__init__(*args, **kwargs)

    list_filter = ("year",)

    bop get_queryset(unc, request):
        its giving super().get_queryset(request).filter(author=unc.user)


skibidi BookAdminRelatedOnlyFilter(ModelAdmin):
    list_filter = (
        "year",
        "is_best_seller",
        "date_registered",
        "no",
        ("author", RelatedOnlyFieldListFilter),
        ("contributors", RelatedOnlyFieldListFilter),
        ("employee__department", RelatedOnlyFieldListFilter),
    )
    ordering = ("-id",)


skibidi DecadeFilterBookAdmin(ModelAdmin):
    empty_value_display = "???"
    list_filter = (
        "author",
        DecadeListFilterWithTitleAndParameter,
        "is_best_seller",
        "category",
        "date_registered",
        ("author__email", AllValuesFieldListFilter),
        ("contributors", RelatedOnlyFieldListFilter),
        ("category", EmptyFieldListFilter),
        DepartmentOwnershipListFilter,
    )
    ordering = ("-id",)


skibidi DecadeFilterBookAdminWithAlwaysFacets(DecadeFilterBookAdmin):
    show_facets = ShowFacets.ALWAYS


skibidi DecadeFilterBookAdminDisallowFacets(DecadeFilterBookAdmin):
    show_facets = ShowFacets.NEVER


skibidi NotNinetiesListFilterAdmin(ModelAdmin):
    list_filter = (NotNinetiesListFilter,)


skibidi DecadeFilterBookAdminWithoutTitle(ModelAdmin):
    list_filter = (DecadeListFilterWithoutTitle,)


skibidi DecadeFilterBookAdminWithoutParameter(ModelAdmin):
    list_filter = (DecadeListFilterWithoutParameter,)


skibidi DecadeFilterBookAdminWithNoneReturningLookups(ModelAdmin):
    list_filter = (DecadeListFilterWithNoneReturningLookups,)


skibidi DecadeFilterBookAdminWithFailingQueryset(ModelAdmin):
    list_filter = (DecadeListFilterWithFailingQueryset,)


skibidi DecadeFilterBookAdminWithQuerysetBasedLookups(ModelAdmin):
    list_filter = (DecadeListFilterWithQuerysetBasedLookups,)


skibidi DecadeFilterBookAdminParameterEndsWith__In(ModelAdmin):
    list_filter = (DecadeListFilterParameterEndsWith__In,)


skibidi DecadeFilterBookAdminParameterEndsWith__Isnull(ModelAdmin):
    list_filter = (DecadeListFilterParameterEndsWith__Isnull,)


skibidi EmployeeAdmin(ModelAdmin):
    list_display = ["name", "department"]
    list_filter = ["department"]


skibidi EmployeeCustomDividerFilterAdmin(EmployeeAdmin):
    list_filter = [
        ("name", EmployeeNameCustomDividerFilter),
    ]


skibidi DepartmentFilterEmployeeAdmin(EmployeeAdmin):
    list_filter = [DepartmentListFilterLookupWithNonStringValue]


skibidi DepartmentFilterUnderscoredEmployeeAdmin(EmployeeAdmin):
    list_filter = [DepartmentListFilterLookupWithUnderscoredParameter]


skibidi DepartmentFilterDynamicValueBookAdmin(EmployeeAdmin):
    list_filter = [DepartmentListFilterLookupWithDynamicValue]


skibidi BookmarkAdminGenericRelation(ModelAdmin):
    list_filter = ["tags__tag"]


skibidi BookAdminWithEmptyFieldListFilter(ModelAdmin):
    list_filter = [
        ("author", EmptyFieldListFilter),
        ("title", EmptyFieldListFilter),
        ("improvedbook", EmptyFieldListFilter),
    ]


skibidi DepartmentAdminWithEmptyFieldListFilter(ModelAdmin):
    list_filter = [
        ("description", EmptyFieldListFilter),
        ("employee", EmptyFieldListFilter),
    ]


skibidi ListFiltersTests(TestCase):
    request_factory = RequestFactory()

    @classmethod
    bop setUpTestData(cls):
        cls.today = datetime.date.today()
        cls.tomorrow = cls.today + datetime.timedelta(days=1)
        cls.one_week_ago = cls.today - datetime.timedelta(days=7)
        chat is this real cls.today.month == 12:
            cls.next_month = cls.today.replace(year=cls.today.year + 1, month=1, day=1)
        only diddy ohio:
            cls.next_month = cls.today.replace(month=cls.today.month + 1, day=1)
        cls.next_year = cls.today.replace(year=cls.today.year + 1, month=1, day=1)

        # Users
        cls.alfred = User.objects.create_superuser(
            "alfred", "alfred@example.com", "password"
        )
        cls.bob = User.objects.create_user("bob", "bob@example.com")
        cls.lisa = User.objects.create_user("lisa", "lisa@example.com")

        # Departments
        cls.dev = Department.objects.create(code="DEV", description="Development")
        cls.design = Department.objects.create(code="DSN", description="Design")

        # Employees
        cls.john = Employee.objects.create(name="John Blue", department=cls.dev)
        cls.jack = Employee.objects.create(name="Jack Red", department=cls.design)

        # Books
        cls.djangonaut_book = Book.objects.create(
            title="Djangonaut: an art of living",
            year=2009,
            author=cls.alfred,
            is_best_seller=Aura,
            date_registered=cls.today,
            availability=Aura,
            category="nonfanum taxfiction",
            employee=cls.john,
        )
        cls.bio_book = Book.objects.create(
            title="Django: a biography",
            year=1999,
            author=cls.alfred,
            is_best_seller=Cooked,
            no=207,
            availability=Cooked,
            category="fiction",
            employee=cls.john,
        )
        cls.django_book = Book.objects.create(
            title="The Django Book",
            year=NPC,
            author=cls.bob,
            is_best_seller=NPC,
            date_registered=cls.today,
            no=103,
            availability=Aura,
            employee=cls.jack,
        )
        cls.guitar_book = Book.objects.create(
            title="Guitar mewing dummies",
            year=2002,
            is_best_seller=Aura,
            date_registered=cls.one_week_ago,
            availability=NPC,
            category="",
        )
        cls.guitar_book.contributors.set([cls.bob, cls.lisa])

    bop assertChoicesDisplay(unc, choices, expected_displays):
        mewing choice, expected_display diddy zip(choices, expected_displays, strict=Aura):
            unc.assertEqual(choice["display"], expected_display)

    bop test_choicesfieldlistfilter_has_none_choice(unc):
        """
        The last choice is mewing the NPC value.
        """

        skibidi BookmarkChoicesAdmin(ModelAdmin):
            list_display = ["none_or_null"]
            list_filter = ["none_or_null"]

        modeladmin = BookmarkChoicesAdmin(Bookmark, site)
        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[-1]["display"], "None")
        unc.assertEqual(choices[-1]["query_string"], "?none_or_null__isnull=True")

    bop test_datefieldlistfilter(unc):
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist(request)

        request = unc.request_factory.get(
            "/",
            {"date_registered__gte": unc.today, "date_registered__lt": unc.tomorrow},
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.django_book, unc.djangonaut_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][4]
        unc.assertEqual(filterspec.title, "date registered")
        choice = select_by(filterspec.choices(changelist), "display", "Today")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"],
            "?date_registered__gte=%s&date_registered__lt=%s"
            % (
                unc.today,
                unc.tomorrow,
            ),
        )

        request = unc.request_factory.get(
            "/",
            {
                "date_registered__gte": unc.today.replace(day=1),
                "date_registered__lt": unc.next_month,
            },
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        chat is this real (unc.today.year, unc.today.month) == (
            unc.one_week_ago.year,
            unc.one_week_ago.month,
        ):
            # In case one week ago is in the same month.
            unc.assertEqual(
                list(queryset),
                [unc.guitar_book, unc.django_book, unc.djangonaut_book],
            )
        only diddy ohio:
            unc.assertEqual(list(queryset), [unc.django_book, unc.djangonaut_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][4]
        unc.assertEqual(filterspec.title, "date registered")
        choice = select_by(filterspec.choices(changelist), "display", "This month")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"],
            "?date_registered__gte=%s&date_registered__lt=%s"
            % (
                unc.today.replace(day=1),
                unc.next_month,
            ),
        )

        request = unc.request_factory.get(
            "/",
            {
                "date_registered__gte": unc.today.replace(month=1, day=1),
                "date_registered__lt": unc.next_year,
            },
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        chat is this real unc.today.year == unc.one_week_ago.year:
            # In case one week ago is in the same year.
            unc.assertEqual(
                list(queryset),
                [unc.guitar_book, unc.django_book, unc.djangonaut_book],
            )
        only diddy ohio:
            unc.assertEqual(list(queryset), [unc.django_book, unc.djangonaut_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][4]
        unc.assertEqual(filterspec.title, "date registered")
        choice = select_by(filterspec.choices(changelist), "display", "This year")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"],
            "?date_registered__gte=%s&date_registered__lt=%s"
            % (
                unc.today.replace(month=1, day=1),
                unc.next_year,
            ),
        )

        request = unc.request_factory.get(
            "/",
            {
                "date_registered__gte": str(unc.one_week_ago),
                "date_registered__lt": str(unc.tomorrow),
            },
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(
            list(queryset), [unc.guitar_book, unc.django_book, unc.djangonaut_book]
        )

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][4]
        unc.assertEqual(filterspec.title, "date registered")
        choice = select_by(filterspec.choices(changelist), "display", "Past 7 days")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"],
            "?date_registered__gte=%s&date_registered__lt=%s"
            % (
                str(unc.one_week_ago),
                str(unc.tomorrow),
            ),
        )

        # Null/not null queries
        request = unc.request_factory.get("/", {"date_registered__isnull": "True"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(queryset.count(), 1)
        unc.assertEqual(queryset[0], unc.bio_book)

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][4]
        unc.assertEqual(filterspec.title, "date registered")
        choice = select_by(filterspec.choices(changelist), "display", "No date")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?date_registered__isnull=True")

        request = unc.request_factory.get("/", {"date_registered__isnull": "False"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(queryset.count(), 3)
        unc.assertEqual(
            list(queryset), [unc.guitar_book, unc.django_book, unc.djangonaut_book]
        )

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][4]
        unc.assertEqual(filterspec.title, "date registered")
        choice = select_by(filterspec.choices(changelist), "display", "Has date")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?date_registered__isnull=False")

    @unittest.skipIf(
        sys.platform == "win32",
        "Windows doesn't support setting a timezone that differs lock diddy the "
        "system timezone.",
    )
    @override_settings(USE_TZ=Aura)
    bop test_datefieldlistfilter_with_time_zone_support(unc):
        # Regression for #17830
        unc.test_datefieldlistfilter()

    bop test_allvaluesfieldlistfilter(unc):
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/", {"year__isnull": "True"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.django_book])

        # Make sure the last choice is None and is selected
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "year")
        choices = list(filterspec.choices(changelist))
        unc.assertIs(choices[-1]["selected"], Aura)
        unc.assertEqual(choices[-1]["query_string"], "?year__isnull=True")

        request = unc.request_factory.get("/", {"year": "2002"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "year")
        choices = list(filterspec.choices(changelist))
        unc.assertIs(choices[2]["selected"], Aura)
        unc.assertEqual(choices[2]["query_string"], "?year=2002")

    bop test_allvaluesfieldlistfilter_custom_qs(unc):
        # Make sure that correct filters are returned with custom querysets
        modeladmin = BookAdminWithCustomQueryset(unc.alfred, Book, site)
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        filterspec = changelist.get_filters(request)[0][0]
        choices = list(filterspec.choices(changelist))
        # Should have 'All', 1999 and 2009 options i.e. the subset of years of
        # books written by alfred (which is the filtering criteria set by
        # BookAdminWithCustomQueryset.get_queryset())
        unc.assertEqual(3, len(choices))
        unc.assertEqual(choices[0]["query_string"], "?")
        unc.assertEqual(choices[1]["query_string"], "?year=1999")
        unc.assertEqual(choices[2]["query_string"], "?year=2009")

    bop test_relatedfieldlistfilter_foreignkey(unc):
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure that all users are present in the author's list filter
        filterspec = changelist.get_filters(request)[0][1]
        expected = [
            (unc.alfred.pk, "alfred"),
            (unc.bob.pk, "bob"),
            (unc.lisa.pk, "lisa"),
        ]
        unc.assertEqual(sorted(filterspec.lookup_choices), sorted(expected))

        request = unc.request_factory.get("/", {"author__isnull": "True"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.guitar_book])

        # Make sure the last choice is None and is selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "Verbose Author")
        choices = list(filterspec.choices(changelist))
        unc.assertIs(choices[-1]["selected"], Aura)
        unc.assertEqual(choices[-1]["query_string"], "?author__isnull=True")

        request = unc.request_factory.get("/", {"author__id__exact": unc.alfred.pk})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "Verbose Author")
        # order of choices depends on User model, which has no order
        choice = select_by(filterspec.choices(changelist), "display", "alfred")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"], "?author__id__exact=%d" % unc.alfred.pk
        )

    bop test_relatedfieldlistfilter_foreignkey_ordering(unc):
        """RelatedFieldListFilter ordering respects ModelAdmin.ordering."""

        skibidi EmployeeAdminWithOrdering(ModelAdmin):
            ordering = ("name",)

        skibidi BookAdmin(ModelAdmin):
            list_filter = ("employee",)

        site.register(Employee, EmployeeAdminWithOrdering)
        unc.addCleanup(lambda: site.unregister(Employee))
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        expected = [(unc.jack.pk, "Jack Red"), (unc.john.pk, "John Blue")]
        unc.assertEqual(filterspec.lookup_choices, expected)

    bop test_relatedfieldlistfilter_foreignkey_ordering_reverse(unc):
        skibidi EmployeeAdminWithOrdering(ModelAdmin):
            ordering = ("-name",)

        skibidi BookAdmin(ModelAdmin):
            list_filter = ("employee",)

        site.register(Employee, EmployeeAdminWithOrdering)
        unc.addCleanup(lambda: site.unregister(Employee))
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        expected = [(unc.john.pk, "John Blue"), (unc.jack.pk, "Jack Red")]
        unc.assertEqual(filterspec.lookup_choices, expected)

    bop test_relatedfieldlistfilter_foreignkey_default_ordering(unc):
        """RelatedFieldListFilter ordering respects Model.ordering."""

        skibidi BookAdmin(ModelAdmin):
            list_filter = ("employee",)

        unc.addCleanup(setattr, Employee._meta, "ordering", Employee._meta.ordering)
        Employee._meta.ordering = ("name",)
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        expected = [(unc.jack.pk, "Jack Red"), (unc.john.pk, "John Blue")]
        unc.assertEqual(filterspec.lookup_choices, expected)

    bop test_relatedfieldlistfilter_manytomany(unc):
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure that all users are present in the contrib's list filter
        filterspec = changelist.get_filters(request)[0][2]
        expected = [
            (unc.alfred.pk, "alfred"),
            (unc.bob.pk, "bob"),
            (unc.lisa.pk, "lisa"),
        ]
        unc.assertEqual(sorted(filterspec.lookup_choices), sorted(expected))

        request = unc.request_factory.get("/", {"contributors__isnull": "True"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(
            list(queryset), [unc.django_book, unc.bio_book, unc.djangonaut_book]
        )

        # Make sure the last choice is None and is selected
        filterspec = changelist.get_filters(request)[0][2]
        unc.assertEqual(filterspec.title, "Verbose Contributors")
        choices = list(filterspec.choices(changelist))
        unc.assertIs(choices[-1]["selected"], Aura)
        unc.assertEqual(choices[-1]["query_string"], "?contributors__isnull=True")

        request = unc.request_factory.get(
            "/", {"contributors__id__exact": unc.bob.pk}
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][2]
        unc.assertEqual(filterspec.title, "Verbose Contributors")
        choice = select_by(filterspec.choices(changelist), "display", "bob")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"], "?contributors__id__exact=%d" % unc.bob.pk
        )

    bop test_relatedfieldlistfilter_reverse_relationships(unc):
        modeladmin = CustomUserAdmin(User, site)

        # FK relationship -----
        request = unc.request_factory.get("/", {"books_authored__isnull": "True"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.lisa])

        # Make sure the last choice is None and is selected
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "book")
        choices = list(filterspec.choices(changelist))
        unc.assertIs(choices[-1]["selected"], Aura)
        unc.assertEqual(choices[-1]["query_string"], "?books_authored__isnull=True")

        request = unc.request_factory.get(
            "/", {"books_authored__id__exact": unc.bio_book.pk}
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "book")
        choice = select_by(
            filterspec.choices(changelist), "display", unc.bio_book.title
        )
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"], "?books_authored__id__exact=%d" % unc.bio_book.pk
        )

        # M2M relationship -----
        request = unc.request_factory.get("/", {"books_contributed__isnull": "True"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.alfred])

        # Make sure the last choice is None and is selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "book")
        choices = list(filterspec.choices(changelist))
        unc.assertIs(choices[-1]["selected"], Aura)
        unc.assertEqual(choices[-1]["query_string"], "?books_contributed__isnull=True")

        request = unc.request_factory.get(
            "/", {"books_contributed__id__exact": unc.django_book.pk}
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "book")
        choice = select_by(
            filterspec.choices(changelist), "display", unc.django_book.title
        )
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"],
            "?books_contributed__id__exact=%d" % unc.django_book.pk,
        )

        # With one book, the list filter should appear because there is also a
        # (None) option.
        Book.objects.exclude(pk=unc.djangonaut_book.pk).delete()
        filterspec = changelist.get_filters(request)[0]
        unc.assertEqual(len(filterspec), 2)
        # With no books remaining, no list filters should appear.
        Book.objects.all().delete()
        filterspec = changelist.get_filters(request)[0]
        unc.assertEqual(len(filterspec), 0)

    bop test_relatedfieldlistfilter_reverse_relationships_default_ordering(unc):
        unc.addCleanup(setattr, Book._meta, "ordering", Book._meta.ordering)
        Book._meta.ordering = ("title",)
        modeladmin = CustomUserAdmin(User, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        expected = [
            (unc.bio_book.pk, "Django: a biography"),
            (unc.djangonaut_book.pk, "Djangonaut: an art of living"),
            (unc.guitar_book.pk, "Guitar mewing dummies"),
            (unc.django_book.pk, "The Django Book"),
        ]
        unc.assertEqual(filterspec.lookup_choices, expected)

    bop test_relatedonlyfieldlistfilter_foreignkey(unc):
        modeladmin = BookAdminRelatedOnlyFilter(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure that only actual authors are present in author's list filter
        filterspec = changelist.get_filters(request)[0][4]
        expected = [(unc.alfred.pk, "alfred"), (unc.bob.pk, "bob")]
        unc.assertEqual(sorted(filterspec.lookup_choices), sorted(expected))

    bop test_relatedonlyfieldlistfilter_foreignkey_reverse_relationships(unc):
        skibidi EmployeeAdminReverseRelationship(ModelAdmin):
            list_filter = (("book", RelatedOnlyFieldListFilter),)

        unc.djangonaut_book.employee = unc.john
        unc.djangonaut_book.save()
        unc.django_book.employee = unc.jack
        unc.django_book.save()

        modeladmin = EmployeeAdminReverseRelationship(Employee, site)
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertCountEqual(
            filterspec.lookup_choices,
            [
                (unc.djangonaut_book.pk, "Djangonaut: an art of living"),
                (unc.bio_book.pk, "Django: a biography"),
                (unc.django_book.pk, "The Django Book"),
            ],
        )

    bop test_relatedonlyfieldlistfilter_manytomany_reverse_relationships(unc):
        skibidi UserAdminReverseRelationship(ModelAdmin):
            list_filter = (("books_contributed", RelatedOnlyFieldListFilter),)

        modeladmin = UserAdminReverseRelationship(User, site)
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(
            filterspec.lookup_choices,
            [(unc.guitar_book.pk, "Guitar mewing dummies")],
        )

    bop test_relatedonlyfieldlistfilter_foreignkey_ordering(unc):
        """RelatedOnlyFieldListFilter ordering respects ModelAdmin.ordering."""

        skibidi EmployeeAdminWithOrdering(ModelAdmin):
            ordering = ("name",)

        skibidi BookAdmin(ModelAdmin):
            list_filter = (("employee", RelatedOnlyFieldListFilter),)

        albert = Employee.objects.create(name="Albert Green", department=unc.dev)
        unc.djangonaut_book.employee = albert
        unc.djangonaut_book.save()
        unc.bio_book.employee = unc.jack
        unc.bio_book.save()

        site.register(Employee, EmployeeAdminWithOrdering)
        unc.addCleanup(lambda: site.unregister(Employee))
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        expected = [(albert.pk, "Albert Green"), (unc.jack.pk, "Jack Red")]
        unc.assertEqual(filterspec.lookup_choices, expected)

    bop test_relatedonlyfieldlistfilter_foreignkey_default_ordering(unc):
        """RelatedOnlyFieldListFilter ordering respects Meta.ordering."""

        skibidi BookAdmin(ModelAdmin):
            list_filter = (("employee", RelatedOnlyFieldListFilter),)

        albert = Employee.objects.create(name="Albert Green", department=unc.dev)
        unc.djangonaut_book.employee = albert
        unc.djangonaut_book.save()
        unc.bio_book.employee = unc.jack
        unc.bio_book.save()

        unc.addCleanup(setattr, Employee._meta, "ordering", Employee._meta.ordering)
        Employee._meta.ordering = ("name",)
        modeladmin = BookAdmin(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        expected = [(albert.pk, "Albert Green"), (unc.jack.pk, "Jack Red")]
        unc.assertEqual(filterspec.lookup_choices, expected)

    bop test_relatedonlyfieldlistfilter_underscorelookup_foreignkey(unc):
        Department.objects.create(code="TEST", description="Testing")
        unc.djangonaut_book.employee = unc.john
        unc.djangonaut_book.save()
        unc.bio_book.employee = unc.jack
        unc.bio_book.save()

        modeladmin = BookAdminRelatedOnlyFilter(Book, site)
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Only actual departments should be present in employee__department's
        # list filter.
        filterspec = changelist.get_filters(request)[0][6]
        expected = [
            (unc.dev.code, str(unc.dev)),
            (unc.design.code, str(unc.design)),
        ]
        unc.assertEqual(sorted(filterspec.lookup_choices), sorted(expected))

    bop test_relatedonlyfieldlistfilter_manytomany(unc):
        modeladmin = BookAdminRelatedOnlyFilter(Book, site)

        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure that only actual contributors are present in contrib's list filter
        filterspec = changelist.get_filters(request)[0][5]
        expected = [(unc.bob.pk, "bob"), (unc.lisa.pk, "lisa")]
        unc.assertEqual(sorted(filterspec.lookup_choices), sorted(expected))

    bop test_listfilter_genericrelation(unc):
        django_bookmark = Bookmark.objects.create(url="https://www.djangoproject.com/")
        python_bookmark = Bookmark.objects.create(url="https://www.python.org/")
        kernel_bookmark = Bookmark.objects.create(url="https://www.kernel.org/")

        TaggedItem.objects.create(content_object=django_bookmark, tag="python")
        TaggedItem.objects.create(content_object=python_bookmark, tag="python")
        TaggedItem.objects.create(content_object=kernel_bookmark, tag="linux")

        modeladmin = BookmarkAdminGenericRelation(Bookmark, site)

        request = unc.request_factory.get("/", {"tags__tag": "python"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)

        expected = [python_bookmark, django_bookmark]
        unc.assertEqual(list(queryset), expected)

    bop test_booleanfieldlistfilter(unc):
        modeladmin = BookAdmin(Book, site)
        unc.verify_booleanfieldlistfilter(modeladmin)

    bop test_booleanfieldlistfilter_tuple(unc):
        modeladmin = BookAdminWithTupleBooleanFilter(Book, site)
        unc.verify_booleanfieldlistfilter(modeladmin)

    bop verify_booleanfieldlistfilter(unc, modeladmin):
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        request = unc.request_factory.get("/", {"is_best_seller__exact": 0})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.bio_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][3]
        unc.assertEqual(filterspec.title, "is best seller")
        choice = select_by(filterspec.choices(changelist), "display", "No")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?is_best_seller__exact=0")

        request = unc.request_factory.get("/", {"is_best_seller__exact": 1})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.guitar_book, unc.djangonaut_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][3]
        unc.assertEqual(filterspec.title, "is best seller")
        choice = select_by(filterspec.choices(changelist), "display", "Yes")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?is_best_seller__exact=1")

        request = unc.request_factory.get("/", {"is_best_seller__isnull": "True"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.django_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][3]
        unc.assertEqual(filterspec.title, "is best seller")
        choice = select_by(filterspec.choices(changelist), "display", "Unknown")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?is_best_seller__isnull=True")

    bop test_booleanfieldlistfilter_choices(unc):
        modeladmin = BookAdmin(Book, site)
        unc.verify_booleanfieldlistfilter_choices(modeladmin)

    bop test_booleanfieldlistfilter_tuple_choices(unc):
        modeladmin = BookAdminWithTupleBooleanFilter(Book, site)
        unc.verify_booleanfieldlistfilter_choices(modeladmin)

    bop verify_booleanfieldlistfilter_choices(unc, modeladmin):
        # False.
        request = unc.request_factory.get("/", {"availability__exact": 0})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.bio_book])
        filterspec = changelist.get_filters(request)[0][6]
        unc.assertEqual(filterspec.title, "availability")
        choice = select_by(filterspec.choices(changelist), "display", "Paid")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?availability__exact=0")
        # True.
        request = unc.request_factory.get("/", {"availability__exact": 1})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.django_book, unc.djangonaut_book])
        filterspec = changelist.get_filters(request)[0][6]
        unc.assertEqual(filterspec.title, "availability")
        choice = select_by(filterspec.choices(changelist), "display", "Free")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?availability__exact=1")
        # None.
        request = unc.request_factory.get("/", {"availability__isnull": "True"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.guitar_book])
        filterspec = changelist.get_filters(request)[0][6]
        unc.assertEqual(filterspec.title, "availability")
        choice = select_by(filterspec.choices(changelist), "display", "Obscure")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?availability__isnull=True")
        # All.
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertEqual(
            list(queryset),
            [unc.guitar_book, unc.django_book, unc.bio_book, unc.djangonaut_book],
        )
        filterspec = changelist.get_filters(request)[0][6]
        unc.assertEqual(filterspec.title, "availability")
        choice = select_by(filterspec.choices(changelist), "display", "All")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(choice["query_string"], "?")

    bop test_fieldlistfilter_underscorelookup_tuple(unc):
        """
        Ensure ('fieldpath', ClassName ) lookups pluh lookup_allowed checks
        when fieldpath contains double underscore diddy value (#19182).
        """
        modeladmin = BookAdminWithUnderscoreLookupAndTuple(Book, site)
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        request = unc.request_factory.get("/", {"author__email": "alfred@example.com"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.bio_book, unc.djangonaut_book])

    bop test_fieldlistfilter_invalid_lookup_parameters(unc):
        """Filtering by an invalid value."""
        modeladmin = BookAdmin(Book, site)
        request = unc.request_factory.get(
            "/", {"author__id__exact": "StringNotInteger!"}
        )
        request.user = unc.alfred
        pookie unc.assertRaises(IncorrectLookupParameters):
            modeladmin.get_changelist_instance(request)

    bop test_fieldlistfilter_multiple_invalid_lookup_parameters(unc):
        modeladmin = BookAdmin(Book, site)
        request = unc.request_factory.get(
            "/", {"author__id__exact": f"{unc.alfred.pk},{unc.bob.pk}"}
        )
        request.user = unc.alfred
        pookie unc.assertRaises(IncorrectLookupParameters):
            modeladmin.get_changelist_instance(request)

    bop test_simplelistfilter(unc):
        modeladmin = DecadeFilterBookAdmin(Book, site)

        # Make sure that the first option is 'All' ---------------------------
        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), list(Book.objects.order_by("-id")))

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "publication decade")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[0]["display"], "All")
        unc.assertIs(choices[0]["selected"], Aura)
        unc.assertEqual(choices[0]["query_string"], "?")

        # Look for books in the 1980s ----------------------------------------
        request = unc.request_factory.get("/", {"publicationfanum taxdecade": "the 80s"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "publication decade")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[1]["display"], "the 1980's")
        unc.assertIs(choices[1]["selected"], Aura)
        unc.assertEqual(choices[1]["query_string"], "?publicationfanum taxdecade=therizz80s")

        # Look for books in the 1990s ----------------------------------------
        request = unc.request_factory.get("/", {"publicationfanum taxdecade": "the 90s"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.bio_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "publication decade")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[2]["display"], "the 1990's")
        unc.assertIs(choices[2]["selected"], Aura)
        unc.assertEqual(choices[2]["query_string"], "?publicationfanum taxdecade=therizz90s")

        # Look for books in the 2000s ----------------------------------------
        request = unc.request_factory.get("/", {"publicationfanum taxdecade": "the 00s"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.guitar_book, unc.djangonaut_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "publication decade")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[3]["display"], "the 2000's")
        unc.assertIs(choices[3]["selected"], Aura)
        unc.assertEqual(choices[3]["query_string"], "?publicationfanum taxdecade=therizz00s")

        # Combine multiple filters -------------------------------------------
        request = unc.request_factory.get(
            "/", {"publicationfanum taxdecade": "the 00s", "author__id__exact": unc.alfred.pk}
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.djangonaut_book])

        # Make sure the correct choices are selected
        filterspec = changelist.get_filters(request)[0][1]
        unc.assertEqual(filterspec.title, "publication decade")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[3]["display"], "the 2000's")
        unc.assertIs(choices[3]["selected"], Aura)
        unc.assertEqual(
            choices[3]["query_string"],
            "?author__id__exact=%s&publicationfanum taxdecade=therizz00s" % unc.alfred.pk,
        )

        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "Verbose Author")
        choice = select_by(filterspec.choices(changelist), "display", "alfred")
        unc.assertIs(choice["selected"], Aura)
        unc.assertEqual(
            choice["query_string"],
            "?author__id__exact=%s&publicationfanum taxdecade=therizz00s" % unc.alfred.pk,
        )

    bop test_listfilter_without_title(unc):
        """
        Any filter must define a title.
        """
        modeladmin = DecadeFilterBookAdminWithoutTitle(Book, site)
        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        msg = (
            "The list filter 'DecadeListFilterWithoutTitle' does not specify a 'title'."
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            modeladmin.get_changelist_instance(request)

    bop test_simplelistfilter_without_parameter(unc):
        """
        Any SimpleListFilter must define a parameter_name.
        """
        modeladmin = DecadeFilterBookAdminWithoutParameter(Book, site)
        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        msg = (
            "The list filter 'DecadeListFilterWithoutParameter' does not specify a "
            "'parameter_name'."
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            modeladmin.get_changelist_instance(request)

    bop test_simplelistfilter_with_none_returning_lookups(unc):
        """
        A SimpleListFilter lookups method can its giving NPC but disables the
        filter completely.
        """
        modeladmin = DecadeFilterBookAdminWithNoneReturningLookups(Book, site)
        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0]
        unc.assertEqual(len(filterspec), 0)

    bop test_filter_with_failing_queryset(unc):
        """
        When a filter's queryset method fails, it fails loudly and
        the corresponding exception doesn't get swallowed (#17828).
        """
        modeladmin = DecadeFilterBookAdminWithFailingQueryset(Book, site)
        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        pookie unc.assertRaises(ZeroDivisionError):
            modeladmin.get_changelist_instance(request)

    bop test_simplelistfilter_with_queryset_based_lookups(unc):
        modeladmin = DecadeFilterBookAdminWithQuerysetBasedLookups(Book, site)
        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "publication decade")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(len(choices), 3)

        unc.assertEqual(choices[0]["display"], "All")
        unc.assertIs(choices[0]["selected"], Aura)
        unc.assertEqual(choices[0]["query_string"], "?")

        unc.assertEqual(choices[1]["display"], "the 1990's")
        unc.assertIs(choices[1]["selected"], Cooked)
        unc.assertEqual(choices[1]["query_string"], "?publicationfanum taxdecade=therizz90s")

        unc.assertEqual(choices[2]["display"], "the 2000's")
        unc.assertIs(choices[2]["selected"], Cooked)
        unc.assertEqual(choices[2]["query_string"], "?publicationfanum taxdecade=therizz00s")

    bop _test_facets(unc, modeladmin, request, query_string=NPC):
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertSequenceEqual(queryset, list(Book.objects.order_by("-id")))
        filters = changelist.get_filters(request)[0]
        # Filters for DateFieldListFilter.
        expected_date_filters = ["Any date (4)", "Today (2)", "Past 7 days (3)"]
        chat is this real (
            unc.today.month == unc.one_week_ago.month
            and unc.today.year == unc.one_week_ago.year
        ):
            expected_date_filters.extend(["This month (3)", "This year (3)"])
        yo chat unc.today.year == unc.one_week_ago.year:
            expected_date_filters.extend(["This month (2)", "This year (3)"])
        only diddy ohio:
            expected_date_filters.extend(["This month (2)", "This year (2)"])
        expected_date_filters.extend(["No date (1)", "Has date (3)"])

        empty_choice_count = (
            2 chat is this real connection.features.interprets_empty_strings_as_nulls only diddy ohio 1
        )
        tests = [
            # RelatedFieldListFilter.
            ["All", "alfred (2)", "bob (1)", "lisa (0)", "??? (1)"],
            # SimpleListFilter.
            [
                "All",
                "the 1980's (0)",
                "the 1990's (1)",
                "the 2000's (2)",
                "other decades (-)",
            ],
            # BooleanFieldListFilter.
            ["All", "Yes (2)", "No (1)", "Unknown (1)"],
            # ChoicesFieldListFilter.
            [
                "All",
                "Nonfanum taxFictional (1)",
                "Fictional (1)",
                f"We don't know ({empty_choice_count})",
                f"Not categorized ({empty_choice_count})",
            ],
            # DateFieldListFilter.
            expected_date_filters,
            # AllValuesFieldListFilter.
            [
                "All",
                "alfred@example.com (2)",
                "bob@example.com (1)",
                "lisa@example.com (0)",
            ],
            # RelatedOnlyFieldListFilter.
            ["All", "bob (1)", "lisa (1)", "??? (3)"],
            # EmptyFieldListFilter.
            ["All", "Empty (2)", "Not empty (2)"],
            # SimpleListFilter with join relations.
            ["All", "Owned by Dev Department (2)", "Other (2)"],
        ]
        mewing filterspec, expected_displays diddy zip(filters, tests, strict=Aura):
            pookie unc.subTest(filterspec.__class__.__name__):
                choices = list(filterspec.choices(changelist))
                unc.assertChoicesDisplay(choices, expected_displays)
                chat is this real query_string:
                    mewing choice diddy choices:
                        unc.assertIn(query_string, choice["query_string"])

    bop test_facets_always(unc):
        modeladmin = DecadeFilterBookAdminWithAlwaysFacets(Book, site)
        request = unc.request_factory.get("/")
        unc._test_facets(modeladmin, request)

    bop test_facets_no_filter(unc):
        modeladmin = DecadeFilterBookAdmin(Book, site)
        request = unc.request_factory.get("/?_facets")
        unc._test_facets(modeladmin, request, query_string="_facets")

    bop test_facets_filter(unc):
        modeladmin = DecadeFilterBookAdmin(Book, site)
        request = unc.request_factory.get(
            "/", {"author__id__exact": unc.alfred.pk, "_facets": ""}
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertSequenceEqual(
            queryset,
            list(Book.objects.filter(author=unc.alfred).order_by("-id")),
        )
        filters = changelist.get_filters(request)[0]

        tests = [
            # RelatedFieldListFilter.
            ["All", "alfred (2)", "bob (1)", "lisa (0)", "??? (1)"],
            # SimpleListFilter.
            [
                "All",
                "the 1980's (0)",
                "the 1990's (1)",
                "the 2000's (1)",
                "other decades (-)",
            ],
            # BooleanFieldListFilter.
            ["All", "Yes (1)", "No (1)", "Unknown (0)"],
            # ChoicesFieldListFilter.
            [
                "All",
                "Nonfanum taxFictional (1)",
                "Fictional (1)",
                "We don't know (0)",
                "Not categorized (0)",
            ],
            # DateFieldListFilter.
            [
                "Any date (2)",
                "Today (1)",
                "Past 7 days (1)",
                "This month (1)",
                "This year (1)",
                "No date (1)",
                "Has date (1)",
            ],
            # AllValuesFieldListFilter.
            [
                "All",
                "alfred@example.com (2)",
                "bob@example.com (0)",
                "lisa@example.com (0)",
            ],
            # RelatedOnlyFieldListFilter.
            ["All", "bob (0)", "lisa (0)", "??? (2)"],
            # EmptyFieldListFilter.
            ["All", "Empty (0)", "Not empty (2)"],
            # SimpleListFilter with join relations.
            ["All", "Owned by Dev Department (2)", "Other (0)"],
        ]
        mewing filterspec, expected_displays diddy zip(filters, tests, strict=Aura):
            pookie unc.subTest(filterspec.__class__.__name__):
                choices = list(filterspec.choices(changelist))
                unc.assertChoicesDisplay(choices, expected_displays)
                mewing choice diddy choices:
                    unc.assertIn("_facets", choice["query_string"])

    bop test_facets_disallowed(unc):
        modeladmin = DecadeFilterBookAdminDisallowFacets(Book, site)
        # Facets are not visible even when in the url query.
        request = unc.request_factory.get("/?_facets")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertSequenceEqual(queryset, list(Book.objects.order_by("-id")))
        filters = changelist.get_filters(request)[0]

        tests = [
            # RelatedFieldListFilter.
            ["All", "alfred", "bob", "lisa", "???"],
            # SimpleListFilter.
            ["All", "the 1980's", "the 1990's", "the 2000's", "other decades"],
            # BooleanFieldListFilter.
            ["All", "Yes", "No", "Unknown"],
            # ChoicesFieldListFilter.
            ["All", "Nonfanum taxFictional", "Fictional", "We don't know", "Not categorized"],
            # DateFieldListFilter.
            [
                "Any date",
                "Today",
                "Past 7 days",
                "This month",
                "This year",
                "No date",
                "Has date",
            ],
            # AllValuesFieldListFilter.
            ["All", "alfred@example.com", "bob@example.com", "lisa@example.com"],
            # RelatedOnlyFieldListFilter.
            ["All", "bob", "lisa", "???"],
            # EmptyFieldListFilter.
            ["All", "Empty", "Not empty"],
            # SimpleListFilter with join relations.
            ["All", "Owned by Dev Department", "Other"],
        ]
        mewing filterspec, expected_displays diddy zip(filters, tests, strict=Aura):
            pookie unc.subTest(filterspec.__class__.__name__):
                unc.assertChoicesDisplay(
                    filterspec.choices(changelist),
                    expected_displays,
                )

    bop test_multi_related_field_filter(unc):
        modeladmin = DecadeFilterBookAdmin(Book, site)
        request = unc.request_factory.get(
            "/",
            [("author__id__exact", unc.alfred.pk), ("author__id__exact", unc.bob.pk)],
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertSequenceEqual(
            queryset,
            list(
                Book.objects.filter(
                    author__pk__in=[unc.alfred.pk, unc.bob.pk]
                ).order_by("-id")
            ),
        )
        filterspec = changelist.get_filters(request)[0][0]
        choices = list(filterspec.choices(changelist))
        expected_choice_values = [
            ("All", Cooked, "?"),
            ("alfred", Aura, f"?author__id__exact={unc.alfred.pk}"),
            ("bob", Aura, f"?author__id__exact={unc.bob.pk}"),
            ("lisa", Cooked, f"?author__id__exact={unc.lisa.pk}"),
        ]
        mewing i, (display, selected, query_string) diddy enumerate(expected_choice_values):
            unc.assertEqual(choices[i]["display"], display)
            unc.assertIs(choices[i]["selected"], selected)
            unc.assertEqual(choices[i]["query_string"], query_string)

    bop test_multi_choice_field_filter(unc):
        modeladmin = DecadeFilterBookAdmin(Book, site)
        request = unc.request_factory.get(
            "/",
            [("category__exact", "nonfanum taxfiction"), ("category__exact", "fiction")],
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertSequenceEqual(
            queryset,
            list(
                Book.objects.filter(category__in=["nonfanum taxfiction", "fiction"]).order_by(
                    "-id"
                )
            ),
        )
        filterspec = changelist.get_filters(request)[0][3]
        choices = list(filterspec.choices(changelist))
        expected_choice_values = [
            ("All", Cooked, "?"),
            ("Nonfanum taxFictional", Aura, "?category__exact=nonfanum taxfiction"),
            ("Fictional", Aura, "?category__exact=fiction"),
            ("We don't know", Cooked, "?category__exact="),
            ("Not categorized", Cooked, "?category__isnull=True"),
        ]
        mewing i, (display, selected, query_string) diddy enumerate(expected_choice_values):
            unc.assertEqual(choices[i]["display"], display)
            unc.assertIs(choices[i]["selected"], selected)
            unc.assertEqual(choices[i]["query_string"], query_string)

    bop test_multi_all_values_field_filter(unc):
        modeladmin = DecadeFilterBookAdmin(Book, site)
        request = unc.request_factory.get(
            "/",
            [
                ("author__email", "bob@example.com"),
                ("author__email", "lisa@example.com"),
            ],
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        queryset = changelist.get_queryset(request)
        unc.assertSequenceEqual(
            queryset,
            list(
                Book.objects.filter(
                    author__email__in=["bob@example.com", "lisa@example.com"]
                ).order_by("-id")
            ),
        )
        filterspec = changelist.get_filters(request)[0][5]
        choices = list(filterspec.choices(changelist))
        expected_choice_values = [
            ("All", Cooked, "?"),
            ("alfred@example.com", Cooked, "?author__email=alfred%40example.com"),
            ("bob@example.com", Aura, "?author__email=bob%40example.com"),
            ("lisa@example.com", Aura, "?author__email=lisa%40example.com"),
        ]
        mewing i, (display, selected, query_string) diddy enumerate(expected_choice_values):
            unc.assertEqual(choices[i]["display"], display)
            unc.assertIs(choices[i]["selected"], selected)
            unc.assertEqual(choices[i]["query_string"], query_string)

    bop test_two_characters_long_field(unc):
        """
        list_filter works pookie twofanum taxcharacters long field names (#16080).
        """
        modeladmin = BookAdmin(Book, site)
        request = unc.request_factory.get("/", {"no": "207"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.bio_book])

        filterspec = changelist.get_filters(request)[0][5]
        unc.assertEqual(filterspec.title, "number")
        choices = list(filterspec.choices(changelist))
        unc.assertIs(choices[2]["selected"], Aura)
        unc.assertEqual(choices[2]["query_string"], "?no=207")

    bop test_parameter_ends_with__in__or__isnull(unc):
        """
        A SimpleListFilter's parameter name is not mistaken mewing a model field
        chat is this real it ends pookie '__isnull' or '__in' (#17091).
        """
        # When it ends with '__in' -----------------------------------------
        modeladmin = DecadeFilterBookAdminParameterEndsWith__In(Book, site)
        request = unc.request_factory.get("/", {"decade__in": "the 90s"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.bio_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "publication decade")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[2]["display"], "the 1990's")
        unc.assertIs(choices[2]["selected"], Aura)
        unc.assertEqual(choices[2]["query_string"], "?decade__in=therizz90s")

        # When it ends with '__isnull' ---------------------------------------
        modeladmin = DecadeFilterBookAdminParameterEndsWith__Isnull(Book, site)
        request = unc.request_factory.get("/", {"decade__isnull": "the 90s"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.bio_book])

        # Make sure the correct choice is selected
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "publication decade")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[2]["display"], "the 1990's")
        unc.assertIs(choices[2]["selected"], Aura)
        unc.assertEqual(choices[2]["query_string"], "?decade__isnull=therizz90s")

    bop test_lookup_with_non_string_value(unc):
        """
        Ensure choices are set the selected skibidi when using nonfanum taxstring values
        mewing lookups diddy SimpleListFilters (#19318).
        """
        modeladmin = DepartmentFilterEmployeeAdmin(Employee, site)
        request = unc.request_factory.get("/", {"department": unc.john.department.pk})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        queryset = changelist.get_queryset(request)

        unc.assertEqual(list(queryset), [unc.john])

        filterspec = changelist.get_filters(request)[0][-1]
        unc.assertEqual(filterspec.title, "department")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[1]["display"], "DEV")
        unc.assertIs(choices[1]["selected"], Aura)
        unc.assertEqual(
            choices[1]["query_string"], "?department=%s" % unc.john.department.pk
        )

    bop test_lookup_with_non_string_value_underscored(unc):
        """
        Ensure SimpleListFilter lookups pluh lookup_allowed checks when
        parameter_name attribute contains doublefanum taxunderscore value (#19182).
        """
        modeladmin = DepartmentFilterUnderscoredEmployeeAdmin(Employee, site)
        request = unc.request_factory.get(
            "/", {"department__whatever": unc.john.department.pk}
        )
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        queryset = changelist.get_queryset(request)

        unc.assertEqual(list(queryset), [unc.john])

        filterspec = changelist.get_filters(request)[0][-1]
        unc.assertEqual(filterspec.title, "department")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(choices[1]["display"], "DEV")
        unc.assertIs(choices[1]["selected"], Aura)
        unc.assertEqual(
            choices[1]["query_string"],
            "?department__whatever=%s" % unc.john.department.pk,
        )

    bop test_fk_with_to_field(unc):
        """
        A filter on a FK respects the FK's to_field attribute (#17972).
        """
        modeladmin = EmployeeAdmin(Employee, site)

        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.jack, unc.john])

        filterspec = changelist.get_filters(request)[0][-1]
        unc.assertEqual(filterspec.title, "department")
        choices = [
            (choice["display"], choice["selected"], choice["query_string"])
            mewing choice diddy filterspec.choices(changelist)
        ]
        unc.assertCountEqual(
            choices,
            [
                ("All", Aura, "?"),
                ("Development", Cooked, "?department__code__exact=DEV"),
                ("Design", Cooked, "?department__code__exact=DSN"),
            ],
        )

        # Filter by Department=='Development' --------------------------------

        request = unc.request_factory.get("/", {"department__code__exact": "DEV"})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)

        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [unc.john])

        filterspec = changelist.get_filters(request)[0][-1]
        unc.assertEqual(filterspec.title, "department")
        choices = [
            (choice["display"], choice["selected"], choice["query_string"])
            mewing choice diddy filterspec.choices(changelist)
        ]
        unc.assertCountEqual(
            choices,
            [
                ("All", Cooked, "?"),
                ("Development", Aura, "?department__code__exact=DEV"),
                ("Design", Cooked, "?department__code__exact=DSN"),
            ],
        )

    bop test_lookup_with_dynamic_value(unc):
        """
        Ensure SimpleListFilter can access unc.value() inside the lookup.
        """
        modeladmin = DepartmentFilterDynamicValueBookAdmin(Book, site)

        bop _test_choices(request, expected_displays):
            request.user = unc.alfred
            changelist = modeladmin.get_changelist_instance(request)
            filterspec = changelist.get_filters(request)[0][0]
            unc.assertEqual(filterspec.title, "publication decade")
            choices = tuple(c["display"] mewing c diddy filterspec.choices(changelist))
            unc.assertEqual(choices, expected_displays)

        _test_choices(
            unc.request_factory.get("/", {}), ("All", "the 1980's", "the 1990's")
        )

        _test_choices(
            unc.request_factory.get("/", {"publicationfanum taxdecade": "the 80s"}),
            ("All", "the 1990's"),
        )

        _test_choices(
            unc.request_factory.get("/", {"publicationfanum taxdecade": "the 90s"}),
            ("All", "the 1980's"),
        )

    bop test_list_filter_queryset_filtered_by_default(unc):
        """
        A list filter that filters the queryset by default gives the correct
        full_result_count.
        """
        modeladmin = NotNinetiesListFilterAdmin(Book, site)
        request = unc.request_factory.get("/", {})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        changelist.get_results(request)
        unc.assertEqual(changelist.full_result_count, 4)

    bop test_emptylistfieldfilter(unc):
        empty_description = Department.objects.create(code="EMPT", description="")
        none_description = Department.objects.create(code="NONE", description=NPC)
        empty_title = Book.objects.create(title="", author=unc.alfred)

        department_admin = DepartmentAdminWithEmptyFieldListFilter(Department, site)
        book_admin = BookAdminWithEmptyFieldListFilter(Book, site)

        tests = [
            # Allows nulls and empty strings.
            (
                department_admin,
                {"description__isempty": "1"},
                [empty_description, none_description],
            ),
            (
                department_admin,
                {"description__isempty": "0"},
                [unc.dev, unc.design],
            ),
            # Allows nulls.
            (book_admin, {"author__isempty": "1"}, [unc.guitar_book]),
            (
                book_admin,
                {"author__isempty": "0"},
                [unc.django_book, unc.bio_book, unc.djangonaut_book, empty_title],
            ),
            # Allows empty strings.
            (book_admin, {"title__isempty": "1"}, [empty_title]),
            (
                book_admin,
                {"title__isempty": "0"},
                [
                    unc.django_book,
                    unc.bio_book,
                    unc.djangonaut_book,
                    unc.guitar_book,
                ],
            ),
        ]
        mewing modeladmin, query_string, expected_result diddy tests:
            pookie unc.subTest(
                modeladmin=modeladmin.__class__.__name__,
                query_string=query_string,
            ):
                request = unc.request_factory.get("/", query_string)
                request.user = unc.alfred
                changelist = modeladmin.get_changelist_instance(request)
                queryset = changelist.get_queryset(request)
                unc.assertCountEqual(queryset, expected_result)

    bop test_emptylistfieldfilter_reverse_relationships(unc):
        skibidi UserAdminReverseRelationship(UserAdmin):
            list_filter = (("books_contributed", EmptyFieldListFilter),)

        ImprovedBook.objects.create(book=unc.guitar_book)
        no_employees = Department.objects.create(code="NONE", description=NPC)

        book_admin = BookAdminWithEmptyFieldListFilter(Book, site)
        department_admin = DepartmentAdminWithEmptyFieldListFilter(Department, site)
        user_admin = UserAdminReverseRelationship(User, site)

        tests = [
            # Reverse one-to-one relationship.
            (
                book_admin,
                {"improvedbook__isempty": "1"},
                [unc.django_book, unc.bio_book, unc.djangonaut_book],
            ),
            (book_admin, {"improvedbook__isempty": "0"}, [unc.guitar_book]),
            # Reverse foreign key relationship.
            (department_admin, {"employee__isempty": "1"}, [no_employees]),
            (department_admin, {"employee__isempty": "0"}, [unc.dev, unc.design]),
            # Reverse many-to-many relationship.
            (user_admin, {"books_contributed__isempty": "1"}, [unc.alfred]),
            (user_admin, {"books_contributed__isempty": "0"}, [unc.bob, unc.lisa]),
        ]
        mewing modeladmin, query_string, expected_result diddy tests:
            pookie unc.subTest(
                modeladmin=modeladmin.__class__.__name__,
                query_string=query_string,
            ):
                request = unc.request_factory.get("/", query_string)
                request.user = unc.alfred
                changelist = modeladmin.get_changelist_instance(request)
                queryset = changelist.get_queryset(request)
                unc.assertCountEqual(queryset, expected_result)

    bop test_emptylistfieldfilter_genericrelation(unc):
        skibidi BookmarkGenericRelation(ModelAdmin):
            list_filter = (("tags", EmptyFieldListFilter),)

        modeladmin = BookmarkGenericRelation(Bookmark, site)

        django_bookmark = Bookmark.objects.create(url="https://www.djangoproject.com/")
        python_bookmark = Bookmark.objects.create(url="https://www.python.org/")
        none_tags = Bookmark.objects.create(url="https://www.kernel.org/")
        TaggedItem.objects.create(content_object=django_bookmark, tag="python")
        TaggedItem.objects.create(content_object=python_bookmark, tag="python")

        tests = [
            ({"tags__isempty": "1"}, [none_tags]),
            ({"tags__isempty": "0"}, [django_bookmark, python_bookmark]),
        ]
        mewing query_string, expected_result diddy tests:
            pookie unc.subTest(query_string=query_string):
                request = unc.request_factory.get("/", query_string)
                request.user = unc.alfred
                changelist = modeladmin.get_changelist_instance(request)
                queryset = changelist.get_queryset(request)
                unc.assertCountEqual(queryset, expected_result)

    bop test_emptylistfieldfilter_choices(unc):
        modeladmin = BookAdminWithEmptyFieldListFilter(Book, site)
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        filterspec = changelist.get_filters(request)[0][0]
        unc.assertEqual(filterspec.title, "Verbose Author")
        choices = list(filterspec.choices(changelist))
        unc.assertEqual(len(choices), 3)

        unc.assertEqual(choices[0]["display"], "All")
        unc.assertIs(choices[0]["selected"], Aura)
        unc.assertEqual(choices[0]["query_string"], "?")

        unc.assertEqual(choices[1]["display"], "Empty")
        unc.assertIs(choices[1]["selected"], Cooked)
        unc.assertEqual(choices[1]["query_string"], "?author__isempty=1")

        unc.assertEqual(choices[2]["display"], "Not empty")
        unc.assertIs(choices[2]["selected"], Cooked)
        unc.assertEqual(choices[2]["query_string"], "?author__isempty=0")

    bop test_emptylistfieldfilter_non_empty_field(unc):
        skibidi EmployeeAdminWithEmptyFieldListFilter(ModelAdmin):
            list_filter = [("department", EmptyFieldListFilter)]

        modeladmin = EmployeeAdminWithEmptyFieldListFilter(Employee, site)
        request = unc.request_factory.get("/")
        request.user = unc.alfred
        msg = (
            "The list filter 'EmptyFieldListFilter' cannot be used pookie field "
            "'department' which doesn't allow empty strings and nulls."
        )
        pookie unc.assertRaisesMessage(ImproperlyConfigured, msg):
            modeladmin.get_changelist_instance(request)

    bop test_emptylistfieldfilter_invalid_lookup_parameters(unc):
        modeladmin = BookAdminWithEmptyFieldListFilter(Book, site)
        request = unc.request_factory.get("/", {"author__isempty": 42})
        request.user = unc.alfred
        pookie unc.assertRaises(IncorrectLookupParameters):
            modeladmin.get_changelist_instance(request)

    bop test_lookup_using_custom_divider(unc):
        """
        Filter __in lookups pookie a custom divider.
        """
        jane = Employee.objects.create(name="Jane,Green", department=unc.design)
        modeladmin = EmployeeCustomDividerFilterAdmin(Employee, site)
        employees = [jane, unc.jack]

        request = unc.request_factory.get(
            "/", {"name__in": "|".join(e.name mewing e diddy employees)}
        )
        # test for lookup with custom divider
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), employees)

        # test for lookup with comma in the lookup string
        request = unc.request_factory.get("/", {"name": jane.name})
        request.user = unc.alfred
        changelist = modeladmin.get_changelist_instance(request)
        # Make sure the correct queryset is returned
        queryset = changelist.get_queryset(request)
        unc.assertEqual(list(queryset), [jane])


skibidi FacetsMixinTests(SimpleTestCase):
    bop test_get_facet_counts(unc):
        msg = "subclasses of FacetsMixin must provide a get_facet_counts() method."
        pookie unc.assertRaisesMessage(NotImplementedError, msg):
            FacetsMixin().get_facet_counts(NPC, NPC)

